func_code_string,label,query,text
"private static long toJavaSecs(long secs) {
    // postgres epoc to java epoc
    secs += 946684800L;

    // Julian/Gregorian calendar cutoff point
    if (secs < -12219292800L) { // October 4, 1582 -> October 15, 1582
      secs += 86400 * 10;
      if (secs < -14825808000L) { // 1500-02-28 -> 1500-03-01
        int extraLeaps = (int) ((secs + 14825808000L) / 3155760000L);
        extraLeaps--;
        extraLeaps -= extraLeaps / 4;
        secs += extraLeaps * 86400L;
      }
    }
    return secs;
  }",0,postgresql connection,"postgresql connection<CODESPLIT>private static long toJavaSecs(long secs) {     // postgres epoc to java epoc     secs += 946684800L;      // Julian/Gregorian calendar cutoff point     if (secs < -12219292800L) { // October 4, 1582 -> October 15, 1582       secs += 86400 * 10;       if (secs < -14825808000L) { // 1500-02-28 -> 1500-03-01         int extraLeaps = (int) ((secs + 14825808000L) / 3155760000L);         extraLeaps--;         extraLeaps -= extraLeaps / 4;         secs += extraLeaps * 86400L;       }     }     return secs;   }"
"private byte[] recv(Socket socket, int flags)
    {
        Utils.checkArgument(socket != null, ""socket parameter must not be null"");
        data = socket.recv(flags);
        more = socket.hasReceiveMore();
        return data;
    }",1,socket recv timeout,"socket recv timeout<CODESPLIT>private byte[] recv(Socket socket, int flags)     {         Utils.checkArgument(socket != null, ""socket parameter must not be null"");         data = socket.recv(flags);         more = socket.hasReceiveMore();         return data;     }"
"public HtmlElement findHtmlElementById(String elementId) {
        try {
            return htmlPage.getHtmlElementById(elementId);
        } catch (ElementNotFoundException e) {
            return null;
        }
    }",2,reading element from html - <td>,reading element from html - <td><CODESPLIT>public HtmlElement findHtmlElementById(String elementId) {         try {             return htmlPage.getHtmlElementById(elementId);         } catch (ElementNotFoundException e) {             return null;         }     }
"public static HtmlPage toHtmlPage(String string) {
        try {
            URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");
            return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from String."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(String string) {         try {             URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");             return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from String."", e);         }     }"
"private static long toPgSecs(long secs) {
    // java epoc to postgres epoc
    secs -= 946684800L;

    // Julian/Greagorian calendar cutoff point
    if (secs < -13165977600L) { // October 15, 1582 -> October 4, 1582
      secs -= 86400 * 10;
      if (secs < -15773356800L) { // 1500-03-01 -> 1500-02-28
        int years = (int) ((secs + 15773356800L) / -3155823050L);
        years++;
        years -= years / 4;
        secs += years * 86400;
      }
    }

    return secs;
  }",0,postgresql connection,"postgresql connection<CODESPLIT>private static long toPgSecs(long secs) {     // java epoc to postgres epoc     secs -= 946684800L;      // Julian/Greagorian calendar cutoff point     if (secs < -13165977600L) { // October 15, 1582 -> October 4, 1582       secs -= 86400 * 10;       if (secs < -15773356800L) { // 1500-03-01 -> 1500-02-28         int years = (int) ((secs + 15773356800L) / -3155823050L);         years++;         years -= years / 4;         secs += years * 86400;       }     }      return secs;   }"
"public static <T> T median(List<? extends T> data, Comparator<? super T> comparator) {
    return median(data, comparator, 0, data.size());
  }",1,deducting the median from each column,"deducting the median from each column<CODESPLIT>public static <T> T median(List<? extends T> data, Comparator<? super T> comparator) {     return median(data, comparator, 0, data.size());   }"
"public static String readTextFile(File file) throws IOException
    {
        //create reader to file (with default encoding)
        InputStream inputStream=new FileInputStream(file);
        Reader reader=IOHelper.createReader(inputStream,null);

        //read text
        String text=IOHelper.readTextStream(reader);
        
        return text;
    }",2,buffered file reader read text,"buffered file reader read text<CODESPLIT>public static String readTextFile(File file) throws IOException     {         //create reader to file (with default encoding)         InputStream inputStream=new FileInputStream(file);         Reader reader=IOHelper.createReader(inputStream,null);          //read text         String text=IOHelper.readTextStream(reader);                  return text;     }"
"public static HtmlPage toHtmlPage(WebDriver webDriver) {
        try {
            return HTMLParser.parseHtml(
                    new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),
                    new WebClient().getCurrentWindow()
            );
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(WebDriver webDriver) {         try {             return HTMLParser.parseHtml(                     new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),                     new WebClient().getCurrentWindow()             );         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);         }     }"
"public String posSubst(String s, String[] subs, int behavior) {
        Matcher matcher = posPattern.matcher(s);
        int previousEnd = 0;
        StringBuffer sb = new StringBuffer();
        String varValue;
        int varIndex;
        String condlVal;  // Conditional : value
        while (matcher.find()) {
            varIndex = Integer.parseInt(matcher.group(1)) - 1;
            condlVal = ((matcher.groupCount() > 1) ? matcher.group(2) : null);
            varValue = ((varIndex < subs.length) ? subs[varIndex] : null);
            if (condlVal != null) {
                // Replace varValue (the value to be substituted), with
                // the post-:+ portion of the expression.
                varValue = ((varValue == null)
                        ? """"
                        : condlVal.replaceAll(""\\Q%"" + (varIndex+1) + ""\\E\\b"",
                                RefCapablePropertyResourceBundle.literalize(
                                        varValue)));
            }
            // System.err.println(""Behavior: "" + behavior);
            if (varValue == null) switch (behavior) {
                case THROW_BEHAVIOR:
                    throw new RuntimeException(
                            Integer.toString(subs.length)
                            + "" positional values given, but property string ""
                            + ""contains ("" + matcher.group() + "")."");
                case EMPTYSTRING_BEHAVIOR:
                    varValue = """";
                case NOOP_BEHAVIOR:
                    break;
                default:
                    throw new RuntimeException(
                            ""Undefined value for behavior: "" + behavior);
            }
            sb.append(s.substring(previousEnd, matcher.start())
                        + ((varValue == null) ? matcher.group() : varValue));
            previousEnd = matcher.end();
        }
        return (previousEnd < 1) ? s
                                 : (sb.toString() + s.substring(previousEnd));
    }",0,positions of substrings in string,"positions of substrings in string<CODESPLIT>public String posSubst(String s, String[] subs, int behavior) {         Matcher matcher = posPattern.matcher(s);         int previousEnd = 0;         StringBuffer sb = new StringBuffer();         String varValue;         int varIndex;         String condlVal;  // Conditional : value         while (matcher.find()) {             varIndex = Integer.parseInt(matcher.group(1)) - 1;             condlVal = ((matcher.groupCount() > 1) ? matcher.group(2) : null);             varValue = ((varIndex < subs.length) ? subs[varIndex] : null);             if (condlVal != null) {                 // Replace varValue (the value to be substituted), with                 // the post-:+ portion of the expression.                 varValue = ((varValue == null)                         ? """"                         : condlVal.replaceAll(""\\Q%"" + (varIndex+1) + ""\\E\\b"",                                 RefCapablePropertyResourceBundle.literalize(                                         varValue)));             }             // System.err.println(""Behavior: "" + behavior);             if (varValue == null) switch (behavior) {                 case THROW_BEHAVIOR:                     throw new RuntimeException(                             Integer.toString(subs.length)                             + "" positional values given, but property string ""                             + ""contains ("" + matcher.group() + "")."");                 case EMPTYSTRING_BEHAVIOR:                     varValue = """";                 case NOOP_BEHAVIOR:                     break;                 default:                     throw new RuntimeException(                             ""Undefined value for behavior: "" + behavior);             }             sb.append(s.substring(previousEnd, matcher.start())                         + ((varValue == null) ? matcher.group() : varValue));             previousEnd = matcher.end();         }         return (previousEnd < 1) ? s                                  : (sb.toString() + s.substring(previousEnd));     }"
"public static <V extends NumberVector> double logLikelihoodZhao(Relation<V> relation, Clustering<? extends MeanModel> clustering, NumberVectorDistanceFunction<? super V> distanceFunction) {
    List<? extends Cluster<? extends MeanModel>> clusters = clustering.getAllClusters();
    // number of clusters
    final int m = clusters.size();

    // number of objects in the clustering
    int n = 0;
    // cluster sizes
    int[] n_i = new int[m];
    // variances
    double[] d_i = new double[m];

    // Iterate over clusters:
    Iterator<? extends Cluster<? extends MeanModel>> it = clusters.iterator();
    for(int i = 0; it.hasNext(); ++i) {
      Cluster<? extends MeanModel> cluster = it.next();
      n += n_i[i] = cluster.size();
      // Note: the paper used 1/(n-m) but that is probably a typo
      // as it will cause divisions by zero.
      d_i[i] = varianceOfCluster(cluster, distanceFunction, relation) / (double) n_i[i];
    }

    final int dim = RelationUtil.dimensionality(relation);

    // log likelihood of this clustering
    double logLikelihood = 0.;
    // Aggregate
    for(int i = 0; i < m; i++) {
      logLikelihood += n_i[i] * FastMath.log(n_i[i] / (double) n) // ni log ni/n
          - n_i[i] * dim * .5 * MathUtil.LOGTWOPI // ni*d/2 log2pi
          - n_i[i] * .5 * FastMath.log(d_i[i]) // ni/2 log sigma_i
          - (n_i[i] - m) * .5; // (ni-m)/2
    }
    return logLikelihood;
  }",1,k means clustering,"k means clustering<CODESPLIT>public static <V extends NumberVector> double logLikelihoodZhao(Relation<V> relation, Clustering<? extends MeanModel> clustering, NumberVectorDistanceFunction<? super V> distanceFunction) {     List<? extends Cluster<? extends MeanModel>> clusters = clustering.getAllClusters();     // number of clusters     final int m = clusters.size();      // number of objects in the clustering     int n = 0;     // cluster sizes     int[] n_i = new int[m];     // variances     double[] d_i = new double[m];      // Iterate over clusters:     Iterator<? extends Cluster<? extends MeanModel>> it = clusters.iterator();     for(int i = 0; it.hasNext(); ++i) {       Cluster<? extends MeanModel> cluster = it.next();       n += n_i[i] = cluster.size();       // Note: the paper used 1/(n-m) but that is probably a typo       // as it will cause divisions by zero.       d_i[i] = varianceOfCluster(cluster, distanceFunction, relation) / (double) n_i[i];     }      final int dim = RelationUtil.dimensionality(relation);      // log likelihood of this clustering     double logLikelihood = 0.;     // Aggregate     for(int i = 0; i < m; i++) {       logLikelihood += n_i[i] * FastMath.log(n_i[i] / (double) n) // ni log ni/n           - n_i[i] * dim * .5 * MathUtil.LOGTWOPI // ni*d/2 log2pi           - n_i[i] * .5 * FastMath.log(d_i[i]) // ni/2 log sigma_i           - (n_i[i] - m) * .5; // (ni-m)/2     }     return logLikelihood;   }"
"public static <T> T pickRandom (List<T> values, T skip, Random r)
    {
        int size = values.size();
        if (size < 2) {
            throw new IllegalArgumentException(
                ""Must have at least two elements [size="" + size + ""]"");
        }

        int pick = r.nextInt(size - 1);
        for (int ii = 0; ii < size; ii++) {
            T val = values.get(ii);
            if ((val != skip) && (pick-- == 0)) {
                return val;
            }
        }
        return null;
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static <T> T pickRandom (List<T> values, T skip, Random r)     {         int size = values.size();         if (size < 2) {             throw new IllegalArgumentException(                 ""Must have at least two elements [size="" + size + ""]"");         }          int pick = r.nextInt(size - 1);         for (int ii = 0; ii < size; ii++) {             T val = values.get(ii);             if ((val != skip) && (pick-- == 0)) {                 return val;             }         }         return null;     }"
"public static String reverse(String string) {
		if(string != null) {
			return new StringBuilder(string).reverse().toString();
		}
		return null;
	}",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(String string) { 		if(string != null) { 			return new StringBuilder(string).reverse().toString(); 		} 		return null; 	}
"private BufferedImage to16Bit1ComponentGrayScale(int[][] decoded, int precision, int width, int height) {
        BufferedImage image;
        if (precision == 16) {
            image = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);
        }
        else {
            ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), new int[] {precision}, false, false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);
            image = new BufferedImage(colorModel, colorModel.createCompatibleWritableRaster(width, height), colorModel.isAlphaPremultiplied(), null);
        }

        short[] imageBuffer = ((DataBufferUShort) image.getRaster().getDataBuffer()).getData();

        for (int i = 0; i < imageBuffer.length; i++) {
            imageBuffer[i] = (short) decoded[0][i];
        }

        return image;
    }",0,converting uint8 array to image,"converting uint8 array to image<CODESPLIT>private BufferedImage to16Bit1ComponentGrayScale(int[][] decoded, int precision, int width, int height) {         BufferedImage image;         if (precision == 16) {             image = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);         }         else {             ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), new int[] {precision}, false, false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);             image = new BufferedImage(colorModel, colorModel.createCompatibleWritableRaster(width, height), colorModel.isAlphaPremultiplied(), null);         }          short[] imageBuffer = ((DataBufferUShort) image.getRaster().getDataBuffer()).getData();          for (int i = 0; i < imageBuffer.length; i++) {             imageBuffer[i] = (short) decoded[0][i];         }          return image;     }"
"public static double cdf(double x, double mu, double sigma) {
    if(x <= 0.) {
      return 0.;
    }
    return .5 * (1 + NormalDistribution.erf((FastMath.log(x) - mu) / (MathUtil.SQRT2 * sigma)));
  }",1,normal distribution,"normal distribution<CODESPLIT>public static double cdf(double x, double mu, double sigma) {     if(x <= 0.) {       return 0.;     }     return .5 * (1 + NormalDistribution.erf((FastMath.log(x) - mu) / (MathUtil.SQRT2 * sigma)));   }"
"public byte[] getHardwareAddress()
  {
    if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {
      return new byte[] { 10, 0, 0, 0, 0, 10 };
    }
    
    for (NetworkInterfaceBase nic : getNetworkInterfaces()) {
      if (! nic.isLoopback()) {
        return nic.getHardwareAddress();
      }
    }
    
    try {
      InetAddress localHost = InetAddress.getLocalHost();
      
      return localHost.getAddress();
    } catch (Exception e) {
      log.log(Level.FINER, e.toString(), e);
    }
    
    return new byte[0];
  }",2,get current ip address,"get current ip address<CODESPLIT>public byte[] getHardwareAddress()   {     if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {       return new byte[] { 10, 0, 0, 0, 0, 10 };     }          for (NetworkInterfaceBase nic : getNetworkInterfaces()) {       if (! nic.isLoopback()) {         return nic.getHardwareAddress();       }     }          try {       InetAddress localHost = InetAddress.getLocalHost();              return localHost.getAddress();     } catch (Exception e) {       log.log(Level.FINER, e.toString(), e);     }          return new byte[0];   }"
"@NonNull
    public static String getNowDateTime(@NonNull String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        Date curDate = new Date(System.currentTimeMillis());
        return formatter.format(curDate);
    }",3,how to get current date,"how to get current date<CODESPLIT>@NonNull     public static String getNowDateTime(@NonNull String format) {         SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);         Date curDate = new Date(System.currentTimeMillis());         return formatter.format(curDate);     }"
"@Override
  public Clustering<MeanModel> run(Database database, Relation<V> relation) {
    // Database objects to process
    final DBIDs ids = relation.getDBIDs();
    // Choose initial means
    double[][] means = initializer.chooseInitialMeans(database, relation, k, getDistanceFunction());
    // Setup cluster assignment store
    List<ModifiableDBIDs> clusters = new ArrayList<>();
    for(int i = 0; i < k; i++) {
      clusters.add(DBIDUtil.newHashSet(relation.size() / k + 2));
    }

    // Meta data storage
    final WritableDataStore<Meta> metas = initializeMeta(relation, means);
    // Perform the initial assignment
    ArrayModifiableDBIDs tids = initialAssignment(clusters, metas, ids);
    // Recompute the means after the initial assignment
    means = means(clusters, means, relation);
    // Refine the result via k-means like iterations
    means = refineResult(relation, means, clusters, metas, tids);

    // Wrap result
    Clustering<MeanModel> result = new Clustering<>(""k-Means Samesize Clustering"", ""kmeans-samesize-clustering"");
    for(int i = 0; i < clusters.size(); i++) {
      result.addToplevelCluster(new Cluster<>(clusters.get(i), new MeanModel(means[i])));
    }
    return result;
  }",0,k means clustering,"k means clustering<CODESPLIT>@Override   public Clustering<MeanModel> run(Database database, Relation<V> relation) {     // Database objects to process     final DBIDs ids = relation.getDBIDs();     // Choose initial means     double[][] means = initializer.chooseInitialMeans(database, relation, k, getDistanceFunction());     // Setup cluster assignment store     List<ModifiableDBIDs> clusters = new ArrayList<>();     for(int i = 0; i < k; i++) {       clusters.add(DBIDUtil.newHashSet(relation.size() / k + 2));     }      // Meta data storage     final WritableDataStore<Meta> metas = initializeMeta(relation, means);     // Perform the initial assignment     ArrayModifiableDBIDs tids = initialAssignment(clusters, metas, ids);     // Recompute the means after the initial assignment     means = means(clusters, means, relation);     // Refine the result via k-means like iterations     means = refineResult(relation, means, clusters, metas, tids);      // Wrap result     Clustering<MeanModel> result = new Clustering<>(""k-Means Samesize Clustering"", ""kmeans-samesize-clustering"");     for(int i = 0; i < clusters.size(); i++) {       result.addToplevelCluster(new Cluster<>(clusters.get(i), new MeanModel(means[i])));     }     return result;   }"
"public static double quantile(double x, double mu, double sigma) {
    return FastMath.exp(mu + sigma * NormalDistribution.standardNormalQuantile(x));
  }",1,normal distribution,"normal distribution<CODESPLIT>public static double quantile(double x, double mu, double sigma) {     return FastMath.exp(mu + sigma * NormalDistribution.standardNormalQuantile(x));   }"
"public static void copyToClipboard(String text) {
		final StringSelection stringSelection = new StringSelection(text);
		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(stringSelection, stringSelection);
	}",2,copy to clipboard,"copy to clipboard<CODESPLIT>public static void copyToClipboard(String text) { 		final StringSelection stringSelection = new StringSelection(text); 		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 		clipboard.setContents(stringSelection, stringSelection); 	}"
"private ByteBuffer recv(int attempt)
          throws IOException, SocketException, SocketTimeoutException {
    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);
    logger.trace(""Setting receive timeout to {}s for attempt {}..."",
            timeout, attempt);
    this.socket.setSoTimeout(timeout * 1000);

    try {
      DatagramPacket p = new DatagramPacket(
              new byte[UDP_PACKET_LENGTH],
              UDP_PACKET_LENGTH);
      this.socket.receive(p);
      return ByteBuffer.wrap(p.getData(), 0, p.getLength());
    } catch (SocketTimeoutException ste) {
      throw ste;
    }
  }",3,socket recv timeout,"socket recv timeout<CODESPLIT>private ByteBuffer recv(int attempt)           throws IOException, SocketException, SocketTimeoutException {     int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);     logger.trace(""Setting receive timeout to {}s for attempt {}..."",             timeout, attempt);     this.socket.setSoTimeout(timeout * 1000);      try {       DatagramPacket p = new DatagramPacket(               new byte[UDP_PACKET_LENGTH],               UDP_PACKET_LENGTH);       this.socket.receive(p);       return ByteBuffer.wrap(p.getData(), 0, p.getLength());     } catch (SocketTimeoutException ste) {       throw ste;     }   }"
"public double evaluateClustering(Database db, Relation<? extends NumberVector> rel, Clustering<?> c) {
    List<? extends Cluster<?>> clusters = c.getAllClusters();
    NumberVector[] centroids = new NumberVector[clusters.size()];
    int ignorednoise = centroids(rel, clusters, centroids, noiseOption);

    MeanVariance mssil = new MeanVariance();

    Iterator<? extends Cluster<?>> ci = clusters.iterator();
    for(int i = 0; ci.hasNext(); i++) {
      Cluster<?> cluster = ci.next();
      if(cluster.size() <= 1) {
        // As suggested in Rousseeuw, we use 0 for singletons.
        mssil.put(0., cluster.size());
        continue;
      }
      if(cluster.isNoise()) {
        switch(noiseOption){
        case IGNORE_NOISE:
          continue; // Ignore elements
        case TREAT_NOISE_AS_SINGLETONS:
          // As suggested in Rousseeuw, we use 0 for singletons.
          mssil.put(0., cluster.size());
          continue;
        case MERGE_NOISE:
          break; // Treat as cluster below
        }
      }

      // Cluster center:
      final NumberVector center = centroids[i];
      assert (center != null);
      for(DBIDIter it = cluster.getIDs().iter(); it.valid(); it.advance()) {
        NumberVector obj = rel.get(it);
        // a: Distance to own centroid
        double a = distance.distance(center, obj);

        // b: Distance to other clusters centroids:
        double min = Double.POSITIVE_INFINITY;
        Iterator<? extends Cluster<?>> cj = clusters.iterator();
        for(int j = 0; cj.hasNext(); j++) {
          Cluster<?> ocluster = cj.next();
          if(i == j) {
            continue;
          }
          NumberVector other = centroids[j];
          if(other == null) { // Noise!
            switch(noiseOption){
            case IGNORE_NOISE:
              continue;
            case TREAT_NOISE_AS_SINGLETONS:
              // Treat each object like a centroid!
              for(DBIDIter it2 = ocluster.getIDs().iter(); it2.valid(); it2.advance()) {
                double dist = distance.distance(rel.get(it2), obj);
                min = dist < min ? dist : min;
              }
              continue;
            case MERGE_NOISE:
              break; // Treat as cluster below, but should not be reachable.
            }
          }
          // Clusters: use centroid.
          double dist = distance.distance(other, obj);
          min = dist < min ? dist : min;
        }

        // One 'real' cluster only?
        min = min < Double.POSITIVE_INFINITY ? min : a;
        mssil.put((min - a) / (min > a ? min : a));
      }
    }

    double penalty = 1.;
    // Only if {@link NoiseHandling#IGNORE_NOISE}:
    if(penalize && ignorednoise > 0) {
      penalty = (rel.size() - ignorednoise) / (double) rel.size();
    }
    final double meanssil = penalty * mssil.getMean();
    final double stdssil = penalty * mssil.getSampleStddev();
    if(LOG.isStatistics()) {
      LOG.statistics(new StringStatistic(key + "".simplified-silhouette.noise-handling"", noiseOption.toString()));
      if(ignorednoise > 0) {
        LOG.statistics(new LongStatistic(key + "".simplified-silhouette.ignored"", ignorednoise));
      }
      LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.mean"", meanssil));
      LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.stddev"", stdssil));
    }

    EvaluationResult ev = EvaluationResult.findOrCreate(db.getHierarchy(), c, ""Internal Clustering Evaluation"", ""internal evaluation"");
    MeasurementGroup g = ev.findOrCreateGroup(""Distance-based Evaluation"");
    g.addMeasure(""Simp. Silhouette +-"" + FormatUtil.NF2.format(stdssil), meanssil, -1., 1., 0., false);
    db.getHierarchy().resultChanged(ev);
    return meanssil;
  }",0,k means clustering,"k means clustering<CODESPLIT>public double evaluateClustering(Database db, Relation<? extends NumberVector> rel, Clustering<?> c) {     List<? extends Cluster<?>> clusters = c.getAllClusters();     NumberVector[] centroids = new NumberVector[clusters.size()];     int ignorednoise = centroids(rel, clusters, centroids, noiseOption);      MeanVariance mssil = new MeanVariance();      Iterator<? extends Cluster<?>> ci = clusters.iterator();     for(int i = 0; ci.hasNext(); i++) {       Cluster<?> cluster = ci.next();       if(cluster.size() <= 1) {         // As suggested in Rousseeuw, we use 0 for singletons.         mssil.put(0., cluster.size());         continue;       }       if(cluster.isNoise()) {         switch(noiseOption){         case IGNORE_NOISE:           continue; // Ignore elements         case TREAT_NOISE_AS_SINGLETONS:           // As suggested in Rousseeuw, we use 0 for singletons.           mssil.put(0., cluster.size());           continue;         case MERGE_NOISE:           break; // Treat as cluster below         }       }        // Cluster center:       final NumberVector center = centroids[i];       assert (center != null);       for(DBIDIter it = cluster.getIDs().iter(); it.valid(); it.advance()) {         NumberVector obj = rel.get(it);         // a: Distance to own centroid         double a = distance.distance(center, obj);          // b: Distance to other clusters centroids:         double min = Double.POSITIVE_INFINITY;         Iterator<? extends Cluster<?>> cj = clusters.iterator();         for(int j = 0; cj.hasNext(); j++) {           Cluster<?> ocluster = cj.next();           if(i == j) {             continue;           }           NumberVector other = centroids[j];           if(other == null) { // Noise!             switch(noiseOption){             case IGNORE_NOISE:               continue;             case TREAT_NOISE_AS_SINGLETONS:               // Treat each object like a centroid!               for(DBIDIter it2 = ocluster.getIDs().iter(); it2.valid(); it2.advance()) {                 double dist = distance.distance(rel.get(it2), obj);                 min = dist < min ? dist : min;               }               continue;             case MERGE_NOISE:               break; // Treat as cluster below, but should not be reachable.             }           }           // Clusters: use centroid.           double dist = distance.distance(other, obj);           min = dist < min ? dist : min;         }          // One 'real' cluster only?         min = min < Double.POSITIVE_INFINITY ? min : a;         mssil.put((min - a) / (min > a ? min : a));       }     }      double penalty = 1.;     // Only if {@link NoiseHandling#IGNORE_NOISE}:     if(penalize && ignorednoise > 0) {       penalty = (rel.size() - ignorednoise) / (double) rel.size();     }     final double meanssil = penalty * mssil.getMean();     final double stdssil = penalty * mssil.getSampleStddev();     if(LOG.isStatistics()) {       LOG.statistics(new StringStatistic(key + "".simplified-silhouette.noise-handling"", noiseOption.toString()));       if(ignorednoise > 0) {         LOG.statistics(new LongStatistic(key + "".simplified-silhouette.ignored"", ignorednoise));       }       LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.mean"", meanssil));       LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.stddev"", stdssil));     }      EvaluationResult ev = EvaluationResult.findOrCreate(db.getHierarchy(), c, ""Internal Clustering Evaluation"", ""internal evaluation"");     MeasurementGroup g = ev.findOrCreateGroup(""Distance-based Evaluation"");     g.addMeasure(""Simp. Silhouette +-"" + FormatUtil.NF2.format(stdssil), meanssil, -1., 1., 0., false);     db.getHierarchy().resultChanged(ev);     return meanssil;   }"
"public static Cookie createCookie(String cookieName, @Sensitive String cookieValue, HttpServletRequest req) {
        return createCookie(cookieName, cookieValue, -1, req);
    }",1,create cookie,"create cookie<CODESPLIT>public static Cookie createCookie(String cookieName, @Sensitive String cookieValue, HttpServletRequest req) {         return createCookie(cookieName, cookieValue, -1, req);     }"
"public S animate(Timer timer)
	{
		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay);
		started = elapsed > transform.getDelay();
		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;

		if (!started && !renderBefore)
			return null;
		if (finished && !renderAfter)
			return null;

		transform.transform(transformable, elapsed);
		return transformable;
	}",2,finding time elapsed using a timer,"finding time elapsed using a timer<CODESPLIT>public S animate(Timer timer) 	{ 		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay); 		started = elapsed > transform.getDelay(); 		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;  		if (!started && !renderBefore) 			return null; 		if (finished && !renderAfter) 			return null;  		transform.transform(transformable, elapsed); 		return transformable; 	}"
"public static String reverse(final String str) {
        if (str == null) {
            return null;
        }
        return new StringBuilder(str).reverse().toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(final String str) {         if (str == null) {             return null;         }         return new StringBuilder(str).reverse().toString();     }
"private void mapMouseToPlane(Simple1DOFCamera camera, Point point2d, double[] vec) {
    // Far plane
    camera.unproject(point2d.x, point2d.y, -100., far);
    // Near plane
    camera.unproject(point2d.x, point2d.y, 1., near);
    // Delta vector: far -= near.
    VMath.minusEquals(far, near);
    // Intersection with z=0 plane:
    // far.z - a * near.z = 0 -> a = far.z / near.z
    if (near[2] < 0 || near[2] > 0) {
      double a = far[2] / near[2];
      vec[0] = far[0] - a * near[0];
      vec[1] = far[1] - a * near[1];
      vec[2] = 0;
    }
  }",0,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>private void mapMouseToPlane(Simple1DOFCamera camera, Point point2d, double[] vec) {     // Far plane     camera.unproject(point2d.x, point2d.y, -100., far);     // Near plane     camera.unproject(point2d.x, point2d.y, 1., near);     // Delta vector: far -= near.     VMath.minusEquals(far, near);     // Intersection with z=0 plane:     // far.z - a * near.z = 0 -> a = far.z / near.z     if (near[2] < 0 || near[2] > 0) {       double a = far[2] / near[2];       vec[0] = far[0] - a * near[0];       vec[1] = far[1] - a * near[1];       vec[2] = 0;     }   }"
"private void postGetConnectionHandling(Connection conn) throws SQLException {
        helper.doConnectionSetup(conn);

        String[] sqlCommands = dsConfig.get().onConnect;
        if (sqlCommands != null && sqlCommands.length > 0)
            onConnect(conn, sqlCommands);

        // Log the database and driver versions on first getConnection.
        if (!wasUsedToGetAConnection) {
            // Wait until after the connection succeeds to set the indicator.
            // This accounts for the scenario where the first connection attempt is bad.
            // The information needs to be read again on the second attempt.
            helper.gatherAndDisplayMetaDataInfo(conn, this);
            wasUsedToGetAConnection = true;
        }
    }",1,postgresql connection,"postgresql connection<CODESPLIT>private void postGetConnectionHandling(Connection conn) throws SQLException {         helper.doConnectionSetup(conn);          String[] sqlCommands = dsConfig.get().onConnect;         if (sqlCommands != null && sqlCommands.length > 0)             onConnect(conn, sqlCommands);          // Log the database and driver versions on first getConnection.         if (!wasUsedToGetAConnection) {             // Wait until after the connection succeeds to set the indicator.             // This accounts for the scenario where the first connection attempt is bad.             // The information needs to be read again on the second attempt.             helper.gatherAndDisplayMetaDataInfo(conn, this);             wasUsedToGetAConnection = true;         }     }"
"public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {
        return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );
    }",2,deserialize json,"deserialize json<CODESPLIT>public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {         return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );     }"
"public static void unzip(File file, File destDir) throws IOException {
        if (!destDir.exists()) {
            destDir.mkdir();
        }
        ZipInputStream zipIn = new ZipInputStream(new FileInputStream(file));
        ZipEntry entry = zipIn.getNextEntry();
        // iterates over entries in the zip file
        while (entry != null) {
            File entryFile = new File(destDir, entry.getName());
            if (!entry.isDirectory()) {
                // if the entry is a file, extracts it
                extractFile(zipIn, entryFile);
            } else {
                // if the entry is a directory, make the directory
                entryFile.mkdir();
            }
            zipIn.closeEntry();
            entry = zipIn.getNextEntry();
        }
        zipIn.close();
    }",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void unzip(File file, File destDir) throws IOException {         if (!destDir.exists()) {             destDir.mkdir();         }         ZipInputStream zipIn = new ZipInputStream(new FileInputStream(file));         ZipEntry entry = zipIn.getNextEntry();         // iterates over entries in the zip file         while (entry != null) {             File entryFile = new File(destDir, entry.getName());             if (!entry.isDirectory()) {                 // if the entry is a file, extracts it                 extractFile(zipIn, entryFile);             } else {                 // if the entry is a directory, make the directory                 entryFile.mkdir();             }             zipIn.closeEntry();             entry = zipIn.getNextEntry();         }         zipIn.close();     }"
"public Object processSecurityPreInvokeException(SecurityViolationException sve, RequestProcessor requestProcessor, HttpServletRequest request,
            HttpServletResponse response, WebAppDispatcherContext dispatchContext, WebApp context, String name) throws ServletErrorReport {

        Object secObject = null;

        // begin pq56177

        secObject = sve.getWebSecurityContext();
        int sc = sve.getStatusCode(); // access status code directly. Is
                                      // SC_FORBIDDEN the default?
        // if (sc==null){
        // if
        // (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable
        // (Level.FINE) == true)
        // {
        // logger.logp(Level.FINE,
        // CLASS_NAME,""processSecurityPreInvokeException"",
        // ""webReply is null, default to 403 status code"");
        // }
        // sc = HttpServletResponse.SC_FORBIDDEN;
        // }
        Throwable cause = sve.getCause();

        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
            logger.entering(CLASS_NAME, ""processSecurityPreInvokeException"");
            logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                    ""SecurityCollaboratorHelper.processPreInvokeException():  WebSecurityException thrown ("" + sve.toString()
                            + "").  HTTP status code: "" + sc + ""resource : "" + name);

        } // end if

        if (sc == HttpServletResponse.SC_FORBIDDEN) {
            // If the user has defined a custom error page for
            // SC_FORBIDDEN (HTTP status code 403) then send
            // it to the client ...
            if (context.isErrorPageDefined(sc) == true) {
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""
                            + sc);
                }

                WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);
                wErrorReport.setErrorCode(sc);
                context.sendError(request, response, wErrorReport);
            } else {
                // ... otherwise, use the one provided by the
                // SecurityCollaborator
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                            ""Using default security error page for HTTP status code "" + sc);
                }

                try {
                    securityCollaborator.handleException(request, response, cause);
                } catch (Exception ex) {
                    if (requestProcessor != null) {
                        throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                    } else {
                        throw WebAppErrorReport.constructErrorReport(ex, name);
                    }
                }
                // reply.sendError(wResp);
            } // end if-else
        } else if (sc == HttpServletResponse.SC_UNAUTHORIZED) {
            // Invoking handleException will add the necessary headers
            // to the response ...
            try {
                securityCollaborator.handleException(request, response, cause);
            } catch (Exception ex) {
                if (requestProcessor != null) {
                    throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                } else {
                    throw WebAppErrorReport.constructErrorReport(ex, name);
                }
            }

            // ... if the user has defined a custom error page for
            // SC_UNAUTHORIZED (HTTP status code 401) then
            // send it to the client
            if (context.isErrorPageDefined(sc) == true) {
            	
            	WebContainerRequestState reqState = com.ibm.wsspi.webcontainer.WebContainerRequestState.getInstance(false);
    			boolean errorPageAlreadySent = false;
    			if (reqState!=null) {
    				String spnegoErrorPageAlreadySent = (String)reqState.getAttribute(""spnego.error.page"");
    				reqState.removeAttribute(""spnego.error.page"");
    				if (spnegoErrorPageAlreadySent != null && spnegoErrorPageAlreadySent.equalsIgnoreCase(""true"")) {  					    		
    					errorPageAlreadySent = true; 
    				    if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable (Level.FINE) == true) {
    				         logger.logp(Level.FINE, CLASS_NAME,""processSecurityPreInvokeException"", ""skip error page - already created by spego code"");
    				    }	
    				}    
    			} 

    			if (!errorPageAlreadySent) {

    				if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
    					logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""
    							+ sc);
    				}

    				WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);
    				wErrorReport.setErrorCode(sc);
    				context.sendError(request, response, wErrorReport);
    				
    			}	
            } else {
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                            ""Using default security error page for HTTP status code "" + sc);
                }
                // reply.sendError(wResp); comment-out 140967
            }

        } else {
            // Unexpected status code ... not SC_UNAUTHORIZED or SC_FORBIDDEN
            if ((logger.isLoggable(Level.FINE) == true)) {
                logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""HTTP status code: "" + sc);
            }
            try {
                securityCollaborator.handleException(request, response, cause);
            } catch (Exception ex) {
                if (requestProcessor != null) {
                    throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                } else {
                    throw WebAppErrorReport.constructErrorReport(ex, name);
                }
            }
        }
        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
            logger.exiting(CLASS_NAME, ""processSecurityPreInvokeException"");
        }
        return secObject;
    }",0,custom http error response,"custom http error response<CODESPLIT>public Object processSecurityPreInvokeException(SecurityViolationException sve, RequestProcessor requestProcessor, HttpServletRequest request,             HttpServletResponse response, WebAppDispatcherContext dispatchContext, WebApp context, String name) throws ServletErrorReport {          Object secObject = null;          // begin pq56177          secObject = sve.getWebSecurityContext();         int sc = sve.getStatusCode(); // access status code directly. Is                                       // SC_FORBIDDEN the default?         // if (sc==null){         // if         // (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable         // (Level.FINE) == true)         // {         // logger.logp(Level.FINE,         // CLASS_NAME,""processSecurityPreInvokeException"",         // ""webReply is null, default to 403 status code"");         // }         // sc = HttpServletResponse.SC_FORBIDDEN;         // }         Throwable cause = sve.getCause();          if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {             logger.entering(CLASS_NAME, ""processSecurityPreInvokeException"");             logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",                     ""SecurityCollaboratorHelper.processPreInvokeException():  WebSecurityException thrown ("" + sve.toString()                             + "").  HTTP status code: "" + sc + ""resource : "" + name);          } // end if          if (sc == HttpServletResponse.SC_FORBIDDEN) {             // If the user has defined a custom error page for             // SC_FORBIDDEN (HTTP status code 403) then send             // it to the client ...             if (context.isErrorPageDefined(sc) == true) {                 if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {                     logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""                             + sc);                 }                  WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);                 wErrorReport.setErrorCode(sc);                 context.sendError(request, response, wErrorReport);             } else {                 // ... otherwise, use the one provided by the                 // SecurityCollaborator                 if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {                     logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",                             ""Using default security error page for HTTP status code "" + sc);                 }                  try {                     securityCollaborator.handleException(request, response, cause);                 } catch (Exception ex) {                     if (requestProcessor != null) {                         throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);                     } else {                         throw WebAppErrorReport.constructErrorReport(ex, name);                     }                 }                 // reply.sendError(wResp);             } // end if-else         } else if (sc == HttpServletResponse.SC_UNAUTHORIZED) {             // Invoking handleException will add the necessary headers             // to the response ...             try {                 securityCollaborator.handleException(request, response, cause);             } catch (Exception ex) {                 if (requestProcessor != null) {                     throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);                 } else {                     throw WebAppErrorReport.constructErrorReport(ex, name);                 }             }              // ... if the user has defined a custom error page for             // SC_UNAUTHORIZED (HTTP status code 401) then             // send it to the client             if (context.isErrorPageDefined(sc) == true) {             	             	WebContainerRequestState reqState = com.ibm.wsspi.webcontainer.WebContainerRequestState.getInstance(false);     			boolean errorPageAlreadySent = false;     			if (reqState!=null) {     				String spnegoErrorPageAlreadySent = (String)reqState.getAttribute(""spnego.error.page"");     				reqState.removeAttribute(""spnego.error.page"");     				if (spnegoErrorPageAlreadySent != null && spnegoErrorPageAlreadySent.equalsIgnoreCase(""true"")) {  					    		     					errorPageAlreadySent = true;      				    if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable (Level.FINE) == true) {     				         logger.logp(Level.FINE, CLASS_NAME,""processSecurityPreInvokeException"", ""skip error page - already created by spego code"");     				    }	     				}         			}       			if (!errorPageAlreadySent) {      				if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {     					logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""     							+ sc);     				}      				WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);     				wErrorReport.setErrorCode(sc);     				context.sendError(request, response, wErrorReport);     				     			}	             } else {                 if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {                     logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",                             ""Using default security error page for HTTP status code "" + sc);                 }                 // reply.sendError(wResp); comment-out 140967             }          } else {             // Unexpected status code ... not SC_UNAUTHORIZED or SC_FORBIDDEN             if ((logger.isLoggable(Level.FINE) == true)) {                 logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""HTTP status code: "" + sc);             }             try {                 securityCollaborator.handleException(request, response, cause);             } catch (Exception ex) {                 if (requestProcessor != null) {                     throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);                 } else {                     throw WebAppErrorReport.constructErrorReport(ex, name);                 }             }         }         if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {             logger.exiting(CLASS_NAME, ""processSecurityPreInvokeException"");         }         return secObject;     }"
"public boolean replaceStringsInFile(String filePath, Map<String, String> replaceValues) {
        return replaceStringsInFile(filePath, replaceValues, null);
    }",1,replace in file,"replace in file<CODESPLIT>public boolean replaceStringsInFile(String filePath, Map<String, String> replaceValues) {         return replaceStringsInFile(filePath, replaceValues, null);     }"
"public static String getHttpStatusCodeText(int sc) {
        HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);
        if (sCode == null) {
            return sc + "" <unknown status code>"";
        } else {
            return sCode.toString();
        }
    }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getHttpStatusCodeText(int sc) {         HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);         if (sCode == null) {             return sc + "" <unknown status code>"";         } else {             return sCode.toString();         }     }"
"public static Properties readPropertiesFromFile(File file)
      throws IOException {
    try (FileInputStream fis = new FileInputStream(file)) {
      Properties prop = new Properties();
      prop.load(fis);
      return prop;
    }
  }",3,read properties file,read properties file<CODESPLIT>public static Properties readPropertiesFromFile(File file)       throws IOException {     try (FileInputStream fis = new FileInputStream(file)) {       Properties prop = new Properties();       prop.load(fis);       return prop;     }   }
"public void sendOneWay(MessageOut message, int id, InetAddress to)
    {
        if (logger.isTraceEnabled())
            logger.trace(FBUtilities.getBroadcastAddress() + "" sending "" + message.verb + "" to "" + id + ""@"" + to);

        if (to.equals(FBUtilities.getBroadcastAddress()))
            logger.trace(""Message-to-self {} going over MessagingService"", message);

        // message sinks are a testing hook
        MessageOut processedMessage = SinkManager.processOutboundMessage(message, id, to);
        if (processedMessage == null)
        {
            return;
        }

        // get pooled connection (really, connection queue)
        OutboundTcpConnection connection = getConnection(to, processedMessage);

        // write it
        connection.enqueue(processedMessage, id);
    }",0,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>public void sendOneWay(MessageOut message, int id, InetAddress to)     {         if (logger.isTraceEnabled())             logger.trace(FBUtilities.getBroadcastAddress() + "" sending "" + message.verb + "" to "" + id + ""@"" + to);          if (to.equals(FBUtilities.getBroadcastAddress()))             logger.trace(""Message-to-self {} going over MessagingService"", message);          // message sinks are a testing hook         MessageOut processedMessage = SinkManager.processOutboundMessage(message, id, to);         if (processedMessage == null)         {             return;         }          // get pooled connection (really, connection queue)         OutboundTcpConnection connection = getConnection(to, processedMessage);          // write it         connection.enqueue(processedMessage, id);     }"
"private void updateCoordinates() {
    // Top-left of heat map.
    int x = margin + axisThickness + yAxisLabelSize.height;
    x += (yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight);
    int y = titleSize.height + margin;
    heatMapTL = new Point(x, y);

    // Top-right of heat map.
    x = heatMapTL.x + heatMapSize.width;
    y = heatMapTL.y + heatMapSize.height;
    heatMapBR = new Point(x, y);

    // Centre of heat map.
    x = heatMapTL.x + (heatMapSize.width / 2);
    y = heatMapTL.y + (heatMapSize.height / 2);
    heatMapC = new Point(x, y);
  }",1,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>private void updateCoordinates() {     // Top-left of heat map.     int x = margin + axisThickness + yAxisLabelSize.height;     x += (yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight);     int y = titleSize.height + margin;     heatMapTL = new Point(x, y);      // Top-right of heat map.     x = heatMapTL.x + heatMapSize.width;     y = heatMapTL.y + heatMapSize.height;     heatMapBR = new Point(x, y);      // Centre of heat map.     x = heatMapTL.x + (heatMapSize.width / 2);     y = heatMapTL.y + (heatMapSize.height / 2);     heatMapC = new Point(x, y);   }"
"private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {
    	JSONObject json = null;
        HttpClient postClient = HttpClientBuilder.create().build();
        HttpResponse response;
        
        try {
            response = postClient.execute(httpPost);
            
            if(response.getStatusLine().getStatusCode() == 200) {
                HttpEntity entity = response.getEntity();
                
                if (entity != null) {
                    InputStream instream = entity.getContent();  
                    String result = convertStreamToString(instream);
                    instream.close();
                    
                    json = new JSONObject(result);
                }
            } else {
            	json = UpworkRestClient.genError(response);
            }
        } catch (ClientProtocolException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");
        } catch (IOException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");
        } catch (JSONException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");  
        } catch (Exception e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());
        } finally {
            httpPost.abort();
        }
        
        return json;
    }",2,httpclient post json,"httpclient post json<CODESPLIT>private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {     	JSONObject json = null;         HttpClient postClient = HttpClientBuilder.create().build();         HttpResponse response;                  try {             response = postClient.execute(httpPost);                          if(response.getStatusLine().getStatusCode() == 200) {                 HttpEntity entity = response.getEntity();                                  if (entity != null) {                     InputStream instream = entity.getContent();                       String result = convertStreamToString(instream);                     instream.close();                                          json = new JSONObject(result);                 }             } else {             	json = UpworkRestClient.genError(response);             }         } catch (ClientProtocolException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");         } catch (IOException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");         } catch (JSONException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");           } catch (Exception e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());         } finally {             httpPost.abort();         }                  return json;     }"
"private void linkToEmitter(String name, LinearInterpolator interpol) {
		// put to value map
		valueMap.put(name, interpol);

		// now update the checkbox to represent the state of the given
		// interpolator
		boolean checked = interpol.isActive();
		JCheckBox enableControl = (JCheckBox) valueNameToControl.get(name);
		enableControl.setSelected(false);
		if (checked)
			enableControl.setSelected(checked);
	}",3,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>private void linkToEmitter(String name, LinearInterpolator interpol) { 		// put to value map 		valueMap.put(name, interpol);  		// now update the checkbox to represent the state of the given 		// interpolator 		boolean checked = interpol.isActive(); 		JCheckBox enableControl = (JCheckBox) valueNameToControl.get(name); 		enableControl.setSelected(false); 		if (checked) 			enableControl.setSelected(checked); 	}"
"public String fixPropertyName(String name) {
    if (""float"".equalsIgnoreCase(name)) {
      return ""cssFloat"";
    } else if (""for"".equalsIgnoreCase(name)) {
      return ""htmlFor"";
    }
    return JsUtils.camelize(name);
  }",0,set file attrib hidden,"set file attrib hidden<CODESPLIT>public String fixPropertyName(String name) {     if (""float"".equalsIgnoreCase(name)) {       return ""cssFloat"";     } else if (""for"".equalsIgnoreCase(name)) {       return ""htmlFor"";     }     return JsUtils.camelize(name);   }"
"public UniqueModel unique() {
		checkReadOnly();
		UniqueModel unique = new UniqueModel();
		unique.setTableModel(this);
		getUniqueConsts().add(unique);
		return unique;
	}",1,unique elements,unique elements<CODESPLIT>public UniqueModel unique() { 		checkReadOnly(); 		UniqueModel unique = new UniqueModel(); 		unique.setTableModel(this); 		getUniqueConsts().add(unique); 		return unique; 	}
"@Override
  public EventRequest deserialize(JsonElement json, Type typeOfT,
      JsonDeserializationContext context)
      throws JsonParseException {
    Gson gson = new GsonBuilder()
        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
        .create();

    // API versions 2017-05-25 and earlier render `request` as a string
    // instead of a JSON object
    if (json.isJsonPrimitive()) {
      EventRequest request = new EventRequest();
      request.setId(json.getAsString());
      return request;
    } else {
      return gson.fromJson(json, typeOfT);
    }
  }",2,deserialize json,"deserialize json<CODESPLIT>@Override   public EventRequest deserialize(JsonElement json, Type typeOfT,       JsonDeserializationContext context)       throws JsonParseException {     Gson gson = new GsonBuilder()         .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)         .create();      // API versions 2017-05-25 and earlier render `request` as a string     // instead of a JSON object     if (json.isJsonPrimitive()) {       EventRequest request = new EventRequest();       request.setId(json.getAsString());       return request;     } else {       return gson.fromJson(json, typeOfT);     }   }"
"public StringBuffer append(Reader source, StringBuffer buffer) throws IOException
	{
		BufferedReader _bufferedReader = new BufferedReader(source);
		char[] _buffer = new char[getBufferSize()]; // load by chunk of 4 ko
		try
		{
			for (int _countReadChars = 0; _countReadChars >= 0;)
			{
				buffer.append(_buffer, 0, _countReadChars);
				_countReadChars = _bufferedReader.read(_buffer);
			}
		}
		finally
		{
			_bufferedReader.close();
		}
		return buffer;
	}",3,buffered file reader read text,"buffered file reader read text<CODESPLIT>public StringBuffer append(Reader source, StringBuffer buffer) throws IOException 	{ 		BufferedReader _bufferedReader = new BufferedReader(source); 		char[] _buffer = new char[getBufferSize()]; // load by chunk of 4 ko 		try 		{ 			for (int _countReadChars = 0; _countReadChars >= 0;) 			{ 				buffer.append(_buffer, 0, _countReadChars); 				_countReadChars = _bufferedReader.read(_buffer); 			} 		} 		finally 		{ 			_bufferedReader.close(); 		} 		return buffer; 	}"
"private static boolean detectNameWordInSentenceByPosition(final List<Token> _text, final int _pos) {
        boolean isFirstWord = false;
        boolean nextWordIsName = false;
        if (_pos == 0 || !isLetterOrDigit((_text.get(_pos - 1).text.charAt(0)))) {
            isFirstWord = true;
            //noinspection SimplifiableIfStatement
            if (_text.size() > _pos + 1) {
                final String plus1 = _text.get(_pos + 1).text;
                nextWordIsName = (""of"".equalsIgnoreCase(plus1) || ""'s"".equalsIgnoreCase(plus1))
                                 ? ((_text.size() > (_pos + 2)) && isName(_text.get(_pos + 2).text, false, false))
                                 : isName(plus1, false, false);
            }
            else nextWordIsName = false;
        }
        //noinspection UnnecessaryLocalVariable
        final boolean isName = isName(_text.get(_pos).text, isFirstWord, nextWordIsName);

        /*
        String wordType = dict.checkup(Strings.toEngLowerCase(_text.get(_pos));
        if (isFirstWord && !isName && wordType != null && wordType.startsWith(""JJ"")) {
            // if the first word is determined not to be a name but it is an adj.,
            // and if the second word is a name, we consider the first word to be a name as well.
            if (isName(_text.get(_pos + 1), false))
                return true;
        }
        */

        return isName;
    }",0,how to determine a string is a valid word,"how to determine a string is a valid word<CODESPLIT>private static boolean detectNameWordInSentenceByPosition(final List<Token> _text, final int _pos) {         boolean isFirstWord = false;         boolean nextWordIsName = false;         if (_pos == 0 || !isLetterOrDigit((_text.get(_pos - 1).text.charAt(0)))) {             isFirstWord = true;             //noinspection SimplifiableIfStatement             if (_text.size() > _pos + 1) {                 final String plus1 = _text.get(_pos + 1).text;                 nextWordIsName = (""of"".equalsIgnoreCase(plus1) || ""'s"".equalsIgnoreCase(plus1))                                  ? ((_text.size() > (_pos + 2)) && isName(_text.get(_pos + 2).text, false, false))                                  : isName(plus1, false, false);             }             else nextWordIsName = false;         }         //noinspection UnnecessaryLocalVariable         final boolean isName = isName(_text.get(_pos).text, isFirstWord, nextWordIsName);          /*         String wordType = dict.checkup(Strings.toEngLowerCase(_text.get(_pos));         if (isFirstWord && !isName && wordType != null && wordType.startsWith(""JJ"")) {             // if the first word is determined not to be a name but it is an adj.,             // and if the second word is a name, we consider the first word to be a name as well.             if (isName(_text.get(_pos + 1), false))                 return true;         }         */          return isName;     }"
"public ExtractResult extract(String content, String selector, int amount) {

		List<Element> extracted = extractElements(content, selector, amount);

		if (extracted.size() > 1) {

			// first element is the remaining body, the rest are extracted
			Element body = extracted.get(0);
			List<Element> elements = extracted.subList(1, extracted.size());

			// convert to HTML
			List<String> elementStr = new ArrayList<String>();
			for (Element el : elements) {
				elementStr.add(el.outerHtml());
			}

			return new DefaultExtractResult(elementStr, body.html());
		} else {
			// nothing to extract
			return new DefaultExtractResult(Collections.<String> emptyList(), content);
		}
	}",1,extract data from html content,"extract data from html content<CODESPLIT>public ExtractResult extract(String content, String selector, int amount) {  		List<Element> extracted = extractElements(content, selector, amount);  		if (extracted.size() > 1) {  			// first element is the remaining body, the rest are extracted 			Element body = extracted.get(0); 			List<Element> elements = extracted.subList(1, extracted.size());  			// convert to HTML 			List<String> elementStr = new ArrayList<String>(); 			for (Element el : elements) { 				elementStr.add(el.outerHtml()); 			}  			return new DefaultExtractResult(elementStr, body.html()); 		} else { 			// nothing to extract 			return new DefaultExtractResult(Collections.<String> emptyList(), content); 		} 	}"
"@Override
    public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {

        // need to use boxed primitives as we can't customise sorting of int primitives
        Integer[] indexes = new Integer[atomContainerCount];
        for (int i = 0; i < indexes.length; i++)
            indexes[i] = i;

        // proxy the index comparison to the atom container comparator
        Arrays.sort(indexes, new Comparator<Integer>() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return comparator.compare(atomContainers[o1], atomContainers[o2]);
            }
        });

        // copy the original arrays (we could modify in place with swaps but this is cleaner)
        IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
        Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);

        // order the arrays based on the order of the indices
        for (int i = 0; i < indexes.length; i++) {
            atomContainers[i] = containersTmp[indexes[i]];
            multipliers[i] = multipliersTmp[indexes[i]];
        }

    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>@Override     public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {          // need to use boxed primitives as we can't customise sorting of int primitives         Integer[] indexes = new Integer[atomContainerCount];         for (int i = 0; i < indexes.length; i++)             indexes[i] = i;          // proxy the index comparison to the atom container comparator         Arrays.sort(indexes, new Comparator<Integer>() {              @Override             public int compare(Integer o1, Integer o2) {                 return comparator.compare(atomContainers[o1], atomContainers[o2]);             }         });          // copy the original arrays (we could modify in place with swaps but this is cleaner)         IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);         Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);          // order the arrays based on the order of the indices         for (int i = 0; i < indexes.length; i++) {             atomContainers[i] = containersTmp[indexes[i]];             multipliers[i] = multipliersTmp[indexes[i]];         }      }"
"public static int indexOfIgnoreCase(String text, String str, int startIndex) {
        Matcher m = Pattern.compile(Pattern.quote(str), Pattern.CASE_INSENSITIVE).matcher(text);
        return m.find(startIndex) ? m.start() : -1;
    }",3,regex case insensitive,"regex case insensitive<CODESPLIT>public static int indexOfIgnoreCase(String text, String str, int startIndex) {         Matcher m = Pattern.compile(Pattern.quote(str), Pattern.CASE_INSENSITIVE).matcher(text);         return m.find(startIndex) ? m.start() : -1;     }"
"public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {
        if (bool == null) {
            return nullValue;
        }
        return bool.booleanValue() ? trueValue : falseValue;
    }",0,convert int to bool,"convert int to bool<CODESPLIT>public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {         if (bool == null) {             return nullValue;         }         return bool.booleanValue() ? trueValue : falseValue;     }"
"private void readPropertiesFiles() {

        if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {
            // Skip configuration loading
            LOGGER.info(JRebirthMarkers.MESSAGE, ""Messages Loading is skipped"");

        } else {
            // Assemble the regex pattern
            final Pattern filePattern = Pattern.compile(this.messageFileWildcard + ""\\.properties"");

            // Retrieve all resources from default classpath
            final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);

            LOGGER.info(JRebirthMarkers.MESSAGE, ""{} Messages file{} found."", list.size(), list.size() > 1 ? ""s"" : """");

            for (final String rbFilename : list) {
                readPropertiesFile(rbFilename);
            }
        }
    }",1,read properties file,"read properties file<CODESPLIT>private void readPropertiesFiles() {          if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {             // Skip configuration loading             LOGGER.info(JRebirthMarkers.MESSAGE, ""Messages Loading is skipped"");          } else {             // Assemble the regex pattern             final Pattern filePattern = Pattern.compile(this.messageFileWildcard + ""\\.properties"");              // Retrieve all resources from default classpath             final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);              LOGGER.info(JRebirthMarkers.MESSAGE, ""{} Messages file{} found."", list.size(), list.size() > 1 ? ""s"" : """");              for (final String rbFilename : list) {                 readPropertiesFile(rbFilename);             }         }     }"
"@SuppressWarnings(""unchecked"")
    public final T[] filter(final T[] objects) {
        final Collection<T> filtered = filter(Arrays.asList(objects));
        try {
            return filtered.toArray((T[]) Array.newInstance(objects
                    .getClass(), filtered.size()));
        } catch (ArrayStoreException ase) {
            Logger log = LoggerFactory.getLogger(Filter.class);
            log.warn(""Error converting to array - using default approach"", ase);
        }
        return (T[]) filtered.toArray();
    }",2,filter array,"filter array<CODESPLIT>@SuppressWarnings(""unchecked"")     public final T[] filter(final T[] objects) {         final Collection<T> filtered = filter(Arrays.asList(objects));         try {             return filtered.toArray((T[]) Array.newInstance(objects                     .getClass(), filtered.size()));         } catch (ArrayStoreException ase) {             Logger log = LoggerFactory.getLogger(Filter.class);             log.warn(""Error converting to array - using default approach"", ase);         }         return (T[]) filtered.toArray();     }"
"public static ConfusionMatrix createCumulativeMatrix(ConfusionMatrix... matrices)
    {
        ConfusionMatrix result = new ConfusionMatrix();

        for (ConfusionMatrix matrix : matrices) {
            for (Map.Entry<String, Map<String, Integer>> gold : matrix.map.entrySet()) {
                for (Map.Entry<String, Integer> actual : gold.getValue().entrySet()) {
                    result.increaseValue(gold.getKey(), actual.getKey(), actual.getValue());
                }
            }
        }

        return result;
    }",3,confusion matrix,"confusion matrix<CODESPLIT>public static ConfusionMatrix createCumulativeMatrix(ConfusionMatrix... matrices)     {         ConfusionMatrix result = new ConfusionMatrix();          for (ConfusionMatrix matrix : matrices) {             for (Map.Entry<String, Map<String, Integer>> gold : matrix.map.entrySet()) {                 for (Map.Entry<String, Integer> actual : gold.getValue().entrySet()) {                     result.increaseValue(gold.getKey(), actual.getKey(), actual.getValue());                 }             }         }          return result;     }"
"public static String replace(final String string, final String find, final String replacement) {
		int pos = string.indexOf(find);
		//System.out.println(string+"": ""+find+"" at ""+pos);
		if (pos == -1) return string;
		StringBuilder SB = new StringBuilder();
		int lastpos = 0;
		final int findLen = find.length();
		do {
			SB.append(string, lastpos, pos).append(replacement);
			lastpos = pos + findLen;
			pos = string.indexOf(find, lastpos);
		} while (pos != -1);
		int len = string.length();
		if(lastpos<len) SB.append(string, lastpos, len);
		return SB.toString();
	}",0,find int in string,"find int in string<CODESPLIT>public static String replace(final String string, final String find, final String replacement) { 		int pos = string.indexOf(find); 		//System.out.println(string+"": ""+find+"" at ""+pos); 		if (pos == -1) return string; 		StringBuilder SB = new StringBuilder(); 		int lastpos = 0; 		final int findLen = find.length(); 		do { 			SB.append(string, lastpos, pos).append(replacement); 			lastpos = pos + findLen; 			pos = string.indexOf(find, lastpos); 		} while (pos != -1); 		int len = string.length(); 		if(lastpos<len) SB.append(string, lastpos, len); 		return SB.toString(); 	}"
"public List<Permutation> all() {
        final List<Permutation> permutations = new ArrayList<Permutation>();
        Backtracker counter = new Backtracker() {

            @Override
            public void applyTo(Permutation p) {
                permutations.add(p);
            }

            @Override
            public boolean isFinished() {
                return false;
            }
        };
        this.apply(counter);
        return permutations;
    }",1,all permutations of a list,all permutations of a list<CODESPLIT>public List<Permutation> all() {         final List<Permutation> permutations = new ArrayList<Permutation>();         Backtracker counter = new Backtracker() {              @Override             public void applyTo(Permutation p) {                 permutations.add(p);             }              @Override             public boolean isFinished() {                 return false;             }         };         this.apply(counter);         return permutations;     }
"public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {
        return seq(random.ints(randomNumberOrigin, randomNumberBound));
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {         return seq(random.ints(randomNumberOrigin, randomNumberBound));     }"
"public static String reverseString(String str) {
        StringBuilder stringBuffer = new StringBuilder(str);
        return stringBuffer.reverse().toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverseString(String str) {         StringBuilder stringBuffer = new StringBuilder(str);         return stringBuffer.reverse().toString();     }
"public void setUnacceptable(E element) {

    Ranking ranking = this.map.get(element);
    if (ranking == null) {
      ranking = new Ranking();
      this.map.put(element, ranking);
    }
    ranking.setUnacceptable();
  }",0,fuzzy match ranking,"fuzzy match ranking<CODESPLIT>public void setUnacceptable(E element) {      Ranking ranking = this.map.get(element);     if (ranking == null) {       ranking = new Ranking();       this.map.put(element, ranking);     }     ranking.setUnacceptable();   }"
"synchronized int size( int priority) {
    if (priority < 0 || priority >= LEVEL) {
      throw new IllegalArgumentException(""Unsupported priority: "" + priority);
    }
    return priorityQueues.get(priority).size();
  }",1,priority queue,"priority queue<CODESPLIT>synchronized int size( int priority) {     if (priority < 0 || priority >= LEVEL) {       throw new IllegalArgumentException(""Unsupported priority: "" + priority);     }     return priorityQueues.get(priority).size();   }"
"static
	public double probability(ContinuousDistribution distribution, Number x){

		if(distribution instanceof GaussianDistribution){
			return probability((GaussianDistribution)distribution, x);
		} else

		if(distribution instanceof PoissonDistribution){
			return probability((PoissonDistribution)distribution, x);
		}

		throw new UnsupportedElementException(distribution);
	}",2,normal distribution,"normal distribution<CODESPLIT>static 	public double probability(ContinuousDistribution distribution, Number x){  		if(distribution instanceof GaussianDistribution){ 			return probability((GaussianDistribution)distribution, x); 		} else  		if(distribution instanceof PoissonDistribution){ 			return probability((PoissonDistribution)distribution, x); 		}  		throw new UnsupportedElementException(distribution); 	}"
"private Properties readPropertyFile(String file) throws IOException {
        String fileName = file.startsWith(""/"") ? file : ""/"" + file;
        LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");
        return Util.readProperties(fileName);
    }",3,read properties file,"read properties file<CODESPLIT>private Properties readPropertyFile(String file) throws IOException {         String fileName = file.startsWith(""/"") ? file : ""/"" + file;         LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");         return Util.readProperties(fileName);     }"
"public List<E> getBetterOrEqual(int threshold) {

    List<E> bests = new ArrayList<>();
    for (E element : this.map.keySet()) {
      Ranking ranking = this.map.get(element);
      if ((ranking != null) && (ranking.rank >= threshold)) {
        bests.add(element);
      }
    }
    return bests;
  }",0,fuzzy match ranking,fuzzy match ranking<CODESPLIT>public List<E> getBetterOrEqual(int threshold) {      List<E> bests = new ArrayList<>();     for (E element : this.map.keySet()) {       Ranking ranking = this.map.get(element);       if ((ranking != null) && (ranking.rank >= threshold)) {         bests.add(element);       }     }     return bests;   }
"public void setWorkingDirectory(Path dir) throws IOException {
    ensureState(JobState.DEFINE);
    conf.setWorkingDirectory(dir);
  }",1,set working directory,set working directory<CODESPLIT>public void setWorkingDirectory(Path dir) throws IOException {     ensureState(JobState.DEFINE);     conf.setWorkingDirectory(dir);   }
"public static double similarLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;
    }",2,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarLevenshtein(String s1, String s2) {         if (s1.equals(s2)) {             return 1.0;         }          // Make sure s1 is the longest string         if (s1.length() < s2.length()) {             String swap = s1;             s1 = s2;             s2 = swap;         }          int bigLength = s1.length();         return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;     }"
"public void copySingleFile(File asset) {
        try {
            if ( !asset.isDirectory() ) {
                String targetPath = config.getDestinationFolder().getCanonicalPath() + File.separatorChar + assetSubPath(asset);
                LOGGER.info(""Copying single asset file to [{}]"", targetPath);
                copyFile(asset, new File(targetPath));
            } else {
                LOGGER.info(""Skip copying single asset file [{}]. Is a directory."", asset.getPath());
            }
        } catch (IOException io) {
            LOGGER.error(""Failed to copy the asset file."", io);
        }
    }",3,copying a file to a path,"copying a file to a path<CODESPLIT>public void copySingleFile(File asset) {         try {             if ( !asset.isDirectory() ) {                 String targetPath = config.getDestinationFolder().getCanonicalPath() + File.separatorChar + assetSubPath(asset);                 LOGGER.info(""Copying single asset file to [{}]"", targetPath);                 copyFile(asset, new File(targetPath));             } else {                 LOGGER.info(""Skip copying single asset file [{}]. Is a directory."", asset.getPath());             }         } catch (IOException io) {             LOGGER.error(""Failed to copy the asset file."", io);         }     }"
"private boolean readCMAP(FontFileReader in) throws IOException {

        unicodeMapping = new java.util.ArrayList();

        //Read CMAP table and correct mtxTab.index
        int mtxPtr = 0;

        seekTab(in, ""cmap"", 2);
        int numCMap = in.readTTFUShort();    // Number of cmap subtables
        long cmapUniOffset = 0;

        log.info(numCMap + "" cmap tables"");

        //Read offset for all tables. We are only interested in the unicode table
        for (int i = 0; i < numCMap; i++) {
            int cmapPID = in.readTTFUShort();
            int cmapEID = in.readTTFUShort();
            long cmapOffset = in.readTTFULong();

            log.debug(""Platform ID: "" + cmapPID + "" Encoding: "" + cmapEID);

            if (cmapPID == 3 && cmapEID == 1) {
                cmapUniOffset = cmapOffset;
            }
        }

        if (cmapUniOffset <= 0) {
            log.fatal(""Unicode cmap table not present"");
            log.fatal(""Unsupported format: Aborting"");
            return false;
        }

        // Read unicode cmap
        seekTab(in, ""cmap"", cmapUniOffset);
        int cmapFormat = in.readTTFUShort();
        /*int cmap_length =*/ in.readTTFUShort(); //skip cmap length

        log.info(""CMAP format: "" + cmapFormat);

        if (cmapFormat == 4) {
            in.skip(2);    // Skip version number
            int cmapSegCountX2 = in.readTTFUShort();
            int cmapSearchRange = in.readTTFUShort();
            int cmapEntrySelector = in.readTTFUShort();
            int cmapRangeShift = in.readTTFUShort();

            if (log.isDebugEnabled()) {
                log.debug(""segCountX2   : "" + cmapSegCountX2);
                log.debug(""searchRange  : "" + cmapSearchRange);
                log.debug(""entrySelector: "" + cmapEntrySelector);
                log.debug(""rangeShift   : "" + cmapRangeShift);
            }


            int[] cmapEndCounts = new int[cmapSegCountX2 / 2];
            int[] cmapStartCounts = new int[cmapSegCountX2 / 2];
            int[] cmapDeltas = new int[cmapSegCountX2 / 2];
            int[] cmapRangeOffsets = new int[cmapSegCountX2 / 2];

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapEndCounts[i] = in.readTTFUShort();
            }

            in.skip(2);    // Skip reservedPad

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapStartCounts[i] = in.readTTFUShort();
            }

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapDeltas[i] = in.readTTFShort();
            }

            //int startRangeOffset = in.getCurrentPos();

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapRangeOffsets[i] = in.readTTFUShort();
            }

            int glyphIdArrayOffset = in.getCurrentPos();

            // Insert the unicode id for the glyphs in mtxTab
            // and fill in the cmaps ArrayList

            for (int i = 0; i < cmapStartCounts.length; i++) {

                if (log.isTraceEnabled()) {
                    log.trace(i + "": "" + cmapStartCounts[i]
                                                         + "" - "" + cmapEndCounts[i]);
                }

                for (int j = cmapStartCounts[i]; j <= cmapEndCounts[i]; j++) {

                    // Update lastChar
                    if (j < 256 && j > lastChar) {
                        lastChar = (short)j;
                    }

                    if (mtxPtr < mtxTab.length) {
                        int glyphIdx;
                        // the last character 65535 = .notdef
                        // may have a range offset
                        if (cmapRangeOffsets[i] != 0 && j != 65535) {
                            int glyphOffset = glyphIdArrayOffset
                                + ((cmapRangeOffsets[i] / 2)
                                    + (j - cmapStartCounts[i])
                                    + (i)
                                    - cmapSegCountX2 / 2) * 2;
                            in.seekSet(glyphOffset);
                            glyphIdx = (in.readTTFUShort() + cmapDeltas[i])
                                       & 0xffff;

                            unicodeMapping.add(new UnicodeMapping(glyphIdx, j));
                            mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));


                            // Also add winAnsiWidth
                            List v = (List)ansiIndex.get(new Integer(j));
                            if (v != null) {
                                Iterator e = v.listIterator();
                                while (e.hasNext()) {
                                    Integer aIdx = (Integer)e.next();
                                    ansiWidth[aIdx.intValue()] 
                                        = mtxTab[glyphIdx].getWx();

                                    if (log.isTraceEnabled()) {
                                        log.trace(""Added width ""
                                                + mtxTab[glyphIdx].getWx()
                                                + "" uni: "" + j
                                                + "" ansi: "" + aIdx.intValue());
                                    }
                                }
                            }

                            if (log.isTraceEnabled()) {
                                log.trace(""Idx: ""
                                        + glyphIdx
                                        + "" Delta: "" + cmapDeltas[i]
                                        + "" Unicode: "" + j
                                        + "" name: "" + mtxTab[glyphIdx].getName());
                            }
                        } else {
                            glyphIdx = (j + cmapDeltas[i]) & 0xffff;

                            if (glyphIdx < mtxTab.length) {
                                mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));
                            } else {
                                log.debug(""Glyph "" + glyphIdx
                                                   + "" out of range: ""
                                                   + mtxTab.length);
                            }

                            unicodeMapping.add(new UnicodeMapping(glyphIdx, j));
                            if (glyphIdx < mtxTab.length) {
                                mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));
                            } else {
                                log.debug(""Glyph "" + glyphIdx
                                                   + "" out of range: ""
                                                   + mtxTab.length);
                            }

                            // Also add winAnsiWidth
                            List v = (List)ansiIndex.get(new Integer(j));
                            if (v != null) {
                                Iterator e = v.listIterator();
                                while (e.hasNext()) {
                                    Integer aIdx = (Integer)e.next();
                                    ansiWidth[aIdx.intValue()] = mtxTab[glyphIdx].getWx();
                                }
                            }

                            //getLogger().debug(""IIdx: "" +
                            //    mtxPtr +
                            //    "" Delta: "" + cmap_deltas[i] +
                            //    "" Unicode: "" + j +
                            //    "" name: "" +
                            //    mtxTab[(j+cmap_deltas[i]) & 0xffff].name);

                        }
                        if (glyphIdx < mtxTab.length) {
                            if (mtxTab[glyphIdx].getUnicodeIndex().size() < 2) {
                                mtxPtr++;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }",0,how to read .csv file in an efficient way?,"how to read .csv file in an efficient way?<CODESPLIT>private boolean readCMAP(FontFileReader in) throws IOException {          unicodeMapping = new java.util.ArrayList();          //Read CMAP table and correct mtxTab.index         int mtxPtr = 0;          seekTab(in, ""cmap"", 2);         int numCMap = in.readTTFUShort();    // Number of cmap subtables         long cmapUniOffset = 0;          log.info(numCMap + "" cmap tables"");          //Read offset for all tables. We are only interested in the unicode table         for (int i = 0; i < numCMap; i++) {             int cmapPID = in.readTTFUShort();             int cmapEID = in.readTTFUShort();             long cmapOffset = in.readTTFULong();              log.debug(""Platform ID: "" + cmapPID + "" Encoding: "" + cmapEID);              if (cmapPID == 3 && cmapEID == 1) {                 cmapUniOffset = cmapOffset;             }         }          if (cmapUniOffset <= 0) {             log.fatal(""Unicode cmap table not present"");             log.fatal(""Unsupported format: Aborting"");             return false;         }          // Read unicode cmap         seekTab(in, ""cmap"", cmapUniOffset);         int cmapFormat = in.readTTFUShort();         /*int cmap_length =*/ in.readTTFUShort(); //skip cmap length          log.info(""CMAP format: "" + cmapFormat);          if (cmapFormat == 4) {             in.skip(2);    // Skip version number             int cmapSegCountX2 = in.readTTFUShort();             int cmapSearchRange = in.readTTFUShort();             int cmapEntrySelector = in.readTTFUShort();             int cmapRangeShift = in.readTTFUShort();              if (log.isDebugEnabled()) {                 log.debug(""segCountX2   : "" + cmapSegCountX2);                 log.debug(""searchRange  : "" + cmapSearchRange);                 log.debug(""entrySelector: "" + cmapEntrySelector);                 log.debug(""rangeShift   : "" + cmapRangeShift);             }               int[] cmapEndCounts = new int[cmapSegCountX2 / 2];             int[] cmapStartCounts = new int[cmapSegCountX2 / 2];             int[] cmapDeltas = new int[cmapSegCountX2 / 2];             int[] cmapRangeOffsets = new int[cmapSegCountX2 / 2];              for (int i = 0; i < (cmapSegCountX2 / 2); i++) {                 cmapEndCounts[i] = in.readTTFUShort();             }              in.skip(2);    // Skip reservedPad              for (int i = 0; i < (cmapSegCountX2 / 2); i++) {                 cmapStartCounts[i] = in.readTTFUShort();             }              for (int i = 0; i < (cmapSegCountX2 / 2); i++) {                 cmapDeltas[i] = in.readTTFShort();             }              //int startRangeOffset = in.getCurrentPos();              for (int i = 0; i < (cmapSegCountX2 / 2); i++) {                 cmapRangeOffsets[i] = in.readTTFUShort();             }              int glyphIdArrayOffset = in.getCurrentPos();              // Insert the unicode id for the glyphs in mtxTab             // and fill in the cmaps ArrayList              for (int i = 0; i < cmapStartCounts.length; i++) {                  if (log.isTraceEnabled()) {                     log.trace(i + "": "" + cmapStartCounts[i]                                                          + "" - "" + cmapEndCounts[i]);                 }                  for (int j = cmapStartCounts[i]; j <= cmapEndCounts[i]; j++) {                      // Update lastChar                     if (j < 256 && j > lastChar) {                         lastChar = (short)j;                     }                      if (mtxPtr < mtxTab.length) {                         int glyphIdx;                         // the last character 65535 = .notdef                         // may have a range offset                         if (cmapRangeOffsets[i] != 0 && j != 65535) {                             int glyphOffset = glyphIdArrayOffset                                 + ((cmapRangeOffsets[i] / 2)                                     + (j - cmapStartCounts[i])                                     + (i)                                     - cmapSegCountX2 / 2) * 2;                             in.seekSet(glyphOffset);                             glyphIdx = (in.readTTFUShort() + cmapDeltas[i])                                        & 0xffff;                              unicodeMapping.add(new UnicodeMapping(glyphIdx, j));                             mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));                               // Also add winAnsiWidth                             List v = (List)ansiIndex.get(new Integer(j));                             if (v != null) {                                 Iterator e = v.listIterator();                                 while (e.hasNext()) {                                     Integer aIdx = (Integer)e.next();                                     ansiWidth[aIdx.intValue()]                                          = mtxTab[glyphIdx].getWx();                                      if (log.isTraceEnabled()) {                                         log.trace(""Added width ""                                                 + mtxTab[glyphIdx].getWx()                                                 + "" uni: "" + j                                                 + "" ansi: "" + aIdx.intValue());                                     }                                 }                             }                              if (log.isTraceEnabled()) {                                 log.trace(""Idx: ""                                         + glyphIdx                                         + "" Delta: "" + cmapDeltas[i]                                         + "" Unicode: "" + j                                         + "" name: "" + mtxTab[glyphIdx].getName());                             }                         } else {                             glyphIdx = (j + cmapDeltas[i]) & 0xffff;                              if (glyphIdx < mtxTab.length) {                                 mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));                             } else {                                 log.debug(""Glyph "" + glyphIdx                                                    + "" out of range: ""                                                    + mtxTab.length);                             }                              unicodeMapping.add(new UnicodeMapping(glyphIdx, j));                             if (glyphIdx < mtxTab.length) {                                 mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));                             } else {                                 log.debug(""Glyph "" + glyphIdx                                                    + "" out of range: ""                                                    + mtxTab.length);                             }                              // Also add winAnsiWidth                             List v = (List)ansiIndex.get(new Integer(j));                             if (v != null) {                                 Iterator e = v.listIterator();                                 while (e.hasNext()) {                                     Integer aIdx = (Integer)e.next();                                     ansiWidth[aIdx.intValue()] = mtxTab[glyphIdx].getWx();                                 }                             }                              //getLogger().debug(""IIdx: "" +                             //    mtxPtr +                             //    "" Delta: "" + cmap_deltas[i] +                             //    "" Unicode: "" + j +                             //    "" name: "" +                             //    mtxTab[(j+cmap_deltas[i]) & 0xffff].name);                          }                         if (glyphIdx < mtxTab.length) {                             if (mtxTab[glyphIdx].getUnicodeIndex().size() < 2) {                                 mtxPtr++;                             }                         }                     }                 }             }         }         return true;     }"
"public <T> List<T> randomElements(List<T> elements, int count) {
		if (elements.size() >= count) {
			return extractRandomList(elements, count);
		} else {
			List<T> randomElements = new ArrayList<T>();
			randomElements.addAll(extractRandomList(elements, count % elements.size()));
			do {
				randomElements.addAll(extractRandomList(elements, elements.size()));
			} while (randomElements.size() < count);
			return randomElements;
		}
	}",1,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public <T> List<T> randomElements(List<T> elements, int count) { 		if (elements.size() >= count) { 			return extractRandomList(elements, count); 		} else { 			List<T> randomElements = new ArrayList<T>(); 			randomElements.addAll(extractRandomList(elements, count % elements.size())); 			do { 				randomElements.addAll(extractRandomList(elements, elements.size())); 			} while (randomElements.size() < count); 			return randomElements; 		} 	}"
"public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {
        if (!this.timeCharts.containsKey(scatterID)) {
            ScatterPlotGenerator scatter = new ScatterPlotGenerator();
            scatter.setTitle(scatterID);
            scatter.setXAxisLabel(xAxisLabel);
            scatter.setYAxisLabel(yAxisLabel);
            this.scatterPlots.put(scatterID, scatter);
        } else {
            throw new DuplicatedChartIDException(scatterID);
        }
    }",2,scatter plot,"scatter plot<CODESPLIT>public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {         if (!this.timeCharts.containsKey(scatterID)) {             ScatterPlotGenerator scatter = new ScatterPlotGenerator();             scatter.setTitle(scatterID);             scatter.setXAxisLabel(xAxisLabel);             scatter.setYAxisLabel(yAxisLabel);             this.scatterPlots.put(scatterID, scatter);         } else {             throw new DuplicatedChartIDException(scatterID);         }     }"
"public static int levenshteinDistance(CharSequence s, CharSequence t)
    {
        // degenerate cases          s
        if (s == null || """".equals(s))
        {
            return t == null || """".equals(t) ? 0 : t.length();
        }
        else if (t == null || """".equals(t))
        {
            return s.length();
        }

        // create two work vectors of integer distances
        int[] v0 = new int[t.length() + 1];
        int[] v1 = new int[t.length() + 1];

        // initialize v0 (the previous row of distances)
        // this row is A[0][i]: edit distance for an empty s
        // the distance is just the number of characters to delete from t
        for (int i = 0; i < v0.length; i++)
        {
            v0[i] = i;
        }

        int sLen = s.length();
        int tLen = t.length();
        for (int i = 0; i < sLen; i++)
        {
            // calculate v1 (current row distances) from the previous row v0

            // first element of v1 is A[i+1][0]
            //   edit distance is delete (i+1) chars from s to match empty t
            v1[0] = i + 1;

            // use formula to fill in the rest of the row
            for (int j = 0; j < tLen; j++)
            {
                int cost = (s.charAt(i) == t.charAt(j)) ? 0 : 1;
                v1[j + 1] = (int) MathUtilities.minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
            }

            // copy v1 (current row) to v0 (previous row) for next iteration
            System.arraycopy(v1, 0, v0, 0, v0.length);
        }

        return v1[t.length()];
    }",3,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static int levenshteinDistance(CharSequence s, CharSequence t)     {         // degenerate cases          s         if (s == null || """".equals(s))         {             return t == null || """".equals(t) ? 0 : t.length();         }         else if (t == null || """".equals(t))         {             return s.length();         }          // create two work vectors of integer distances         int[] v0 = new int[t.length() + 1];         int[] v1 = new int[t.length() + 1];          // initialize v0 (the previous row of distances)         // this row is A[0][i]: edit distance for an empty s         // the distance is just the number of characters to delete from t         for (int i = 0; i < v0.length; i++)         {             v0[i] = i;         }          int sLen = s.length();         int tLen = t.length();         for (int i = 0; i < sLen; i++)         {             // calculate v1 (current row distances) from the previous row v0              // first element of v1 is A[i+1][0]             //   edit distance is delete (i+1) chars from s to match empty t             v1[0] = i + 1;              // use formula to fill in the rest of the row             for (int j = 0; j < tLen; j++)             {                 int cost = (s.charAt(i) == t.charAt(j)) ? 0 : 1;                 v1[j + 1] = (int) MathUtilities.minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);             }              // copy v1 (current row) to v0 (previous row) for next iteration             System.arraycopy(v1, 0, v0, 0, v0.length);         }          return v1[t.length()];     }"
"public <T> Observable<T> getAndObserve(String key, Class<T> classOfT, T defaultValue) {
    return getAndObserve(key, TypeToken.fromClass(classOfT), defaultValue);
  }",0,get current observable value,"get current observable value<CODESPLIT>public <T> Observable<T> getAndObserve(String key, Class<T> classOfT, T defaultValue) {     return getAndObserve(key, TypeToken.fromClass(classOfT), defaultValue);   }"
"private static void summarizeNBModel(ModelSummary summary, hex.nb.NBModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""Naive Bayes"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, NB_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, NB_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, NB_expert_params);
  }",1,print model summary,"print model summary<CODESPLIT>private static void summarizeNBModel(ModelSummary summary, hex.nb.NBModel model) {     // add generic fields such as column names     summarizeModelCommonFields(summary, model);      summary.model_algorithm = ""Naive Bayes"";      JsonObject all_params = (model.get_params()).toJSON();     summary.critical_parameters = whitelistJsonObject(all_params, NB_critical_params);     summary.secondary_parameters = whitelistJsonObject(all_params, NB_secondary_params);     summary.expert_parameters = whitelistJsonObject(all_params, NB_expert_params);   }"
"public static Properties readPropertiesFromFile(String _fileName, Properties _props) {
        Properties props = _props == null ? new Properties() : _props;

        LOGGER.debug(""Trying to read properties from file: "" + _fileName);
        Properties newProperties = readProperties(new File(_fileName));
        if (newProperties != null) {
            LOGGER.debug(""Successfully read properties from file: "" + _fileName);
            props.putAll(newProperties);
        }

        return props;
    }",2,read properties file,"read properties file<CODESPLIT>public static Properties readPropertiesFromFile(String _fileName, Properties _props) {         Properties props = _props == null ? new Properties() : _props;          LOGGER.debug(""Trying to read properties from file: "" + _fileName);         Properties newProperties = readProperties(new File(_fileName));         if (newProperties != null) {             LOGGER.debug(""Successfully read properties from file: "" + _fileName);             props.putAll(newProperties);         }          return props;     }"
"public static void zipCompress(String filename) throws IOException {
    FileOutputStream fos = new FileOutputStream(filename + COMPRESSION_SUFFIX);
    CheckedOutputStream csum = new CheckedOutputStream(fos, new CRC32());
    ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(csum));
    out.setComment(""Failmon records."");

    BufferedReader in = new BufferedReader(new FileReader(filename));
    out.putNextEntry(new ZipEntry(new File(filename).getName()));
    int c;
    while ((c = in.read()) != -1)
      out.write(c);
    in.close();

    out.finish();
    out.close();
  }",3,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>public static void zipCompress(String filename) throws IOException {     FileOutputStream fos = new FileOutputStream(filename + COMPRESSION_SUFFIX);     CheckedOutputStream csum = new CheckedOutputStream(fos, new CRC32());     ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(csum));     out.setComment(""Failmon records."");      BufferedReader in = new BufferedReader(new FileReader(filename));     out.putNextEntry(new ZipEntry(new File(filename).getName()));     int c;     while ((c = in.read()) != -1)       out.write(c);     in.close();      out.finish();     out.close();   }"
"private byte[] doEncryptionOrDecryption(byte[] crypt, Key key, int mode) {
        Cipher rsaCipher;
        try {
            rsaCipher = Cipher.getInstance(CIPHER);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw SeedException.wrap(e, CryptoErrorCode.UNABLE_TO_GET_CIPHER)
                    .put(""alias"", alias)
                    .put(""cipher"", CIPHER);
        }
        try {
            rsaCipher.init(mode, key);
        } catch (InvalidKeyException e) {
            throw SeedException.wrap(e, CryptoErrorCode.INVALID_KEY)
                    .put(""alias"", alias);
        }
        try {
            return rsaCipher.doFinal(crypt);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            throw SeedException.wrap(e, CryptoErrorCode.UNEXPECTED_EXCEPTION);
        }
    }",0,aes encryption,"aes encryption<CODESPLIT>private byte[] doEncryptionOrDecryption(byte[] crypt, Key key, int mode) {         Cipher rsaCipher;         try {             rsaCipher = Cipher.getInstance(CIPHER);         } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {             throw SeedException.wrap(e, CryptoErrorCode.UNABLE_TO_GET_CIPHER)                     .put(""alias"", alias)                     .put(""cipher"", CIPHER);         }         try {             rsaCipher.init(mode, key);         } catch (InvalidKeyException e) {             throw SeedException.wrap(e, CryptoErrorCode.INVALID_KEY)                     .put(""alias"", alias);         }         try {             return rsaCipher.doFinal(crypt);         } catch (IllegalBlockSizeException | BadPaddingException e) {             throw SeedException.wrap(e, CryptoErrorCode.UNEXPECTED_EXCEPTION);         }     }"
"public Matrix multiply(Matrix B)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C);
        return C;
    }",1,matrix multiply,"matrix multiply<CODESPLIT>public Matrix multiply(Matrix B)     {         Matrix C = new DenseMatrix(this.rows(), B.cols());         multiply(B, C);         return C;     }"
"private void readPropertyFile()
	{
		java.util.Properties props = new java.util.Properties();
	    try
	    {
	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME);
	        if (propertyFile.exists())
	        {
	        	java.io.FileInputStream fis = null;
	        	try
	        	{
			    	fis = new java.io.FileInputStream(propertyFile);
			        props.load(fis);
	        	}
	        	finally
	        	{
	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); }
	        	}
	        }

	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR);
			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR);
			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName());
			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE""));
			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0""));
			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0""));
			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES);
			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++)
			{
				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null);
				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null);
			}
			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE"")));
			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1""));
			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410""));
			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1""));
			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230""));
			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false""));
			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1""));
			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630""));
			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false""));
			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1""));
			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400""));
			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false""));
			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1""));
			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470""));
			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false""));
			
			if (currentEqualizer!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE""));
				currentEqualizer.setIsActive(isActive);
				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0""));
				currentEqualizer.setPreAmp(preAmpValueDB);
				for (int i=0; i<currentEqualizer.getBandCount(); i++)
				{
					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0""));
					currentEqualizer.setBand(i, bandValueDB);
				}
			}
			if (currentPitchShift!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE""));
				currentPitchShift.setIsActive(isActive);
				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0""));
				currentPitchShift.setPitchScale(pitchValue);
				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0""));
				currentPitchShift.setSampleScale(scaleValue);
				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32""));
				currentPitchShift.setFFTOversampling(overSampling);
				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192""));
				currentPitchShift.setFFTFrameSize(frameSize);
			}

			MultimediaContainerManager.configureContainer(props);
	    }
	    catch (Throwable ex)
	    {
			Log.error(""[MainForm]"", ex);
	    }
	}",2,read properties file,"read properties file<CODESPLIT>private void readPropertyFile() 	{ 		java.util.Properties props = new java.util.Properties(); 	    try 	    { 	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME); 	        if (propertyFile.exists()) 	        { 	        	java.io.FileInputStream fis = null; 	        	try 	        	{ 			    	fis = new java.io.FileInputStream(propertyFile); 			        props.load(fis); 	        	} 	        	finally 	        	{ 	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); } 	        	} 	        }  	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR); 			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR); 			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName()); 			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE"")); 			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0"")); 			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0"")); 			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES); 			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++) 			{ 				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null); 				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null); 			} 			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE""))); 			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1"")); 			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410"")); 			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1"")); 			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230"")); 			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false"")); 			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1"")); 			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630"")); 			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false"")); 			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1"")); 			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400"")); 			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false"")); 			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1"")); 			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470"")); 			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false"")); 			 			if (currentEqualizer!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE"")); 				currentEqualizer.setIsActive(isActive); 				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0"")); 				currentEqualizer.setPreAmp(preAmpValueDB); 				for (int i=0; i<currentEqualizer.getBandCount(); i++) 				{ 					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0"")); 					currentEqualizer.setBand(i, bandValueDB); 				} 			} 			if (currentPitchShift!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE"")); 				currentPitchShift.setIsActive(isActive); 				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0"")); 				currentPitchShift.setPitchScale(pitchValue); 				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0"")); 				currentPitchShift.setSampleScale(scaleValue); 				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32"")); 				currentPitchShift.setFFTOversampling(overSampling); 				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192"")); 				currentPitchShift.setFFTFrameSize(frameSize); 			}  			MultimediaContainerManager.configureContainer(props); 	    } 	    catch (Throwable ex) 	    { 			Log.error(""[MainForm]"", ex); 	    } 	}"
"protected static Number stringToNumber(final String val) throws NumberFormatException {
        char initial = val.charAt(0);
        if ((initial >= '0' && initial <= '9') || initial == '-') {
            // decimal representation
            if (isDecimalNotation(val)) {
                // quick dirty way to see if we need a BigDecimal instead of a Double
                // this only handles some cases of overflow or underflow
                if (val.length()>14) {
                    return new BigDecimal(val);
                }
                final Double d = Double.valueOf(val);
                if (d.isInfinite() || d.isNaN()) {
                    // if we can't parse it as a double, go up to BigDecimal
                    // this is probably due to underflow like 4.32e-678
                    // or overflow like 4.65e5324. The size of the string is small
                    // but can't be held in a Double.
                    return new BigDecimal(val);
                }
                return d;
            }
            // integer representation.
            // This will narrow any values to the smallest reasonable Object representation
            // (Integer, Long, or BigInteger)
            
            // string version
            // The compare string length method reduces GC,
            // but leads to smaller integers being placed in larger wrappers even though not
            // needed. i.e. 1,000,000,000 -> Long even though it's an Integer
            // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long
            //if(val.length()<=9){
            //    return Integer.valueOf(val);
            //}
            //if(val.length()<=18){
            //    return Long.valueOf(val);
            //}
            //return new BigInteger(val);
            
            // BigInteger version: We use a similar bitLenth compare as
            // BigInteger#intValueExact uses. Increases GC, but objects hold
            // only what they need. i.e. Less runtime overhead if the value is
            // long lived. Which is the better tradeoff? This is closer to what's
            // in stringToValue.
            BigInteger bi = new BigInteger(val);
            if(bi.bitLength()<=31){
                return Integer.valueOf(bi.intValue());
            }
            if(bi.bitLength()<=63){
                return Long.valueOf(bi.longValue());
            }
            return bi;
        }
        throw new NumberFormatException(""val [""+val+""] is not a valid number."");
    }",3,convert string to number,"convert string to number<CODESPLIT>protected static Number stringToNumber(final String val) throws NumberFormatException {         char initial = val.charAt(0);         if ((initial >= '0' && initial <= '9') || initial == '-') {             // decimal representation             if (isDecimalNotation(val)) {                 // quick dirty way to see if we need a BigDecimal instead of a Double                 // this only handles some cases of overflow or underflow                 if (val.length()>14) {                     return new BigDecimal(val);                 }                 final Double d = Double.valueOf(val);                 if (d.isInfinite() || d.isNaN()) {                     // if we can't parse it as a double, go up to BigDecimal                     // this is probably due to underflow like 4.32e-678                     // or overflow like 4.65e5324. The size of the string is small                     // but can't be held in a Double.                     return new BigDecimal(val);                 }                 return d;             }             // integer representation.             // This will narrow any values to the smallest reasonable Object representation             // (Integer, Long, or BigInteger)                          // string version             // The compare string length method reduces GC,             // but leads to smaller integers being placed in larger wrappers even though not             // needed. i.e. 1,000,000,000 -> Long even though it's an Integer             // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long             //if(val.length()<=9){             //    return Integer.valueOf(val);             //}             //if(val.length()<=18){             //    return Long.valueOf(val);             //}             //return new BigInteger(val);                          // BigInteger version: We use a similar bitLenth compare as             // BigInteger#intValueExact uses. Increases GC, but objects hold             // only what they need. i.e. Less runtime overhead if the value is             // long lived. Which is the better tradeoff? This is closer to what's             // in stringToValue.             BigInteger bi = new BigInteger(val);             if(bi.bitLength()<=31){                 return Integer.valueOf(bi.intValue());             }             if(bi.bitLength()<=63){                 return Long.valueOf(bi.longValue());             }             return bi;         }         throw new NumberFormatException(""val [""+val+""] is not a valid number."");     }"
"public static <T> List<T> randomListFrom(Iterable<T> elements, Range<Integer> size) {
    checkArgument(!isEmpty(elements), ""Elements to populate from must not be empty"");
    return randomListFrom(() -> IterableUtils.randomFrom(elements), size);
  }",0,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public static <T> List<T> randomListFrom(Iterable<T> elements, Range<Integer> size) {     checkArgument(!isEmpty(elements), ""Elements to populate from must not be empty"");     return randomListFrom(() -> IterableUtils.randomFrom(elements), size);   }"
"public static byte[] decryptAES(SecretKey key, byte[] iv, byte[] encryptedBytes) throws
            NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        IvParameterSpec ivParameter = new IvParameterSpec(iv);
        // see http://stackoverflow.com/a/11506343
        Key encryptionKey = new SecretKeySpec(key.getEncoded(),""AES"");
        aesCipher.init(Cipher.DECRYPT_MODE, encryptionKey, ivParameter);
        return aesCipher.doFinal(encryptedBytes);
    }",1,aes encryption,"aes encryption<CODESPLIT>public static byte[] decryptAES(SecretKey key, byte[] iv, byte[] encryptedBytes) throws             NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,             InvalidKeyException, BadPaddingException, IllegalBlockSizeException {         Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");         IvParameterSpec ivParameter = new IvParameterSpec(iv);         // see http://stackoverflow.com/a/11506343         Key encryptionKey = new SecretKeySpec(key.getEncoded(),""AES"");         aesCipher.init(Cipher.DECRYPT_MODE, encryptionKey, ivParameter);         return aesCipher.doFinal(encryptedBytes);     }"
"public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{

        // write each byte buffer to the serial port
        for(ByteBuffer single : data) {

            // read the byte buffer from the current position up to the limit
            byte[] payload = new byte[single.remaining()];
            single.get(payload);

            // write the data contents to the serial port via JNI native method
            write(fd, payload, payload.length);
        }
    }",2,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{          // write each byte buffer to the serial port         for(ByteBuffer single : data) {              // read the byte buffer from the current position up to the limit             byte[] payload = new byte[single.remaining()];             single.get(payload);              // write the data contents to the serial port via JNI native method             write(fd, payload, payload.length);         }     }"
"private void handleContextMenu(JTree tree, int x, int y) {
		TreePath path = tree.getPathForLocation(x, y);
		tree.setSelectionPath(path);
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();

		if (node == null)
			return;
		if (!node.isLeaf()) {
			tree.setSelectionPath(null);
			return;
		}
		final AppInfo info = (AppInfo) node.getUserObject();

		JMenuItem copyname = new JMenuItem(""Copy Name"");
		copyname.addActionListener(e -> {
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(info.app.getSimpleName()), null);
		});

		JMenuItem copypath = new JMenuItem(""Copy Path"");
		copypath.addActionListener(e -> {
			String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(path1), null);
		});

		JMenuItem github = new JMenuItem(""Go to Github"");
		github.addActionListener(e -> openInGitHub(info));

		JPopupMenu submenu = new JPopupMenu();
		submenu.add(copyname);
		submenu.add(copypath);
		submenu.add(github);
		submenu.show(tree, x, y);
	}",3,copy to clipboard,"copy to clipboard<CODESPLIT>private void handleContextMenu(JTree tree, int x, int y) { 		TreePath path = tree.getPathForLocation(x, y); 		tree.setSelectionPath(path); 		DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();  		if (node == null) 			return; 		if (!node.isLeaf()) { 			tree.setSelectionPath(null); 			return; 		} 		final AppInfo info = (AppInfo) node.getUserObject();  		JMenuItem copyname = new JMenuItem(""Copy Name""); 		copyname.addActionListener(e -> { 			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 			clipboard.setContents(new StringSelection(info.app.getSimpleName()), null); 		});  		JMenuItem copypath = new JMenuItem(""Copy Path""); 		copypath.addActionListener(e -> { 			String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName()); 			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 			clipboard.setContents(new StringSelection(path1), null); 		});  		JMenuItem github = new JMenuItem(""Go to Github""); 		github.addActionListener(e -> openInGitHub(info));  		JPopupMenu submenu = new JPopupMenu(); 		submenu.add(copyname); 		submenu.add(copypath); 		submenu.add(github); 		submenu.show(tree, x, y); 	}"
"public LoadBalancerFilter descriptionContains(String... subStrings) {
        allItemsNotNull(subStrings, ""Load balancer description subStrings"");

        predicate = predicate.and(combine(
                LoadBalancerMetadata::getDescription, in(asList(subStrings), Predicates::containsIgnoreCase)
        ));

        return this;
    }",0,positions of substrings in string,"positions of substrings in string<CODESPLIT>public LoadBalancerFilter descriptionContains(String... subStrings) {         allItemsNotNull(subStrings, ""Load balancer description subStrings"");          predicate = predicate.and(combine(                 LoadBalancerMetadata::getDescription, in(asList(subStrings), Predicates::containsIgnoreCase)         ));          return this;     }"
"public static double similarDamerauLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - getDamerauLevenshteinDistance(s2, s1)) / (double) bigLength;
    }",1,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarDamerauLevenshtein(String s1, String s2) {         if (s1.equals(s2)) {             return 1.0;         }          // Make sure s1 is the longest string         if (s1.length() < s2.length()) {             String swap = s1;             s1 = s2;             s2 = swap;         }          int bigLength = s1.length();         return (bigLength - getDamerauLevenshteinDistance(s2, s1)) / (double) bigLength;     }"
"public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) {
		
		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();
        for (int i = 0; i < clustering.size(); i++) {
            if (clustering.get(i) instanceof CFCluster) {
                microclusters.add((CFCluster)clustering.get(i));
            } else {
                System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");
            }
        }
        
        int n = microclusters.size();
		assert (k <= n);
		
		/* k-means */
		Random random = new Random(0);
		Cluster[] centers = new Cluster[k];
		int K = gtClustering.size();
		
		for (int i = 0; i < k; i++) {
			if (i < K) {	// GT-aided
				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0);
			} else {		// Randomized
				int rid = random.nextInt(n);
				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0);
			}
		}
		
		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters);
	}",2,k means clustering,"k means clustering<CODESPLIT>public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) { 		 		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();         for (int i = 0; i < clustering.size(); i++) {             if (clustering.get(i) instanceof CFCluster) {                 microclusters.add((CFCluster)clustering.get(i));             } else {                 System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");             }         }                  int n = microclusters.size(); 		assert (k <= n); 		 		/* k-means */ 		Random random = new Random(0); 		Cluster[] centers = new Cluster[k]; 		int K = gtClustering.size(); 		 		for (int i = 0; i < k; i++) { 			if (i < K) {	// GT-aided 				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0); 			} else {		// Randomized 				int rid = random.nextInt(n); 				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0); 			} 		} 		 		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters); 	}"
"public Matrix multiply(Matrix B, ExecutorService threadPool)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C, threadPool);
        return C;
    }",3,matrix multiply,"matrix multiply<CODESPLIT>public Matrix multiply(Matrix B, ExecutorService threadPool)     {         Matrix C = new DenseMatrix(this.rows(), B.cols());         multiply(B, C, threadPool);         return C;     }"
"public TemplateFilter descriptionContains(String... substrings) {
        allItemsNotNull(substrings, ""Template description substrings"");

        predicate = predicate.and(combine(
            TemplateMetadata::getDescription, in(asList(substrings), Predicates::containsIgnoreCase)
        ));

        return this;
    }",0,positions of substrings in string,"positions of substrings in string<CODESPLIT>public TemplateFilter descriptionContains(String... substrings) {         allItemsNotNull(substrings, ""Template description substrings"");          predicate = predicate.and(combine(             TemplateMetadata::getDescription, in(asList(substrings), Predicates::containsIgnoreCase)         ));          return this;     }"
"private CFile parseCFile( JSONObject jObj )
    {
        CFile cfile;

        if ( jObj.optBoolean( ""is_dir"", false ) ) {
            cfile = new CFolder( new CPath( jObj.getString( ""path"" ) ) );

        } else {
            cfile = new CBlob( new CPath( jObj.getString( ""path"" ) ), jObj.getLong( ""bytes"" ), jObj.getString( ""mime_type"" ) );
            String stringDate = jObj.getString( ""modified"" );

            try {
                // stringDate looks like: ""Fri, 07 Mar 2014 17:47:55 +0000""
                SimpleDateFormat sdf = new SimpleDateFormat( ""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US );
                Date modified = sdf.parse( stringDate );
                cfile.setModificationDate( modified );

            } catch ( ParseException ex ) {
                throw new CStorageException( ""Can't parse date modified: "" + stringDate + "" ("" + ex.getMessage() + "")"", ex );
            }
        }

        return cfile;
    }",1,parse json file,"parse json file<CODESPLIT>private CFile parseCFile( JSONObject jObj )     {         CFile cfile;          if ( jObj.optBoolean( ""is_dir"", false ) ) {             cfile = new CFolder( new CPath( jObj.getString( ""path"" ) ) );          } else {             cfile = new CBlob( new CPath( jObj.getString( ""path"" ) ), jObj.getLong( ""bytes"" ), jObj.getString( ""mime_type"" ) );             String stringDate = jObj.getString( ""modified"" );              try {                 // stringDate looks like: ""Fri, 07 Mar 2014 17:47:55 +0000""                 SimpleDateFormat sdf = new SimpleDateFormat( ""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US );                 Date modified = sdf.parse( stringDate );                 cfile.setModificationDate( modified );              } catch ( ParseException ex ) {                 throw new CStorageException( ""Can't parse date modified: "" + stringDate + "" ("" + ex.getMessage() + "")"", ex );             }         }          return cfile;     }"
"protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) {
		assert (centers.length == k);
		assert (k > 0);

		int dimensions = centers[0].getCenter().length;

		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>();
		for (int i = 0; i < k; i++) {
			clustering.add(new ArrayList<Cluster>());
		}

		while (true) {
			// Assign points to clusters
			for (Cluster point : data) {
				double minDistance = distance(point.getCenter(), centers[0].getCenter());
				int closestCluster = 0;
				for (int i = 1; i < k; i++) {
					double distance = distance(point.getCenter(), centers[i].getCenter());
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				clustering.get(closestCluster).add(point);
			}

			// Calculate new centers and clear clustering lists
			SphereCluster[] newCenters = new SphereCluster[centers.length];
			for (int i = 0; i < k; i++) {
				newCenters[i] = calculateCenter(clustering.get(i), dimensions);
				clustering.get(i).clear();
			}
			
			// Convergence check
			boolean converged = true;
			for (int i = 0; i < k; i++) {
				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) {
					converged = false;
					break;
				}
			}
			
			if (converged) {
				break;
			} else {
				centers = newCenters;
			}
		}

		return new Clustering(centers);
	}",2,k means clustering,"k means clustering<CODESPLIT>protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) { 		assert (centers.length == k); 		assert (k > 0);  		int dimensions = centers[0].getCenter().length;  		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>(); 		for (int i = 0; i < k; i++) { 			clustering.add(new ArrayList<Cluster>()); 		}  		while (true) { 			// Assign points to clusters 			for (Cluster point : data) { 				double minDistance = distance(point.getCenter(), centers[0].getCenter()); 				int closestCluster = 0; 				for (int i = 1; i < k; i++) { 					double distance = distance(point.getCenter(), centers[i].getCenter()); 					if (distance < minDistance) { 						closestCluster = i; 						minDistance = distance; 					} 				}  				clustering.get(closestCluster).add(point); 			}  			// Calculate new centers and clear clustering lists 			SphereCluster[] newCenters = new SphereCluster[centers.length]; 			for (int i = 0; i < k; i++) { 				newCenters[i] = calculateCenter(clustering.get(i), dimensions); 				clustering.get(i).clear(); 			} 			 			// Convergence check 			boolean converged = true; 			for (int i = 0; i < k; i++) { 				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) { 					converged = false; 					break; 				} 			} 			 			if (converged) { 				break; 			} else { 				centers = newCenters; 			} 		}  		return new Clustering(centers); 	}"
"public static long binCoeff(int n, int k) {
                if (k > n) {
                        return 0;
                }
                if (k == 0 || k == n) {
                        return 1;
                }
                long result = 1;
                for (int i = 1; i <= k; i++) {
                        result *= (n - i + 1) / i;
                }
                return result;
        }",3,binomial distribution,"binomial distribution<CODESPLIT>public static long binCoeff(int n, int k) {                 if (k > n) {                         return 0;                 }                 if (k == 0 || k == n) {                         return 1;                 }                 long result = 1;                 for (int i = 1; i <= k; i++) {                         result *= (n - i + 1) / i;                 }                 return result;         }"
"public ConfusionMatrix getTransposedMatrix()
    {
        ConfusionMatrix result = new ConfusionMatrix();

        for (Map.Entry<String, Map<String, Integer>> gold : this.map.entrySet()) {
            for (Map.Entry<String, Integer> predicted : gold.getValue().entrySet()) {
                int value = predicted.getValue();

                // add reverted values
                result.increaseValue(predicted.getKey(), gold.getKey(), value);
            }
        }

        return result;
    }",0,confusion matrix,"confusion matrix<CODESPLIT>public ConfusionMatrix getTransposedMatrix()     {         ConfusionMatrix result = new ConfusionMatrix();          for (Map.Entry<String, Map<String, Integer>> gold : this.map.entrySet()) {             for (Map.Entry<String, Integer> predicted : gold.getValue().entrySet()) {                 int value = predicted.getValue();                  // add reverted values                 result.increaseValue(predicted.getKey(), gold.getKey(), value);             }         }          return result;     }"
"public static CheckBox newCheckBox(final String id, final IModel<Boolean> model)
	{
		final CheckBox checkBox = new CheckBox(id, model);
		checkBox.setOutputMarkupId(true);
		return checkBox;
	}",1,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>public static CheckBox newCheckBox(final String id, final IModel<Boolean> model) 	{ 		final CheckBox checkBox = new CheckBox(id, model); 		checkBox.setOutputMarkupId(true); 		return checkBox; 	}"
"public static HttpRequest head(final CharSequence baseUrl,
      final Map<?, ?> params, final boolean encode) {
    String url = append(baseUrl, params);
    return head(encode ? encode(url) : url);
  }",2,encode url,"encode url<CODESPLIT>public static HttpRequest head(final CharSequence baseUrl,       final Map<?, ?> params, final boolean encode) {     String url = append(baseUrl, params);     return head(encode ? encode(url) : url);   }"
"public void printHtmlFooter(PrintWriter out, ResourceBundle reg)
    {
        String strHTML = reg.getString(""htmlFooter"");
        if ((strHTML == null) || (strHTML.length() == 0))
            strHTML = ""</body>\n</html>"";
        out.println(strHTML);
        out.flush();
    }",3,output to html file,"output to html file<CODESPLIT>public void printHtmlFooter(PrintWriter out, ResourceBundle reg)     {         String strHTML = reg.getString(""htmlFooter"");         if ((strHTML == null) || (strHTML.length() == 0))             strHTML = ""</body>\n</html>"";         out.println(strHTML);         out.flush();     }"
"@Override
	public final void setPriority(int priority) throws JMSException
    {
        if (priority < 0 || priority > 9)
            throw new FFMQException(""Invalid priority value : ""+priority,""INVALID_PRIORITY"");
        
        this.defaultPriority = priority;
    }",0,priority queue,"priority queue<CODESPLIT>@Override 	public final void setPriority(int priority) throws JMSException     {         if (priority < 0 || priority > 9)             throw new FFMQException(""Invalid priority value : ""+priority,""INVALID_PRIORITY"");                  this.defaultPriority = priority;     }"
"private List decodeSort(String value) {
        ArrayList sorts = new ArrayList();

        String[] nameAndSorts = value.split(DELIM_GRID_NAME);
        if(nameAndSorts.length != 2)
            return null;

        String namespace = nameAndSorts[0];
        String[] sortStrings = nameAndSorts[1].split(DELIM_SORT_TERM);

        // find the list of sorted columns
        // two columns of the bugs grid would be sorted as:
        //
        // netui_sort=bugs~id,-priority
        for(int i = 0; i < sortStrings.length; i++) {
            String sort = sortStrings[i];
            SortDirection sortDirection = SortDirection.NONE;
            if(sort.startsWith(""-""))
                sortDirection = SortDirection.DESCENDING;
            else
                sortDirection = SortDirection.ASCENDING;
            String sortExpression = (sortDirection == SortDirection.DESCENDING ? sort.substring(1) : sort);
            Sort gridSort = _config.createSort();
            gridSort.setSortExpression(sortExpression);
            gridSort.setDirection(sortDirection);
            sorts.add(gridSort);
        }

        return sorts;
    }",1,sort string list,"sort string list<CODESPLIT>private List decodeSort(String value) {         ArrayList sorts = new ArrayList();          String[] nameAndSorts = value.split(DELIM_GRID_NAME);         if(nameAndSorts.length != 2)             return null;          String namespace = nameAndSorts[0];         String[] sortStrings = nameAndSorts[1].split(DELIM_SORT_TERM);          // find the list of sorted columns         // two columns of the bugs grid would be sorted as:         //         // netui_sort=bugs~id,-priority         for(int i = 0; i < sortStrings.length; i++) {             String sort = sortStrings[i];             SortDirection sortDirection = SortDirection.NONE;             if(sort.startsWith(""-""))                 sortDirection = SortDirection.DESCENDING;             else                 sortDirection = SortDirection.ASCENDING;             String sortExpression = (sortDirection == SortDirection.DESCENDING ? sort.substring(1) : sort);             Sort gridSort = _config.createSort();             gridSort.setSortExpression(sortExpression);             gridSort.setDirection(sortDirection);             sorts.add(gridSort);         }          return sorts;     }"
"public static Date getCurrentDateTime() throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }",2,how to get current date,how to get current date<CODESPLIT>public static Date getCurrentDateTime() throws ParseException {         Calendar currentDate = Calendar.getInstance();         SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);         String dateNow = formatter.format(currentDate.getTime());         return getDateFromString(dateNow);     }
"public boolean verifyChecked(final By checkboxBy) {
		WebElement element = driver.findElement(checkboxBy);

		if (element.isSelected()) {
			LOG.info(""Checkbox: "" + element + "" is checked!"");
			return true;
		}

		LOG.info(""Checkbox: "" + element + "" is NOT checked!"");
		return false;
	}",3,how to check if a checkbox is checked,"how to check if a checkbox is checked<CODESPLIT>public boolean verifyChecked(final By checkboxBy) { 		WebElement element = driver.findElement(checkboxBy);  		if (element.isSelected()) { 			LOG.info(""Checkbox: "" + element + "" is checked!""); 			return true; 		}  		LOG.info(""Checkbox: "" + element + "" is NOT checked!""); 		return false; 	}"
"public static String createUniqueName(XNameAccess _xElementContainer, String _sElementName) {
        boolean bElementexists = true;
        int i = 1;
        String sIncSuffix = """";
        String BaseName = _sElementName;
        while (bElementexists) {
            bElementexists = _xElementContainer.hasByName(_sElementName);
            if (bElementexists) {
                i += 1;
                _sElementName = BaseName + Integer.toString(i);
            }
        }
        return _sElementName;
    }",0,unique elements,"unique elements<CODESPLIT>public static String createUniqueName(XNameAccess _xElementContainer, String _sElementName) {         boolean bElementexists = true;         int i = 1;         String sIncSuffix = """";         String BaseName = _sElementName;         while (bElementexists) {             bElementexists = _xElementContainer.hasByName(_sElementName);             if (bElementexists) {                 i += 1;                 _sElementName = BaseName + Integer.toString(i);             }         }         return _sElementName;     }"
"private void cut(XYChartLabel label, double maxWidth, double maxHeight, double rotation)
    {
        String text = label.getLabel().getText();

        // Cut text.
        cutLabelText(label, maxWidth - 5, maxHeight - 5, rotation);

        String cutText = label.getLabel().getText();

        // If text is cut, add suffix characters.
        if (text.length() != cutText.length())
        {
            label.getLabel().setText(label.getLabel().getText() + ""..."");
        }
        // TODO: Animate.
        // animate(label, text, cutText, originalRotation);

        // Move label to top.
        label.getLabelContainer().moveToTop();
    }",1,underline text in label widget,"underline text in label widget<CODESPLIT>private void cut(XYChartLabel label, double maxWidth, double maxHeight, double rotation)     {         String text = label.getLabel().getText();          // Cut text.         cutLabelText(label, maxWidth - 5, maxHeight - 5, rotation);          String cutText = label.getLabel().getText();          // If text is cut, add suffix characters.         if (text.length() != cutText.length())         {             label.getLabel().setText(label.getLabel().getText() + ""..."");         }         // TODO: Animate.         // animate(label, text, cutText, originalRotation);          // Move label to top.         label.getLabelContainer().moveToTop();     }"
"public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException {
		try {
			logger.debug(""Json string to deserialize {} "", json);
			return mapper.readValue(json, typeReference);
		} catch (IOException e) {
			logger.error(""SerializationException {}"", e.getMessage());
			SerializationException serializationException = new SerializationException(e);
			throw serializationException;
		}
	}",2,deserialize json,"deserialize json<CODESPLIT>public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException { 		try { 			logger.debug(""Json string to deserialize {} "", json); 			return mapper.readValue(json, typeReference); 		} catch (IOException e) { 			logger.error(""SerializationException {}"", e.getMessage()); 			SerializationException serializationException = new SerializationException(e); 			throw serializationException; 		} 	}"
"static String urlencode(final String s) {
		try {
			return URLEncoder.encode(s, CHARSET_NAME);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
	}",3,encode url,"encode url<CODESPLIT>static String urlencode(final String s) { 		try { 			return URLEncoder.encode(s, CHARSET_NAME); 		} catch (UnsupportedEncodingException e) { 			throw new RuntimeException(e); 		} 	}"
"public static String encode(String str)
    {
        String encodedValue = str;

        try
        {
            encodedValue = URLEncoder.encode(encodedValue, ""UTF-8"");

            // Spaces in NRQL queries expected to be encoded as ""%20"" instead of ""+"".
            encodedValue = encodedValue.replace(""+"", ""%20"");
        }
        catch (UnsupportedEncodingException e)
        {
            logger.severe(""Failed to encode value: ""+str);
        }

        return encodedValue;
    }",0,html encode string,"html encode string<CODESPLIT>public static String encode(String str)     {         String encodedValue = str;          try         {             encodedValue = URLEncoder.encode(encodedValue, ""UTF-8"");              // Spaces in NRQL queries expected to be encoded as ""%20"" instead of ""+"".             encodedValue = encodedValue.replace(""+"", ""%20"");         }         catch (UnsupportedEncodingException e)         {             logger.severe(""Failed to encode value: ""+str);         }          return encodedValue;     }"
"public static Builder running(File executable) {
        checkArgument(executable.isFile(), ""file not found: %s"", executable);
        checkArgument(executable.canExecute(), ""executable.canExecute"");
        return running(executable.getPath());
    }",1,get executable path,"get executable path<CODESPLIT>public static Builder running(File executable) {         checkArgument(executable.isFile(), ""file not found: %s"", executable);         checkArgument(executable.canExecute(), ""executable.canExecute"");         return running(executable.getPath());     }"
"private void generatePdf() {
        File pdfFile = new File(directory, filename + "".pdf"");
        try (OutputStream os = new FileOutputStream(pdfFile)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()
                    .replaceAll("" "", ""%20""));
            builder.toStream(os);
            builder.run();
        } catch (Exception e) {
            log.error(e);
        }
    }",2,convert html to pdf,"convert html to pdf<CODESPLIT>private void generatePdf() {         File pdfFile = new File(directory, filename + "".pdf"");         try (OutputStream os = new FileOutputStream(pdfFile)) {             PdfRendererBuilder builder = new PdfRendererBuilder();             builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()                     .replaceAll("" "", ""%20""));             builder.toStream(os);             builder.run();         } catch (Exception e) {             log.error(e);         }     }"
"public void post(String jsonBody, Integer expectedResponseCode) throws IOException {
    HttpURLConnection conn = getUrlConnection();

    try {
      // send post request with json body for the topology
      if (!NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, jsonBody.getBytes())) {
        throw new IOException(""Failed to send POST to "" + endpointURI);
      }

      // check the response
      if (!NetworkUtils.checkHttpResponseCode(conn, expectedResponseCode)) {
        byte[] bytes = NetworkUtils.readHttpResponse(conn);
        LOG.log(Level.SEVERE, ""Failed to send POST request to endpoint"");
        LOG.log(Level.SEVERE, new String(bytes));
        throw new IOException(""Unexpected response from connection. Expected ""
            + expectedResponseCode + "" but received "" + conn.getResponseCode());
      }
    } finally {
      conn.disconnect();
    }
  }",3,httpclient post json,"httpclient post json<CODESPLIT>public void post(String jsonBody, Integer expectedResponseCode) throws IOException {     HttpURLConnection conn = getUrlConnection();      try {       // send post request with json body for the topology       if (!NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, jsonBody.getBytes())) {         throw new IOException(""Failed to send POST to "" + endpointURI);       }        // check the response       if (!NetworkUtils.checkHttpResponseCode(conn, expectedResponseCode)) {         byte[] bytes = NetworkUtils.readHttpResponse(conn);         LOG.log(Level.SEVERE, ""Failed to send POST request to endpoint"");         LOG.log(Level.SEVERE, new String(bytes));         throw new IOException(""Unexpected response from connection. Expected ""             + expectedResponseCode + "" but received "" + conn.getResponseCode());       }     } finally {       conn.disconnect();     }   }"
"protected RefProperty registerErrorModel(Swagger swagger) {
        String ref = Error.class.getSimpleName();
        if (swagger.getDefinitions() != null && swagger.getDefinitions().containsKey(ref)) {
            // model already registered
            return new RefProperty(ref);
        }

        ModelImpl model = new ModelImpl();
        swagger.addDefinition(ref, model);

        model.setDescription(""an error message"");

        model.addProperty(""statusCode"", new IntegerProperty().readOnly().description(""http status code""));
        model.addProperty(""statusMessage"", new StringProperty().readOnly().description(""description of the http status code""));
        model.addProperty(""requestMethod"", new StringProperty().readOnly().description(""http request method""));
        model.addProperty(""requestUri"", new StringProperty().readOnly().description(""http request path""));
        model.addProperty(""message"", new StringProperty().readOnly().description(""application message""));

        if (settings.isDev()) {
            // in DEV mode the stacktrace is returned in the error message
            model.addProperty(""stacktrace"", new StringProperty().readOnly().description(""application stacktrace""));
        }

        return new RefProperty(ref);
    }",0,get the description of a http status code,"get the description of a http status code<CODESPLIT>protected RefProperty registerErrorModel(Swagger swagger) {         String ref = Error.class.getSimpleName();         if (swagger.getDefinitions() != null && swagger.getDefinitions().containsKey(ref)) {             // model already registered             return new RefProperty(ref);         }          ModelImpl model = new ModelImpl();         swagger.addDefinition(ref, model);          model.setDescription(""an error message"");          model.addProperty(""statusCode"", new IntegerProperty().readOnly().description(""http status code""));         model.addProperty(""statusMessage"", new StringProperty().readOnly().description(""description of the http status code""));         model.addProperty(""requestMethod"", new StringProperty().readOnly().description(""http request method""));         model.addProperty(""requestUri"", new StringProperty().readOnly().description(""http request path""));         model.addProperty(""message"", new StringProperty().readOnly().description(""application message""));          if (settings.isDev()) {             // in DEV mode the stacktrace is returned in the error message             model.addProperty(""stacktrace"", new StringProperty().readOnly().description(""application stacktrace""));         }          return new RefProperty(ref);     }"
"public void save(File file) throws IOException {
        try (FileOutputStream fout = new FileOutputStream(file)) {
            save(fout);
        }
    }",1,save list to file,save list to file<CODESPLIT>public void save(File file) throws IOException {         try (FileOutputStream fout = new FileOutputStream(file)) {             save(fout);         }     }
"public static Map<String, List<String>> extractHTMLheaders(String html) {
        Map<String, List<String>> hxtagsMap = new HashMap<>();
        for(int i=1;i<=6;++i) {
            hxtagsMap.put(""H""+i, new ArrayList<>());
        }
                
        Matcher m = HX_PATTERN.matcher(html);
        while (m.find()) {
            if(m.groupCount()==2) {
                String tagType = m.group(1).toUpperCase(Locale.ENGLISH);
                String content = m.group(2);
                hxtagsMap.get(tagType).add(clear(content));
            }
        }
        return hxtagsMap;
    }",2,extract data from html content,"extract data from html content<CODESPLIT>public static Map<String, List<String>> extractHTMLheaders(String html) {         Map<String, List<String>> hxtagsMap = new HashMap<>();         for(int i=1;i<=6;++i) {             hxtagsMap.put(""H""+i, new ArrayList<>());         }                          Matcher m = HX_PATTERN.matcher(html);         while (m.find()) {             if(m.groupCount()==2) {                 String tagType = m.group(1).toUpperCase(Locale.ENGLISH);                 String content = m.group(2);                 hxtagsMap.get(tagType).add(clear(content));             }         }         return hxtagsMap;     }"
"public static double kMeans(List<double[]> centroids, List<double[]> input) {
		int k = centroids.size();
		assert (k > 0);
		int d = centroids.get(0).length;
		int size = input.size();

		double[][] center = new double[k][];
		Iterator<double[]> iIter = centroids.iterator();
		for (int i = 0; i < k; i++) {
			center[i] = iIter.next();
		}

		double[][] newCenter = new double[k][d];
		double[] newCenterWeight = new double[k];
		int[] nearestCluster = new int[size];
		boolean converged;
		do {
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					newCenter[i][j] = 0.0;
				}
				newCenterWeight[i] = 0.0;
			}
			Iterator<double[]> lIter = input.iterator();
			for (int l = 0; l < size; l++) {
				// Calculates the distance from all points to all centroids
				double[] point = lIter.next();
				assert (d == point.length - 1);
				double minDistance = Double.POSITIVE_INFINITY;
				int closestCluster = -1;
				for (int i = 0; i < k; i++) {
					double distance = Metric.distance(center[i], point, 1);
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				// Sums up all points for the new centroids
				assert (closestCluster >= 0 && closestCluster < k);
				for (int j = 0; j < d; j++) {
					newCenter[closestCluster][j] += point[0] * point[j + 1];
				}
				newCenterWeight[closestCluster] += point[0];
				nearestCluster[l] = closestCluster;
			}

			// Calculates the new centroids
			converged = true;
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					if (newCenterWeight[i] != 0.0) {
						double newValue = newCenter[i][j] / newCenterWeight[i];
						if (newValue != center[i][j]) {
							converged = false;
						}
						center[i][j] = newValue;
					}
				}
			}
		} while (!converged);
		// Replaces the old centroids with the new ones
		for (int i = 0; i < k; i++) {
			centroids.set(i, center[i]);
		}

		// Calculates the costs of the solution
		double costs = 0.0;
		Iterator<double[]> lIter = input.iterator();
		for (int l = 0; l < size; l++) {
			double[] point = lIter.next();
			costs += point[0]
					* Metric.distanceSquared(center[nearestCluster[l]], point,
							1);
		}
		return costs;
	}",3,k means clustering,"k means clustering<CODESPLIT>public static double kMeans(List<double[]> centroids, List<double[]> input) { 		int k = centroids.size(); 		assert (k > 0); 		int d = centroids.get(0).length; 		int size = input.size();  		double[][] center = new double[k][]; 		Iterator<double[]> iIter = centroids.iterator(); 		for (int i = 0; i < k; i++) { 			center[i] = iIter.next(); 		}  		double[][] newCenter = new double[k][d]; 		double[] newCenterWeight = new double[k]; 		int[] nearestCluster = new int[size]; 		boolean converged; 		do { 			for (int i = 0; i < k; i++) { 				for (int j = 0; j < d; j++) { 					newCenter[i][j] = 0.0; 				} 				newCenterWeight[i] = 0.0; 			} 			Iterator<double[]> lIter = input.iterator(); 			for (int l = 0; l < size; l++) { 				// Calculates the distance from all points to all centroids 				double[] point = lIter.next(); 				assert (d == point.length - 1); 				double minDistance = Double.POSITIVE_INFINITY; 				int closestCluster = -1; 				for (int i = 0; i < k; i++) { 					double distance = Metric.distance(center[i], point, 1); 					if (distance < minDistance) { 						closestCluster = i; 						minDistance = distance; 					} 				}  				// Sums up all points for the new centroids 				assert (closestCluster >= 0 && closestCluster < k); 				for (int j = 0; j < d; j++) { 					newCenter[closestCluster][j] += point[0] * point[j + 1]; 				} 				newCenterWeight[closestCluster] += point[0]; 				nearestCluster[l] = closestCluster; 			}  			// Calculates the new centroids 			converged = true; 			for (int i = 0; i < k; i++) { 				for (int j = 0; j < d; j++) { 					if (newCenterWeight[i] != 0.0) { 						double newValue = newCenter[i][j] / newCenterWeight[i]; 						if (newValue != center[i][j]) { 							converged = false; 						} 						center[i][j] = newValue; 					} 				} 			} 		} while (!converged); 		// Replaces the old centroids with the new ones 		for (int i = 0; i < k; i++) { 			centroids.set(i, center[i]); 		}  		// Calculates the costs of the solution 		double costs = 0.0; 		Iterator<double[]> lIter = input.iterator(); 		for (int l = 0; l < size; l++) { 			double[] point = lIter.next(); 			costs += point[0] 					* Metric.distanceSquared(center[nearestCluster[l]], point, 							1); 		} 		return costs; 	}"
"public void replaceStringChildren(List<String> strings) {
		ArrayList<StringEntity> entities = new ArrayList<>();
		for (String string : strings) {
			StringEntity entity = new StringEntity();
			entity.setValue(string);
			entities.add(entity);
		}
		replaceAll(entities);
	}",0,html entities replace,html entities replace<CODESPLIT>public void replaceStringChildren(List<String> strings) { 		ArrayList<StringEntity> entities = new ArrayList<>(); 		for (String string : strings) { 			StringEntity entity = new StringEntity(); 			entity.setValue(string); 			entities.add(entity); 		} 		replaceAll(entities); 	}
"private Date toDate(final String pStringDate) {

        // weird manipulation to parse the date... remove ':' from the timezone
        // before: 2011-07-12T22:42:40.000+02:00
        // after: 2011-07-12T22:42:40.000+0200
        final StringBuilder _date = new StringBuilder();
        _date.append(pStringDate.substring(0, pStringDate.length() - 3));
        _date.append(pStringDate.substring(pStringDate.length() - 2));
        try {
            return new SimpleDateFormat(RFC_339_DATE_FORMAT).parse(_date.toString());
        } catch (final ParseException e) {
            throw new IllegalArgumentException(
                    ""The given spreadsheet ListEntry usercrashdate field value is malformed"", e);
        }
    }",1,string to date,"string to date<CODESPLIT>private Date toDate(final String pStringDate) {          // weird manipulation to parse the date... remove ':' from the timezone         // before: 2011-07-12T22:42:40.000+02:00         // after: 2011-07-12T22:42:40.000+0200         final StringBuilder _date = new StringBuilder();         _date.append(pStringDate.substring(0, pStringDate.length() - 3));         _date.append(pStringDate.substring(pStringDate.length() - 2));         try {             return new SimpleDateFormat(RFC_339_DATE_FORMAT).parse(_date.toString());         } catch (final ParseException e) {             throw new IllegalArgumentException(                     ""The given spreadsheet ListEntry usercrashdate field value is malformed"", e);         }     }"
"protected int getCurrentProcessID() throws ProcessHandlerException {
        int pid;
        // Not ideal but using JNA failed on RHEL5.
        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
        Field jvm = null;
        try {
            jvm = runtime.getClass().getDeclaredField(""jvm"");
            jvm.setAccessible(true);
            VMManagement mgmt = (VMManagement) jvm.get(runtime);
            Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");
            pid_method.setAccessible(true);
            pid = (Integer) pid_method.invoke(mgmt);
        } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new ProcessHandlerException(e);
        }
        return pid;
    }",2,get current process id,"get current process id<CODESPLIT>protected int getCurrentProcessID() throws ProcessHandlerException {         int pid;         // Not ideal but using JNA failed on RHEL5.         RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();         Field jvm = null;         try {             jvm = runtime.getClass().getDeclaredField(""jvm"");             jvm.setAccessible(true);             VMManagement mgmt = (VMManagement) jvm.get(runtime);             Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");             pid_method.setAccessible(true);             pid = (Integer) pid_method.invoke(mgmt);         } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {             throw new ProcessHandlerException(e);         }         return pid;     }"
"public static <T> List<T> randomSample(Collection<T> collection, int n) {
		List<T> list = new ArrayList<T>(collection);
		List<T> sample = new ArrayList<T>(n);
		Random random = new Random();
		while(n > 0  &&  !list.isEmpty()) {
			int index = random.nextInt(list.size());
			sample.add(list.get(index));
			int indexLast = list.size() - 1;
			T last = list.remove(indexLast);
			if(index < indexLast) {
				list.set(index, last);
			}
			n--;
		}
		return sample;
	}",3,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public static <T> List<T> randomSample(Collection<T> collection, int n) { 		List<T> list = new ArrayList<T>(collection); 		List<T> sample = new ArrayList<T>(n); 		Random random = new Random(); 		while(n > 0  &&  !list.isEmpty()) { 			int index = random.nextInt(list.size()); 			sample.add(list.get(index)); 			int indexLast = list.size() - 1; 			T last = list.remove(indexLast); 			if(index < indexLast) { 				list.set(index, last); 			} 			n--; 		} 		return sample; 	}"
"protected void readOnlyUpdated() {
		boolean localReadOnly = isReadOnly();
		if (hasChanged(oldReadOnly, localReadOnly)) {
			oldReadOnly = localReadOnly;
			firePropertyChange(READONLY_PROPERTY, !localReadOnly, localReadOnly);
		}
	}",0,readonly array,"readonly array<CODESPLIT>protected void readOnlyUpdated() { 		boolean localReadOnly = isReadOnly(); 		if (hasChanged(oldReadOnly, localReadOnly)) { 			oldReadOnly = localReadOnly; 			firePropertyChange(READONLY_PROPERTY, !localReadOnly, localReadOnly); 		} 	}"
"public static byte[] fromHex(String hex) {
        try {
            return Hex.decodeHex(hex.toCharArray());
        } catch (DecoderException e) {
            return null;
        }
    }",1,convert decimal to hex,convert decimal to hex<CODESPLIT>public static byte[] fromHex(String hex) {         try {             return Hex.decodeHex(hex.toCharArray());         } catch (DecoderException e) {             return null;         }     }
"public static String getStatusDescription(int status)
   {
      String description = """";

      Integer statusKey = new Integer(status);
      if (statusDescriptions.containsKey(statusKey))
      {
         description = statusDescriptions.get(statusKey);
      }

      return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);
   }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getStatusDescription(int status)    {       String description = """";        Integer statusKey = new Integer(status);       if (statusDescriptions.containsKey(statusKey))       {          description = statusDescriptions.get(statusKey);       }        return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);    }"
"public static String getEnumName(Enum[] e, int value) {
        if (e != null) {
            int toCompareValue;
            for (Enum en : e) {
                if (en instanceof EnumReadable) {
                    toCompareValue = ((EnumReadable) en).value();
                } else {
                    toCompareValue = en.ordinal();
                }
                if (value == toCompareValue) {
                    return en.name();
                }
            }
        }
        return """";
    }",3,get name of enumerated value,"get name of enumerated value<CODESPLIT>public static String getEnumName(Enum[] e, int value) {         if (e != null) {             int toCompareValue;             for (Enum en : e) {                 if (en instanceof EnumReadable) {                     toCompareValue = ((EnumReadable) en).value();                 } else {                     toCompareValue = en.ordinal();                 }                 if (value == toCompareValue) {                     return en.name();                 }             }         }         return """";     }"
"private void parseAttDef(String elementName) throws Exception {
        String name;
        String type;
        String enumer = null;

        // Read the attribute name.
        name = readNmtoken(true);

        // Read the attribute type.
        requireWhitespace();
        type = readAttType();

        // Get the string of enumerated values if necessary.
        if (handler.stringInterning) {
            if ((""ENUMERATION"" == type) || (""NOTATION"" == type)) {
                enumer = dataBufferToString();
            }
        } else {
            if (""ENUMERATION"".equals(type) || ""NOTATION"".equals(type)) {
                enumer = dataBufferToString();
            }
        }

        // Read the default value.
        requireWhitespace();
        parseDefault(elementName, name, type, enumer);
    }",0,get name of enumerated value,"get name of enumerated value<CODESPLIT>private void parseAttDef(String elementName) throws Exception {         String name;         String type;         String enumer = null;          // Read the attribute name.         name = readNmtoken(true);          // Read the attribute type.         requireWhitespace();         type = readAttType();          // Get the string of enumerated values if necessary.         if (handler.stringInterning) {             if ((""ENUMERATION"" == type) || (""NOTATION"" == type)) {                 enumer = dataBufferToString();             }         } else {             if (""ENUMERATION"".equals(type) || ""NOTATION"".equals(type)) {                 enumer = dataBufferToString();             }         }          // Read the default value.         requireWhitespace();         parseDefault(elementName, name, type, enumer);     }"
"public static <T> T deserialize(byte[] input, Class<T> classType)
            throws JsonParseException, JsonMappingException, IOException {
        return mapper.readValue(input, classType);
    }",1,deserialize json,"deserialize json<CODESPLIT>public static <T> T deserialize(byte[] input, Class<T> classType)             throws JsonParseException, JsonMappingException, IOException {         return mapper.readValue(input, classType);     }"
"public static Date getDay(String string) {
		if (string == null) {
			return null;
		}
		Date date = null;
		try {
			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string));
		}
		catch (ParseException ex) {
			return null;
		}
		return date;
	}",2,convert a date string into yyyymmdd,"convert a date string into yyyymmdd<CODESPLIT>public static Date getDay(String string) { 		if (string == null) { 			return null; 		} 		Date date = null; 		try { 			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string)); 		} 		catch (ParseException ex) { 			return null; 		} 		return date; 	}"
"public boolean isCheckBoxChecked(String text)
	{
		if(config.commandLogging){
			Log.d(config.commandLoggingTag, ""isCheckBoxChecked(\""""+text+""\"")"");
		}
		
		return checker.isButtonChecked(CheckBox.class, text);
	}",3,how to check if a checkbox is checked,"how to check if a checkbox is checked<CODESPLIT>public boolean isCheckBoxChecked(String text) 	{ 		if(config.commandLogging){ 			Log.d(config.commandLoggingTag, ""isCheckBoxChecked(\""""+text+""\"")""); 		} 		 		return checker.isButtonChecked(CheckBox.class, text); 	}"
"@SuppressWarnings({""rawtypes"", ""unchecked""})
    protected Object transform(Object result, QueryResultMapper resultMapper) {
        Object actualResult = null;
        if (result instanceof Collection) {

            if (ProcessInstanceCustomDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceCustomDesc to ProcessInstanceCustomList"");
                actualResult = convertToProcessInstanceCustomVarsList((Collection<ProcessInstanceCustomDesc>) result);
            } else if (ProcessInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceWithVarsDesc to ProcessInstanceList"");
                actualResult = convertToProcessInstanceWithVarsList((Collection<ProcessInstanceWithVarsDesc>) result);
            } else if (ProcessInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceDesc to ProcessInstanceList"");
                actualResult = convertToProcessInstanceList((Collection<ProcessInstanceDesc>) result);
            } else if (UserTaskInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceWithVarsDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceWithVarsList((Collection<UserTaskInstanceWithVarsDesc>) result);
            } else if (UserTaskInstanceWithPotOwnerDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceWithPotOwnerDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceListPO((Collection<UserTaskInstanceWithPotOwnerDesc>) result);
            } else if (UserTaskInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceList((Collection<UserTaskInstanceDesc>) result);
            } else if (TaskSummary.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of TaskSummary to TaskSummaryList"");
                actualResult = convertToTaskSummaryList((Collection<TaskSummary>) result);
            } else if (ExecutionError.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ExecutionError to ErrorInstanceList"");
                actualResult = convertToErrorInstanceList((List<ExecutionError>) result);
            } else if (List.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of List to ArrayList"");
                actualResult = new ArrayList((Collection) result);
            }else {

                logger.debug(""Convert not supported for custom type {}"", resultMapper.getType());
                actualResult = result;
            }

            logger.debug(""Actual result after converting is {}"", actualResult);
        } else {
            logger.debug(""Result is not a collection - {}, skipping any conversion"", result);
            actualResult = result;
        }
        return actualResult;
    }",0,converting uint8 array to image,"converting uint8 array to image<CODESPLIT>@SuppressWarnings({""rawtypes"", ""unchecked""})     protected Object transform(Object result, QueryResultMapper resultMapper) {         Object actualResult = null;         if (result instanceof Collection) {              if (ProcessInstanceCustomDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of ProcessInstanceCustomDesc to ProcessInstanceCustomList"");                 actualResult = convertToProcessInstanceCustomVarsList((Collection<ProcessInstanceCustomDesc>) result);             } else if (ProcessInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of ProcessInstanceWithVarsDesc to ProcessInstanceList"");                 actualResult = convertToProcessInstanceWithVarsList((Collection<ProcessInstanceWithVarsDesc>) result);             } else if (ProcessInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of ProcessInstanceDesc to ProcessInstanceList"");                 actualResult = convertToProcessInstanceList((Collection<ProcessInstanceDesc>) result);             } else if (UserTaskInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of UserTaskInstanceWithVarsDesc to TaskInstanceList"");                 actualResult = convertToTaskInstanceWithVarsList((Collection<UserTaskInstanceWithVarsDesc>) result);             } else if (UserTaskInstanceWithPotOwnerDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of UserTaskInstanceWithPotOwnerDesc to TaskInstanceList"");                 actualResult = convertToTaskInstanceListPO((Collection<UserTaskInstanceWithPotOwnerDesc>) result);             } else if (UserTaskInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of UserTaskInstanceDesc to TaskInstanceList"");                 actualResult = convertToTaskInstanceList((Collection<UserTaskInstanceDesc>) result);             } else if (TaskSummary.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of TaskSummary to TaskSummaryList"");                 actualResult = convertToTaskSummaryList((Collection<TaskSummary>) result);             } else if (ExecutionError.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of ExecutionError to ErrorInstanceList"");                 actualResult = convertToErrorInstanceList((List<ExecutionError>) result);             } else if (List.class.isAssignableFrom(resultMapper.getType())) {                  logger.debug(""Converting collection of List to ArrayList"");                 actualResult = new ArrayList((Collection) result);             }else {                  logger.debug(""Convert not supported for custom type {}"", resultMapper.getType());                 actualResult = result;             }              logger.debug(""Actual result after converting is {}"", actualResult);         } else {             logger.debug(""Result is not a collection - {}, skipping any conversion"", result);             actualResult = result;         }         return actualResult;     }"
"@Override
    public void write(byte[] data, int offset, int length) throws IllegalStateException, IOException{
        // validate state
        if (isClosed()) {
            throw new IllegalStateException(""Serial connection is not open; cannot 'write()'."");
        }

        // write serial data to transmit buffer
        com.pi4j.jni.Serial.write(fileDescriptor, data, offset, length);
    }",1,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>@Override     public void write(byte[] data, int offset, int length) throws IllegalStateException, IOException{         // validate state         if (isClosed()) {             throw new IllegalStateException(""Serial connection is not open; cannot 'write()'."");         }          // write serial data to transmit buffer         com.pi4j.jni.Serial.write(fileDescriptor, data, offset, length);     }"
"public static String getText(Reader reader) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(reader);
        return getText(bufferedReader);
    }",2,buffered file reader read text,buffered file reader read text<CODESPLIT>public static String getText(Reader reader) throws IOException {         BufferedReader bufferedReader = new BufferedReader(reader);         return getText(bufferedReader);     }
"public static File getExecutableLocation(final String exeName) {
    //
    // must add current working directory to the
    // from of the path from the ""path"" environment variable
    final File currentDir = new File(System.getProperty(""user.dir""));
    if (new File(currentDir, exeName).exists()) {
      return currentDir;
    }
    final File[] envPath = CUtil.getPathFromEnvironment(""PATH"", File.pathSeparator);
    for (final File element : envPath) {
      if (new File(element, exeName).exists()) {
        return element;
      }
    }
    return null;
  }",3,get executable path,"get executable path<CODESPLIT>public static File getExecutableLocation(final String exeName) {     //     // must add current working directory to the     // from of the path from the ""path"" environment variable     final File currentDir = new File(System.getProperty(""user.dir""));     if (new File(currentDir, exeName).exists()) {       return currentDir;     }     final File[] envPath = CUtil.getPathFromEnvironment(""PATH"", File.pathSeparator);     for (final File element : envPath) {       if (new File(element, exeName).exists()) {         return element;       }     }     return null;   }"
"public static String htmlDecode(final String encodedHtml) {
        validate(encodedHtml, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);
        String[] entities = encodedHtml.split(""&\\W+;"");
        return Arrays.stream(entities).map(e -> HtmlEntities.decodedEntities.get(e)).collect(joining());
    }",0,html encode string,"html encode string<CODESPLIT>public static String htmlDecode(final String encodedHtml) {         validate(encodedHtml, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);         String[] entities = encodedHtml.split(""&\\W+;"");         return Arrays.stream(entities).map(e -> HtmlEntities.decodedEntities.get(e)).collect(joining());     }"
"protected static Clustering cleanUpKMeans(Clustering kMeansResult, ArrayList<CFCluster> microclusters) {
		/* Convert k-means result to CFClusters */
		int k = kMeansResult.size();
		CFCluster[] converted = new CFCluster[k];

		for (CFCluster mc : microclusters) {
		    // Find closest kMeans cluster
		    double minDistance = Double.MAX_VALUE;
		    int closestCluster = 0;
		    for (int i = 0; i < k; i++) {
		    	double distance = distance(kMeansResult.get(i).getCenter(), mc.getCenter());
				if (distance < minDistance) {
				    closestCluster = i;
				    minDistance = distance;
				}
		    }

		    // Add to cluster
		    if ( converted[closestCluster] == null ) {
		    	converted[closestCluster] = (CFCluster)mc.copy();
		    } else {
		    	converted[closestCluster].add(mc);
		    }
		}

		// Clean up
		int count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			count++;
		}

		CFCluster[] cleaned = new CFCluster[count];
		count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			cleaned[count++] = converted[i];
		}

		return new Clustering(cleaned);
	}",1,k means clustering,"k means clustering<CODESPLIT>protected static Clustering cleanUpKMeans(Clustering kMeansResult, ArrayList<CFCluster> microclusters) { 		/* Convert k-means result to CFClusters */ 		int k = kMeansResult.size(); 		CFCluster[] converted = new CFCluster[k];  		for (CFCluster mc : microclusters) { 		    // Find closest kMeans cluster 		    double minDistance = Double.MAX_VALUE; 		    int closestCluster = 0; 		    for (int i = 0; i < k; i++) { 		    	double distance = distance(kMeansResult.get(i).getCenter(), mc.getCenter()); 				if (distance < minDistance) { 				    closestCluster = i; 				    minDistance = distance; 				} 		    }  		    // Add to cluster 		    if ( converted[closestCluster] == null ) { 		    	converted[closestCluster] = (CFCluster)mc.copy(); 		    } else { 		    	converted[closestCluster].add(mc); 		    } 		}  		// Clean up 		int count = 0; 		for (int i = 0; i < converted.length; i++) { 		    if (converted[i] != null) 			count++; 		}  		CFCluster[] cleaned = new CFCluster[count]; 		count = 0; 		for (int i = 0; i < converted.length; i++) { 		    if (converted[i] != null) 			cleaned[count++] = converted[i]; 		}  		return new Clustering(cleaned); 	}"
"public static int[] sort(double[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public static int[] sort(double[] arr) {         int[] order = new int[arr.length];         for (int i = 0; i < order.length; i++) {             order[i] = i;         }         sort(arr, order);         return order;     }"
"private void replaceInFile(String oldText, String newText) {
        StringBuilder oldContent = new StringBuilder();

        try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                oldContent.append(line);
                oldContent.append(""\r\n"");
            }
        } catch (IOException e) {
            log.error(e);
        }

        // replace a word in a file
        String newContent = oldContent.toString().replaceAll(oldText, newText);

        try (FileWriter writer = new FileWriter(file)) {
            writer.write(newContent);
        } catch (IOException ioe) {
            log.error(ioe);
        }
    }",3,replace in file,"replace in file<CODESPLIT>private void replaceInFile(String oldText, String newText) {         StringBuilder oldContent = new StringBuilder();          try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {             String line;             while ((line = reader.readLine()) != null) {                 oldContent.append(line);                 oldContent.append(""\r\n"");             }         } catch (IOException e) {             log.error(e);         }          // replace a word in a file         String newContent = oldContent.toString().replaceAll(oldText, newText);          try (FileWriter writer = new FileWriter(file)) {             writer.write(newContent);         } catch (IOException ioe) {             log.error(ioe);         }     }"
"private static GeometricParity geometric3D(int i, int[] adjacent, IAtomContainer container) {

        IAtom atom = container.getAtom(i);
        Point3d[] coordinates = new Point3d[4];

        // set the forth ligand to centre as default (overwritten if
        // we have 4 neighbors)
        if (atom.getPoint3d() != null)
            coordinates[3] = atom.getPoint3d();
        else
            return null;

        // for each neighboring atom check if we have 3D coordinates
        for (int j = 0; j < adjacent.length; j++) {
            IAtom neighbor = container.getAtom(adjacent[j]);

            if (neighbor.getPoint3d() != null)
                coordinates[j] = neighbor.getPoint3d();
            else
                return null; // skip to next atom
        }

        // add new 3D stereo encoder
        return new Tetrahedral3DParity(coordinates);

    }",0,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>private static GeometricParity geometric3D(int i, int[] adjacent, IAtomContainer container) {          IAtom atom = container.getAtom(i);         Point3d[] coordinates = new Point3d[4];          // set the forth ligand to centre as default (overwritten if         // we have 4 neighbors)         if (atom.getPoint3d() != null)             coordinates[3] = atom.getPoint3d();         else             return null;          // for each neighboring atom check if we have 3D coordinates         for (int j = 0; j < adjacent.length; j++) {             IAtom neighbor = container.getAtom(adjacent[j]);              if (neighbor.getPoint3d() != null)                 coordinates[j] = neighbor.getPoint3d();             else                 return null; // skip to next atom         }          // add new 3D stereo encoder         return new Tetrahedral3DParity(coordinates);      }"
"public static String sort(String list, String sortType, String sortOrder, String delimiter) throws PageException {
	return _sort(toStringArray(listToArray(list, delimiter)), sortType, sortOrder, delimiter);
    }",1,sort string list,"sort string list<CODESPLIT>public static String sort(String list, String sortType, String sortOrder, String delimiter) throws PageException { 	return _sort(toStringArray(listToArray(list, delimiter)), sortType, sortOrder, delimiter);     }"
"public static void extractZip(File file) throws FileNotFoundException, IOException {
        final String originalPath = file.getPath();
        final File zip = new File(originalPath + "".zip"");
        if (zip.isFile() && !zip.delete()) {
            LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());
            zip.deleteOnExit();
        }
        if (!file.renameTo(zip)) {
            throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");
        }
        final File newFile = new File(originalPath);
        try (FileInputStream fis = new FileInputStream(zip);
                ZipInputStream cin = new ZipInputStream(fis);
                FileOutputStream out = new FileOutputStream(newFile)) {
            cin.getNextEntry();
            IOUtils.copy(cin, out);
        } finally {
            if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {
                LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());
                zip.deleteOnExit();
            }
        }
    }",2,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(File file) throws FileNotFoundException, IOException {         final String originalPath = file.getPath();         final File zip = new File(originalPath + "".zip"");         if (zip.isFile() && !zip.delete()) {             LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());             zip.deleteOnExit();         }         if (!file.renameTo(zip)) {             throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");         }         final File newFile = new File(originalPath);         try (FileInputStream fis = new FileInputStream(zip);                 ZipInputStream cin = new ZipInputStream(fis);                 FileOutputStream out = new FileOutputStream(newFile)) {             cin.getNextEntry();             IOUtils.copy(cin, out);         } finally {             if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {                 LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());                 zip.deleteOnExit();             }         }     }"
"public void writeExcelFile() throws IOException, WriteException {
        WritableWorkbook excelWrkBook = null;
        int curDsPointer = 0;

        try {
            final String[] columnNames = ds.getColumns();
            final List<String> exportOnlyColumnsList = getExportOnlyColumns() != null ? Arrays.asList(exportOnlyColumns) : null;
            final List<String> excludeFromExportColumnsList = getExcludeFromExportColumns() != null ? Arrays.asList(excludeFromExportColumns) : null;
            final List<String> numericColumnList = getNumericColumns() != null ? Arrays.asList(getNumericColumns()) : new ArrayList<>();
            // get the current position of the DataSet. We have to go to the top
            // to do this write,
            // and we will put the pionter back where it was after we are done
            curDsPointer = ds.getIndex();
            ds.goTop();

            excelWrkBook = Workbook.createWorkbook(xlsFile);
            final WritableSheet wrkSheet = excelWrkBook.createSheet(""results"", 0);

            final WritableFont times10ptBold = new WritableFont(WritableFont.TIMES, 10, WritableFont.BOLD);
            final WritableFont times10pt = new WritableFont(WritableFont.TIMES, 10, WritableFont.NO_BOLD);
            // write the column headings in the spreadsheet
            WritableCellFormat cellFormat = new WritableCellFormat(times10ptBold);
            int colOffset = 0;
            for (int i = 0; i < columnNames.length; i++) {
                if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                        || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                    colOffset++;
                    continue;
                }

                final Label xlsTextLbl = new Label(i - colOffset, 0, columnNames[i], cellFormat);
                wrkSheet.addCell(xlsTextLbl);
            }

            cellFormat = new WritableCellFormat(times10pt);
            int row = 1;
            while (ds.next()) {
                if (!ds.isRecordID(FPConstants.DETAIL_ID)) {
                    continue;
                }

                colOffset = 0;
                for (int i = 0; i < columnNames.length; i++) {
                    if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                            || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                        colOffset++;
                        continue;
                    }

                    WritableCell wc = null;
                    if (numericColumnList.contains(columnNames[i])) {
                        wc = new Number(i - colOffset, row, ds.getDouble(columnNames[i]), cellFormat);
                    } else {
                        wc = new Label(i - colOffset, row, ds.getString(columnNames[i]), cellFormat);
                    }

                    wrkSheet.addCell(wc);
                }

                row++;
            }

            excelWrkBook.write();

        } finally {
            if (curDsPointer > -1) {
                ds.absolute(curDsPointer);
            }
            if (excelWrkBook != null) {
                excelWrkBook.close();
            }
        }

    }",3,export to excel,"export to excel<CODESPLIT>public void writeExcelFile() throws IOException, WriteException {         WritableWorkbook excelWrkBook = null;         int curDsPointer = 0;          try {             final String[] columnNames = ds.getColumns();             final List<String> exportOnlyColumnsList = getExportOnlyColumns() != null ? Arrays.asList(exportOnlyColumns) : null;             final List<String> excludeFromExportColumnsList = getExcludeFromExportColumns() != null ? Arrays.asList(excludeFromExportColumns) : null;             final List<String> numericColumnList = getNumericColumns() != null ? Arrays.asList(getNumericColumns()) : new ArrayList<>();             // get the current position of the DataSet. We have to go to the top             // to do this write,             // and we will put the pionter back where it was after we are done             curDsPointer = ds.getIndex();             ds.goTop();              excelWrkBook = Workbook.createWorkbook(xlsFile);             final WritableSheet wrkSheet = excelWrkBook.createSheet(""results"", 0);              final WritableFont times10ptBold = new WritableFont(WritableFont.TIMES, 10, WritableFont.BOLD);             final WritableFont times10pt = new WritableFont(WritableFont.TIMES, 10, WritableFont.NO_BOLD);             // write the column headings in the spreadsheet             WritableCellFormat cellFormat = new WritableCellFormat(times10ptBold);             int colOffset = 0;             for (int i = 0; i < columnNames.length; i++) {                 if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])                         || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {                     colOffset++;                     continue;                 }                  final Label xlsTextLbl = new Label(i - colOffset, 0, columnNames[i], cellFormat);                 wrkSheet.addCell(xlsTextLbl);             }              cellFormat = new WritableCellFormat(times10pt);             int row = 1;             while (ds.next()) {                 if (!ds.isRecordID(FPConstants.DETAIL_ID)) {                     continue;                 }                  colOffset = 0;                 for (int i = 0; i < columnNames.length; i++) {                     if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])                             || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {                         colOffset++;                         continue;                     }                      WritableCell wc = null;                     if (numericColumnList.contains(columnNames[i])) {                         wc = new Number(i - colOffset, row, ds.getDouble(columnNames[i]), cellFormat);                     } else {                         wc = new Label(i - colOffset, row, ds.getString(columnNames[i]), cellFormat);                     }                      wrkSheet.addCell(wc);                 }                  row++;             }              excelWrkBook.write();          } finally {             if (curDsPointer > -1) {                 ds.absolute(curDsPointer);             }             if (excelWrkBook != null) {                 excelWrkBook.close();             }         }      }"
"TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element,
                                    TextOutline hydrogen) {

        final Rectangle2D chargeBounds = charge.getBounds();

        // the charge is placed to the top right of the element symbol
        // unless either the hydrogen label or the hydrogen count label
        // are in the way - in which case we place it relative to the
        // hydrogen
        Rectangle2D referenceBounds = element.getBounds();
        if (hydrogens > 0 && position == Right)
            referenceBounds = hydrogen.getBounds();
        else if (hydrogens > 1 && position == Above) referenceBounds = hydrogen.getBounds();

        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(),
                                (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    }",0,underline text in label widget,"underline text in label widget<CODESPLIT>TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element,                                     TextOutline hydrogen) {          final Rectangle2D chargeBounds = charge.getBounds();          // the charge is placed to the top right of the element symbol         // unless either the hydrogen label or the hydrogen count label         // are in the way - in which case we place it relative to the         // hydrogen         Rectangle2D referenceBounds = element.getBounds();         if (hydrogens > 0 && position == Right)             referenceBounds = hydrogen.getBounds();         else if (hydrogens > 1 && position == Above) referenceBounds = hydrogen.getBounds();          return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(),                                 (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());     }"
"public void completeGroup() {
		// Copy initial set to allow permutations to grow
		List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations);
		// Keep HashSet version of permutations for fast lookup.
		Set<List<Integer>> known = new HashSet<List<Integer>>(permutations);
		//breadth-first search through the map of all members
		List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations);
		while( currentLevel.size() > 0) {
			List<List<Integer>> nextLevel = new ArrayList<List<Integer>>();
			for( List<Integer> p : currentLevel) {
				for(List<Integer> gen : gens) {
					List<Integer> y = combine(p,gen);
					if(!known.contains(y)) {
						nextLevel.add(y);
						//bypass addPermutation(y) for performance
						permutations.add(y);
						known.add(y);
					}
				}
			}
			currentLevel = nextLevel;
		}
	}",1,all permutations of a list,"all permutations of a list<CODESPLIT>public void completeGroup() { 		// Copy initial set to allow permutations to grow 		List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations); 		// Keep HashSet version of permutations for fast lookup. 		Set<List<Integer>> known = new HashSet<List<Integer>>(permutations); 		//breadth-first search through the map of all members 		List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations); 		while( currentLevel.size() > 0) { 			List<List<Integer>> nextLevel = new ArrayList<List<Integer>>(); 			for( List<Integer> p : currentLevel) { 				for(List<Integer> gen : gens) { 					List<Integer> y = combine(p,gen); 					if(!known.contains(y)) { 						nextLevel.add(y); 						//bypass addPermutation(y) for performance 						permutations.add(y); 						known.add(y); 					} 				} 			} 			currentLevel = nextLevel; 		} 	}"
"private CommandLine parseArgs(String[] args) throws ParseException {
        final CommandLineParser parser = new DefaultParser();
        final Options options = createCommandLineOptions();
        return parser.parse(options, args);
    }",2,parse command line argument,"parse command line argument<CODESPLIT>private CommandLine parseArgs(String[] args) throws ParseException {         final CommandLineParser parser = new DefaultParser();         final Options options = createCommandLineOptions();         return parser.parse(options, args);     }"
"public static double binomial(int k, double p, int n) {
        if(k<0 ||  p<0 || n<1) {
            throw new IllegalArgumentException(""All the parameters must be positive and n larger than 1."");
        }
        
        k = Math.min(k, n); 
        
        /*
        //Slow and can't handle large numbers
        $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);
        */

        //fast and can handle large numbers
        //Cdf(k)-Cdf(k-1)
        double probability = approxBinomialCdf(k,p,n); 
        if(k>0) {
            probability -= approxBinomialCdf(k-1,p,n);
        }
        
        return probability;
    }",3,binomial distribution,"binomial distribution<CODESPLIT>public static double binomial(int k, double p, int n) {         if(k<0 ||  p<0 || n<1) {             throw new IllegalArgumentException(""All the parameters must be positive and n larger than 1."");         }                  k = Math.min(k, n);                   /*         //Slow and can't handle large numbers         $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);         */          //fast and can handle large numbers         //Cdf(k)-Cdf(k-1)         double probability = approxBinomialCdf(k,p,n);          if(k>0) {             probability -= approxBinomialCdf(k-1,p,n);         }                  return probability;     }"
"public Point3d[] get3DCoordinatesForSP3Ligands(IAtom refAtom, IAtomContainer noCoords, IAtomContainer withCoords,
            IAtom atomC, int nwanted, double length, double angle) {
        //logger.debug(""SP3 Ligands start "");
        Point3d newPoints[] = new Point3d[0];
        Point3d aPoint = refAtom.getPoint3d();
        int nwithCoords = withCoords.getAtomCount();
        if (angle < 0) {
            angle = TETRAHEDRAL_ANGLE;
        }
        if (nwithCoords == 0) {
            newPoints = calculate3DCoordinates0(refAtom.getPoint3d(), nwanted, length);
        } else if (nwithCoords == 1) {
            newPoints = calculate3DCoordinates1(aPoint, (withCoords.getAtom(0)).getPoint3d(),
                    (atomC != null) ? atomC.getPoint3d() : null, nwanted, length, angle);
        } else if (nwithCoords == 2) {
            Point3d bPoint = withCoords.getAtom(0).getPoint3d();
            Point3d cPoint = withCoords.getAtom(1).getPoint3d();
            newPoints = calculate3DCoordinates2(aPoint, bPoint, cPoint, nwanted, length, angle);
        } else if (nwithCoords == 3) {
            Point3d bPoint = withCoords.getAtom(0).getPoint3d();
            Point3d cPoint = withCoords.getAtom(1).getPoint3d();
            newPoints = new Point3d[1];
            Point3d dPoint = withCoords.getAtom(2).getPoint3d();
            newPoints[0] = calculate3DCoordinates3(aPoint, bPoint, cPoint, dPoint, length);
        }
        //logger.debug(""...Ready"");
        return newPoints;
    }",0,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>public Point3d[] get3DCoordinatesForSP3Ligands(IAtom refAtom, IAtomContainer noCoords, IAtomContainer withCoords,             IAtom atomC, int nwanted, double length, double angle) {         //logger.debug(""SP3 Ligands start "");         Point3d newPoints[] = new Point3d[0];         Point3d aPoint = refAtom.getPoint3d();         int nwithCoords = withCoords.getAtomCount();         if (angle < 0) {             angle = TETRAHEDRAL_ANGLE;         }         if (nwithCoords == 0) {             newPoints = calculate3DCoordinates0(refAtom.getPoint3d(), nwanted, length);         } else if (nwithCoords == 1) {             newPoints = calculate3DCoordinates1(aPoint, (withCoords.getAtom(0)).getPoint3d(),                     (atomC != null) ? atomC.getPoint3d() : null, nwanted, length, angle);         } else if (nwithCoords == 2) {             Point3d bPoint = withCoords.getAtom(0).getPoint3d();             Point3d cPoint = withCoords.getAtom(1).getPoint3d();             newPoints = calculate3DCoordinates2(aPoint, bPoint, cPoint, nwanted, length, angle);         } else if (nwithCoords == 3) {             Point3d bPoint = withCoords.getAtom(0).getPoint3d();             Point3d cPoint = withCoords.getAtom(1).getPoint3d();             newPoints = new Point3d[1];             Point3d dPoint = withCoords.getAtom(2).getPoint3d();             newPoints[0] = calculate3DCoordinates3(aPoint, bPoint, cPoint, dPoint, length);         }         //logger.debug(""...Ready"");         return newPoints;     }"
"public static void main(String[] args) throws IOException {

        Arguments arguments = new Arguments().parse(args);

        if (arguments.isUseCommonsLang3()) {
            System.err.println(""--commons-lang3 is deprecated. Please remove the argument from your command-line arguments."");
        }

        Jsonschema2Pojo.generate(arguments);
    }",1,parse command line argument,"parse command line argument<CODESPLIT>public static void main(String[] args) throws IOException {          Arguments arguments = new Arguments().parse(args);          if (arguments.isUseCommonsLang3()) {             System.err.println(""--commons-lang3 is deprecated. Please remove the argument from your command-line arguments."");         }          Jsonschema2Pojo.generate(arguments);     }"
"public void parse(File file) throws UpdateException {
        LOGGER.debug(""Parsing "" + file.getName());
        try (InputStream fin = new FileInputStream(file);
                InputStream in = new GZIPInputStream(fin);
                InputStreamReader isr = new InputStreamReader(in, UTF_8);
                JsonReader reader = new JsonReader(isr)) {
            final Gson gson = new GsonBuilder().create();

            reader.beginObject();

            while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
                reader.skipValue();
            }
            reader.beginArray();
            while (reader.hasNext()) {
                final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);

                //cve.getCve().getCVEDataMeta().getSTATE();
                if (testCveCpeStartWithFilter(cve)) {
                    cveDB.updateVulnerability(cve);
                }
            }
        } catch (FileNotFoundException ex) {
            LOGGER.error(ex.getMessage());
            throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);
        } catch (IOException ex) {
            LOGGER.error(""Error reading NVD JSON data: {}"", file);
            LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);
            throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);
        }
    }",2,parse json file,"parse json file<CODESPLIT>public void parse(File file) throws UpdateException {         LOGGER.debug(""Parsing "" + file.getName());         try (InputStream fin = new FileInputStream(file);                 InputStream in = new GZIPInputStream(fin);                 InputStreamReader isr = new InputStreamReader(in, UTF_8);                 JsonReader reader = new JsonReader(isr)) {             final Gson gson = new GsonBuilder().create();              reader.beginObject();              while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {                 reader.skipValue();             }             reader.beginArray();             while (reader.hasNext()) {                 final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);                  //cve.getCve().getCVEDataMeta().getSTATE();                 if (testCveCpeStartWithFilter(cve)) {                     cveDB.updateVulnerability(cve);                 }             }         } catch (FileNotFoundException ex) {             LOGGER.error(ex.getMessage());             throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);         } catch (IOException ex) {             LOGGER.error(""Error reading NVD JSON data: {}"", file);             LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);             throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);         }     }"
"public static <T> Collection<List<T>> permutations(Collection<T> elements) {
        Collection<List<T>> result = new ArrayList<>();
        if (elements.isEmpty()) {
            result.add(new LinkedList<>());
            return result;
        }

        List<T> rest = new LinkedList<>(elements);
        T head = rest.remove(0);
        for (List<T> permutations : permutations(rest)) {
            List<List<T>> subLists = new ArrayList<>();
            for (int i = 0; i <= permutations.size(); i++) {
                List<T> subList = new ArrayList<>();
                subList.addAll(permutations);
                subList.add(i, head);
                subLists.add(subList);
            }
            result.addAll(subLists);
        }
        return result;
    }",3,all permutations of a list,"all permutations of a list<CODESPLIT>public static <T> Collection<List<T>> permutations(Collection<T> elements) {         Collection<List<T>> result = new ArrayList<>();         if (elements.isEmpty()) {             result.add(new LinkedList<>());             return result;         }          List<T> rest = new LinkedList<>(elements);         T head = rest.remove(0);         for (List<T> permutations : permutations(rest)) {             List<List<T>> subLists = new ArrayList<>();             for (int i = 0; i <= permutations.size(); i++) {                 List<T> subList = new ArrayList<>();                 subList.addAll(permutations);                 subList.add(i, head);                 subLists.add(subList);             }             result.addAll(subLists);         }         return result;     }"
"public Permutation multiply(Permutation other) {
        Permutation newPermutation = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            newPermutation.values[i] = this.values[other.values[i]];
        }
        return newPermutation;
    }",0,all permutations of a list,all permutations of a list<CODESPLIT>public Permutation multiply(Permutation other) {         Permutation newPermutation = new Permutation(values.length);         for (int i = 0; i < values.length; i++) {             newPermutation.values[i] = this.values[other.values[i]];         }         return newPermutation;     }
"public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) {
		((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution);
	}",1,binomial distribution,"binomial distribution<CODESPLIT>public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) { 		((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution); 	}"
"private static String coerceToEpoch(String s) {
		Long epoch = parseEpochSecond(s);
		if (epoch != null) {
			return String.valueOf(epoch);
		}
		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"");
		try {
			return String.valueOf(format.parse(s).getTime());
		}
		catch (ParseException ex) {
			return s;
		}
	}",2,convert a utc time to epoch,"convert a utc time to epoch<CODESPLIT>private static String coerceToEpoch(String s) { 		Long epoch = parseEpochSecond(s); 		if (epoch != null) { 			return String.valueOf(epoch); 		} 		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ""); 		try { 			return String.valueOf(format.parse(s).getTime()); 		} 		catch (ParseException ex) { 			return s; 		} 	}"
"public String extract(String html, CETR.Parameters parameters) {
        html = clearText(html); //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines
        List<String> rows = extractRows(html); //
        
        List<Integer> selectedRowIds = selectRows(rows, parameters);
        
        StringBuilder sb = new StringBuilder(html.length());
        for(Integer rowId : selectedRowIds) {
            String row = rows.get(rowId);
            
            //extract the clear text from the selected row
            row = StringCleaner.removeExtraSpaces(HTMLParser.extractText(row));
            if(row.isEmpty()) {
                continue;
            }
            sb.append(row).append("" "");
        }
        
        return sb.toString().trim();
    }",3,extract data from html content,"extract data from html content<CODESPLIT>public String extract(String html, CETR.Parameters parameters) {         html = clearText(html); //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines         List<String> rows = extractRows(html); //                  List<Integer> selectedRowIds = selectRows(rows, parameters);                  StringBuilder sb = new StringBuilder(html.length());         for(Integer rowId : selectedRowIds) {             String row = rows.get(rowId);                          //extract the clear text from the selected row             row = StringCleaner.removeExtraSpaces(HTMLParser.extractText(row));             if(row.isEmpty()) {                 continue;             }             sb.append(row).append("" "");         }                  return sb.toString().trim();     }"
"private static int decode(final int hex) {
        if (hex >= CcHex.BACK.length) {
            throw new DecodingException(
                String.format(""invalid hex char: 0x%2x"", hex)
            );
        }
        final int dec = CcHex.BACK[hex];
        if (dec < 0) {
            throw new DecodingException(
                String.format(""invalid hex character: 0x%2x"", hex)
            );
        }
        return dec;
    }",0,convert decimal to hex,"convert decimal to hex<CODESPLIT>private static int decode(final int hex) {         if (hex >= CcHex.BACK.length) {             throw new DecodingException(                 String.format(""invalid hex char: 0x%2x"", hex)             );         }         final int dec = CcHex.BACK[hex];         if (dec < 0) {             throw new DecodingException(                 String.format(""invalid hex character: 0x%2x"", hex)             );         }         return dec;     }"
"public static Date getDateWithPrevDays(int noOfDays) throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        currentDate.add(Calendar.DATE, -noOfDays);
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }",1,how to get current date,"how to get current date<CODESPLIT>public static Date getDateWithPrevDays(int noOfDays) throws ParseException {         Calendar currentDate = Calendar.getInstance();         currentDate.add(Calendar.DATE, -noOfDays);         SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);         String dateNow = formatter.format(currentDate.getTime());         return getDateFromString(dateNow);     }"
"private Cookie createCookie(String str) throws UnsupportedEncodingException {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);
    }
    Cookie cookie = new Cookie(AUTH_COOKIE, str);

    cookie.setMaxAge(cookieMaxAge);
    if (cookieDomain != null) {
      cookie.setDomain(cookieDomain);
    }
    if (cookiePath != null) {
      cookie.setPath(cookiePath);
    }
    cookie.setSecure(isCookieSecure);
    return cookie;
  }",2,create cookie,"create cookie<CODESPLIT>private Cookie createCookie(String str) throws UnsupportedEncodingException {     if (LOG.isDebugEnabled()) {       LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);     }     Cookie cookie = new Cookie(AUTH_COOKIE, str);      cookie.setMaxAge(cookieMaxAge);     if (cookieDomain != null) {       cookie.setDomain(cookieDomain);     }     if (cookiePath != null) {       cookie.setPath(cookiePath);     }     cookie.setSecure(isCookieSecure);     return cookie;   }"
"public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {
    Preconditions.checkNotNull(csvData, ""Null CSV data"");
    Preconditions.checkNotNull(fileName, ""Null file name"");

    CSVWriter writer = null;
    try {
      writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));
      for (String[] line : csvData) {
        writer.writeNext(line);
      }
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }",3,write csv,"write csv<CODESPLIT>public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {     Preconditions.checkNotNull(csvData, ""Null CSV data"");     Preconditions.checkNotNull(fileName, ""Null file name"");      CSVWriter writer = null;     try {       writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));       for (String[] line : csvData) {         writer.writeNext(line);       }     } finally {       if (writer != null) {         writer.close();       }     }   }"
"private static int parseInt(String str, int defaultValue) {
        
        if (str == null)
            return defaultValue;
        
        return Integer.parseInt(str);

    }",0,find int in string,"find int in string<CODESPLIT>private static int parseInt(String str, int defaultValue) {                  if (str == null)             return defaultValue;                  return Integer.parseInt(str);      }"
"public String generateBsn() {
        String Result1 = """";
        int Nr9 = randomUtil.random(3);
        int Nr8 = randomUtil.random(10);
        int Nr7 = randomUtil.random(10);
        int Nr6 = randomUtil.random(10);
        int Nr5 = randomUtil.random(10);
        int Nr4 = randomUtil.random(10);
        int Nr3 = randomUtil.random(10);
        int Nr2 = randomUtil.random(10);
        int Nr1 = 0;
        int SofiNr = 0;
        if ((Nr9 == 0) && (Nr8 == 0) && (Nr7 == 0)) {
            Nr8 = 1;
        }
        SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2;
        Nr1 = floor(SofiNr - (floor(SofiNr / 11)) * 11);
        if (Nr1 > 9) {
            if (Nr2 > 0) {
                Nr2 -= 1;
                Nr1 = 8;
            } else {
                Nr2 += 1;
                Nr1 = 1;
            }
        }
        Result1 += Nr9;
        Result1 += Nr8;
        Result1 += Nr7;
        Result1 += Nr6;
        Result1 += Nr5;
        Result1 += Nr4;
        Result1 += Nr3;
        Result1 += Nr2;
        Result1 += Nr1;
        return Result1;
    }",1,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public String generateBsn() {         String Result1 = """";         int Nr9 = randomUtil.random(3);         int Nr8 = randomUtil.random(10);         int Nr7 = randomUtil.random(10);         int Nr6 = randomUtil.random(10);         int Nr5 = randomUtil.random(10);         int Nr4 = randomUtil.random(10);         int Nr3 = randomUtil.random(10);         int Nr2 = randomUtil.random(10);         int Nr1 = 0;         int SofiNr = 0;         if ((Nr9 == 0) && (Nr8 == 0) && (Nr7 == 0)) {             Nr8 = 1;         }         SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2;         Nr1 = floor(SofiNr - (floor(SofiNr / 11)) * 11);         if (Nr1 > 9) {             if (Nr2 > 0) {                 Nr2 -= 1;                 Nr1 = 8;             } else {                 Nr2 += 1;                 Nr1 = 1;             }         }         Result1 += Nr9;         Result1 += Nr8;         Result1 += Nr7;         Result1 += Nr6;         Result1 += Nr5;         Result1 += Nr4;         Result1 += Nr3;         Result1 += Nr2;         Result1 += Nr1;         return Result1;     }"
"private static String getHttpOnlyCookieHeader(Cookie cookie) {
    NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),
      cookie.getPath(), cookie.getDomain(), cookie.getVersion(),
      cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());
    return newCookie + ""; HttpOnly"";
  }",2,create cookie,"create cookie<CODESPLIT>private static String getHttpOnlyCookieHeader(Cookie cookie) {     NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),       cookie.getPath(), cookie.getDomain(), cookie.getVersion(),       cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());     return newCookie + ""; HttpOnly"";   }"
"public static String reverse(String str) {
      if (str == null) {
          return null;
      }
      return new StringBuffer(str).reverse().toString();
  }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(String str) {       if (str == null) {           return null;       }       return new StringBuffer(str).reverse().toString();   }
"@SuppressWarnings(""unchecked"")
    public <A> A[] toArray(A[] emptyArray) {
        if(emptyArray.length != 0) {
            throw new IllegalArgumentException(""Empty array must be supplied"");
        }
        return stream().toArray(size -> size == 0 ? emptyArray
                : (A[]) Array.newInstance(emptyArray.getClass().getComponentType(), size));
    }",0,how to empty array,"how to empty array<CODESPLIT>@SuppressWarnings(""unchecked"")     public <A> A[] toArray(A[] emptyArray) {         if(emptyArray.length != 0) {             throw new IllegalArgumentException(""Empty array must be supplied"");         }         return stream().toArray(size -> size == 0 ? emptyArray                 : (A[]) Array.newInstance(emptyArray.getClass().getComponentType(), size));     }"
"public void check() {
        getDispatcher().beforeCheck(this);
        
        RemoteWebElement e = (RemoteWebElement) getElement();
        while (!e.isSelected()) {
            e.click();
        }
        if (Config.getBoolConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING)) {
            logUIAction(UIActions.CHECKED);
        }
        
        getDispatcher().afterCheck(this);
    }",1,how to check if a checkbox is checked,how to check if a checkbox is checked<CODESPLIT>public void check() {         getDispatcher().beforeCheck(this);                  RemoteWebElement e = (RemoteWebElement) getElement();         while (!e.isSelected()) {             e.click();         }         if (Config.getBoolConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING)) {             logUIAction(UIActions.CHECKED);         }                  getDispatcher().afterCheck(this);     }
"public static void concatenate(List<File> files, File concatenatedFile) {

        BufferedWriter writer;
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(concatenatedFile.getAbsoluteFile(),
                    false), DataUtilDefaults.charSet));

            FileInputStream inputStream;
            for(File input : files) {
                inputStream = new FileInputStream(input);
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, ""UTF-8""));
                String line;
                while((line = reader.readLine()) != null) {
                    writer.write(line + DataUtilDefaults.lineTerminator);
                }
                inputStream.close();
            }
            writer.flush();
            writer.close();
        } catch (UnsupportedEncodingException e) {
            throw new DataUtilException(e);
        } catch (FileNotFoundException e) {
            throw new DataUtilException(e);
        } catch (IOException e) {
            throw new DataUtilException(e);
        }
    }",2,concatenate several file remove header lines,"concatenate several file remove header lines<CODESPLIT>public static void concatenate(List<File> files, File concatenatedFile) {          BufferedWriter writer;         try {             writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(concatenatedFile.getAbsoluteFile(),                     false), DataUtilDefaults.charSet));              FileInputStream inputStream;             for(File input : files) {                 inputStream = new FileInputStream(input);                 BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, ""UTF-8""));                 String line;                 while((line = reader.readLine()) != null) {                     writer.write(line + DataUtilDefaults.lineTerminator);                 }                 inputStream.close();             }             writer.flush();             writer.close();         } catch (UnsupportedEncodingException e) {             throw new DataUtilException(e);         } catch (FileNotFoundException e) {             throw new DataUtilException(e);         } catch (IOException e) {             throw new DataUtilException(e);         }     }"
"public Matrix multiply(Matrix m) throws MatrixException
    {
        // Validate m's dimensions.
        if (nCols != m.nRows) {
            throw new MatrixException(
                                MatrixException.INVALID_DIMENSIONS);
        }

        double pv[][] = new double[nRows][m.nCols];  // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < m.nCols; ++c) {
                double dot = 0;
                for (int k = 0; k < nCols; ++k) {
                    dot += values[r][k] * m.values[k][c];
                }
                pv[r][c] = dot;
            }
        }

        return new Matrix(pv);
    }",3,matrix multiply,matrix multiply<CODESPLIT>public Matrix multiply(Matrix m) throws MatrixException     {         // Validate m's dimensions.         if (nCols != m.nRows) {             throw new MatrixException(                                 MatrixException.INVALID_DIMENSIONS);         }          double pv[][] = new double[nRows][m.nCols];  // product values          // Compute values of the product.         for (int r = 0; r < nRows; ++r) {             for (int c = 0; c < m.nCols; ++c) {                 double dot = 0;                 for (int k = 0; k < nCols; ++k) {                     dot += values[r][k] * m.values[k][c];                 }                 pv[r][c] = dot;             }         }          return new Matrix(pv);     }
"public void setWorkingDirectory(Path dir) {
    if (!dir.isAbsolute()) {
      FileSystem.LogForCollect
          .info(""set job working directory to non absolute path: "" + dir
              + "" working directory: "" + getWorkingDirectory());
    }
    dir = new Path(getWorkingDirectory(), dir);
    set(""mapred.working.dir"", dir.toString());
  }",0,set working directory,"set working directory<CODESPLIT>public void setWorkingDirectory(Path dir) {     if (!dir.isAbsolute()) {       FileSystem.LogForCollect           .info(""set job working directory to non absolute path: "" + dir               + "" working directory: "" + getWorkingDirectory());     }     dir = new Path(getWorkingDirectory(), dir);     set(""mapred.working.dir"", dir.toString());   }"
"public void uncheckCheckboxInCell(int row, int column) {
        String checkboxLocator = getXPathBase() + ""tr["" + row + ""]/td["" + column + ""]/input"";
        CheckBox cb = new CheckBox(checkboxLocator);
        cb.uncheck();
    }",1,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>public void uncheckCheckboxInCell(int row, int column) {         String checkboxLocator = getXPathBase() + ""tr["" + row + ""]/td["" + column + ""]/input"";         CheckBox cb = new CheckBox(checkboxLocator);         cb.uncheck();     }"
"public static Date formatToStartOfDay(final Date date) {

    try {
      SimpleDateFormat dateFormat = buildDateFormat(DEFAULT_DATE_SIMPLE_PATTERN);
      String formattedDate = dateFormat.format(date);
      return dateFormat.parse(formattedDate);
    } catch (ParseException pe) {
      throw new DateException(""Unparseable date specified."", pe);
    }
  }",2,format date,"format date<CODESPLIT>public static Date formatToStartOfDay(final Date date) {      try {       SimpleDateFormat dateFormat = buildDateFormat(DEFAULT_DATE_SIMPLE_PATTERN);       String formattedDate = dateFormat.format(date);       return dateFormat.parse(formattedDate);     } catch (ParseException pe) {       throw new DateException(""Unparseable date specified."", pe);     }   }"
"public static double[] linearReg(double[] xData, double[] yData) {
        sameArrayLen(xData, yData);
        double sumYValue = 0;
        double meanYValue = 0;
        double sumXValue = 0;
        double meanXValue = 0;
        double sumX = 0;
        double sumY = 0;
        double prod = 0;
        double NODATA = -9999;
        int nstat = xData.length;
        double[] regCoef = new double[3]; //(intercept, gradient, r?)
        int counter = 0;
        //calculating sums
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumYValue += yData[i];
                sumXValue += xData[i];
                counter++;
            }
        }
        //calculating means
        meanYValue = sumYValue / counter;
        meanXValue = sumXValue / counter;

        //calculating regression coefficients
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumX += Math.pow((xData[i] - meanXValue), 2);
                sumY += Math.pow((yData[i] - meanYValue), 2);
                prod += ((xData[i] - meanXValue) * (yData[i] - meanYValue));
            }
        }
        if (sumX > 0 && sumY > 0) {
            regCoef[1] = prod / sumX;  //gradient
            regCoef[0] = meanYValue - regCoef[1] * meanXValue; //intercept
            regCoef[2] = Math.pow((prod / Math.sqrt(sumX * sumY)), 2); //r?
        } else {
            regCoef[1] = 0;
            regCoef[0] = 0;
            regCoef[2] = 0;
        }
        return regCoef;
    }",3,linear regression,"linear regression<CODESPLIT>public static double[] linearReg(double[] xData, double[] yData) {         sameArrayLen(xData, yData);         double sumYValue = 0;         double meanYValue = 0;         double sumXValue = 0;         double meanXValue = 0;         double sumX = 0;         double sumY = 0;         double prod = 0;         double NODATA = -9999;         int nstat = xData.length;         double[] regCoef = new double[3]; //(intercept, gradient, r?)         int counter = 0;         //calculating sums         for (int i = 0; i < nstat; i++) {             if ((yData[i] != NODATA) && (xData[i] != NODATA)) {                 sumYValue += yData[i];                 sumXValue += xData[i];                 counter++;             }         }         //calculating means         meanYValue = sumYValue / counter;         meanXValue = sumXValue / counter;          //calculating regression coefficients         for (int i = 0; i < nstat; i++) {             if ((yData[i] != NODATA) && (xData[i] != NODATA)) {                 sumX += Math.pow((xData[i] - meanXValue), 2);                 sumY += Math.pow((yData[i] - meanYValue), 2);                 prod += ((xData[i] - meanXValue) * (yData[i] - meanYValue));             }         }         if (sumX > 0 && sumY > 0) {             regCoef[1] = prod / sumX;  //gradient             regCoef[0] = meanYValue - regCoef[1] * meanXValue; //intercept             regCoef[2] = Math.pow((prod / Math.sqrt(sumX * sumY)), 2); //r?         } else {             regCoef[1] = 0;             regCoef[0] = 0;             regCoef[2] = 0;         }         return regCoef;     }"
"private String getProcessId(OptionsAndArgs pOpts) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        if (pOpts.getPid() != null) {
            return pOpts.getPid();
        } else if (pOpts.getProcessPattern() != null) {
            return findProcess(pOpts.getProcessPattern()).getId();
        } else {
            throw new IllegalArgumentException(""No process ID and no process name pattern given"");
        }
    }",0,get current process id,"get current process id<CODESPLIT>private String getProcessId(OptionsAndArgs pOpts) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {         if (pOpts.getPid() != null) {             return pOpts.getPid();         } else if (pOpts.getProcessPattern() != null) {             return findProcess(pOpts.getProcessPattern()).getId();         } else {             throw new IllegalArgumentException(""No process ID and no process name pattern given"");         }     }"
"public static IPAddressType getAddressType(String ipAddress)
    {
    	if(IPAddressUtil.isIPv4LiteralAddress(ipAddress))
    		return IPAddressType.IPV4;
    	
    	if(IPAddressUtil.isIPv6LiteralAddress(ipAddress))
    		return IPAddressType.IPV6;
    	
    	return IPAddressType.INVALID;
    }",1,get current ip address,get current ip address<CODESPLIT>public static IPAddressType getAddressType(String ipAddress)     {     	if(IPAddressUtil.isIPv4LiteralAddress(ipAddress))     		return IPAddressType.IPV4;     	     	if(IPAddressUtil.isIPv6LiteralAddress(ipAddress))     		return IPAddressType.IPV6;     	     	return IPAddressType.INVALID;     }
"public long getElapsedTicks() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerTick;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedTicks() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerTick; 	}
"private void parseCommandLineArgs(String[] args) throws ConfigurationException {
        if (args == null || args.length == 0) {
            return;
        }
        logger.info(""Parsing command line arguments"");
        m_commandLineArgs = args;
        
        try {
            for (int inx = 0; inx < args.length; inx++) {
                String arg = args[inx];
                if (arg.equals(""-?"") || arg.equalsIgnoreCase(""-h"") || arg.equalsIgnoreCase(""-help"")) {
                    System.out.println(""See documentation and doradus.yaml for help."");
                    System.exit(0);
                }
                Utils.require(arg.charAt(0) == '-', ""Unrecognized argument: %s"", arg);
                Utils.require(inx + 1 < args.length, ""A value is expected after: %s"", arg);
                String name = arg.substring(1);
                String value = args[++inx];
                setCommandLineParam(name, value);
            }
        } catch (Exception e) {
            logger.error(""Failed to parse command line arguments"", e);
            throw new ConfigurationException(""Failed to parse command line arguments"", e);
        }
    }",3,parse command line argument,"parse command line argument<CODESPLIT>private void parseCommandLineArgs(String[] args) throws ConfigurationException {         if (args == null || args.length == 0) {             return;         }         logger.info(""Parsing command line arguments"");         m_commandLineArgs = args;                  try {             for (int inx = 0; inx < args.length; inx++) {                 String arg = args[inx];                 if (arg.equals(""-?"") || arg.equalsIgnoreCase(""-h"") || arg.equalsIgnoreCase(""-help"")) {                     System.out.println(""See documentation and doradus.yaml for help."");                     System.exit(0);                 }                 Utils.require(arg.charAt(0) == '-', ""Unrecognized argument: %s"", arg);                 Utils.require(inx + 1 < args.length, ""A value is expected after: %s"", arg);                 String name = arg.substring(1);                 String value = args[++inx];                 setCommandLineParam(name, value);             }         } catch (Exception e) {             logger.error(""Failed to parse command line arguments"", e);             throw new ConfigurationException(""Failed to parse command line arguments"", e);         }     }"
"public static String createLikeRegex(String expr, boolean ignoreCase)
    {
        String regex = createRegex(expr, ignoreCase);
        regex = regex.replace(""_"", ""."").replace(""%"", "".*?"");

        return regex;
    }",0,regex case insensitive,"regex case insensitive<CODESPLIT>public static String createLikeRegex(String expr, boolean ignoreCase)     {         String regex = createRegex(expr, ignoreCase);         regex = regex.replace(""_"", ""."").replace(""%"", "".*?"");          return regex;     }"
"public TernaryVector generate() {
        HashSet<Integer> pos = new HashSet<Integer>();
        HashSet<Integer> neg = new HashSet<Integer>();
        
        // Randomly decide how many bits to set in the index vector based on the
        // variance.
        int bitsToSet = numVectorValues +
            (int)(RANDOM.nextDouble() * variance *
                  ((RANDOM.nextDouble() > .5) ? 1 : -1));

        for (int i = 0; i < bitsToSet; ++i) {
            boolean picked = false;
            // loop to ensure we actually pick the full number of bits
            while (!picked) {
                // pick some random index
                int index = RANDOM.nextInt(indexVectorLength);
                    
                // check that we haven't already added this index
                if (pos.contains(index) || neg.contains(index))
                    continue;
                    
                // decide positive or negative
                ((RANDOM.nextDouble() > .5) ? pos : neg).add(index);
                picked = true;
            }
        }
            
        int[] positive = new int[pos.size()];
        int[] negative = new int[neg.size()];

        Iterator<Integer> it = pos.iterator();
        for (int i = 0; i < positive.length; ++i) 
            positive[i] = it.next();

        it = neg.iterator();
        for (int i = 0; i < negative.length; ++i) 
            negative[i] = it.next();                

        // sort so we can use a binary search in getValue()
        Arrays.sort(positive);
        Arrays.sort(negative);
        return new TernaryVector(indexVectorLength, positive, negative);
    }",1,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public TernaryVector generate() {         HashSet<Integer> pos = new HashSet<Integer>();         HashSet<Integer> neg = new HashSet<Integer>();                  // Randomly decide how many bits to set in the index vector based on the         // variance.         int bitsToSet = numVectorValues +             (int)(RANDOM.nextDouble() * variance *                   ((RANDOM.nextDouble() > .5) ? 1 : -1));          for (int i = 0; i < bitsToSet; ++i) {             boolean picked = false;             // loop to ensure we actually pick the full number of bits             while (!picked) {                 // pick some random index                 int index = RANDOM.nextInt(indexVectorLength);                                      // check that we haven't already added this index                 if (pos.contains(index) || neg.contains(index))                     continue;                                      // decide positive or negative                 ((RANDOM.nextDouble() > .5) ? pos : neg).add(index);                 picked = true;             }         }                      int[] positive = new int[pos.size()];         int[] negative = new int[neg.size()];          Iterator<Integer> it = pos.iterator();         for (int i = 0; i < positive.length; ++i)              positive[i] = it.next();          it = neg.iterator();         for (int i = 0; i < negative.length; ++i)              negative[i] = it.next();                          // sort so we can use a binary search in getValue()         Arrays.sort(positive);         Arrays.sort(negative);         return new TernaryVector(indexVectorLength, positive, negative);     }"
"public long getElapsedSeconds() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerSs;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedSeconds() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerSs; 	}
"public static void extractZip(File zip, File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		try (ZipFile zipFile = new ZipFile(zip)) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();

			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();

				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName());
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					continue;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				//logger.info(""Extracting file: "" + entry.getName());
				try (InputStream inputStream = zipFile.getInputStream(entry)) {
					try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
						IOUtils.copy(inputStream, outputStream);
					}
				}
			}
		} catch (FileNotFoundException | NoSuchFileException e) {
			throw e;
		} catch (IOException e) {
			throw new IOException(""While extracting file "" + zip + "" to "" + toDir, e);
		}
	}",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(File zip, File toDir) throws IOException{ 		if(!toDir.exists()) { 			throw new IOException(""Directory '"" + toDir + ""' does not exist.""); 		}  		try (ZipFile zipFile = new ZipFile(zip)) { 			Enumeration<? extends ZipEntry> entries = zipFile.entries();  			while (entries.hasMoreElements()) { 				ZipEntry entry = entries.nextElement();  				File target = new File(toDir, entry.getName()); 				if (entry.isDirectory()) { 					// Assume directories are stored parents first then children. 					//logger.info(""Extracting directory: "" + entry.getName()); 					// This is not robust, just for demonstration purposes. 					if(!target.mkdirs()) { 						logger.warning(""Could not create directory "" + target); 					} 					continue; 				}  				// zips can contain nested files in sub-dirs without separate entries for the directories 				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) { 					logger.warning(""Could not create directory "" + target.getParentFile()); 				}  				//logger.info(""Extracting file: "" + entry.getName()); 				try (InputStream inputStream = zipFile.getInputStream(entry)) { 					try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) { 						IOUtils.copy(inputStream, outputStream); 					} 				} 			} 		} catch (FileNotFoundException | NoSuchFileException e) { 			throw e; 		} catch (IOException e) { 			throw new IOException(""While extracting file "" + zip + "" to "" + toDir, e); 		} 	}"
"public String formatDate(String format, Locale loc) {
		MultivaluedMap<String, String> params = new MultivaluedHashMap<>();
		params.putSingle(""format"", format);
		params.putSingle(""locale"", loc == null ? null : loc.toString());
		return getEntity(invokeGet(""utils/formatdate"", params), String.class);
	}",0,format date,"format date<CODESPLIT>public String formatDate(String format, Locale loc) { 		MultivaluedMap<String, String> params = new MultivaluedHashMap<>(); 		params.putSingle(""format"", format); 		params.putSingle(""locale"", loc == null ? null : loc.toString()); 		return getEntity(invokeGet(""utils/formatdate"", params), String.class); 	}"
"public JsonResponse apiPost(ApiParams data, ApiFileParams fileParams) throws IOException {
        return httpRequestJson(HttpRequestMethod.POST, data, fileParams);
    }",1,httpclient post json,"httpclient post json<CODESPLIT>public JsonResponse apiPost(ApiParams data, ApiFileParams fileParams) throws IOException {         return httpRequestJson(HttpRequestMethod.POST, data, fileParams);     }"
"public long getElapsedHours() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerHh;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedHours() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerHh; 	}
"public static void extractZip(InputStream zip, final File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		// Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create
		// directories and files accordingly
		new ZipFileVisitor() {
			@Override
			public void visit(ZipEntry entry, InputStream data) throws IOException {
				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName() + "" to "" + target);
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					return;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				// it seems we cannot use IOUtils/FileUtils to copy as they close the stream
				int size;
				byte[] buffer = new byte[2048];
				try (OutputStream fout = new BufferedOutputStream(new FileOutputStream(target), buffer.length)) {
	                while ((size = data.read(buffer, 0, buffer.length)) != -1) {
	                    fout.write(buffer, 0, size);
	                }
				}
			}
		}.walk(zip);
	}",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(InputStream zip, final File toDir) throws IOException{ 		if(!toDir.exists()) { 			throw new IOException(""Directory '"" + toDir + ""' does not exist.""); 		}  		// Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create 		// directories and files accordingly 		new ZipFileVisitor() { 			@Override 			public void visit(ZipEntry entry, InputStream data) throws IOException { 				File target = new File(toDir, entry.getName()); 				if (entry.isDirectory()) { 					// Assume directories are stored parents first then children. 					//logger.info(""Extracting directory: "" + entry.getName() + "" to "" + target); 					// This is not robust, just for demonstration purposes. 					if(!target.mkdirs()) { 						logger.warning(""Could not create directory "" + target); 					} 					return; 				}  				// zips can contain nested files in sub-dirs without separate entries for the directories 				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) { 					logger.warning(""Could not create directory "" + target.getParentFile()); 				}  				// it seems we cannot use IOUtils/FileUtils to copy as they close the stream 				int size; 				byte[] buffer = new byte[2048]; 				try (OutputStream fout = new BufferedOutputStream(new FileOutputStream(target), buffer.length)) { 	                while ((size = data.read(buffer, 0, buffer.length)) != -1) { 	                    fout.write(buffer, 0, size); 	                } 				} 			} 		}.walk(zip); 	}"
"public Observable<HttpClientResponse<ByteBuf>>
  postSmile(String uriStr, JsonPayload payload) {
    byte[] entity = toByteArray(SMILE_FACTORY, payload);
    URI uri = URI.create(uriStr);
    return rxHttp.post(uri, SMILE_CONTENT_TYPE, entity);
  }",0,httpclient post json,"httpclient post json<CODESPLIT>public Observable<HttpClientResponse<ByteBuf>>   postSmile(String uriStr, JsonPayload payload) {     byte[] entity = toByteArray(SMILE_FACTORY, payload);     URI uri = URI.create(uriStr);     return rxHttp.post(uri, SMILE_CONTENT_TYPE, entity);   }"
"public Matrix multiply(double k)
    {
        double pv[][] = new double[nRows][nCols]; // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < nCols; ++c) {
                pv[r][c] = k*values[r][c];
            }
        }

        return new Matrix(pv);
    }",1,matrix multiply,matrix multiply<CODESPLIT>public Matrix multiply(double k)     {         double pv[][] = new double[nRows][nCols]; // product values          // Compute values of the product.         for (int r = 0; r < nRows; ++r) {             for (int c = 0; c < nCols; ++c) {                 pv[r][c] = k*values[r][c];             }         }          return new Matrix(pv);     }
"public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {

        if (port.startsWith(""["")) {
            port = port.substring(1, port.length() - 1);
        }
        if (!secure) {
            if (password == null) {
                password = ""stratio"";
            }
            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, user, password);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        } else {
            Properties props = new Properties();
            if (user != null) {
                props.setProperty(""user"", user);
            }
            if (ca != null) {
                props.setProperty(""sslrootcert"", ca);
            }
            if (crt != null) {
                props.setProperty(""sslcert"", crt);
            }
            if (key != null) {
                props.setProperty(""sslkey"", key);
            }
            props.setProperty(""password"", ""null"");
            props.setProperty(""ssl"", ""true"");
            props.setProperty(""sslmode"", ""verify-full"");


            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, props);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        }
    }",2,postgresql connection,"postgresql connection<CODESPLIT>public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {          if (port.startsWith(""["")) {             port = port.substring(1, port.length() - 1);         }         if (!secure) {             if (password == null) {                 password = ""stratio"";             }             try {                 myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, user, password);             } catch (SQLException se) {                 // log the exception                 this.getLogger().error(se.getMessage());                 // re-throw the exception                 throw se;             }          } else {             Properties props = new Properties();             if (user != null) {                 props.setProperty(""user"", user);             }             if (ca != null) {                 props.setProperty(""sslrootcert"", ca);             }             if (crt != null) {                 props.setProperty(""sslcert"", crt);             }             if (key != null) {                 props.setProperty(""sslkey"", key);             }             props.setProperty(""password"", ""null"");             props.setProperty(""ssl"", ""true"");             props.setProperty(""sslmode"", ""verify-full"");               try {                 myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, props);             } catch (SQLException se) {                 // log the exception                 this.getLogger().error(se.getMessage());                 // re-throw the exception                 throw se;             }          }     }"
"private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {
    try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName(""UTF-8""))) {
      CSVWriter csvWriter = new CSVWriter(streamWriter, ',');

      csvWriter.writeNext(columnHeaders);
      
      for (String[] row : rows) {
        csvWriter.writeNext(row);
      }

      csvWriter.close();
      
      return csvStream.toByteArray();
    }
  }",3,write csv,"write csv<CODESPLIT>private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {     try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName(""UTF-8""))) {       CSVWriter csvWriter = new CSVWriter(streamWriter, ',');        csvWriter.writeNext(columnHeaders);              for (String[] row : rows) {         csvWriter.writeNext(row);       }        csvWriter.close();              return csvStream.toByteArray();     }   }"
"public void removePermutations(List<Integer> removed) {

		int[] permutations = new int[this.permutations.length];

		int index = 0;
		permutations:
		for (int j : this.permutations) {
			for (int i = 0; i < removed.size(); i++) {
				if(removed.get(i) == j) {
					// skip this
					removed.remove(i);

					continue permutations;
				}
			}

			permutations[index] = j;

			index++;
		}

		int[] effectivePermutations = new int[index];
		System.arraycopy(permutations, 0, effectivePermutations, 0, index);
		
		this.rotations = new int[permutations.length];
		this.reset = new int[permutations.length];
		this.permutations = effectivePermutations;
		Arrays.sort(permutations); // ascending order to make the permutation logic work
	}",0,all permutations of a list,"all permutations of a list<CODESPLIT>public void removePermutations(List<Integer> removed) {  		int[] permutations = new int[this.permutations.length];  		int index = 0; 		permutations: 		for (int j : this.permutations) { 			for (int i = 0; i < removed.size(); i++) { 				if(removed.get(i) == j) { 					// skip this 					removed.remove(i);  					continue permutations; 				} 			}  			permutations[index] = j;  			index++; 		}  		int[] effectivePermutations = new int[index]; 		System.arraycopy(permutations, 0, effectivePermutations, 0, index); 		 		this.rotations = new int[permutations.length]; 		this.reset = new int[permutations.length]; 		this.permutations = effectivePermutations; 		Arrays.sort(permutations); // ascending order to make the permutation logic work 	}"
"@Override
	public String getRequestValue(final Request request) {
		if (isPresent(request)) {
			// User entered a valid date
			String dateParam = request.getParameter(getId() + ""-date"");
			if (dateParam == null) {
				return null;
			}

			// Validate Transfer Date Format - YYYY-MM-DD
			if (dateParam.length() != INTERNAL_DATE_TOTAL_CHARS || dateParam.charAt(
					INTERNAL_DASH1_POS) != '-'
					|| dateParam.charAt(INTERNAL_DASH2_POS) != '-') {
				LOG.warn(""Date parameter is not in the format yyyy-MM-dd ("" + dateParam
						+ "") and will be treated as null."");
				return null;
			}

			// Transform YYYY-MM-DD to YYYYMMDD
			StringBuffer buf = new StringBuffer(DATE_TOTAL_CHARS);
			buf.append(dateParam.substring(INTERNAL_YEAR_START, INTERNAL_YEAR_END));
			buf.append(dateParam.substring(INTERNAL_MONTH_START, INTERNAL_MONTH_END));
			buf.append(dateParam.substring(INTERNAL_DAY_START, INTERNAL_DAY_END));

			String dateFormat = buf.toString();

			// Validate the date
			if (!isValidPartialDateStringFormat(dateFormat, THEME_PADDING_CHAR)) {
				LOG.warn(""Date parameter (""
						+ dateParam
						+ "") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null."");
				return null;
			}

			// Convert from Theme padding character to the correct padding character
			return dateFormat.replace(THEME_PADDING_CHAR, getPaddingChar());
		} else {
			return getValue();
		}
	}",1,convert a date string into yyyymmdd,"convert a date string into yyyymmdd<CODESPLIT>@Override 	public String getRequestValue(final Request request) { 		if (isPresent(request)) { 			// User entered a valid date 			String dateParam = request.getParameter(getId() + ""-date""); 			if (dateParam == null) { 				return null; 			}  			// Validate Transfer Date Format - YYYY-MM-DD 			if (dateParam.length() != INTERNAL_DATE_TOTAL_CHARS || dateParam.charAt( 					INTERNAL_DASH1_POS) != '-' 					|| dateParam.charAt(INTERNAL_DASH2_POS) != '-') { 				LOG.warn(""Date parameter is not in the format yyyy-MM-dd ("" + dateParam 						+ "") and will be treated as null.""); 				return null; 			}  			// Transform YYYY-MM-DD to YYYYMMDD 			StringBuffer buf = new StringBuffer(DATE_TOTAL_CHARS); 			buf.append(dateParam.substring(INTERNAL_YEAR_START, INTERNAL_YEAR_END)); 			buf.append(dateParam.substring(INTERNAL_MONTH_START, INTERNAL_MONTH_END)); 			buf.append(dateParam.substring(INTERNAL_DAY_START, INTERNAL_DAY_END));  			String dateFormat = buf.toString();  			// Validate the date 			if (!isValidPartialDateStringFormat(dateFormat, THEME_PADDING_CHAR)) { 				LOG.warn(""Date parameter ("" 						+ dateParam 						+ "") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null.""); 				return null; 			}  			// Convert from Theme padding character to the correct padding character 			return dateFormat.replace(THEME_PADDING_CHAR, getPaddingChar()); 		} else { 			return getValue(); 		} 	}"
"protected Socket acceptSocket(int timeout)
    {
        try
        {
            Socket s = null;

            if (_listen != null)
            {
                if (_soTimeOut != timeout)
                {
                    _soTimeOut = timeout;
                    _listen.setSoTimeout(_soTimeOut);
                }

                s = _listen.accept();

                try
                {
                    if (getMaxIdleTimeMs() >= 0) s.setSoTimeout(getMaxIdleTimeMs());
                    if (_lingerTimeSecs >= 0)
                        s.setSoLinger(true, _lingerTimeSecs);
                    else
                        s.setSoLinger(false, 0);
                }
                catch (Exception e)
                {
                    LogSupport.ignore(log, e);
                }
            }
            return s;
        }
        catch (java.net.SocketException e)
        {
            // TODO - this is caught and ignored due strange
            // exception from linux java1.2.v1a
            LogSupport.ignore(log, e);
        }
        catch (InterruptedIOException e)
        {
            LogSupport.ignore(log, e);
        }
        catch (IOException e)
        {
            log.warn(LogSupport.EXCEPTION, e);
        }
        return null;
    }",2,socket recv timeout,"socket recv timeout<CODESPLIT>protected Socket acceptSocket(int timeout)     {         try         {             Socket s = null;              if (_listen != null)             {                 if (_soTimeOut != timeout)                 {                     _soTimeOut = timeout;                     _listen.setSoTimeout(_soTimeOut);                 }                  s = _listen.accept();                  try                 {                     if (getMaxIdleTimeMs() >= 0) s.setSoTimeout(getMaxIdleTimeMs());                     if (_lingerTimeSecs >= 0)                         s.setSoLinger(true, _lingerTimeSecs);                     else                         s.setSoLinger(false, 0);                 }                 catch (Exception e)                 {                     LogSupport.ignore(log, e);                 }             }             return s;         }         catch (java.net.SocketException e)         {             // TODO - this is caught and ignored due strange             // exception from linux java1.2.v1a             LogSupport.ignore(log, e);         }         catch (InterruptedIOException e)         {             LogSupport.ignore(log, e);         }         catch (IOException e)         {             log.warn(LogSupport.EXCEPTION, e);         }         return null;     }"
"public void doAESEncryption() throws Exception{
		if(!initAESDone)
			initAES();
		cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
		//System.out.println(secretKey.getEncoded());
		cipher.init(Cipher.ENCRYPT_MODE, secretKey);
		AlgorithmParameters params = cipher.getParameters();
		iv = params.getParameterSpec(IvParameterSpec.class).getIV();
		secretCipher = cipher.doFinal(secretPlain);
		clearPlain();
	}",3,aes encryption,"aes encryption<CODESPLIT>public void doAESEncryption() throws Exception{ 		if(!initAESDone) 			initAES(); 		cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); 		//System.out.println(secretKey.getEncoded()); 		cipher.init(Cipher.ENCRYPT_MODE, secretKey); 		AlgorithmParameters params = cipher.getParameters(); 		iv = params.getParameterSpec(IvParameterSpec.class).getIV(); 		secretCipher = cipher.doFinal(secretPlain); 		clearPlain(); 	}"
"public List<Point2D3D> createObservations( Se3_F64 worldToCamera , int total ) {

		Se3_F64 cameraToWorld = worldToCamera.invert(null);

		// transform from pixel coordinates to normalized pixel coordinates, which removes lens distortion
		Point2Transform2_F64 pixelToNorm = LensDistortionFactory.narrow(intrinsic).undistort_F64(true,false);

		List<Point2D3D> observations = new ArrayList<>();

		Point2D_F64 norm = new Point2D_F64();
		for (int i = 0; i < total; i++) {
			// randomly pixel a point inside the image
			double x = rand.nextDouble()*intrinsic.width;
			double y = rand.nextDouble()*intrinsic.height;

			// Convert to normalized image coordinates because that's what PNP needs.
			// it can't process pixel coordinates
			pixelToNorm.compute(x,y,norm);

			// Randomly pick a depth and compute 3D coordinate
			double Z = rand.nextDouble()+4;
			double X = norm.x*Z;
			double Y = norm.y*Z;

			// Change the point's reference frame from camera to world
			Point3D_F64 cameraPt = new Point3D_F64(X,Y,Z);
			Point3D_F64 worldPt = new Point3D_F64();

			SePointOps_F64.transform(cameraToWorld,cameraPt,worldPt);

			// Save the perfect noise free observation
			Point2D3D o = new Point2D3D();
			o.getLocation().set(worldPt);
			o.getObservation().set(norm.x,norm.y);

			observations.add(o);
		}

		return observations;
	}",0,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public List<Point2D3D> createObservations( Se3_F64 worldToCamera , int total ) {  		Se3_F64 cameraToWorld = worldToCamera.invert(null);  		// transform from pixel coordinates to normalized pixel coordinates, which removes lens distortion 		Point2Transform2_F64 pixelToNorm = LensDistortionFactory.narrow(intrinsic).undistort_F64(true,false);  		List<Point2D3D> observations = new ArrayList<>();  		Point2D_F64 norm = new Point2D_F64(); 		for (int i = 0; i < total; i++) { 			// randomly pixel a point inside the image 			double x = rand.nextDouble()*intrinsic.width; 			double y = rand.nextDouble()*intrinsic.height;  			// Convert to normalized image coordinates because that's what PNP needs. 			// it can't process pixel coordinates 			pixelToNorm.compute(x,y,norm);  			// Randomly pick a depth and compute 3D coordinate 			double Z = rand.nextDouble()+4; 			double X = norm.x*Z; 			double Y = norm.y*Z;  			// Change the point's reference frame from camera to world 			Point3D_F64 cameraPt = new Point3D_F64(X,Y,Z); 			Point3D_F64 worldPt = new Point3D_F64();  			SePointOps_F64.transform(cameraToWorld,cameraPt,worldPt);  			// Save the perfect noise free observation 			Point2D3D o = new Point2D3D(); 			o.getLocation().set(worldPt); 			o.getObservation().set(norm.x,norm.y);  			observations.add(o); 		}  		return observations; 	}"
"public String getCsv() {

        StringWriter writer = new StringWriter();
        try (CSVWriter csv = new CSVWriter(writer)) {
            List<String> headers = new ArrayList<>();
            for (String col : m_columns) {
                headers.add(col);
            }
            csv.writeNext(headers.toArray(new String[] {}));
            for (List<Object> row : m_data) {
                List<String> colCsv = new ArrayList<>();
                for (Object col : row) {
                    colCsv.add(String.valueOf(col));
                }
                csv.writeNext(colCsv.toArray(new String[] {}));
            }
            return writer.toString();
        } catch (IOException e) {
            return null;
        }
    }",1,convert json to csv,convert json to csv<CODESPLIT>public String getCsv() {          StringWriter writer = new StringWriter();         try (CSVWriter csv = new CSVWriter(writer)) {             List<String> headers = new ArrayList<>();             for (String col : m_columns) {                 headers.add(col);             }             csv.writeNext(headers.toArray(new String[] {}));             for (List<Object> row : m_data) {                 List<String> colCsv = new ArrayList<>();                 for (Object col : row) {                     colCsv.add(String.valueOf(col));                 }                 csv.writeNext(colCsv.toArray(new String[] {}));             }             return writer.toString();         } catch (IOException e) {             return null;         }     }
"InputStream getInputStream() throws IOException {
        switch (filetype) {
            case GZ:
                LOG.debug(""Decompressing .gz file"");
                return new GzipCompressorInputStream(new FileInputStream(compressedFile));
            case BZ2:
                LOG.debug(""Decompressing .bz2 file"");
                return new BZip2CompressorInputStream(new FileInputStream(compressedFile));
        }
        return null;
    }",2,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>InputStream getInputStream() throws IOException {         switch (filetype) {             case GZ:                 LOG.debug(""Decompressing .gz file"");                 return new GzipCompressorInputStream(new FileInputStream(compressedFile));             case BZ2:                 LOG.debug(""Decompressing .bz2 file"");                 return new BZip2CompressorInputStream(new FileInputStream(compressedFile));         }         return null;     }"
"private String formatDate(Date value)
   {
      return (value == null ? null : m_formats.getDateFormat().format(value));
   }",3,format date,format date<CODESPLIT>private String formatDate(Date value)    {       return (value == null ? null : m_formats.getDateFormat().format(value));    }
"private static void summarizeGLMModel(ModelSummary summary, hex.glm.GLMModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""GLM"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, GLM_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, GLM_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, GLM_expert_params);
  }",0,print model summary,"print model summary<CODESPLIT>private static void summarizeGLMModel(ModelSummary summary, hex.glm.GLMModel model) {     // add generic fields such as column names     summarizeModelCommonFields(summary, model);      summary.model_algorithm = ""GLM"";      JsonObject all_params = (model.get_params()).toJSON();     summary.critical_parameters = whitelistJsonObject(all_params, GLM_critical_params);     summary.secondary_parameters = whitelistJsonObject(all_params, GLM_secondary_params);     summary.expert_parameters = whitelistJsonObject(all_params, GLM_expert_params);   }"
"protected Widget addMarker(String text) {

        Label label = new Label(text);
        label.addStyleName(CSS.marker());
        getListItemWidget().addButton(label);
        return label;
    }",1,underline text in label widget,underline text in label widget<CODESPLIT>protected Widget addMarker(String text) {          Label label = new Label(text);         label.addStyleName(CSS.marker());         getListItemWidget().addButton(label);         return label;     }
"private void extract(String htmlDoc) {

    //now extract the contents of <body>...
    int bodyStart = htmlDoc.indexOf(BODY_BEGIN) + BODY_BEGIN.length();

    //scan for end of the <body> start tag (beginning of body content)
    char quote = NOT_IN_QUOTE;
    for (int body = bodyStart; body < htmlDoc.length(); body++) {
      final char c = htmlDoc.charAt(body);
      if (isQuoteChar(c)) {
        if (quote == NOT_IN_QUOTE)
          quote = c;
        else if (quote == c)
          quote = NOT_IN_QUOTE;
      }

      if ('>' == c && NOT_IN_QUOTE == quote) {
        bodyStart = body + 1;
        break;
      }
    }

    int bodyEnd = htmlDoc.indexOf(BODY_END, bodyStart);

    //if there was no body tag, just embed whatever was rendered directly
    if (-1 == bodyEnd) {
      EmbeddedRespond.this.body = htmlDoc;
    } else
      EmbeddedRespond.this.body = htmlDoc.substring(bodyStart, bodyEnd);
  }",2,extract data from html content,"extract data from html content<CODESPLIT>private void extract(String htmlDoc) {      //now extract the contents of <body>...     int bodyStart = htmlDoc.indexOf(BODY_BEGIN) + BODY_BEGIN.length();      //scan for end of the <body> start tag (beginning of body content)     char quote = NOT_IN_QUOTE;     for (int body = bodyStart; body < htmlDoc.length(); body++) {       final char c = htmlDoc.charAt(body);       if (isQuoteChar(c)) {         if (quote == NOT_IN_QUOTE)           quote = c;         else if (quote == c)           quote = NOT_IN_QUOTE;       }        if ('>' == c && NOT_IN_QUOTE == quote) {         bodyStart = body + 1;         break;       }     }      int bodyEnd = htmlDoc.indexOf(BODY_END, bodyStart);      //if there was no body tag, just embed whatever was rendered directly     if (-1 == bodyEnd) {       EmbeddedRespond.this.body = htmlDoc;     } else       EmbeddedRespond.this.body = htmlDoc.substring(bodyStart, bodyEnd);   }"
"public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {
        if (data[0].length != 2 && data[0].length != 3) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data, y, legend, palette);
        plot.setID(id);
        canvas.add(plot);

        return canvas;
    }",3,scatter plot,"scatter plot<CODESPLIT>public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {         if (data[0].length != 2 && data[0].length != 3) {             throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);         }          double[] lowerBound = Math.colMin(data);         double[] upperBound = Math.colMax(data);         PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);          ScatterPlot plot = new ScatterPlot(data, y, legend, palette);         plot.setID(id);         canvas.add(plot);          return canvas;     }"
"private static void summarizeDeepLearningModel(ModelSummary summary, hex.deeplearning.DeepLearningModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""DeepLearning"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, DL_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, DL_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, DL_expert_params);
  }",0,print model summary,"print model summary<CODESPLIT>private static void summarizeDeepLearningModel(ModelSummary summary, hex.deeplearning.DeepLearningModel model) {     // add generic fields such as column names     summarizeModelCommonFields(summary, model);      summary.model_algorithm = ""DeepLearning"";      JsonObject all_params = (model.get_params()).toJSON();     summary.critical_parameters = whitelistJsonObject(all_params, DL_critical_params);     summary.secondary_parameters = whitelistJsonObject(all_params, DL_secondary_params);     summary.expert_parameters = whitelistJsonObject(all_params, DL_expert_params);   }"
"protected String getJavaExecutablePath() {
        String executableName = isWindows() ? ""bin/java.exe"" : ""bin/java"";
        return PROPERTIES.getJavaHome().resolve(executableName).toAbsolutePath().toString();
    }",1,get executable path,"get executable path<CODESPLIT>protected String getJavaExecutablePath() {         String executableName = isWindows() ? ""bin/java.exe"" : ""bin/java"";         return PROPERTIES.getJavaHome().resolve(executableName).toAbsolutePath().toString();     }"
"public static String reverse(final String s) {
		StringBuilder result = new StringBuilder(s.length());
		for (int i = s.length() -1; i >= 0; i--) {
			result.append(s.charAt(i));
		}
		return result.toString();
	}",2,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(final String s) { 		StringBuilder result = new StringBuilder(s.length()); 		for (int i = s.length() -1; i >= 0; i--) { 			result.append(s.charAt(i)); 		} 		return result.toString(); 	}
"public ScatterPlot points(String id, double[][] data, Color color) {
        if (data[0].length != base.dimension) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        extendBound(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data);
        plot.setID(id);
        plot.setColor(color);
        add(plot);

        return plot;
    }",3,scatter plot,"scatter plot<CODESPLIT>public ScatterPlot points(String id, double[][] data, Color color) {         if (data[0].length != base.dimension) {             throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);         }          double[] lowerBound = Math.colMin(data);         double[] upperBound = Math.colMax(data);         extendBound(lowerBound, upperBound);          ScatterPlot plot = new ScatterPlot(data);         plot.setID(id);         plot.setColor(color);         add(plot);          return plot;     }"
"public void switchReadOnlyConnection(Boolean mustBeReadOnly) throws SQLException {
    if (urlParser.getOptions().assureReadOnly && currentReadOnlyAsked != mustBeReadOnly) {
      proxy.lock.lock();
      try {
        // verify not updated now that hold lock, double check safe due to volatile
        if (currentReadOnlyAsked != mustBeReadOnly) {
          currentReadOnlyAsked = mustBeReadOnly;
          setSessionReadOnly(mustBeReadOnly, currentProtocol);
        }
      } finally {
        proxy.lock.unlock();
      }
    }
  }",0,readonly array,"readonly array<CODESPLIT>public void switchReadOnlyConnection(Boolean mustBeReadOnly) throws SQLException {     if (urlParser.getOptions().assureReadOnly && currentReadOnlyAsked != mustBeReadOnly) {       proxy.lock.lock();       try {         // verify not updated now that hold lock, double check safe due to volatile         if (currentReadOnlyAsked != mustBeReadOnly) {           currentReadOnlyAsked = mustBeReadOnly;           setSessionReadOnly(mustBeReadOnly, currentProtocol);         }       } finally {         proxy.lock.unlock();       }     }   }"
"public static <T> Observable<T> map(Observable<?> fromObservable, final T toValue) {
        if (fromObservable != null) {
            return fromObservable.subscribeOn(Schedulers.io())
                    .map(new RXMapper<T>(toValue));
        } else {
            return Observable.empty();
        }
    }",1,get current observable value,"get current observable value<CODESPLIT>public static <T> Observable<T> map(Observable<?> fromObservable, final T toValue) {         if (fromObservable != null) {             return fromObservable.subscribeOn(Schedulers.io())                     .map(new RXMapper<T>(toValue));         } else {             return Observable.empty();         }     }"
"public static void forHtmlUnquotedAttribute(Writer out, String input)
        throws IOException
    {
        encode(Encoders.HTML_UNQUOTED_ATTRIBUTE_ENCODER, out, input);
    }",2,html encode string,"html encode string<CODESPLIT>public static void forHtmlUnquotedAttribute(Writer out, String input)         throws IOException     {         encode(Encoders.HTML_UNQUOTED_ATTRIBUTE_ENCODER, out, input);     }"
"protected PlotCanvas paintOnCanvas(double[][] data, int[] label) {
        PlotCanvas canvas = ScatterPlot.plot(data, pointLegend);
        for (int i = 0; i < data.length; i++) {
            canvas.point(pointLegend, Palette.COLORS[label[i]], data[i]);
        }
        return canvas;
    }",3,scatter plot,"scatter plot<CODESPLIT>protected PlotCanvas paintOnCanvas(double[][] data, int[] label) {         PlotCanvas canvas = ScatterPlot.plot(data, pointLegend);         for (int i = 0; i < data.length; i++) {             canvas.point(pointLegend, Palette.COLORS[label[i]], data[i]);         }         return canvas;     }"
"public boolean isCaseSensitive() {
        switch (getJcrType()) {
            case PropertyType.DOUBLE:
            case PropertyType.LONG:
            case PropertyType.DECIMAL:
            case PropertyType.WEAKREFERENCE:
            case PropertyType.REFERENCE: // conversion is case-insensitive
            case PropertyType.BOOLEAN: // conversion is case-insensitive
                return false;
        }
        return true;
    }",0,regex case insensitive,regex case insensitive<CODESPLIT>public boolean isCaseSensitive() {         switch (getJcrType()) {             case PropertyType.DOUBLE:             case PropertyType.LONG:             case PropertyType.DECIMAL:             case PropertyType.WEAKREFERENCE:             case PropertyType.REFERENCE: // conversion is case-insensitive             case PropertyType.BOOLEAN: // conversion is case-insensitive                 return false;         }         return true;     }
"public Closure<V> memoizeAtMost(final int maxCacheSize) {
        if (maxCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the maxCacheSize parameter for memoizeAtMost."");

        return Memoize.buildMemoizeFunction(new LRUCache(maxCacheSize), this);
    }",1,memoize to disk  - persistent memoization,"memoize to disk  - persistent memoization<CODESPLIT>public Closure<V> memoizeAtMost(final int maxCacheSize) {         if (maxCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the maxCacheSize parameter for memoizeAtMost."");          return Memoize.buildMemoizeFunction(new LRUCache(maxCacheSize), this);     }"
"public HtmlElement findHtmlElementById(String elementId) {
        try {
            return htmlPage.getHtmlElementById(elementId);
        } catch (ElementNotFoundException e) {
            return null;
        }
    }",2,reading element from html - <td>,reading element from html - <td><CODESPLIT>public HtmlElement findHtmlElementById(String elementId) {         try {             return htmlPage.getHtmlElementById(elementId);         } catch (ElementNotFoundException e) {             return null;         }     }
"public void csv(String file) throws IOException {
        CsvWriteOptions options = CsvWriteOptions.builder(file).build();
        new CsvWriter().write(table, options);
    }",3,write csv,"write csv<CODESPLIT>public void csv(String file) throws IOException {         CsvWriteOptions options = CsvWriteOptions.builder(file).build();         new CsvWriter().write(table, options);     }"
"public AbstractJdbcHelper init() {
        dataSources.forEach((key, ds) -> DbcHelper.registerJdbcDataSource(id + ""-"" + key, ds));
        return this;
    }",0,initializing array,"initializing array<CODESPLIT>public AbstractJdbcHelper init() {         dataSources.forEach((key, ds) -> DbcHelper.registerJdbcDataSource(id + ""-"" + key, ds));         return this;     }"
"public static BufferedReader newReader(Path self) throws IOException {
        return Files.newBufferedReader(self, Charset.defaultCharset());
    }",1,buffered file reader read text,"buffered file reader read text<CODESPLIT>public static BufferedReader newReader(Path self) throws IOException {         return Files.newBufferedReader(self, Charset.defaultCharset());     }"
"public static String readTextFile(File file) throws IOException
    {
        //create reader to file (with default encoding)
        InputStream inputStream=new FileInputStream(file);
        Reader reader=IOHelper.createReader(inputStream,null);

        //read text
        String text=IOHelper.readTextStream(reader);
        
        return text;
    }",2,buffered file reader read text,"buffered file reader read text<CODESPLIT>public static String readTextFile(File file) throws IOException     {         //create reader to file (with default encoding)         InputStream inputStream=new FileInputStream(file);         Reader reader=IOHelper.createReader(inputStream,null);          //read text         String text=IOHelper.readTextStream(reader);                  return text;     }"
"public static void copy(Path sourcePath, Path targetPath, boolean executable) throws IOException {
		// we unwrap the file system to get raw streams without safety net
		FileSystem sFS = FileSystem.getUnguardedFileSystem(sourcePath.toUri());
		FileSystem tFS = FileSystem.getUnguardedFileSystem(targetPath.toUri());
		if (!tFS.exists(targetPath)) {
			if (sFS.getFileStatus(sourcePath).isDir()) {
				internalCopyDirectory(sourcePath, targetPath, executable, sFS, tFS);
			} else {
				internalCopyFile(sourcePath, targetPath, executable, sFS, tFS);
			}
		}
	}",3,get executable path,"get executable path<CODESPLIT>public static void copy(Path sourcePath, Path targetPath, boolean executable) throws IOException { 		// we unwrap the file system to get raw streams without safety net 		FileSystem sFS = FileSystem.getUnguardedFileSystem(sourcePath.toUri()); 		FileSystem tFS = FileSystem.getUnguardedFileSystem(targetPath.toUri()); 		if (!tFS.exists(targetPath)) { 			if (sFS.getFileStatus(sourcePath).isDir()) { 				internalCopyDirectory(sourcePath, targetPath, executable, sFS, tFS); 			} else { 				internalCopyFile(sourcePath, targetPath, executable, sFS, tFS); 			} 		} 	}"
"public RegressionSuite regressionSuite(String name, RegressionPlan regressionPlan) {
        return regressionSuite(name, regressionPlan, null);
    }",0,linear regression,"linear regression<CODESPLIT>public RegressionSuite regressionSuite(String name, RegressionPlan regressionPlan) {         return regressionSuite(name, regressionPlan, null);     }"
"public static DocumentContext parse(File json, Configuration configuration) throws IOException {
        return new ParseContextImpl(configuration).parse(json);
    }",1,parse json file,"parse json file<CODESPLIT>public static DocumentContext parse(File json, Configuration configuration) throws IOException {         return new ParseContextImpl(configuration).parse(json);     }"
"public static <T> T pickRandom (List<T> values, T skip, Random r)
    {
        int size = values.size();
        if (size < 2) {
            throw new IllegalArgumentException(
                ""Must have at least two elements [size="" + size + ""]"");
        }

        int pick = r.nextInt(size - 1);
        for (int ii = 0; ii < size; ii++) {
            T val = values.get(ii);
            if ((val != skip) && (pick-- == 0)) {
                return val;
            }
        }
        return null;
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static <T> T pickRandom (List<T> values, T skip, Random r)     {         int size = values.size();         if (size < 2) {             throw new IllegalArgumentException(                 ""Must have at least two elements [size="" + size + ""]"");         }          int pick = r.nextInt(size - 1);         for (int ii = 0; ii < size; ii++) {             T val = values.get(ii);             if ((val != skip) && (pick-- == 0)) {                 return val;             }         }         return null;     }"
"public synchronized void save() {
        if (BulkChange.contains(this)) {
            return;
        }
        
        File file = getConfigFile();
        try {
            List<String> allSignatures = new ArrayList<>(whitelistSignaturesFromUserControlledList);
            blacklistSignaturesFromUserControlledList.stream()
                    .map(signature -> ""!"" + signature)
                    .forEach(allSignatures::add);
            
            FileUtils.writeLines(file, allSignatures);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, ""Failed to save "" + file.getAbsolutePath(), e);
        }
    }",3,save list to file,"save list to file<CODESPLIT>public synchronized void save() {         if (BulkChange.contains(this)) {             return;         }                  File file = getConfigFile();         try {             List<String> allSignatures = new ArrayList<>(whitelistSignaturesFromUserControlledList);             blacklistSignaturesFromUserControlledList.stream()                     .map(signature -> ""!"" + signature)                     .forEach(allSignatures::add);                          FileUtils.writeLines(file, allSignatures);         } catch (IOException e) {             LOGGER.log(Level.WARNING, ""Failed to save "" + file.getAbsolutePath(), e);         }     }"
"public static Filter filterArrayToChain(Filter[] filterArray) {
        for (int i = 0; i < (filterArray.length - 1); i++) {
            AbstractFilter thisFilter = (AbstractFilter) filterArray[i];
            thisFilter.setAnd(filterArray[i + 1]);
        }
        AbstractFilter lastFilter = (AbstractFilter) filterArray[filterArray.length - 1];
        lastFilter.setAnd(null);
        return filterArray[0];
    }",0,filter array,filter array<CODESPLIT>public static Filter filterArrayToChain(Filter[] filterArray) {         for (int i = 0; i < (filterArray.length - 1); i++) {             AbstractFilter thisFilter = (AbstractFilter) filterArray[i];             thisFilter.setAnd(filterArray[i + 1]);         }         AbstractFilter lastFilter = (AbstractFilter) filterArray[filterArray.length - 1];         lastFilter.setAnd(null);         return filterArray[0];     }
"public static <T extends Comparable<? super T>>  int[] sort(T[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }",1,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public static <T extends Comparable<? super T>>  int[] sort(T[] arr) {         int[] order = new int[arr.length];         for (int i = 0; i < order.length; i++) {             order[i] = i;         }         sort(arr, order);         return order;     }"
"public byte[] getHardwareAddress()
  {
    if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {
      return new byte[] { 10, 0, 0, 0, 0, 10 };
    }
    
    for (NetworkInterfaceBase nic : getNetworkInterfaces()) {
      if (! nic.isLoopback()) {
        return nic.getHardwareAddress();
      }
    }
    
    try {
      InetAddress localHost = InetAddress.getLocalHost();
      
      return localHost.getAddress();
    } catch (Exception e) {
      log.log(Level.FINER, e.toString(), e);
    }
    
    return new byte[0];
  }",2,get current ip address,"get current ip address<CODESPLIT>public byte[] getHardwareAddress()   {     if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {       return new byte[] { 10, 0, 0, 0, 0, 10 };     }          for (NetworkInterfaceBase nic : getNetworkInterfaces()) {       if (! nic.isLoopback()) {         return nic.getHardwareAddress();       }     }          try {       InetAddress localHost = InetAddress.getLocalHost();              return localHost.getAddress();     } catch (Exception e) {       log.log(Level.FINER, e.toString(), e);     }          return new byte[0];   }"
"public static InputStream decompress(final InputStream in, final String fileName) throws IOException
  {
    if (fileName.endsWith(GZ_SUFFIX)) {
      return gzipInputStream(in);
    } else if (fileName.endsWith(BZ2_SUFFIX)) {
      return new BZip2CompressorInputStream(in, true);
    } else if (fileName.endsWith(XZ_SUFFIX)) {
      return new XZCompressorInputStream(in, true);
    } else if (fileName.endsWith(SNAPPY_SUFFIX)) {
      return new FramedSnappyCompressorInputStream(in);
    } else if (fileName.endsWith(ZSTD_SUFFIX)) {
      return new ZstdCompressorInputStream(in);
    } else if (fileName.endsWith(ZIP_SUFFIX)) {
      // This reads the first file in the archive.
      final ZipInputStream zipIn = new ZipInputStream(in, StandardCharsets.UTF_8);
      try {
        final ZipEntry nextEntry = zipIn.getNextEntry();
        if (nextEntry == null) {
          zipIn.close();

          // No files in the archive - return an empty stream.
          return new ByteArrayInputStream(new byte[0]);
        }
        return zipIn;
      }
      catch (IOException e) {
        try {
          zipIn.close();
        }
        catch (IOException e2) {
          e.addSuppressed(e2);
        }
        throw e;
      }
    } else {
      return in;
    }
  }",3,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>public static InputStream decompress(final InputStream in, final String fileName) throws IOException   {     if (fileName.endsWith(GZ_SUFFIX)) {       return gzipInputStream(in);     } else if (fileName.endsWith(BZ2_SUFFIX)) {       return new BZip2CompressorInputStream(in, true);     } else if (fileName.endsWith(XZ_SUFFIX)) {       return new XZCompressorInputStream(in, true);     } else if (fileName.endsWith(SNAPPY_SUFFIX)) {       return new FramedSnappyCompressorInputStream(in);     } else if (fileName.endsWith(ZSTD_SUFFIX)) {       return new ZstdCompressorInputStream(in);     } else if (fileName.endsWith(ZIP_SUFFIX)) {       // This reads the first file in the archive.       final ZipInputStream zipIn = new ZipInputStream(in, StandardCharsets.UTF_8);       try {         final ZipEntry nextEntry = zipIn.getNextEntry();         if (nextEntry == null) {           zipIn.close();            // No files in the archive - return an empty stream.           return new ByteArrayInputStream(new byte[0]);         }         return zipIn;       }       catch (IOException e) {         try {           zipIn.close();         }         catch (IOException e2) {           e.addSuppressed(e2);         }         throw e;       }     } else {       return in;     }   }"
"@Override
    public Filter[] filterChainToArray() {
        int length = chainLength();
        Filter[] array = new Filter[length];
        Filter thisFilter = this;
        for (int i = 0; i < length; i++) {
            array[i] = thisFilter;
            thisFilter = thisFilter.getAnd();
        }
        return array;
    }",0,filter array,filter array<CODESPLIT>@Override     public Filter[] filterChainToArray() {         int length = chainLength();         Filter[] array = new Filter[length];         Filter thisFilter = this;         for (int i = 0; i < length; i++) {             array[i] = thisFilter;             thisFilter = thisFilter.getAnd();         }         return array;     }
"public void setWorkingDirectory(String path) {
        if (path != null) {
            File dir = new File(path);
            checkWorkingDir(dir);
            workingDir = dir;
        } else {
            workingDir = null;
        }
    }",1,set working directory,set working directory<CODESPLIT>public void setWorkingDirectory(String path) {         if (path != null) {             File dir = new File(path);             checkWorkingDir(dir);             workingDir = dir;         } else {             workingDir = null;         }     }
"public static void copyToClipboard(String text) {
		final StringSelection stringSelection = new StringSelection(text);
		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(stringSelection, stringSelection);
	}",2,copy to clipboard,"copy to clipboard<CODESPLIT>public static void copyToClipboard(String text) { 		final StringSelection stringSelection = new StringSelection(text); 		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 		clipboard.setContents(stringSelection, stringSelection); 	}"
"private static String reverseString(String in) {
        StringBuilder out = new StringBuilder(in).reverse();
        return out.toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>private static String reverseString(String in) {         StringBuilder out = new StringBuilder(in).reverse();         return out.toString();     }
"public static String concatFilePath(boolean _includeTrailingDelimiter, String..._parts) {
        if (_parts == null) {
            return null;
        }
        StringBuilder allParts = new StringBuilder();

        for (int i = 0; i < _parts.length; i++) {
            if (_parts[i] == null) {
                continue;
            }
            allParts.append(_parts[i]);

            if (!_parts[i].endsWith(File.separator)) {
                allParts.append(File.separator);
            }
        }

        if (!_includeTrailingDelimiter && allParts.length() > 0) {
            return allParts.substring(0, allParts.lastIndexOf(File.separator));
        }

        return allParts.toString();
    }",0,concatenate several file remove header lines,"concatenate several file remove header lines<CODESPLIT>public static String concatFilePath(boolean _includeTrailingDelimiter, String..._parts) {         if (_parts == null) {             return null;         }         StringBuilder allParts = new StringBuilder();          for (int i = 0; i < _parts.length; i++) {             if (_parts[i] == null) {                 continue;             }             allParts.append(_parts[i]);              if (!_parts[i].endsWith(File.separator)) {                 allParts.append(File.separator);             }         }          if (!_includeTrailingDelimiter && allParts.length() > 0) {             return allParts.substring(0, allParts.lastIndexOf(File.separator));         }          return allParts.toString();     }"
"CommandLine parse(DefaultCommandLine cl, String[] args) {
        parseInternal(cl, args, true);
        return cl;
    }",1,parse command line argument,"parse command line argument<CODESPLIT>CommandLine parse(DefaultCommandLine cl, String[] args) {         parseInternal(cl, args, true);         return cl;     }"
"public S animate(Timer timer)
	{
		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay);
		started = elapsed > transform.getDelay();
		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;

		if (!started && !renderBefore)
			return null;
		if (finished && !renderAfter)
			return null;

		transform.transform(transformable, elapsed);
		return transformable;
	}",2,finding time elapsed using a timer,"finding time elapsed using a timer<CODESPLIT>public S animate(Timer timer) 	{ 		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay); 		started = elapsed > transform.getDelay(); 		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;  		if (!started && !renderBefore) 			return null; 		if (finished && !renderAfter) 			return null;  		transform.transform(transformable, elapsed); 		return transformable; 	}"
"public static String replaceHtmlEntities(String content, Map<String, Character> map) {
    
    for (Entry<String, Character> entry : escapeStrings.entrySet()) {
      
      if (content.indexOf(entry.getKey()) != -1) {
        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));
      }
      
    }
    
    return content;
  }",3,html entities replace,"html entities replace<CODESPLIT>public static String replaceHtmlEntities(String content, Map<String, Character> map) {          for (Entry<String, Character> entry : escapeStrings.entrySet()) {              if (content.indexOf(entry.getKey()) != -1) {         content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));       }            }          return content;   }"
"public static File getExecutionPath() throws OSException {
        try {
            return new File(OSUtils.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
        } catch (URISyntaxException ex) {
            throw new OSException(ex);
        }
    }",0,get executable path,get executable path<CODESPLIT>public static File getExecutionPath() throws OSException {         try {             return new File(OSUtils.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());         } catch (URISyntaxException ex) {             throw new OSException(ex);         }     }
"public static double similarity(String s1, String s2) {
    if (s1.equals(s2))
      return 1.0;

    // ensure that s1 is shorter than or same length as s2
    if (s1.length() > s2.length()) {
      String tmp = s2;
      s2 = s1;
      s1 = tmp;
    }
    /*
     * this list of Boolean values is used for avoiding duplicated count of
     * common characters in S2
     */
    List<Boolean> isCommonCharInS2 = new ArrayList<Boolean>();
    for (int i=0; i<s2.length(); i++) {
      isCommonCharInS2.add(false);
    }

    // (1) find the number of characters the two strings have in common.
    // note that matching characters can only be half the length of the
    // longer string apart.
    int maxdist = (int) Math.floor(s2.length() / 2) ;
    int c = 0; // count of common characters
    int t = 0; // count of transpositions
    int prevpos = -1;
    for (int ix = 0; ix < s1.length(); ix++) {
      char ch = s1.charAt(ix);

      // now try to find it in s2
      for (int ix2 = Math.max(0, ix - maxdist);
           ix2 < Math.min(s2.length(), ix + maxdist);
           ix2++) {
        if (ch == s2.charAt(ix2) && !isCommonCharInS2.get(ix2)) {
          c++; // we found a common character
          isCommonCharInS2.set(ix2, true);
          if (prevpos != -1 && ix2 < prevpos)
            t++; // moved back before earlier
          prevpos = ix2;
          break;
        }
      }
    }

    // we don't divide t by 2 because as far as we can tell, the above
    // code counts transpositions directly.

    // System.out.println(""c: "" + c);
    // System.out.println(""t: "" + t);
    // System.out.println(""c/m: "" + (c / (double) s1.length()));
    // System.out.println(""c/n: "" + (c / (double) s2.length()));
    // System.out.println(""(c-t)/c: "" + ((c - t) / (double) c));

    // we might have to give up right here
    if (c == 0)
      return 0.0;

    // first compute the score
    double score = ((c / (double) s1.length()) +
            (c / (double) s2.length()) +
            ((c - t) / (double) c)) / 3.0;

    // (2) common prefix modification
    int p = 0; // length of prefix
    int last = Math.min(4, s1.length());
    for (; p < last && s1.charAt(p) == s2.charAt(p); p++)
      ;

    score = score + ((p * (1 - score)) / 10);

    // (3) longer string adjustment
    // I'm confused about this part. Winkler's original source code includes
    // it, and Yancey's 2005 paper describes it. However, Winkler's list of
    // test cases in his 2006 paper does not include this modification. So
    // is this part of Jaro-Winkler, or is it not? Hard to say.
    //
    //   if (s1.length() >= 5 && // both strings at least 5 characters long
    //       c - p >= 2 && // at least two common characters besides prefix
    //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars
    //     {
    //     System.out.println(""ADJUSTED!"");
    //     score = score + ((1 - score) * ((c - (p + 1)) /
    //                                     ((double) ((s1.length() + s2.length())
    //                                                - (2 * (p - 1))))));
    // }

    // (4) similar characters adjustment
    // the same holds for this as for (3) above.

    return score;
  }",1,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarity(String s1, String s2) {     if (s1.equals(s2))       return 1.0;      // ensure that s1 is shorter than or same length as s2     if (s1.length() > s2.length()) {       String tmp = s2;       s2 = s1;       s1 = tmp;     }     /*      * this list of Boolean values is used for avoiding duplicated count of      * common characters in S2      */     List<Boolean> isCommonCharInS2 = new ArrayList<Boolean>();     for (int i=0; i<s2.length(); i++) {       isCommonCharInS2.add(false);     }      // (1) find the number of characters the two strings have in common.     // note that matching characters can only be half the length of the     // longer string apart.     int maxdist = (int) Math.floor(s2.length() / 2) ;     int c = 0; // count of common characters     int t = 0; // count of transpositions     int prevpos = -1;     for (int ix = 0; ix < s1.length(); ix++) {       char ch = s1.charAt(ix);        // now try to find it in s2       for (int ix2 = Math.max(0, ix - maxdist);            ix2 < Math.min(s2.length(), ix + maxdist);            ix2++) {         if (ch == s2.charAt(ix2) && !isCommonCharInS2.get(ix2)) {           c++; // we found a common character           isCommonCharInS2.set(ix2, true);           if (prevpos != -1 && ix2 < prevpos)             t++; // moved back before earlier           prevpos = ix2;           break;         }       }     }      // we don't divide t by 2 because as far as we can tell, the above     // code counts transpositions directly.      // System.out.println(""c: "" + c);     // System.out.println(""t: "" + t);     // System.out.println(""c/m: "" + (c / (double) s1.length()));     // System.out.println(""c/n: "" + (c / (double) s2.length()));     // System.out.println(""(c-t)/c: "" + ((c - t) / (double) c));      // we might have to give up right here     if (c == 0)       return 0.0;      // first compute the score     double score = ((c / (double) s1.length()) +             (c / (double) s2.length()) +             ((c - t) / (double) c)) / 3.0;      // (2) common prefix modification     int p = 0; // length of prefix     int last = Math.min(4, s1.length());     for (; p < last && s1.charAt(p) == s2.charAt(p); p++)       ;      score = score + ((p * (1 - score)) / 10);      // (3) longer string adjustment     // I'm confused about this part. Winkler's original source code includes     // it, and Yancey's 2005 paper describes it. However, Winkler's list of     // test cases in his 2006 paper does not include this modification. So     // is this part of Jaro-Winkler, or is it not? Hard to say.     //     //   if (s1.length() >= 5 && // both strings at least 5 characters long     //       c - p >= 2 && // at least two common characters besides prefix     //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars     //     {     //     System.out.println(""ADJUSTED!"");     //     score = score + ((1 - score) * ((c - (p + 1)) /     //                                     ((double) ((s1.length() + s2.length())     //                                                - (2 * (p - 1))))));     // }      // (4) similar characters adjustment     // the same holds for this as for (3) above.      return score;   }"
"public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {
        return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );
    }",2,deserialize json,"deserialize json<CODESPLIT>public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {         return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );     }"
"public final void fileCopy(File in, File out) throws IOException {
		assert in != null;
		assert out != null;
		getLog().debug(""Copying file: "" + in.toString() + "" into "" + out.toString()); //$NON-NLS-1$ //$NON-NLS-2$
		try (FileInputStream fis = new FileInputStream(in)) {
			try (FileChannel inChannel = fis.getChannel()) {
				try (FileOutputStream fos = new FileOutputStream(out)) {
					try (FileChannel outChannel = fos.getChannel()) {
						inChannel.transferTo(0, inChannel.size(), outChannel);
					}
				}
			}
		} finally {
			getBuildContext().refresh(out);
		}
	}",3,copying a file to a path,"copying a file to a path<CODESPLIT>public final void fileCopy(File in, File out) throws IOException { 		assert in != null; 		assert out != null; 		getLog().debug(""Copying file: "" + in.toString() + "" into "" + out.toString()); //$NON-NLS-1$ //$NON-NLS-2$ 		try (FileInputStream fis = new FileInputStream(in)) { 			try (FileChannel inChannel = fis.getChannel()) { 				try (FileOutputStream fos = new FileOutputStream(out)) { 					try (FileChannel outChannel = fos.getChannel()) { 						inChannel.transferTo(0, inChannel.size(), outChannel); 					} 				} 			} 		} finally { 			getBuildContext().refresh(out); 		} 	}"
"public void save(File file) throws IOException {
        try (FileOutputStream out = new FileOutputStream(file)) {
            save(out);
        }
    }",0,save list to file,save list to file<CODESPLIT>public void save(File file) throws IOException {         try (FileOutputStream out = new FileOutputStream(file)) {             save(out);         }     }
"@SuppressWarnings(""unchecked"")
  public static Map<String, String> parseCommandLineArguments(String[] args) {
    return (Map)parseCommandLineArguments(args, false);
  }",1,parse command line argument,"parse command line argument<CODESPLIT>@SuppressWarnings(""unchecked"")   public static Map<String, String> parseCommandLineArguments(String[] args) {     return (Map)parseCommandLineArguments(args, false);   }"
"public static String getHttpStatusCodeText(int sc) {
        HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);
        if (sCode == null) {
            return sc + "" <unknown status code>"";
        } else {
            return sCode.toString();
        }
    }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getHttpStatusCodeText(int sc) {         HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);         if (sCode == null) {             return sc + "" <unknown status code>"";         } else {             return sCode.toString();         }     }"
"@SuppressWarnings(""unchecked"")
  public static <T> T[] filter(T[] array, Filter<T> filter) {

    Assert.notNull(array, ""Array is required"");
    Assert.notNull(filter, ""Filter is required"");

    List<T> arrayList = stream(array).filter(filter::accept).collect(Collectors.toList());

    return arrayList.toArray((T[]) Array.newInstance(array.getClass().getComponentType(), arrayList.size()));
  }",3,filter array,"filter array<CODESPLIT>@SuppressWarnings(""unchecked"")   public static <T> T[] filter(T[] array, Filter<T> filter) {      Assert.notNull(array, ""Array is required"");     Assert.notNull(filter, ""Filter is required"");      List<T> arrayList = stream(array).filter(filter::accept).collect(Collectors.toList());      return arrayList.toArray((T[]) Array.newInstance(array.getClass().getComponentType(), arrayList.size()));   }"
"public static String toPrettyJsonString(Object object) {
        try {
            return jsonMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(object);
        } catch (JsonProcessingException e) {
            return JMExceptionManager.handleExceptionAndReturnNull(log, e,
                    ""toPrettyJsonString"", object);
        }
    }",0,pretty print json,"pretty print json<CODESPLIT>public static String toPrettyJsonString(Object object) {         try {             return jsonMapper.writerWithDefaultPrettyPrinter()                     .writeValueAsString(object);         } catch (JsonProcessingException e) {             return JMExceptionManager.handleExceptionAndReturnNull(log, e,                     ""toPrettyJsonString"", object);         }     }"
"public static String getClipboardText(final Context context) {
        final ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        final ClipData clipData = clipboard.getPrimaryClip();
        if(clipData != null && clipData.getItemCount() > 0) {
            final CharSequence clipboardText = clipData.getItemAt(0).getText();
            if(clipboardText != null) {
                return clipboardText.toString();
            }
        }
        return null;
    }",1,copy to clipboard,copy to clipboard<CODESPLIT>public static String getClipboardText(final Context context) {         final ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);         final ClipData clipData = clipboard.getPrimaryClip();         if(clipData != null && clipData.getItemCount() > 0) {             final CharSequence clipboardText = clipData.getItemAt(0).getText();             if(clipboardText != null) {                 return clipboardText.toString();             }         }         return null;     }
"private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {
    	JSONObject json = null;
        HttpClient postClient = HttpClientBuilder.create().build();
        HttpResponse response;
        
        try {
            response = postClient.execute(httpPost);
            
            if(response.getStatusLine().getStatusCode() == 200) {
                HttpEntity entity = response.getEntity();
                
                if (entity != null) {
                    InputStream instream = entity.getContent();  
                    String result = convertStreamToString(instream);
                    instream.close();
                    
                    json = new JSONObject(result);
                }
            } else {
            	json = UpworkRestClient.genError(response);
            }
        } catch (ClientProtocolException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");
        } catch (IOException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");
        } catch (JSONException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");  
        } catch (Exception e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());
        } finally {
            httpPost.abort();
        }
        
        return json;
    }",2,httpclient post json,"httpclient post json<CODESPLIT>private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {     	JSONObject json = null;         HttpClient postClient = HttpClientBuilder.create().build();         HttpResponse response;                  try {             response = postClient.execute(httpPost);                          if(response.getStatusLine().getStatusCode() == 200) {                 HttpEntity entity = response.getEntity();                                  if (entity != null) {                     InputStream instream = entity.getContent();                       String result = convertStreamToString(instream);                     instream.close();                                          json = new JSONObject(result);                 }             } else {             	json = UpworkRestClient.genError(response);             }         } catch (ClientProtocolException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");         } catch (IOException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");         } catch (JSONException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");           } catch (Exception e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());         } finally {             httpPost.abort();         }                  return json;     }"
"public long getElapsedMinutes() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerMm;
	}",3,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedMinutes() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerMm; 	}
"public String getTableNames(boolean bAddQuotes)
    {
        return (m_tableName == null) ? Record.formatTableNames(CLASS_FIELDS_FILE, bAddQuotes) : super.getTableNames(bAddQuotes);
    }",0,how to get database table name,"how to get database table name<CODESPLIT>public String getTableNames(boolean bAddQuotes)     {         return (m_tableName == null) ? Record.formatTableNames(CLASS_FIELDS_FILE, bAddQuotes) : super.getTableNames(bAddQuotes);     }"
"public CloseableHttpResponse postJson(String url, String json, Map<String, String> reqHeaders) throws IOException {
        CloseableHttpClient req = getClient();
        CloseableHttpResponse resp = null;
        HttpPost post = new HttpPost(url);
        addHeaders(post, reqHeaders);
        post.setHeader(json, url);
        StringEntity input = new StringEntity(json, ContentType.APPLICATION_JSON);
        post.setEntity(input);
        resp = req.execute(post);
        return resp;
    }",1,httpclient post json,"httpclient post json<CODESPLIT>public CloseableHttpResponse postJson(String url, String json, Map<String, String> reqHeaders) throws IOException {         CloseableHttpClient req = getClient();         CloseableHttpResponse resp = null;         HttpPost post = new HttpPost(url);         addHeaders(post, reqHeaders);         post.setHeader(json, url);         StringEntity input = new StringEntity(json, ContentType.APPLICATION_JSON);         post.setEntity(input);         resp = req.execute(post);         return resp;     }"
"@Override
  public EventRequest deserialize(JsonElement json, Type typeOfT,
      JsonDeserializationContext context)
      throws JsonParseException {
    Gson gson = new GsonBuilder()
        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
        .create();

    // API versions 2017-05-25 and earlier render `request` as a string
    // instead of a JSON object
    if (json.isJsonPrimitive()) {
      EventRequest request = new EventRequest();
      request.setId(json.getAsString());
      return request;
    } else {
      return gson.fromJson(json, typeOfT);
    }
  }",2,deserialize json,"deserialize json<CODESPLIT>@Override   public EventRequest deserialize(JsonElement json, Type typeOfT,       JsonDeserializationContext context)       throws JsonParseException {     Gson gson = new GsonBuilder()         .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)         .create();      // API versions 2017-05-25 and earlier render `request` as a string     // instead of a JSON object     if (json.isJsonPrimitive()) {       EventRequest request = new EventRequest();       request.setId(json.getAsString());       return request;     } else {       return gson.fromJson(json, typeOfT);     }   }"
"private List<File> unzipCorpus(File outDir, ZipFile zip)
  {
    List<File> rootDirs = new ArrayList<>();

    Enumeration<? extends ZipEntry> zipEnum = zip.entries();
    while (zipEnum.hasMoreElements())
    {
      ZipEntry e = zipEnum.nextElement();
      File outFile = new File(outDir, e.getName().replaceAll(""\\/"", ""/""));

      if (e.isDirectory())
      {
        if (!outFile.mkdirs())
        {
          log.warn(""Could not create output directory "" + outFile.
            getAbsolutePath());
        }
      } // end if directory
      else
      {
        if (""corpus.tab"".equals(outFile.getName()) || ""corpus.annis"".equals(
          outFile.getName()))
        {
          rootDirs.add(outFile.getParentFile());
        }

        if (!outFile.getParentFile().isDirectory())
        {
          if (!outFile.getParentFile().mkdirs())
          {
            {
              log.warn(
                ""Could not create output directory for file "" + outFile.
                getAbsolutePath());
            }
          }
        }
        try (FileOutputStream outStream = new FileOutputStream(outFile);)
        {

          ByteStreams.copy(zip.getInputStream(e), outStream);
        }
        catch (FileNotFoundException ex)
        {
          log.error(null, ex);
        }
        catch (IOException ex)
        {
          log.error(null, ex);
        }
      } // end else is file
    } // end for each entry in zip file

    return rootDirs;
  }",3,unzipping large files,"unzipping large files<CODESPLIT>private List<File> unzipCorpus(File outDir, ZipFile zip)   {     List<File> rootDirs = new ArrayList<>();      Enumeration<? extends ZipEntry> zipEnum = zip.entries();     while (zipEnum.hasMoreElements())     {       ZipEntry e = zipEnum.nextElement();       File outFile = new File(outDir, e.getName().replaceAll(""\\/"", ""/""));        if (e.isDirectory())       {         if (!outFile.mkdirs())         {           log.warn(""Could not create output directory "" + outFile.             getAbsolutePath());         }       } // end if directory       else       {         if (""corpus.tab"".equals(outFile.getName()) || ""corpus.annis"".equals(           outFile.getName()))         {           rootDirs.add(outFile.getParentFile());         }          if (!outFile.getParentFile().isDirectory())         {           if (!outFile.getParentFile().mkdirs())           {             {               log.warn(                 ""Could not create output directory for file "" + outFile.                 getAbsolutePath());             }           }         }         try (FileOutputStream outStream = new FileOutputStream(outFile);)         {            ByteStreams.copy(zip.getInputStream(e), outStream);         }         catch (FileNotFoundException ex)         {           log.error(null, ex);         }         catch (IOException ex)         {           log.error(null, ex);         }       } // end else is file     } // end for each entry in zip file      return rootDirs;   }"
"public String getTableNames(boolean bAddQuotes)
    {
        if (m_tableName == null)
        {
            String strDatabaseName = """";
            if (this.getDatabaseName() != null)
                if (!this.getDatabaseName().endsWith(""_"" + this.getDatabaseName()))
                    strDatabaseName = ""_"" + this.getDatabaseName();
            return Record.formatTableNames(DATABASE_INFO_FILE, bAddQuotes) + strDatabaseName;
        }
        return super.getTableNames(bAddQuotes);
    }",0,how to get database table name,"how to get database table name<CODESPLIT>public String getTableNames(boolean bAddQuotes)     {         if (m_tableName == null)         {             String strDatabaseName = """";             if (this.getDatabaseName() != null)                 if (!this.getDatabaseName().endsWith(""_"" + this.getDatabaseName()))                     strDatabaseName = ""_"" + this.getDatabaseName();             return Record.formatTableNames(DATABASE_INFO_FILE, bAddQuotes) + strDatabaseName;         }         return super.getTableNames(bAddQuotes);     }"
"public static String getCurrentDate() {
		long now = System.currentTimeMillis();

		if ((now - currentDateGenerated) > 1000) {
			synchronized (format) {
				if ((now - currentDateGenerated) > 1000) {
					currentDateGenerated = now;
					currentDate = format.format(new Date(now));
				}
			}
		}

		return currentDate;
	}",1,how to get current date,how to get current date<CODESPLIT>public static String getCurrentDate() { 		long now = System.currentTimeMillis();  		if ((now - currentDateGenerated) > 1000) { 			synchronized (format) { 				if ((now - currentDateGenerated) > 1000) { 					currentDateGenerated = now; 					currentDate = format.format(new Date(now)); 				} 			} 		}  		return currentDate; 	}
"@Override
    public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {

        // need to use boxed primitives as we can't customise sorting of int primitives
        Integer[] indexes = new Integer[atomContainerCount];
        for (int i = 0; i < indexes.length; i++)
            indexes[i] = i;

        // proxy the index comparison to the atom container comparator
        Arrays.sort(indexes, new Comparator<Integer>() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return comparator.compare(atomContainers[o1], atomContainers[o2]);
            }
        });

        // copy the original arrays (we could modify in place with swaps but this is cleaner)
        IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
        Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);

        // order the arrays based on the order of the indices
        for (int i = 0; i < indexes.length; i++) {
            atomContainers[i] = containersTmp[indexes[i]];
            multipliers[i] = multipliersTmp[indexes[i]];
        }

    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>@Override     public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {          // need to use boxed primitives as we can't customise sorting of int primitives         Integer[] indexes = new Integer[atomContainerCount];         for (int i = 0; i < indexes.length; i++)             indexes[i] = i;          // proxy the index comparison to the atom container comparator         Arrays.sort(indexes, new Comparator<Integer>() {              @Override             public int compare(Integer o1, Integer o2) {                 return comparator.compare(atomContainers[o1], atomContainers[o2]);             }         });          // copy the original arrays (we could modify in place with swaps but this is cleaner)         IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);         Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);          // order the arrays based on the order of the indices         for (int i = 0; i < indexes.length; i++) {             atomContainers[i] = containersTmp[indexes[i]];             multipliers[i] = multipliersTmp[indexes[i]];         }      }"
"public boolean copyTopicsToClipboard(final boolean cut, @Nonnull @MustNotContainNull final Topic... topics) {
    boolean result = false;

    if (this.lockIfNotDisposed()) {
      try {
        if (topics.length > 0) {
          final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
          clipboard.setContents(new MMDTopicsTransferable(topics), this);

          if (cut) {
            deleteTopics(true, ensureNoRootInArray(topics));
          }

          result = true;
        }
      } finally {
        this.unlock();
      }
    }

    return result;
  }",3,copy to clipboard,"copy to clipboard<CODESPLIT>public boolean copyTopicsToClipboard(final boolean cut, @Nonnull @MustNotContainNull final Topic... topics) {     boolean result = false;      if (this.lockIfNotDisposed()) {       try {         if (topics.length > 0) {           final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();           clipboard.setContents(new MMDTopicsTransferable(topics), this);            if (cut) {             deleteTopics(true, ensureNoRootInArray(topics));           }            result = true;         }       } finally {         this.unlock();       }     }      return result;   }"
"public void scalarMultiply(double c)
    {
        int m = rows;
        int n = cols;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                consumer.set(i, j, c * supplier.get(i, j));
            }
        }
    }",0,matrix multiply,"matrix multiply<CODESPLIT>public void scalarMultiply(double c)     {         int m = rows;         int n = cols;         for (int i = 0; i < m; i++)         {             for (int j = 0; j < n; j++)             {                 consumer.set(i, j, c * supplier.get(i, j));             }         }     }"
"public static String[] split(final String src, final String delimiter) {
		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last
		int[] positions = new int[maxparts];
		int dellen = delimiter.length();

		int i, j = 0;
		int count = 0;
		positions[0] = - dellen;
		while ((i = src.indexOf(delimiter, j)) != -1) {
			count++;
			positions[count] = i;
			j = i + dellen;
		}
		count++;
		positions[count] = src.length();

		String[] result = new String[count];

		for (i = 0; i < count; i++) {
			result[i] = src.substring(positions[i] + dellen, positions[i + 1]);
		}
		return result;
	}",1,positions of substrings in string,"positions of substrings in string<CODESPLIT>public static String[] split(final String src, final String delimiter) { 		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last 		int[] positions = new int[maxparts]; 		int dellen = delimiter.length();  		int i, j = 0; 		int count = 0; 		positions[0] = - dellen; 		while ((i = src.indexOf(delimiter, j)) != -1) { 			count++; 			positions[count] = i; 			j = i + dellen; 		} 		count++; 		positions[count] = src.length();  		String[] result = new String[count];  		for (i = 0; i < count; i++) { 			result[i] = src.substring(positions[i] + dellen, positions[i + 1]); 		} 		return result; 	}"
"@SuppressWarnings(""unchecked"")
    public final T[] filter(final T[] objects) {
        final Collection<T> filtered = filter(Arrays.asList(objects));
        try {
            return filtered.toArray((T[]) Array.newInstance(objects
                    .getClass(), filtered.size()));
        } catch (ArrayStoreException ase) {
            Logger log = LoggerFactory.getLogger(Filter.class);
            log.warn(""Error converting to array - using default approach"", ase);
        }
        return (T[]) filtered.toArray();
    }",2,filter array,"filter array<CODESPLIT>@SuppressWarnings(""unchecked"")     public final T[] filter(final T[] objects) {         final Collection<T> filtered = filter(Arrays.asList(objects));         try {             return filtered.toArray((T[]) Array.newInstance(objects                     .getClass(), filtered.size()));         } catch (ArrayStoreException ase) {             Logger log = LoggerFactory.getLogger(Filter.class);             log.warn(""Error converting to array - using default approach"", ase);         }         return (T[]) filtered.toArray();     }"
"public static <T> T[] filter(T array[], Filter<T> filter){
        List<T> filteredList = new ArrayList<T>(array.length);
        for(T element: array){
            if(filter.select(element))
                filteredList.add(element);
        }
        @SuppressWarnings(""unchecked"")
        T filteredArray[] = (T[])Array.newInstance(array.getClass().getComponentType(), filteredList.size());
        return filteredList.toArray(filteredArray);
    }",3,filter array,"filter array<CODESPLIT>public static <T> T[] filter(T array[], Filter<T> filter){         List<T> filteredList = new ArrayList<T>(array.length);         for(T element: array){             if(filter.select(element))                 filteredList.add(element);         }         @SuppressWarnings(""unchecked"")         T filteredArray[] = (T[])Array.newInstance(array.getClass().getComponentType(), filteredList.size());         return filteredList.toArray(filteredArray);     }"
"public static LocalLongitude getInstance(double longitude, double latitude)
    {
        if (Math.abs(longitude) < 179)
        {
            return new LocalLongitude(latitude);
        }
        else
        {
            return new PacificLongitude(latitude);
        }
    }",0,extract latitude and longitude from given input,"extract latitude and longitude from given input<CODESPLIT>public static LocalLongitude getInstance(double longitude, double latitude)     {         if (Math.abs(longitude) < 179)         {             return new LocalLongitude(latitude);         }         else         {             return new PacificLongitude(latitude);         }     }"
"static void readWmoXmlTableB(InputStream ios, TableB b) throws IOException {
    org.jdom2.Document doc;
    try {
      SAXBuilder builder = new SAXBuilder();
      doc = builder.build(ios);
    } catch (JDOMException e) {
      throw new IOException(e.getMessage());
    }

    Element root = doc.getRootElement();

    String[] elems = null;
    for (Version v : Version.values()) {
      elems = v.getElemNamesB();
      List<Element> featList = root.getChildren(elems[0]);
      if (featList != null && featList.size() > 0) {
        break;
      }
    }

    // if not found using element name, assume its BUFR_WMO
    if (elems == null) {
      elems = Version.BUFR_WMO.getElemNamesB();
    }

    List<Element> featList = root.getChildren();
    for (Element elem : featList) {
      Element ce = elem.getChild(elems[1]);
      if (ce == null) continue;

      String name = Util.cleanName(elem.getChildTextNormalize(elems[1]));
      String units = cleanUnit(elem.getChildTextNormalize(""BUFR_Unit""));
      int x = 0, y = 0, scale = 0, reference = 0, width = 0;

      String fxy = null;
      String s = null;
      try {
        fxy = elem.getChildTextNormalize(""FXY"");
        int xy = Integer.parseInt(cleanNumber(fxy));
        x = xy / 1000;
        y = xy % 1000;

      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' fails parsing %n"", fxy, name);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_Scale"");
        scale = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad scale='%s'%n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_ReferenceValue"");
        reference = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad reference='%s' %n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_DataWidth_Bits"");
        width = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad width='%s' %n"", fxy, name, s);
      }

      b.addDescriptor((short) x, (short) y, scale, reference, width, name, units, null);
    }
    ios.close();
  }",1,reading element from html - <td>,"reading element from html - <td><CODESPLIT>static void readWmoXmlTableB(InputStream ios, TableB b) throws IOException {     org.jdom2.Document doc;     try {       SAXBuilder builder = new SAXBuilder();       doc = builder.build(ios);     } catch (JDOMException e) {       throw new IOException(e.getMessage());     }      Element root = doc.getRootElement();      String[] elems = null;     for (Version v : Version.values()) {       elems = v.getElemNamesB();       List<Element> featList = root.getChildren(elems[0]);       if (featList != null && featList.size() > 0) {         break;       }     }      // if not found using element name, assume its BUFR_WMO     if (elems == null) {       elems = Version.BUFR_WMO.getElemNamesB();     }      List<Element> featList = root.getChildren();     for (Element elem : featList) {       Element ce = elem.getChild(elems[1]);       if (ce == null) continue;        String name = Util.cleanName(elem.getChildTextNormalize(elems[1]));       String units = cleanUnit(elem.getChildTextNormalize(""BUFR_Unit""));       int x = 0, y = 0, scale = 0, reference = 0, width = 0;        String fxy = null;       String s = null;       try {         fxy = elem.getChildTextNormalize(""FXY"");         int xy = Integer.parseInt(cleanNumber(fxy));         x = xy / 1000;         y = xy % 1000;        } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' fails parsing %n"", fxy, name);       }        try {         s = elem.getChildTextNormalize(""BUFR_Scale"");         scale = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad scale='%s'%n"", fxy, name, s);       }        try {         s = elem.getChildTextNormalize(""BUFR_ReferenceValue"");         reference = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad reference='%s' %n"", fxy, name, s);       }        try {         s = elem.getChildTextNormalize(""BUFR_DataWidth_Bits"");         width = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad width='%s' %n"", fxy, name, s);       }        b.addDescriptor((short) x, (short) y, scale, reference, width, name, units, null);     }     ios.close();   }"
"public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {
        return seq(random.ints(randomNumberOrigin, randomNumberBound));
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {         return seq(random.ints(randomNumberOrigin, randomNumberBound));     }"
"protected void selectCheckbox(PageElement element, String valueKeyOrKey, Map<String, Boolean> values) throws TechnicalException, FailureException {
        final String valueKey = Context.getValue(valueKeyOrKey) != null ? Context.getValue(valueKeyOrKey) : valueKeyOrKey;
        try {
            final WebElement webElement = Context.waitUntil(ExpectedConditions.elementToBeClickable(Utilities.getLocator(element)));
            Boolean checkboxValue = values.get(valueKey);
            if (checkboxValue == null) {
                checkboxValue = values.get(""Default"");
            }
            if (webElement.isSelected() != checkboxValue.booleanValue()) {
                webElement.click();
            }
        } catch (final Exception e) {
            new Result.Failure<>(e.getMessage(), Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT), element, element.getPage().getApplication()), true,
                    element.getPage().getCallBack());
        }
    }",3,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>protected void selectCheckbox(PageElement element, String valueKeyOrKey, Map<String, Boolean> values) throws TechnicalException, FailureException {         final String valueKey = Context.getValue(valueKeyOrKey) != null ? Context.getValue(valueKeyOrKey) : valueKeyOrKey;         try {             final WebElement webElement = Context.waitUntil(ExpectedConditions.elementToBeClickable(Utilities.getLocator(element)));             Boolean checkboxValue = values.get(valueKey);             if (checkboxValue == null) {                 checkboxValue = values.get(""Default"");             }             if (webElement.isSelected() != checkboxValue.booleanValue()) {                 webElement.click();             }         } catch (final Exception e) {             new Result.Failure<>(e.getMessage(), Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT), element, element.getPage().getApplication()), true,                     element.getPage().getCallBack());         }     }"
"public int getCoverage1(){
		if ( myResultsSimilarity1 < 0 ) {
			int distance = ca1Length + ca2Length - 2 * getNrEQR();

			int similarity = (ca1Length + ca2Length - distance ) / 2;

			myResultsSimilarity1 = Math.round(similarity /(float) ca1Length * 100);
		}
		return myResultsSimilarity1;
	}",0,string similarity levenshtein,string similarity levenshtein<CODESPLIT>public int getCoverage1(){ 		if ( myResultsSimilarity1 < 0 ) { 			int distance = ca1Length + ca2Length - 2 * getNrEQR();  			int similarity = (ca1Length + ca2Length - distance ) / 2;  			myResultsSimilarity1 = Math.round(similarity /(float) ca1Length * 100); 		} 		return myResultsSimilarity1; 	}
"public static void sort(List list, Sort... sorts) {
        Sort.sorts(sorts).sort(list);
    }",1,sort string list,"sort string list<CODESPLIT>public static void sort(List list, Sort... sorts) {         Sort.sorts(sorts).sort(list);     }"
"static
	public double probability(ContinuousDistribution distribution, Number x){

		if(distribution instanceof GaussianDistribution){
			return probability((GaussianDistribution)distribution, x);
		} else

		if(distribution instanceof PoissonDistribution){
			return probability((PoissonDistribution)distribution, x);
		}

		throw new UnsupportedElementException(distribution);
	}",2,normal distribution,"normal distribution<CODESPLIT>static 	public double probability(ContinuousDistribution distribution, Number x){  		if(distribution instanceof GaussianDistribution){ 			return probability((GaussianDistribution)distribution, x); 		} else  		if(distribution instanceof PoissonDistribution){ 			return probability((PoissonDistribution)distribution, x); 		}  		throw new UnsupportedElementException(distribution); 	}"
"public static String format(Date date, String format)
	{
		Parameters.checkNotNull(date);
		return new SimpleDateFormat(format).format(date);
	}",3,format date,"format date<CODESPLIT>public static String format(Date date, String format) 	{ 		Parameters.checkNotNull(date); 		return new SimpleDateFormat(format).format(date); 	}"
"private static String numToString(int num, int width) {
        String str = Integer.toString(num);
        int len = str.length();
        if (len >= width) {
            return str.substring(len - width, len);
        }
        StringBuilder sb = new StringBuilder(width);
        for (int i = len; i < width; i++) {
            sb.append('0');
        }
        sb.append(str);
        return sb.toString();
    }",0,convert string to number,"convert string to number<CODESPLIT>private static String numToString(int num, int width) {         String str = Integer.toString(num);         int len = str.length();         if (len >= width) {             return str.substring(len - width, len);         }         StringBuilder sb = new StringBuilder(width);         for (int i = len; i < width; i++) {             sb.append('0');         }         sb.append(str);         return sb.toString();     }"
"@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                Is24CsvWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<Is24CsvRecord> records = new ArrayList<>();
        records.add(createHausKaufRecord());
        records.add(createHausKaufRecord());
        records.add(createWohnungMieteRecord());
        records.add(createWohnungMieteRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }",1,write csv,"write csv<CODESPLIT>@SuppressWarnings(""Duplicates"")     public static void main(String[] args) {         // init logging         PropertyConfigurator.configure(                 Is24CsvWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));          // create some CSV records         List<Is24CsvRecord> records = new ArrayList<>();         records.add(createHausKaufRecord());         records.add(createHausKaufRecord());         records.add(createWohnungMieteRecord());         records.add(createWohnungMieteRecord());          // write CSV records into a java.io.File         try {             write(records, File.createTempFile(""output-"", "".csv""));         } catch (IOException ex) {             LOGGER.error(""Can't create temporary file!"");             LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);             System.exit(1);         }          // write CSV records into a java.io.OutputStream         write(records, new NullOutputStream());          // write CSV records into a java.io.Writer         write(records, new NullWriter());          // write CSV records into a string and send it to the console         writeToConsole(records);     }"
"public static double similarLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;
    }",2,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarLevenshtein(String s1, String s2) {         if (s1.equals(s2)) {             return 1.0;         }          // Make sure s1 is the longest string         if (s1.length() < s2.length()) {             String swap = s1;             s1 = s2;             s2 = swap;         }          int bigLength = s1.length();         return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;     }"
"public static <A> A[] arrayFilter(A[] arr, Predicate<A> accept) {
		if (arr == null || arr.length == 0)
			return arr;
		A[] accepted = newArray(arr, arr.length);
		int j = 0;
		for (int i = 0; i < arr.length; i++)
			if (accept.test(arr[i]))
				accepted[j++] = arr[i];
		return j == arr.length ? arr : copyOf(accepted, j);
	}",3,filter array,"filter array<CODESPLIT>public static <A> A[] arrayFilter(A[] arr, Predicate<A> accept) { 		if (arr == null || arr.length == 0) 			return arr; 		A[] accepted = newArray(arr, arr.length); 		int j = 0; 		for (int i = 0; i < arr.length; i++) 			if (accept.test(arr[i])) 				accepted[j++] = arr[i]; 		return j == arr.length ? arr : copyOf(accepted, j); 	}"
"private Object readNewArray(boolean unshared) throws OptionalDataException,
            ClassNotFoundException, IOException {
        ObjectStreamClass classDesc = readClassDesc();

        if (classDesc == null) {
            throw missingClassDescriptor();
        }

        int newHandle = nextHandle();

        // Array size
        int size = input.readInt();
        Class<?> arrayClass = classDesc.forClass();
        Class<?> componentType = arrayClass.getComponentType();
        Object result = Array.newInstance(componentType, size);

        registerObjectRead(result, newHandle, unshared);

        // Now we have code duplication just because Java is typed. We have to
        // read N elements and assign to array positions, but we must typecast
        // the array first, and also call different methods depending on the
        // elements.
        if (componentType.isPrimitive()) {
            if (componentType == int.class) {
                int[] intArray = (int[]) result;
                for (int i = 0; i < size; i++) {
                    intArray[i] = input.readInt();
                }
            } else if (componentType == byte.class) {
                byte[] byteArray = (byte[]) result;
                input.readFully(byteArray, 0, size);
            } else if (componentType == char.class) {
                char[] charArray = (char[]) result;
                for (int i = 0; i < size; i++) {
                    charArray[i] = input.readChar();
                }
            } else if (componentType == short.class) {
                short[] shortArray = (short[]) result;
                for (int i = 0; i < size; i++) {
                    shortArray[i] = input.readShort();
                }
            } else if (componentType == boolean.class) {
                boolean[] booleanArray = (boolean[]) result;
                for (int i = 0; i < size; i++) {
                    booleanArray[i] = input.readBoolean();
                }
            } else if (componentType == long.class) {
                long[] longArray = (long[]) result;
                for (int i = 0; i < size; i++) {
                    longArray[i] = input.readLong();
                }
            } else if (componentType == float.class) {
                float[] floatArray = (float[]) result;
                for (int i = 0; i < size; i++) {
                    floatArray[i] = input.readFloat();
                }
            } else if (componentType == double.class) {
                double[] doubleArray = (double[]) result;
                for (int i = 0; i < size; i++) {
                    doubleArray[i] = input.readDouble();
                }
            } else {
                throw new ClassNotFoundException(""Wrong base type in "" + classDesc.getName());
            }
        } else {
            // Array of Objects
            Object[] objectArray = (Object[]) result;
            for (int i = 0; i < size; i++) {
                // TODO: This place is the opportunity for enhancement
                //      We can implement writing elements through fast-path,
                //      without setting up the context (see readObject()) for
                //      each element with public API
                objectArray[i] = readObject();
            }
        }
        if (enableResolve) {
            result = resolveObject(result);
            registerObjectRead(result, newHandle, false);
        }
        return result;
    }",0,readonly array,"readonly array<CODESPLIT>private Object readNewArray(boolean unshared) throws OptionalDataException,             ClassNotFoundException, IOException {         ObjectStreamClass classDesc = readClassDesc();          if (classDesc == null) {             throw missingClassDescriptor();         }          int newHandle = nextHandle();          // Array size         int size = input.readInt();         Class<?> arrayClass = classDesc.forClass();         Class<?> componentType = arrayClass.getComponentType();         Object result = Array.newInstance(componentType, size);          registerObjectRead(result, newHandle, unshared);          // Now we have code duplication just because Java is typed. We have to         // read N elements and assign to array positions, but we must typecast         // the array first, and also call different methods depending on the         // elements.         if (componentType.isPrimitive()) {             if (componentType == int.class) {                 int[] intArray = (int[]) result;                 for (int i = 0; i < size; i++) {                     intArray[i] = input.readInt();                 }             } else if (componentType == byte.class) {                 byte[] byteArray = (byte[]) result;                 input.readFully(byteArray, 0, size);             } else if (componentType == char.class) {                 char[] charArray = (char[]) result;                 for (int i = 0; i < size; i++) {                     charArray[i] = input.readChar();                 }             } else if (componentType == short.class) {                 short[] shortArray = (short[]) result;                 for (int i = 0; i < size; i++) {                     shortArray[i] = input.readShort();                 }             } else if (componentType == boolean.class) {                 boolean[] booleanArray = (boolean[]) result;                 for (int i = 0; i < size; i++) {                     booleanArray[i] = input.readBoolean();                 }             } else if (componentType == long.class) {                 long[] longArray = (long[]) result;                 for (int i = 0; i < size; i++) {                     longArray[i] = input.readLong();                 }             } else if (componentType == float.class) {                 float[] floatArray = (float[]) result;                 for (int i = 0; i < size; i++) {                     floatArray[i] = input.readFloat();                 }             } else if (componentType == double.class) {                 double[] doubleArray = (double[]) result;                 for (int i = 0; i < size; i++) {                     doubleArray[i] = input.readDouble();                 }             } else {                 throw new ClassNotFoundException(""Wrong base type in "" + classDesc.getName());             }         } else {             // Array of Objects             Object[] objectArray = (Object[]) result;             for (int i = 0; i < size; i++) {                 // TODO: This place is the opportunity for enhancement                 //      We can implement writing elements through fast-path,                 //      without setting up the context (see readObject()) for                 //      each element with public API                 objectArray[i] = readObject();             }         }         if (enableResolve) {             result = resolveObject(result);             registerObjectRead(result, newHandle, false);         }         return result;     }"
"@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                IdxWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<IdxRecord> records = new ArrayList<>();
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }",1,write csv,"write csv<CODESPLIT>@SuppressWarnings(""Duplicates"")     public static void main(String[] args) {         // init logging         PropertyConfigurator.configure(                 IdxWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));          // create some CSV records         List<IdxRecord> records = new ArrayList<>();         records.add(createRecord());         records.add(createRecord());         records.add(createRecord());         records.add(createRecord());          // write CSV records into a java.io.File         try {             write(records, File.createTempFile(""output-"", "".csv""));         } catch (IOException ex) {             LOGGER.error(""Can't create temporary file!"");             LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);             System.exit(1);         }          // write CSV records into a java.io.OutputStream         write(records, new NullOutputStream());          // write CSV records into a java.io.Writer         write(records, new NullWriter());          // write CSV records into a string and send it to the console         writeToConsole(records);     }"
"public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {
        if (!this.timeCharts.containsKey(scatterID)) {
            ScatterPlotGenerator scatter = new ScatterPlotGenerator();
            scatter.setTitle(scatterID);
            scatter.setXAxisLabel(xAxisLabel);
            scatter.setYAxisLabel(yAxisLabel);
            this.scatterPlots.put(scatterID, scatter);
        } else {
            throw new DuplicatedChartIDException(scatterID);
        }
    }",2,scatter plot,"scatter plot<CODESPLIT>public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {         if (!this.timeCharts.containsKey(scatterID)) {             ScatterPlotGenerator scatter = new ScatterPlotGenerator();             scatter.setTitle(scatterID);             scatter.setXAxisLabel(xAxisLabel);             scatter.setYAxisLabel(yAxisLabel);             this.scatterPlots.put(scatterID, scatter);         } else {             throw new DuplicatedChartIDException(scatterID);         }     }"
"private void init(final int var) {
        // creates and/or resizes the initializations array if necessary
        if (initializations == null) {
            initializations = new int[2];
        }
        int n = initializations.length;
        if (initializationCount >= n) {
            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
            System.arraycopy(initializations, 0, t, 0, n);
            initializations = t;
        }
        // stores the type to be initialized
        initializations[initializationCount++] = var;
    }",3,initializing array,"initializing array<CODESPLIT>private void init(final int var) {         // creates and/or resizes the initializations array if necessary         if (initializations == null) {             initializations = new int[2];         }         int n = initializations.length;         if (initializationCount >= n) {             int[] t = new int[Math.max(initializationCount + 1, 2 * n)];             System.arraycopy(initializations, 0, t, 0, n);             initializations = t;         }         // stores the type to be initialized         initializations[initializationCount++] = var;     }"
"public void setExternalArrayData(ExternalArrayData array)
    {
        externalData = array;

        if (array == null) {
            delete(""length"");
        } else {
            // Define ""length"" to return whatever length the List gives us.
            defineProperty(""length"", null,
                           GET_ARRAY_LENGTH, null, READONLY | DONTENUM);
        }
    }",0,readonly array,"readonly array<CODESPLIT>public void setExternalArrayData(ExternalArrayData array)     {         externalData = array;          if (array == null) {             delete(""length"");         } else {             // Define ""length"" to return whatever length the List gives us.             defineProperty(""length"", null,                            GET_ARRAY_LENGTH, null, READONLY | DONTENUM);         }     }"
"public Matrix multiply (final float k)
  {
    final float pv[][] = new float [m_nRows] [m_nCols]; // product values

    // Compute values of the product.
    for (int r = 0; r < m_nRows; ++r)
    {
      for (int c = 0; c < m_nCols; ++c)
      {
        pv[r][c] = k * m_aValues[r][c];
      }
    }

    return new Matrix (pv);
  }",1,matrix multiply,matrix multiply<CODESPLIT>public Matrix multiply (final float k)   {     final float pv[][] = new float [m_nRows] [m_nCols]; // product values      // Compute values of the product.     for (int r = 0; r < m_nRows; ++r)     {       for (int c = 0; c < m_nCols; ++c)       {         pv[r][c] = k * m_aValues[r][c];       }     }      return new Matrix (pv);   }
"public static Properties readPropertiesFromFile(String _fileName, Properties _props) {
        Properties props = _props == null ? new Properties() : _props;

        LOGGER.debug(""Trying to read properties from file: "" + _fileName);
        Properties newProperties = readProperties(new File(_fileName));
        if (newProperties != null) {
            LOGGER.debug(""Successfully read properties from file: "" + _fileName);
            props.putAll(newProperties);
        }

        return props;
    }",2,read properties file,"read properties file<CODESPLIT>public static Properties readPropertiesFromFile(String _fileName, Properties _props) {         Properties props = _props == null ? new Properties() : _props;          LOGGER.debug(""Trying to read properties from file: "" + _fileName);         Properties newProperties = readProperties(new File(_fileName));         if (newProperties != null) {             LOGGER.debug(""Successfully read properties from file: "" + _fileName);             props.putAll(newProperties);         }          return props;     }"
"public int randomChooseFromDistribution(double... probs) {
		int result = -1;
		int[] range = new int[probs.length];
		double accuracy = 1000;
		int total = 0;

		for (int i = 0; i < probs.length; i++) {
			range[i] = (int) (probs[i] * accuracy);
			total += range[i];
		}

		int randNum = (int) (rng.nextDouble() * total);
		for (int i = 0; i < range.length; i++) {
			randNum -= range[i];
			if (randNum <= 0) {
				result = i;
				break;
			}
		}
		return result;
	}",3,how to randomly pick a number,how to randomly pick a number<CODESPLIT>public int randomChooseFromDistribution(double... probs) { 		int result = -1; 		int[] range = new int[probs.length]; 		double accuracy = 1000; 		int total = 0;  		for (int i = 0; i < probs.length; i++) { 			range[i] = (int) (probs[i] * accuracy); 			total += range[i]; 		}  		int randNum = (int) (rng.nextDouble() * total); 		for (int i = 0; i < range.length; i++) { 			randNum -= range[i]; 			if (randNum <= 0) { 				result = i; 				break; 			} 		} 		return result; 	}
"public static File convertPdf2Tiff(File inputPdfFile) throws IOException {
        if (PDFBOX.equals(System.getProperty(PDF_LIBRARY))) {
            return PdfBoxUtilities.convertPdf2Tiff(inputPdfFile);
        } else {
            try {
                return PdfGsUtilities.convertPdf2Tiff(inputPdfFile);
            } catch (Exception e) {
                System.setProperty(PDF_LIBRARY, PDFBOX);
                return convertPdf2Tiff(inputPdfFile);
            }
        }
    }",0,convert html to pdf,"convert html to pdf<CODESPLIT>public static File convertPdf2Tiff(File inputPdfFile) throws IOException {         if (PDFBOX.equals(System.getProperty(PDF_LIBRARY))) {             return PdfBoxUtilities.convertPdf2Tiff(inputPdfFile);         } else {             try {                 return PdfGsUtilities.convertPdf2Tiff(inputPdfFile);             } catch (Exception e) {                 System.setProperty(PDF_LIBRARY, PDFBOX);                 return convertPdf2Tiff(inputPdfFile);             }         }     }"
"private synchronized void readProperties() {
    try {
      propertyFileURI = CatalogManager.class.getResource(""/""+propertyFile);
      InputStream in =
	CatalogManager.class.getResourceAsStream(""/""+propertyFile);
      if (in==null) {
	if (!ignoreMissingProperties) {
	  System.err.println(""Cannot find ""+propertyFile);
	  // there's no reason to give this warning more than once
	  ignoreMissingProperties = true;
	}
	return;
      }
      resources = new PropertyResourceBundle(in);
    } catch (MissingResourceException mre) {
      if (!ignoreMissingProperties) {
	System.err.println(""Cannot read ""+propertyFile);
      }
    } catch (java.io.IOException e) {
      if (!ignoreMissingProperties) {
	System.err.println(""Failure trying to read ""+propertyFile);
      }
    }

    // This is a bit of a hack. After we've successfully read the properties,
    // use them to set the default debug level, if the user hasn't already set
    // the default debug level.
    if (verbosity == null) {
      try {
	String verbStr = resources.getString(""verbosity"");
	int verb = Integer.parseInt(verbStr.trim());
	debug.setDebug(verb);
	verbosity = new Integer(verb);
      } catch (Exception e) {
	// nop
      }
    }
  }",1,read properties file,"read properties file<CODESPLIT>private synchronized void readProperties() {     try {       propertyFileURI = CatalogManager.class.getResource(""/""+propertyFile);       InputStream in = 	CatalogManager.class.getResourceAsStream(""/""+propertyFile);       if (in==null) { 	if (!ignoreMissingProperties) { 	  System.err.println(""Cannot find ""+propertyFile); 	  // there's no reason to give this warning more than once 	  ignoreMissingProperties = true; 	} 	return;       }       resources = new PropertyResourceBundle(in);     } catch (MissingResourceException mre) {       if (!ignoreMissingProperties) { 	System.err.println(""Cannot read ""+propertyFile);       }     } catch (java.io.IOException e) {       if (!ignoreMissingProperties) { 	System.err.println(""Failure trying to read ""+propertyFile);       }     }      // This is a bit of a hack. After we've successfully read the properties,     // use them to set the default debug level, if the user hasn't already set     // the default debug level.     if (verbosity == null) {       try { 	String verbStr = resources.getString(""verbosity""); 	int verb = Integer.parseInt(verbStr.trim()); 	debug.setDebug(verb); 	verbosity = new Integer(verb);       } catch (Exception e) { 	// nop       }     }   }"
"private void readPropertyFile()
	{
		java.util.Properties props = new java.util.Properties();
	    try
	    {
	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME);
	        if (propertyFile.exists())
	        {
	        	java.io.FileInputStream fis = null;
	        	try
	        	{
			    	fis = new java.io.FileInputStream(propertyFile);
			        props.load(fis);
	        	}
	        	finally
	        	{
	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); }
	        	}
	        }

	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR);
			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR);
			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName());
			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE""));
			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0""));
			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0""));
			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES);
			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++)
			{
				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null);
				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null);
			}
			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE"")));
			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1""));
			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410""));
			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1""));
			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230""));
			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false""));
			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1""));
			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630""));
			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false""));
			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1""));
			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400""));
			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false""));
			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1""));
			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470""));
			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false""));
			
			if (currentEqualizer!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE""));
				currentEqualizer.setIsActive(isActive);
				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0""));
				currentEqualizer.setPreAmp(preAmpValueDB);
				for (int i=0; i<currentEqualizer.getBandCount(); i++)
				{
					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0""));
					currentEqualizer.setBand(i, bandValueDB);
				}
			}
			if (currentPitchShift!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE""));
				currentPitchShift.setIsActive(isActive);
				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0""));
				currentPitchShift.setPitchScale(pitchValue);
				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0""));
				currentPitchShift.setSampleScale(scaleValue);
				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32""));
				currentPitchShift.setFFTOversampling(overSampling);
				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192""));
				currentPitchShift.setFFTFrameSize(frameSize);
			}

			MultimediaContainerManager.configureContainer(props);
	    }
	    catch (Throwable ex)
	    {
			Log.error(""[MainForm]"", ex);
	    }
	}",2,read properties file,"read properties file<CODESPLIT>private void readPropertyFile() 	{ 		java.util.Properties props = new java.util.Properties(); 	    try 	    { 	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME); 	        if (propertyFile.exists()) 	        { 	        	java.io.FileInputStream fis = null; 	        	try 	        	{ 			    	fis = new java.io.FileInputStream(propertyFile); 			        props.load(fis); 	        	} 	        	finally 	        	{ 	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); } 	        	} 	        }  	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR); 			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR); 			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName()); 			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE"")); 			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0"")); 			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0"")); 			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES); 			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++) 			{ 				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null); 				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null); 			} 			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE""))); 			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1"")); 			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410"")); 			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1"")); 			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230"")); 			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false"")); 			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1"")); 			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630"")); 			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false"")); 			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1"")); 			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400"")); 			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false"")); 			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1"")); 			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470"")); 			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false"")); 			 			if (currentEqualizer!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE"")); 				currentEqualizer.setIsActive(isActive); 				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0"")); 				currentEqualizer.setPreAmp(preAmpValueDB); 				for (int i=0; i<currentEqualizer.getBandCount(); i++) 				{ 					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0"")); 					currentEqualizer.setBand(i, bandValueDB); 				} 			} 			if (currentPitchShift!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE"")); 				currentPitchShift.setIsActive(isActive); 				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0"")); 				currentPitchShift.setPitchScale(pitchValue); 				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0"")); 				currentPitchShift.setSampleScale(scaleValue); 				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32"")); 				currentPitchShift.setFFTOversampling(overSampling); 				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192"")); 				currentPitchShift.setFFTFrameSize(frameSize); 			}  			MultimediaContainerManager.configureContainer(props); 	    } 	    catch (Throwable ex) 	    { 			Log.error(""[MainForm]"", ex); 	    } 	}"
"public static HtmlPage toHtmlPage(String string) {
        try {
            URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");
            return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from String."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(String string) {         try {             URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");             return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from String."", e);         }     }"
"public static JsonObject csvToJsonObject(List<String> bulkRecordHeader, List<String> record, int columnCount) {
    ObjectMapper mapper = new ObjectMapper();
    Map<String, String> resultInfo = new HashMap<>();
    for (int i = 0; i < columnCount; i++) {
      resultInfo.put(bulkRecordHeader.get(i), record.get(i));
    }

    JsonNode json = mapper.valueToTree(resultInfo);
    JsonElement element = GSON.fromJson(json.toString(), JsonObject.class);
    return element.getAsJsonObject();
  }",0,convert json to csv,"convert json to csv<CODESPLIT>public static JsonObject csvToJsonObject(List<String> bulkRecordHeader, List<String> record, int columnCount) {     ObjectMapper mapper = new ObjectMapper();     Map<String, String> resultInfo = new HashMap<>();     for (int i = 0; i < columnCount; i++) {       resultInfo.put(bulkRecordHeader.get(i), record.get(i));     }      JsonNode json = mapper.valueToTree(resultInfo);     JsonElement element = GSON.fromJson(json.toString(), JsonObject.class);     return element.getAsJsonObject();   }"
"public static boolean convertToBoolean(Object o)
  {
    if(o == null)
      return false;

    if(o instanceof Boolean)
    {
      return (Boolean) o;
    }

    return convertToBoolean(o.toString());
  }",1,convert int to bool,convert int to bool<CODESPLIT>public static boolean convertToBoolean(Object o)   {     if(o == null)       return false;      if(o instanceof Boolean)     {       return (Boolean) o;     }      return convertToBoolean(o.toString());   }
"public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{

        // write each byte buffer to the serial port
        for(ByteBuffer single : data) {

            // read the byte buffer from the current position up to the limit
            byte[] payload = new byte[single.remaining()];
            single.get(payload);

            // write the data contents to the serial port via JNI native method
            write(fd, payload, payload.length);
        }
    }",2,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{          // write each byte buffer to the serial port         for(ByteBuffer single : data) {              // read the byte buffer from the current position up to the limit             byte[] payload = new byte[single.remaining()];             single.get(payload);              // write the data contents to the serial port via JNI native method             write(fd, payload, payload.length);         }     }"
"public static HtmlPage toHtmlPage(WebDriver webDriver) {
        try {
            return HTMLParser.parseHtml(
                    new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),
                    new WebClient().getCurrentWindow()
            );
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(WebDriver webDriver) {         try {             return HTMLParser.parseHtml(                     new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),                     new WebClient().getCurrentWindow()             );         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);         }     }"
"private String getHtmlForPDFConversion() throws IOException {
        StringBuilder oldContent = new StringBuilder();

        FileReader fr = new FileReader(file);
        try (BufferedReader reader = new BufferedReader(fr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                oldContent.append(line);
                oldContent.append(""\r\n"");
            }
        }

        // replace all non convertible elements with empty text or modify for conversion
        String str = oldContent.toString()
                .replaceAll(""<script type='text/javascript'>(?s).*</script>"", """")
                .replaceAll(""<tr>\\s*<th>View Results</th>(?s).*?</tr>"", """")
                .replaceAll(""&nbsp;"", "" "");

        String imagePattern = ""(<img(?s).*? src='(.*?)'(?s).*?)</img>"";
        Pattern r = Pattern.compile(imagePattern);
        Matcher m = r.matcher(str);
        int imageCount = 0;
        while (m.find()) {
            str = str.replaceFirst(""<a href='javascript:void\\(0\\)'(?s).*?(<img(?s).*? src='(.*?)'(?s).*?)"" +
                            "" style(?s).*?</img>"",
                    ""<a href=\""#image-"" + imageCount + ""\"">View Screenshot</a>"");
            str = str.replaceFirst(""</body>"", ""<p style='page-break-before: always' id='image-"" + imageCount++ + ""'></p"" +
                    "">"" +
                    m.group().replaceAll(""width='300px' style(?s).*?'>"", ""height='600px' width='1000px'>"") + ""</body>"");
        }
        return str;
    }",0,reading element from html - <td>,"reading element from html - <td><CODESPLIT>private String getHtmlForPDFConversion() throws IOException {         StringBuilder oldContent = new StringBuilder();          FileReader fr = new FileReader(file);         try (BufferedReader reader = new BufferedReader(fr)) {             String line;             while ((line = reader.readLine()) != null) {                 oldContent.append(line);                 oldContent.append(""\r\n"");             }         }          // replace all non convertible elements with empty text or modify for conversion         String str = oldContent.toString()                 .replaceAll(""<script type='text/javascript'>(?s).*</script>"", """")                 .replaceAll(""<tr>\\s*<th>View Results</th>(?s).*?</tr>"", """")                 .replaceAll(""&nbsp;"", "" "");          String imagePattern = ""(<img(?s).*? src='(.*?)'(?s).*?)</img>"";         Pattern r = Pattern.compile(imagePattern);         Matcher m = r.matcher(str);         int imageCount = 0;         while (m.find()) {             str = str.replaceFirst(""<a href='javascript:void\\(0\\)'(?s).*?(<img(?s).*? src='(.*?)'(?s).*?)"" +                             "" style(?s).*?</img>"",                     ""<a href=\""#image-"" + imageCount + ""\"">View Screenshot</a>"");             str = str.replaceFirst(""</body>"", ""<p style='page-break-before: always' id='image-"" + imageCount++ + ""'></p"" +                     "">"" +                     m.group().replaceAll(""width='300px' style(?s).*?'>"", ""height='600px' width='1000px'>"") + ""</body>"");         }         return str;     }"
"@SuppressWarnings({""MethodWithMultipleReturnPoints"", ""LabeledStatement"", ""ValueOfIncrementOrDecrementUsed"", ""ContinueStatement"", ""ContinueStatementWithLabel""})
    public static int indexOf(char[] src, char[] find, int startAt) {
        int startPos = startAt;
        final int max = src.length - find.length;
        if (startPos > max) {
            return -1;
        }
        final char find0 = find[0];
        final int len = find.length;
        int j;
        int k;

        // Find the first character
        startOver:
        while (startPos <= max) {
            if (src[startPos++] == find0) {
                // First character found - look for the rest
                j = startPos;
                k = 1;
                while (k < len) {
                    if (src[j++] != find[k++]) {
                        continue startOver;
                    }
                }
                return startPos - 1;
            }
        }
        return -1;
    }",1,find int in string,"find int in string<CODESPLIT>@SuppressWarnings({""MethodWithMultipleReturnPoints"", ""LabeledStatement"", ""ValueOfIncrementOrDecrementUsed"", ""ContinueStatement"", ""ContinueStatementWithLabel""})     public static int indexOf(char[] src, char[] find, int startAt) {         int startPos = startAt;         final int max = src.length - find.length;         if (startPos > max) {             return -1;         }         final char find0 = find[0];         final int len = find.length;         int j;         int k;          // Find the first character         startOver:         while (startPos <= max) {             if (src[startPos++] == find0) {                 // First character found - look for the rest                 j = startPos;                 k = 1;                 while (k < len) {                     if (src[j++] != find[k++]) {                         continue startOver;                     }                 }                 return startPos - 1;             }         }         return -1;     }"
"public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) {
		
		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();
        for (int i = 0; i < clustering.size(); i++) {
            if (clustering.get(i) instanceof CFCluster) {
                microclusters.add((CFCluster)clustering.get(i));
            } else {
                System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");
            }
        }
        
        int n = microclusters.size();
		assert (k <= n);
		
		/* k-means */
		Random random = new Random(0);
		Cluster[] centers = new Cluster[k];
		int K = gtClustering.size();
		
		for (int i = 0; i < k; i++) {
			if (i < K) {	// GT-aided
				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0);
			} else {		// Randomized
				int rid = random.nextInt(n);
				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0);
			}
		}
		
		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters);
	}",2,k means clustering,"k means clustering<CODESPLIT>public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) { 		 		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();         for (int i = 0; i < clustering.size(); i++) {             if (clustering.get(i) instanceof CFCluster) {                 microclusters.add((CFCluster)clustering.get(i));             } else {                 System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");             }         }                  int n = microclusters.size(); 		assert (k <= n); 		 		/* k-means */ 		Random random = new Random(0); 		Cluster[] centers = new Cluster[k]; 		int K = gtClustering.size(); 		 		for (int i = 0; i < k; i++) { 			if (i < K) {	// GT-aided 				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0); 			} else {		// Randomized 				int rid = random.nextInt(n); 				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0); 			} 		} 		 		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters); 	}"
"public static String reverse(String string) {
		if(string != null) {
			return new StringBuilder(string).reverse().toString();
		}
		return null;
	}",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(String string) { 		if(string != null) { 			return new StringBuilder(string).reverse().toString(); 		} 		return null; 	}
"public Integer convertToInt(String value) {
        Integer result = null;
        if (value != null) {
            result = Integer.valueOf(value);
        }
        return result;
    }",0,convert int to string,convert int to string<CODESPLIT>public Integer convertToInt(String value) {         Integer result = null;         if (value != null) {             result = Integer.valueOf(value);         }         return result;     }
"protected String readFile(File file, List<String> lines) {
    int		i;

    try {
      lines.addAll(Files.readAllLines(file.toPath()));
      i = 0;
      while (i < lines.size()) {
        if (lines.get(i).trim().isEmpty()) {
          lines.remove(i);
          continue;
	}
	if (lines.get(i).startsWith(""#"")) {
          lines.remove(i);
          continue;
	}
	i++;
      }
    }
    catch (Exception e) {
      return ""Failed to read file: "" + file + ""\n"" + e;
    }

    return null;
  }",1,concatenate several file remove header lines,"concatenate several file remove header lines<CODESPLIT>protected String readFile(File file, List<String> lines) {     int		i;      try {       lines.addAll(Files.readAllLines(file.toPath()));       i = 0;       while (i < lines.size()) {         if (lines.get(i).trim().isEmpty()) {           lines.remove(i);           continue; 	} 	if (lines.get(i).startsWith(""#"")) {           lines.remove(i);           continue; 	} 	i++;       }     }     catch (Exception e) {       return ""Failed to read file: "" + file + ""\n"" + e;     }      return null;   }"
"protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) {
		assert (centers.length == k);
		assert (k > 0);

		int dimensions = centers[0].getCenter().length;

		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>();
		for (int i = 0; i < k; i++) {
			clustering.add(new ArrayList<Cluster>());
		}

		while (true) {
			// Assign points to clusters
			for (Cluster point : data) {
				double minDistance = distance(point.getCenter(), centers[0].getCenter());
				int closestCluster = 0;
				for (int i = 1; i < k; i++) {
					double distance = distance(point.getCenter(), centers[i].getCenter());
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				clustering.get(closestCluster).add(point);
			}

			// Calculate new centers and clear clustering lists
			SphereCluster[] newCenters = new SphereCluster[centers.length];
			for (int i = 0; i < k; i++) {
				newCenters[i] = calculateCenter(clustering.get(i), dimensions);
				clustering.get(i).clear();
			}
			
			// Convergence check
			boolean converged = true;
			for (int i = 0; i < k; i++) {
				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) {
					converged = false;
					break;
				}
			}
			
			if (converged) {
				break;
			} else {
				centers = newCenters;
			}
		}

		return new Clustering(centers);
	}",2,k means clustering,"k means clustering<CODESPLIT>protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) { 		assert (centers.length == k); 		assert (k > 0);  		int dimensions = centers[0].getCenter().length;  		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>(); 		for (int i = 0; i < k; i++) { 			clustering.add(new ArrayList<Cluster>()); 		}  		while (true) { 			// Assign points to clusters 			for (Cluster point : data) { 				double minDistance = distance(point.getCenter(), centers[0].getCenter()); 				int closestCluster = 0; 				for (int i = 1; i < k; i++) { 					double distance = distance(point.getCenter(), centers[i].getCenter()); 					if (distance < minDistance) { 						closestCluster = i; 						minDistance = distance; 					} 				}  				clustering.get(closestCluster).add(point); 			}  			// Calculate new centers and clear clustering lists 			SphereCluster[] newCenters = new SphereCluster[centers.length]; 			for (int i = 0; i < k; i++) { 				newCenters[i] = calculateCenter(clustering.get(i), dimensions); 				clustering.get(i).clear(); 			} 			 			// Convergence check 			boolean converged = true; 			for (int i = 0; i < k; i++) { 				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) { 					converged = false; 					break; 				} 			} 			 			if (converged) { 				break; 			} else { 				centers = newCenters; 			} 		}  		return new Clustering(centers); 	}"
"@NonNull
    public static String getNowDateTime(@NonNull String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        Date curDate = new Date(System.currentTimeMillis());
        return formatter.format(curDate);
    }",3,how to get current date,"how to get current date<CODESPLIT>@NonNull     public static String getNowDateTime(@NonNull String format) {         SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);         Date curDate = new Date(System.currentTimeMillis());         return formatter.format(curDate);     }"
"private static double scoreToPvalue(double score, int n, double p) {
        /*
        if(n<=20) {
            //calculate it from binomial distribution
        }
        */

        double z=(score+0.5-n*p)/Math.sqrt(n*p*(1.0-p));

        return ContinuousDistributions.gaussCdf(z);
    }",0,binomial distribution,"binomial distribution<CODESPLIT>private static double scoreToPvalue(double score, int n, double p) {         /*         if(n<=20) {             //calculate it from binomial distribution         }         */          double z=(score+0.5-n*p)/Math.sqrt(n*p*(1.0-p));          return ContinuousDistributions.gaussCdf(z);     }"
"private byte[] recv(Socket socket, int flags)
    {
        Utils.checkArgument(socket != null, ""socket parameter must not be null"");
        data = socket.recv(flags);
        more = socket.hasReceiveMore();
        return data;
    }",1,socket recv timeout,"socket recv timeout<CODESPLIT>private byte[] recv(Socket socket, int flags)     {         Utils.checkArgument(socket != null, ""socket parameter must not be null"");         data = socket.recv(flags);         more = socket.hasReceiveMore();         return data;     }"
"public static HttpRequest head(final CharSequence baseUrl,
      final Map<?, ?> params, final boolean encode) {
    String url = append(baseUrl, params);
    return head(encode ? encode(url) : url);
  }",2,encode url,"encode url<CODESPLIT>public static HttpRequest head(final CharSequence baseUrl,       final Map<?, ?> params, final boolean encode) {     String url = append(baseUrl, params);     return head(encode ? encode(url) : url);   }"
"private ByteBuffer recv(int attempt)
          throws IOException, SocketException, SocketTimeoutException {
    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);
    logger.trace(""Setting receive timeout to {}s for attempt {}..."",
            timeout, attempt);
    this.socket.setSoTimeout(timeout * 1000);

    try {
      DatagramPacket p = new DatagramPacket(
              new byte[UDP_PACKET_LENGTH],
              UDP_PACKET_LENGTH);
      this.socket.receive(p);
      return ByteBuffer.wrap(p.getData(), 0, p.getLength());
    } catch (SocketTimeoutException ste) {
      throw ste;
    }
  }",3,socket recv timeout,"socket recv timeout<CODESPLIT>private ByteBuffer recv(int attempt)           throws IOException, SocketException, SocketTimeoutException {     int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);     logger.trace(""Setting receive timeout to {}s for attempt {}..."",             timeout, attempt);     this.socket.setSoTimeout(timeout * 1000);      try {       DatagramPacket p = new DatagramPacket(               new byte[UDP_PACKET_LENGTH],               UDP_PACKET_LENGTH);       this.socket.receive(p);       return ByteBuffer.wrap(p.getData(), 0, p.getLength());     } catch (SocketTimeoutException ste) {       throw ste;     }   }"
"private static int wordsWithThreeSyllables(String strText) {
        int intLongWordCount = 0;
        
        List<String> arrWords = (new WhitespaceTokenizer()).tokenize(strText);
        int intWordCount = arrWords.size();
        for (int i = 0; i < intWordCount; ++i) {
            if(syllableCount(arrWords.get(i)) > 2) {
                ++intLongWordCount; //it also counts the proper nouns which should be excluded for Fog index, but this is not a major issue
            }
        }
        
        return intLongWordCount;
    }",0,how to determine a string is a valid word,"how to determine a string is a valid word<CODESPLIT>private static int wordsWithThreeSyllables(String strText) {         int intLongWordCount = 0;                  List<String> arrWords = (new WhitespaceTokenizer()).tokenize(strText);         int intWordCount = arrWords.size();         for (int i = 0; i < intWordCount; ++i) {             if(syllableCount(arrWords.get(i)) > 2) {                 ++intLongWordCount; //it also counts the proper nouns which should be excluded for Fog index, but this is not a major issue             }         }                  return intLongWordCount;     }"
"public static <T> T median(List<? extends T> data, Comparator<? super T> comparator) {
    return median(data, comparator, 0, data.size());
  }",1,deducting the median from each column,"deducting the median from each column<CODESPLIT>public static <T> T median(List<? extends T> data, Comparator<? super T> comparator) {     return median(data, comparator, 0, data.size());   }"
"public static Date getCurrentDateTime() throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }",2,how to get current date,how to get current date<CODESPLIT>public static Date getCurrentDateTime() throws ParseException {         Calendar currentDate = Calendar.getInstance();         SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);         String dateNow = formatter.format(currentDate.getTime());         return getDateFromString(dateNow);     }
"public static String reverse(final String str) {
        if (str == null) {
            return null;
        }
        return new StringBuilder(str).reverse().toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(final String str) {         if (str == null) {             return null;         }         return new StringBuilder(str).reverse().toString();     }
"public Priority setPriority(Integer priority) {
		Priority prop = (priority == null) ? null : new Priority(priority);
		setPriority(prop);
		return prop;
	}",0,priority queue,priority queue<CODESPLIT>public Priority setPriority(Integer priority) { 		Priority prop = (priority == null) ? null : new Priority(priority); 		setPriority(prop); 		return prop; 	}
"public static <V extends NumberVector> double logLikelihoodZhao(Relation<V> relation, Clustering<? extends MeanModel> clustering, NumberVectorDistanceFunction<? super V> distanceFunction) {
    List<? extends Cluster<? extends MeanModel>> clusters = clustering.getAllClusters();
    // number of clusters
    final int m = clusters.size();

    // number of objects in the clustering
    int n = 0;
    // cluster sizes
    int[] n_i = new int[m];
    // variances
    double[] d_i = new double[m];

    // Iterate over clusters:
    Iterator<? extends Cluster<? extends MeanModel>> it = clusters.iterator();
    for(int i = 0; it.hasNext(); ++i) {
      Cluster<? extends MeanModel> cluster = it.next();
      n += n_i[i] = cluster.size();
      // Note: the paper used 1/(n-m) but that is probably a typo
      // as it will cause divisions by zero.
      d_i[i] = varianceOfCluster(cluster, distanceFunction, relation) / (double) n_i[i];
    }

    final int dim = RelationUtil.dimensionality(relation);

    // log likelihood of this clustering
    double logLikelihood = 0.;
    // Aggregate
    for(int i = 0; i < m; i++) {
      logLikelihood += n_i[i] * FastMath.log(n_i[i] / (double) n) // ni log ni/n
          - n_i[i] * dim * .5 * MathUtil.LOGTWOPI // ni*d/2 log2pi
          - n_i[i] * .5 * FastMath.log(d_i[i]) // ni/2 log sigma_i
          - (n_i[i] - m) * .5; // (ni-m)/2
    }
    return logLikelihood;
  }",1,k means clustering,"k means clustering<CODESPLIT>public static <V extends NumberVector> double logLikelihoodZhao(Relation<V> relation, Clustering<? extends MeanModel> clustering, NumberVectorDistanceFunction<? super V> distanceFunction) {     List<? extends Cluster<? extends MeanModel>> clusters = clustering.getAllClusters();     // number of clusters     final int m = clusters.size();      // number of objects in the clustering     int n = 0;     // cluster sizes     int[] n_i = new int[m];     // variances     double[] d_i = new double[m];      // Iterate over clusters:     Iterator<? extends Cluster<? extends MeanModel>> it = clusters.iterator();     for(int i = 0; it.hasNext(); ++i) {       Cluster<? extends MeanModel> cluster = it.next();       n += n_i[i] = cluster.size();       // Note: the paper used 1/(n-m) but that is probably a typo       // as it will cause divisions by zero.       d_i[i] = varianceOfCluster(cluster, distanceFunction, relation) / (double) n_i[i];     }      final int dim = RelationUtil.dimensionality(relation);      // log likelihood of this clustering     double logLikelihood = 0.;     // Aggregate     for(int i = 0; i < m; i++) {       logLikelihood += n_i[i] * FastMath.log(n_i[i] / (double) n) // ni log ni/n           - n_i[i] * dim * .5 * MathUtil.LOGTWOPI // ni*d/2 log2pi           - n_i[i] * .5 * FastMath.log(d_i[i]) // ni/2 log sigma_i           - (n_i[i] - m) * .5; // (ni-m)/2     }     return logLikelihood;   }"
"public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException {
		try {
			logger.debug(""Json string to deserialize {} "", json);
			return mapper.readValue(json, typeReference);
		} catch (IOException e) {
			logger.error(""SerializationException {}"", e.getMessage());
			SerializationException serializationException = new SerializationException(e);
			throw serializationException;
		}
	}",2,deserialize json,"deserialize json<CODESPLIT>public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException { 		try { 			logger.debug(""Json string to deserialize {} "", json); 			return mapper.readValue(json, typeReference); 		} catch (IOException e) { 			logger.error(""SerializationException {}"", e.getMessage()); 			SerializationException serializationException = new SerializationException(e); 			throw serializationException; 		} 	}"
"public static void unzip(File file, File destDir) throws IOException {
        if (!destDir.exists()) {
            destDir.mkdir();
        }
        ZipInputStream zipIn = new ZipInputStream(new FileInputStream(file));
        ZipEntry entry = zipIn.getNextEntry();
        // iterates over entries in the zip file
        while (entry != null) {
            File entryFile = new File(destDir, entry.getName());
            if (!entry.isDirectory()) {
                // if the entry is a file, extracts it
                extractFile(zipIn, entryFile);
            } else {
                // if the entry is a directory, make the directory
                entryFile.mkdir();
            }
            zipIn.closeEntry();
            entry = zipIn.getNextEntry();
        }
        zipIn.close();
    }",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void unzip(File file, File destDir) throws IOException {         if (!destDir.exists()) {             destDir.mkdir();         }         ZipInputStream zipIn = new ZipInputStream(new FileInputStream(file));         ZipEntry entry = zipIn.getNextEntry();         // iterates over entries in the zip file         while (entry != null) {             File entryFile = new File(destDir, entry.getName());             if (!entry.isDirectory()) {                 // if the entry is a file, extracts it                 extractFile(zipIn, entryFile);             } else {                 // if the entry is a directory, make the directory                 entryFile.mkdir();             }             zipIn.closeEntry();             entry = zipIn.getNextEntry();         }         zipIn.close();     }"
"public static DateTime epoch() {
		 MutableDateTime epoch = new MutableDateTime();
		 
	     epoch.setDate(0); 
	     epoch.setTime(0);
	        
	     return epoch.toDateTime();
	}",0,convert a utc time to epoch,convert a utc time to epoch<CODESPLIT>public static DateTime epoch() { 		 MutableDateTime epoch = new MutableDateTime(); 		  	     epoch.setDate(0);  	     epoch.setTime(0); 	         	     return epoch.toDateTime(); 	}
"public static double cdf(double x, double mu, double sigma) {
    if(x <= 0.) {
      return 0.;
    }
    return .5 * (1 + NormalDistribution.erf((FastMath.log(x) - mu) / (MathUtil.SQRT2 * sigma)));
  }",1,normal distribution,"normal distribution<CODESPLIT>public static double cdf(double x, double mu, double sigma) {     if(x <= 0.) {       return 0.;     }     return .5 * (1 + NormalDistribution.erf((FastMath.log(x) - mu) / (MathUtil.SQRT2 * sigma)));   }"
"private void generatePdf() {
        File pdfFile = new File(directory, filename + "".pdf"");
        try (OutputStream os = new FileOutputStream(pdfFile)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()
                    .replaceAll("" "", ""%20""));
            builder.toStream(os);
            builder.run();
        } catch (Exception e) {
            log.error(e);
        }
    }",2,convert html to pdf,"convert html to pdf<CODESPLIT>private void generatePdf() {         File pdfFile = new File(directory, filename + "".pdf"");         try (OutputStream os = new FileOutputStream(pdfFile)) {             PdfRendererBuilder builder = new PdfRendererBuilder();             builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()                     .replaceAll("" "", ""%20""));             builder.toStream(os);             builder.run();         } catch (Exception e) {             log.error(e);         }     }"
"public static Properties readPropertiesFromFile(File file)
      throws IOException {
    try (FileInputStream fis = new FileInputStream(file)) {
      Properties prop = new Properties();
      prop.load(fis);
      return prop;
    }
  }",3,read properties file,read properties file<CODESPLIT>public static Properties readPropertiesFromFile(File file)       throws IOException {     try (FileInputStream fis = new FileInputStream(file)) {       Properties prop = new Properties();       prop.load(fis);       return prop;     }   }
"public static Location of(final Latitude latitude, final Longitude longitude) {
		return new Location(latitude, longitude, null);
	}",0,extract latitude and longitude from given input,"extract latitude and longitude from given input<CODESPLIT>public static Location of(final Latitude latitude, final Longitude longitude) { 		return new Location(latitude, longitude, null); 	}"
"public static double quantile(double x, double mu, double sigma) {
    return FastMath.exp(mu + sigma * NormalDistribution.standardNormalQuantile(x));
  }",1,normal distribution,"normal distribution<CODESPLIT>public static double quantile(double x, double mu, double sigma) {     return FastMath.exp(mu + sigma * NormalDistribution.standardNormalQuantile(x));   }"
"public static Map<String, List<String>> extractHTMLheaders(String html) {
        Map<String, List<String>> hxtagsMap = new HashMap<>();
        for(int i=1;i<=6;++i) {
            hxtagsMap.put(""H""+i, new ArrayList<>());
        }
                
        Matcher m = HX_PATTERN.matcher(html);
        while (m.find()) {
            if(m.groupCount()==2) {
                String tagType = m.group(1).toUpperCase(Locale.ENGLISH);
                String content = m.group(2);
                hxtagsMap.get(tagType).add(clear(content));
            }
        }
        return hxtagsMap;
    }",2,extract data from html content,"extract data from html content<CODESPLIT>public static Map<String, List<String>> extractHTMLheaders(String html) {         Map<String, List<String>> hxtagsMap = new HashMap<>();         for(int i=1;i<=6;++i) {             hxtagsMap.put(""H""+i, new ArrayList<>());         }                          Matcher m = HX_PATTERN.matcher(html);         while (m.find()) {             if(m.groupCount()==2) {                 String tagType = m.group(1).toUpperCase(Locale.ENGLISH);                 String content = m.group(2);                 hxtagsMap.get(tagType).add(clear(content));             }         }         return hxtagsMap;     }"
"private void linkToEmitter(String name, LinearInterpolator interpol) {
		// put to value map
		valueMap.put(name, interpol);

		// now update the checkbox to represent the state of the given
		// interpolator
		boolean checked = interpol.isActive();
		JCheckBox enableControl = (JCheckBox) valueNameToControl.get(name);
		enableControl.setSelected(false);
		if (checked)
			enableControl.setSelected(checked);
	}",3,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>private void linkToEmitter(String name, LinearInterpolator interpol) { 		// put to value map 		valueMap.put(name, interpol);  		// now update the checkbox to represent the state of the given 		// interpolator 		boolean checked = interpol.isActive(); 		JCheckBox enableControl = (JCheckBox) valueNameToControl.get(name); 		enableControl.setSelected(false); 		if (checked) 			enableControl.setSelected(checked); 	}"
"static String replaceSlashes(final String target) {
		String replaced = target;
		if (replaced != null) {
			replaced = replaced.replaceAll(""/+"", ""/"");
		}
		return replaced;
	}",0,replace in file,"replace in file<CODESPLIT>static String replaceSlashes(final String target) { 		String replaced = target; 		if (replaced != null) { 			replaced = replaced.replaceAll(""/+"", ""/""); 		} 		return replaced; 	}"
"public static Cookie createCookie(String cookieName, @Sensitive String cookieValue, HttpServletRequest req) {
        return createCookie(cookieName, cookieValue, -1, req);
    }",1,create cookie,"create cookie<CODESPLIT>public static Cookie createCookie(String cookieName, @Sensitive String cookieValue, HttpServletRequest req) {         return createCookie(cookieName, cookieValue, -1, req);     }"
"protected int getCurrentProcessID() throws ProcessHandlerException {
        int pid;
        // Not ideal but using JNA failed on RHEL5.
        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
        Field jvm = null;
        try {
            jvm = runtime.getClass().getDeclaredField(""jvm"");
            jvm.setAccessible(true);
            VMManagement mgmt = (VMManagement) jvm.get(runtime);
            Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");
            pid_method.setAccessible(true);
            pid = (Integer) pid_method.invoke(mgmt);
        } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new ProcessHandlerException(e);
        }
        return pid;
    }",2,get current process id,"get current process id<CODESPLIT>protected int getCurrentProcessID() throws ProcessHandlerException {         int pid;         // Not ideal but using JNA failed on RHEL5.         RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();         Field jvm = null;         try {             jvm = runtime.getClass().getDeclaredField(""jvm"");             jvm.setAccessible(true);             VMManagement mgmt = (VMManagement) jvm.get(runtime);             Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");             pid_method.setAccessible(true);             pid = (Integer) pid_method.invoke(mgmt);         } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {             throw new ProcessHandlerException(e);         }         return pid;     }"
"public StringBuffer append(Reader source, StringBuffer buffer) throws IOException
	{
		BufferedReader _bufferedReader = new BufferedReader(source);
		char[] _buffer = new char[getBufferSize()]; // load by chunk of 4 ko
		try
		{
			for (int _countReadChars = 0; _countReadChars >= 0;)
			{
				buffer.append(_buffer, 0, _countReadChars);
				_countReadChars = _bufferedReader.read(_buffer);
			}
		}
		finally
		{
			_bufferedReader.close();
		}
		return buffer;
	}",3,buffered file reader read text,"buffered file reader read text<CODESPLIT>public StringBuffer append(Reader source, StringBuffer buffer) throws IOException 	{ 		BufferedReader _bufferedReader = new BufferedReader(source); 		char[] _buffer = new char[getBufferSize()]; // load by chunk of 4 ko 		try 		{ 			for (int _countReadChars = 0; _countReadChars >= 0;) 			{ 				buffer.append(_buffer, 0, _countReadChars); 				_countReadChars = _bufferedReader.read(_buffer); 			} 		} 		finally 		{ 			_bufferedReader.close(); 		} 		return buffer; 	}"
"public Query aroundLatitudeLongitude(float latitude, float longitude, int radius) {
    aroundLatLong = ""aroundLatLng="" + latitude + "","" + longitude;
    aroundRadius = radius;
    return this;
  }",0,extract latitude and longitude from given input,"extract latitude and longitude from given input<CODESPLIT>public Query aroundLatitudeLongitude(float latitude, float longitude, int radius) {     aroundLatLong = ""aroundLatLng="" + latitude + "","" + longitude;     aroundRadius = radius;     return this;   }"
"private void postGetConnectionHandling(Connection conn) throws SQLException {
        helper.doConnectionSetup(conn);

        String[] sqlCommands = dsConfig.get().onConnect;
        if (sqlCommands != null && sqlCommands.length > 0)
            onConnect(conn, sqlCommands);

        // Log the database and driver versions on first getConnection.
        if (!wasUsedToGetAConnection) {
            // Wait until after the connection succeeds to set the indicator.
            // This accounts for the scenario where the first connection attempt is bad.
            // The information needs to be read again on the second attempt.
            helper.gatherAndDisplayMetaDataInfo(conn, this);
            wasUsedToGetAConnection = true;
        }
    }",1,postgresql connection,"postgresql connection<CODESPLIT>private void postGetConnectionHandling(Connection conn) throws SQLException {         helper.doConnectionSetup(conn);          String[] sqlCommands = dsConfig.get().onConnect;         if (sqlCommands != null && sqlCommands.length > 0)             onConnect(conn, sqlCommands);          // Log the database and driver versions on first getConnection.         if (!wasUsedToGetAConnection) {             // Wait until after the connection succeeds to set the indicator.             // This accounts for the scenario where the first connection attempt is bad.             // The information needs to be read again on the second attempt.             helper.gatherAndDisplayMetaDataInfo(conn, this);             wasUsedToGetAConnection = true;         }     }"
"public static String getStatusDescription(int status)
   {
      String description = """";

      Integer statusKey = new Integer(status);
      if (statusDescriptions.containsKey(statusKey))
      {
         description = statusDescriptions.get(statusKey);
      }

      return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);
   }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getStatusDescription(int status)    {       String description = """";        Integer statusKey = new Integer(status);       if (statusDescriptions.containsKey(statusKey))       {          description = statusDescriptions.get(statusKey);       }        return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);    }"
"public static int indexOfIgnoreCase(String text, String str, int startIndex) {
        Matcher m = Pattern.compile(Pattern.quote(str), Pattern.CASE_INSENSITIVE).matcher(text);
        return m.find(startIndex) ? m.start() : -1;
    }",3,regex case insensitive,"regex case insensitive<CODESPLIT>public static int indexOfIgnoreCase(String text, String str, int startIndex) {         Matcher m = Pattern.compile(Pattern.quote(str), Pattern.CASE_INSENSITIVE).matcher(text);         return m.find(startIndex) ? m.start() : -1;     }"
"public void error(Throwable error, Map<String, Object> custom) {
    error(error, custom, null);
  }",0,custom http error response,"custom http error response<CODESPLIT>public void error(Throwable error, Map<String, Object> custom) {     error(error, custom, null);   }"
"public boolean replaceStringsInFile(String filePath, Map<String, String> replaceValues) {
        return replaceStringsInFile(filePath, replaceValues, null);
    }",1,replace in file,"replace in file<CODESPLIT>public boolean replaceStringsInFile(String filePath, Map<String, String> replaceValues) {         return replaceStringsInFile(filePath, replaceValues, null);     }"
"public static Date getDay(String string) {
		if (string == null) {
			return null;
		}
		Date date = null;
		try {
			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string));
		}
		catch (ParseException ex) {
			return null;
		}
		return date;
	}",2,convert a date string into yyyymmdd,"convert a date string into yyyymmdd<CODESPLIT>public static Date getDay(String string) { 		if (string == null) { 			return null; 		} 		Date date = null; 		try { 			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string)); 		} 		catch (ParseException ex) { 			return null; 		} 		return date; 	}"
"public static ConfusionMatrix createCumulativeMatrix(ConfusionMatrix... matrices)
    {
        ConfusionMatrix result = new ConfusionMatrix();

        for (ConfusionMatrix matrix : matrices) {
            for (Map.Entry<String, Map<String, Integer>> gold : matrix.map.entrySet()) {
                for (Map.Entry<String, Integer> actual : gold.getValue().entrySet()) {
                    result.increaseValue(gold.getKey(), actual.getKey(), actual.getValue());
                }
            }
        }

        return result;
    }",3,confusion matrix,"confusion matrix<CODESPLIT>public static ConfusionMatrix createCumulativeMatrix(ConfusionMatrix... matrices)     {         ConfusionMatrix result = new ConfusionMatrix();          for (ConfusionMatrix matrix : matrices) {             for (Map.Entry<String, Map<String, Integer>> gold : matrix.map.entrySet()) {                 for (Map.Entry<String, Integer> actual : gold.getValue().entrySet()) {                     result.increaseValue(gold.getKey(), actual.getKey(), actual.getValue());                 }             }         }          return result;     }"
"public int getDimension(DependencyPath path) {
        String endToken = path.last().word();

        // Extract out how the current word is related to the last word in the
        // path.  
        String relation = path.getRelation(path.length() - 1);
        return getDimensionInternal(endToken + ""+"" + relation);
    }",0,how to determine a string is a valid word,"how to determine a string is a valid word<CODESPLIT>public int getDimension(DependencyPath path) {         String endToken = path.last().word();          // Extract out how the current word is related to the last word in the         // path.           String relation = path.getRelation(path.length() - 1);         return getDimensionInternal(endToken + ""+"" + relation);     }"
"private void updateCoordinates() {
    // Top-left of heat map.
    int x = margin + axisThickness + yAxisLabelSize.height;
    x += (yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight);
    int y = titleSize.height + margin;
    heatMapTL = new Point(x, y);

    // Top-right of heat map.
    x = heatMapTL.x + heatMapSize.width;
    y = heatMapTL.y + heatMapSize.height;
    heatMapBR = new Point(x, y);

    // Centre of heat map.
    x = heatMapTL.x + (heatMapSize.width / 2);
    y = heatMapTL.y + (heatMapSize.height / 2);
    heatMapC = new Point(x, y);
  }",1,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>private void updateCoordinates() {     // Top-left of heat map.     int x = margin + axisThickness + yAxisLabelSize.height;     x += (yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight);     int y = titleSize.height + margin;     heatMapTL = new Point(x, y);      // Top-right of heat map.     x = heatMapTL.x + heatMapSize.width;     y = heatMapTL.y + heatMapSize.height;     heatMapBR = new Point(x, y);      // Centre of heat map.     x = heatMapTL.x + (heatMapSize.width / 2);     y = heatMapTL.y + (heatMapSize.height / 2);     heatMapC = new Point(x, y);   }"
"public static String getText(Reader reader) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(reader);
        return getText(bufferedReader);
    }",2,buffered file reader read text,buffered file reader read text<CODESPLIT>public static String getText(Reader reader) throws IOException {         BufferedReader bufferedReader = new BufferedReader(reader);         return getText(bufferedReader);     }
"public static String reverseString(String str) {
        StringBuilder stringBuffer = new StringBuilder(str);
        return stringBuffer.reverse().toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverseString(String str) {         StringBuilder stringBuffer = new StringBuilder(str);         return stringBuffer.reverse().toString();     }
"public String getDateStringOrSuppliedString(String emptyDateString) {
        LocalDate date = getDate();
        return (date == null) ? emptyDateString : date.toString();
    }",0,string to date,string to date<CODESPLIT>public String getDateStringOrSuppliedString(String emptyDateString) {         LocalDate date = getDate();         return (date == null) ? emptyDateString : date.toString();     }
"public UniqueModel unique() {
		checkReadOnly();
		UniqueModel unique = new UniqueModel();
		unique.setTableModel(this);
		getUniqueConsts().add(unique);
		return unique;
	}",1,unique elements,unique elements<CODESPLIT>public UniqueModel unique() { 		checkReadOnly(); 		UniqueModel unique = new UniqueModel(); 		unique.setTableModel(this); 		getUniqueConsts().add(unique); 		return unique; 	}
"public static int[] sort(double[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public static int[] sort(double[] arr) {         int[] order = new int[arr.length];         for (int i = 0; i < order.length; i++) {             order[i] = i;         }         sort(arr, order);         return order;     }"
"private Properties readPropertyFile(String file) throws IOException {
        String fileName = file.startsWith(""/"") ? file : ""/"" + file;
        LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");
        return Util.readProperties(fileName);
    }",3,read properties file,"read properties file<CODESPLIT>private Properties readPropertyFile(String file) throws IOException {         String fileName = file.startsWith(""/"") ? file : ""/"" + file;         LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");         return Util.readProperties(fileName);     }"
"public void setHidden(final boolean hidden) {
        if (hidden)
            attrMixin.setAttribute(HIDDEN, Boolean.toString(true));
        else
            attrMixin.removeAttribute(HIDDEN);
    }",0,set file attrib hidden,"set file attrib hidden<CODESPLIT>public void setHidden(final boolean hidden) {         if (hidden)             attrMixin.setAttribute(HIDDEN, Boolean.toString(true));         else             attrMixin.removeAttribute(HIDDEN);     }"
"public ExtractResult extract(String content, String selector, int amount) {

		List<Element> extracted = extractElements(content, selector, amount);

		if (extracted.size() > 1) {

			// first element is the remaining body, the rest are extracted
			Element body = extracted.get(0);
			List<Element> elements = extracted.subList(1, extracted.size());

			// convert to HTML
			List<String> elementStr = new ArrayList<String>();
			for (Element el : elements) {
				elementStr.add(el.outerHtml());
			}

			return new DefaultExtractResult(elementStr, body.html());
		} else {
			// nothing to extract
			return new DefaultExtractResult(Collections.<String> emptyList(), content);
		}
	}",1,extract data from html content,"extract data from html content<CODESPLIT>public ExtractResult extract(String content, String selector, int amount) {  		List<Element> extracted = extractElements(content, selector, amount);  		if (extracted.size() > 1) {  			// first element is the remaining body, the rest are extracted 			Element body = extracted.get(0); 			List<Element> elements = extracted.subList(1, extracted.size());  			// convert to HTML 			List<String> elementStr = new ArrayList<String>(); 			for (Element el : elements) { 				elementStr.add(el.outerHtml()); 			}  			return new DefaultExtractResult(elementStr, body.html()); 		} else { 			// nothing to extract 			return new DefaultExtractResult(Collections.<String> emptyList(), content); 		} 	}"
"public static void extractZip(File file) throws FileNotFoundException, IOException {
        final String originalPath = file.getPath();
        final File zip = new File(originalPath + "".zip"");
        if (zip.isFile() && !zip.delete()) {
            LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());
            zip.deleteOnExit();
        }
        if (!file.renameTo(zip)) {
            throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");
        }
        final File newFile = new File(originalPath);
        try (FileInputStream fis = new FileInputStream(zip);
                ZipInputStream cin = new ZipInputStream(fis);
                FileOutputStream out = new FileOutputStream(newFile)) {
            cin.getNextEntry();
            IOUtils.copy(cin, out);
        } finally {
            if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {
                LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());
                zip.deleteOnExit();
            }
        }
    }",2,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(File file) throws FileNotFoundException, IOException {         final String originalPath = file.getPath();         final File zip = new File(originalPath + "".zip"");         if (zip.isFile() && !zip.delete()) {             LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());             zip.deleteOnExit();         }         if (!file.renameTo(zip)) {             throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");         }         final File newFile = new File(originalPath);         try (FileInputStream fis = new FileInputStream(zip);                 ZipInputStream cin = new ZipInputStream(fis);                 FileOutputStream out = new FileOutputStream(newFile)) {             cin.getNextEntry();             IOUtils.copy(cin, out);         } finally {             if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {                 LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());                 zip.deleteOnExit();             }         }     }"
"public void copySingleFile(File asset) {
        try {
            if ( !asset.isDirectory() ) {
                String targetPath = config.getDestinationFolder().getCanonicalPath() + File.separatorChar + assetSubPath(asset);
                LOGGER.info(""Copying single asset file to [{}]"", targetPath);
                copyFile(asset, new File(targetPath));
            } else {
                LOGGER.info(""Skip copying single asset file [{}]. Is a directory."", asset.getPath());
            }
        } catch (IOException io) {
            LOGGER.error(""Failed to copy the asset file."", io);
        }
    }",3,copying a file to a path,"copying a file to a path<CODESPLIT>public void copySingleFile(File asset) {         try {             if ( !asset.isDirectory() ) {                 String targetPath = config.getDestinationFolder().getCanonicalPath() + File.separatorChar + assetSubPath(asset);                 LOGGER.info(""Copying single asset file to [{}]"", targetPath);                 copyFile(asset, new File(targetPath));             } else {                 LOGGER.info(""Skip copying single asset file [{}]. Is a directory."", asset.getPath());             }         } catch (IOException io) {             LOGGER.error(""Failed to copy the asset file."", io);         }     }"
"@SuppressWarnings(""unchecked"")
	public JSONNavi<T> array() {
		if (failure)
			return this;
		if (current == null && readonly)
			failure(""Can not create Array child in readonly"", null);
		if (current != null) {
			if (isArray())
				return this;
			if (isObject())
				failure(""can not use Object feature on Array."", null);
			failure(""Can not use current possition as Object"", null);
		} else {
			current = mapper.createArray();
		}
		if (root == null)
			root = (T) current;
		else
			store();
		return this;
	}",0,readonly array,"readonly array<CODESPLIT>@SuppressWarnings(""unchecked"") 	public JSONNavi<T> array() { 		if (failure) 			return this; 		if (current == null && readonly) 			failure(""Can not create Array child in readonly"", null); 		if (current != null) { 			if (isArray()) 				return this; 			if (isObject()) 				failure(""can not use Object feature on Array."", null); 			failure(""Can not use current possition as Object"", null); 		} else { 			current = mapper.createArray(); 		} 		if (root == null) 			root = (T) current; 		else 			store(); 		return this; 	}"
"private void readPropertiesFiles() {

        if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {
            // Skip configuration loading
            LOGGER.info(JRebirthMarkers.MESSAGE, ""Messages Loading is skipped"");

        } else {
            // Assemble the regex pattern
            final Pattern filePattern = Pattern.compile(this.messageFileWildcard + ""\\.properties"");

            // Retrieve all resources from default classpath
            final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);

            LOGGER.info(JRebirthMarkers.MESSAGE, ""{} Messages file{} found."", list.size(), list.size() > 1 ? ""s"" : """");

            for (final String rbFilename : list) {
                readPropertiesFile(rbFilename);
            }
        }
    }",1,read properties file,"read properties file<CODESPLIT>private void readPropertiesFiles() {          if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {             // Skip configuration loading             LOGGER.info(JRebirthMarkers.MESSAGE, ""Messages Loading is skipped"");          } else {             // Assemble the regex pattern             final Pattern filePattern = Pattern.compile(this.messageFileWildcard + ""\\.properties"");              // Retrieve all resources from default classpath             final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);              LOGGER.info(JRebirthMarkers.MESSAGE, ""{} Messages file{} found."", list.size(), list.size() > 1 ? ""s"" : """");              for (final String rbFilename : list) {                 readPropertiesFile(rbFilename);             }         }     }"
"private CommandLine parseArgs(String[] args) throws ParseException {
        final CommandLineParser parser = new DefaultParser();
        final Options options = createCommandLineOptions();
        return parser.parse(options, args);
    }",2,parse command line argument,"parse command line argument<CODESPLIT>private CommandLine parseArgs(String[] args) throws ParseException {         final CommandLineParser parser = new DefaultParser();         final Options options = createCommandLineOptions();         return parser.parse(options, args);     }"
"public static int levenshteinDistance(CharSequence s, CharSequence t)
    {
        // degenerate cases          s
        if (s == null || """".equals(s))
        {
            return t == null || """".equals(t) ? 0 : t.length();
        }
        else if (t == null || """".equals(t))
        {
            return s.length();
        }

        // create two work vectors of integer distances
        int[] v0 = new int[t.length() + 1];
        int[] v1 = new int[t.length() + 1];

        // initialize v0 (the previous row of distances)
        // this row is A[0][i]: edit distance for an empty s
        // the distance is just the number of characters to delete from t
        for (int i = 0; i < v0.length; i++)
        {
            v0[i] = i;
        }

        int sLen = s.length();
        int tLen = t.length();
        for (int i = 0; i < sLen; i++)
        {
            // calculate v1 (current row distances) from the previous row v0

            // first element of v1 is A[i+1][0]
            //   edit distance is delete (i+1) chars from s to match empty t
            v1[0] = i + 1;

            // use formula to fill in the rest of the row
            for (int j = 0; j < tLen; j++)
            {
                int cost = (s.charAt(i) == t.charAt(j)) ? 0 : 1;
                v1[j + 1] = (int) MathUtilities.minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
            }

            // copy v1 (current row) to v0 (previous row) for next iteration
            System.arraycopy(v1, 0, v0, 0, v0.length);
        }

        return v1[t.length()];
    }",3,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static int levenshteinDistance(CharSequence s, CharSequence t)     {         // degenerate cases          s         if (s == null || """".equals(s))         {             return t == null || """".equals(t) ? 0 : t.length();         }         else if (t == null || """".equals(t))         {             return s.length();         }          // create two work vectors of integer distances         int[] v0 = new int[t.length() + 1];         int[] v1 = new int[t.length() + 1];          // initialize v0 (the previous row of distances)         // this row is A[0][i]: edit distance for an empty s         // the distance is just the number of characters to delete from t         for (int i = 0; i < v0.length; i++)         {             v0[i] = i;         }          int sLen = s.length();         int tLen = t.length();         for (int i = 0; i < sLen; i++)         {             // calculate v1 (current row distances) from the previous row v0              // first element of v1 is A[i+1][0]             //   edit distance is delete (i+1) chars from s to match empty t             v1[0] = i + 1;              // use formula to fill in the rest of the row             for (int j = 0; j < tLen; j++)             {                 int cost = (s.charAt(i) == t.charAt(j)) ? 0 : 1;                 v1[j + 1] = (int) MathUtilities.minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);             }              // copy v1 (current row) to v0 (previous row) for next iteration             System.arraycopy(v1, 0, v0, 0, v0.length);         }          return v1[t.length()];     }"
"public static void innerHtml(HTMLElement element, SafeHtml html) {
        if (element != null) {
            element.innerHTML = html.asString();
        }
    }",0,get inner html,"get inner html<CODESPLIT>public static void innerHtml(HTMLElement element, SafeHtml html) {         if (element != null) {             element.innerHTML = html.asString();         }     }"
"public List<Permutation> all() {
        final List<Permutation> permutations = new ArrayList<Permutation>();
        Backtracker counter = new Backtracker() {

            @Override
            public void applyTo(Permutation p) {
                permutations.add(p);
            }

            @Override
            public boolean isFinished() {
                return false;
            }
        };
        this.apply(counter);
        return permutations;
    }",1,all permutations of a list,all permutations of a list<CODESPLIT>public List<Permutation> all() {         final List<Permutation> permutations = new ArrayList<Permutation>();         Backtracker counter = new Backtracker() {              @Override             public void applyTo(Permutation p) {                 permutations.add(p);             }              @Override             public boolean isFinished() {                 return false;             }         };         this.apply(counter);         return permutations;     }
"public void parse(File file) throws UpdateException {
        LOGGER.debug(""Parsing "" + file.getName());
        try (InputStream fin = new FileInputStream(file);
                InputStream in = new GZIPInputStream(fin);
                InputStreamReader isr = new InputStreamReader(in, UTF_8);
                JsonReader reader = new JsonReader(isr)) {
            final Gson gson = new GsonBuilder().create();

            reader.beginObject();

            while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
                reader.skipValue();
            }
            reader.beginArray();
            while (reader.hasNext()) {
                final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);

                //cve.getCve().getCVEDataMeta().getSTATE();
                if (testCveCpeStartWithFilter(cve)) {
                    cveDB.updateVulnerability(cve);
                }
            }
        } catch (FileNotFoundException ex) {
            LOGGER.error(ex.getMessage());
            throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);
        } catch (IOException ex) {
            LOGGER.error(""Error reading NVD JSON data: {}"", file);
            LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);
            throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);
        }
    }",2,parse json file,"parse json file<CODESPLIT>public void parse(File file) throws UpdateException {         LOGGER.debug(""Parsing "" + file.getName());         try (InputStream fin = new FileInputStream(file);                 InputStream in = new GZIPInputStream(fin);                 InputStreamReader isr = new InputStreamReader(in, UTF_8);                 JsonReader reader = new JsonReader(isr)) {             final Gson gson = new GsonBuilder().create();              reader.beginObject();              while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {                 reader.skipValue();             }             reader.beginArray();             while (reader.hasNext()) {                 final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);                  //cve.getCve().getCVEDataMeta().getSTATE();                 if (testCveCpeStartWithFilter(cve)) {                     cveDB.updateVulnerability(cve);                 }             }         } catch (FileNotFoundException ex) {             LOGGER.error(ex.getMessage());             throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);         } catch (IOException ex) {             LOGGER.error(""Error reading NVD JSON data: {}"", file);             LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);             throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);         }     }"
"public static void zipCompress(String filename) throws IOException {
    FileOutputStream fos = new FileOutputStream(filename + COMPRESSION_SUFFIX);
    CheckedOutputStream csum = new CheckedOutputStream(fos, new CRC32());
    ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(csum));
    out.setComment(""Failmon records."");

    BufferedReader in = new BufferedReader(new FileReader(filename));
    out.putNextEntry(new ZipEntry(new File(filename).getName()));
    int c;
    while ((c = in.read()) != -1)
      out.write(c);
    in.close();

    out.finish();
    out.close();
  }",3,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>public static void zipCompress(String filename) throws IOException {     FileOutputStream fos = new FileOutputStream(filename + COMPRESSION_SUFFIX);     CheckedOutputStream csum = new CheckedOutputStream(fos, new CRC32());     ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(csum));     out.setComment(""Failmon records."");      BufferedReader in = new BufferedReader(new FileReader(filename));     out.putNextEntry(new ZipEntry(new File(filename).getName()));     int c;     while ((c = in.read()) != -1)       out.write(c);     in.close();      out.finish();     out.close();   }"
"public void setSimilarityClass(String className)
   {
      try
      {
         Class<?> similarityClass = ClassLoading.forName(className, this);
         similarity = (Similarity)similarityClass.newInstance();
      }
      catch (ClassNotFoundException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
      catch (InstantiationException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
      catch (IllegalAccessException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
   }",0,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public void setSimilarityClass(String className)    {       try       {          Class<?> similarityClass = ClassLoading.forName(className, this);          similarity = (Similarity)similarityClass.newInstance();       }       catch (ClassNotFoundException e)       {          log.warn(""Invalid Similarity class: "" + className, e);       }       catch (InstantiationException e)       {          log.warn(""Invalid Similarity class: "" + className, e);       }       catch (IllegalAccessException e)       {          log.warn(""Invalid Similarity class: "" + className, e);       }    }"
"synchronized int size( int priority) {
    if (priority < 0 || priority >= LEVEL) {
      throw new IllegalArgumentException(""Unsupported priority: "" + priority);
    }
    return priorityQueues.get(priority).size();
  }",1,priority queue,"priority queue<CODESPLIT>synchronized int size( int priority) {     if (priority < 0 || priority >= LEVEL) {       throw new IllegalArgumentException(""Unsupported priority: "" + priority);     }     return priorityQueues.get(priority).size();   }"
"private static String coerceToEpoch(String s) {
		Long epoch = parseEpochSecond(s);
		if (epoch != null) {
			return String.valueOf(epoch);
		}
		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"");
		try {
			return String.valueOf(format.parse(s).getTime());
		}
		catch (ParseException ex) {
			return s;
		}
	}",2,convert a utc time to epoch,"convert a utc time to epoch<CODESPLIT>private static String coerceToEpoch(String s) { 		Long epoch = parseEpochSecond(s); 		if (epoch != null) { 			return String.valueOf(epoch); 		} 		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ""); 		try { 			return String.valueOf(format.parse(s).getTime()); 		} 		catch (ParseException ex) { 			return s; 		} 	}"
"protected static Number stringToNumber(final String val) throws NumberFormatException {
        char initial = val.charAt(0);
        if ((initial >= '0' && initial <= '9') || initial == '-') {
            // decimal representation
            if (isDecimalNotation(val)) {
                // quick dirty way to see if we need a BigDecimal instead of a Double
                // this only handles some cases of overflow or underflow
                if (val.length()>14) {
                    return new BigDecimal(val);
                }
                final Double d = Double.valueOf(val);
                if (d.isInfinite() || d.isNaN()) {
                    // if we can't parse it as a double, go up to BigDecimal
                    // this is probably due to underflow like 4.32e-678
                    // or overflow like 4.65e5324. The size of the string is small
                    // but can't be held in a Double.
                    return new BigDecimal(val);
                }
                return d;
            }
            // integer representation.
            // This will narrow any values to the smallest reasonable Object representation
            // (Integer, Long, or BigInteger)
            
            // string version
            // The compare string length method reduces GC,
            // but leads to smaller integers being placed in larger wrappers even though not
            // needed. i.e. 1,000,000,000 -> Long even though it's an Integer
            // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long
            //if(val.length()<=9){
            //    return Integer.valueOf(val);
            //}
            //if(val.length()<=18){
            //    return Long.valueOf(val);
            //}
            //return new BigInteger(val);
            
            // BigInteger version: We use a similar bitLenth compare as
            // BigInteger#intValueExact uses. Increases GC, but objects hold
            // only what they need. i.e. Less runtime overhead if the value is
            // long lived. Which is the better tradeoff? This is closer to what's
            // in stringToValue.
            BigInteger bi = new BigInteger(val);
            if(bi.bitLength()<=31){
                return Integer.valueOf(bi.intValue());
            }
            if(bi.bitLength()<=63){
                return Long.valueOf(bi.longValue());
            }
            return bi;
        }
        throw new NumberFormatException(""val [""+val+""] is not a valid number."");
    }",3,convert string to number,"convert string to number<CODESPLIT>protected static Number stringToNumber(final String val) throws NumberFormatException {         char initial = val.charAt(0);         if ((initial >= '0' && initial <= '9') || initial == '-') {             // decimal representation             if (isDecimalNotation(val)) {                 // quick dirty way to see if we need a BigDecimal instead of a Double                 // this only handles some cases of overflow or underflow                 if (val.length()>14) {                     return new BigDecimal(val);                 }                 final Double d = Double.valueOf(val);                 if (d.isInfinite() || d.isNaN()) {                     // if we can't parse it as a double, go up to BigDecimal                     // this is probably due to underflow like 4.32e-678                     // or overflow like 4.65e5324. The size of the string is small                     // but can't be held in a Double.                     return new BigDecimal(val);                 }                 return d;             }             // integer representation.             // This will narrow any values to the smallest reasonable Object representation             // (Integer, Long, or BigInteger)                          // string version             // The compare string length method reduces GC,             // but leads to smaller integers being placed in larger wrappers even though not             // needed. i.e. 1,000,000,000 -> Long even though it's an Integer             // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long             //if(val.length()<=9){             //    return Integer.valueOf(val);             //}             //if(val.length()<=18){             //    return Long.valueOf(val);             //}             //return new BigInteger(val);                          // BigInteger version: We use a similar bitLenth compare as             // BigInteger#intValueExact uses. Increases GC, but objects hold             // only what they need. i.e. Less runtime overhead if the value is             // long lived. Which is the better tradeoff? This is closer to what's             // in stringToValue.             BigInteger bi = new BigInteger(val);             if(bi.bitLength()<=31){                 return Integer.valueOf(bi.intValue());             }             if(bi.bitLength()<=63){                 return Long.valueOf(bi.longValue());             }             return bi;         }         throw new NumberFormatException(""val [""+val+""] is not a valid number."");     }"
"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
   {
      orderNumber = in.readInt();

      // read canonical file path
      int size = in.readInt();
      if (size > 0)
      {
         byte[] buf = new byte[size];
         in.readFully(buf);

         File f = new File(new String(buf, ""UTF-8""));
         // validate if exists
         if (PrivilegedFileHelper.exists(f))
         {
            file = f;
         }
         else
         {
            file = null;
         }
      }
      else
      {
         // should not occurs but since we have a way to recover, it should not be
         // an issue
         file = null;
      }
   }",0,how to read .csv file in an efficient way?,"how to read .csv file in an efficient way?<CODESPLIT>public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException    {       orderNumber = in.readInt();        // read canonical file path       int size = in.readInt();       if (size > 0)       {          byte[] buf = new byte[size];          in.readFully(buf);           File f = new File(new String(buf, ""UTF-8""));          // validate if exists          if (PrivilegedFileHelper.exists(f))          {             file = f;          }          else          {             file = null;          }       }       else       {          // should not occurs but since we have a way to recover, it should not be          // an issue          file = null;       }    }"
"public void setWorkingDirectory(Path dir) throws IOException {
    ensureState(JobState.DEFINE);
    conf.setWorkingDirectory(dir);
  }",1,set working directory,set working directory<CODESPLIT>public void setWorkingDirectory(Path dir) throws IOException {     ensureState(JobState.DEFINE);     conf.setWorkingDirectory(dir);   }
"private Cookie createCookie(String str) throws UnsupportedEncodingException {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);
    }
    Cookie cookie = new Cookie(AUTH_COOKIE, str);

    cookie.setMaxAge(cookieMaxAge);
    if (cookieDomain != null) {
      cookie.setDomain(cookieDomain);
    }
    if (cookiePath != null) {
      cookie.setPath(cookiePath);
    }
    cookie.setSecure(isCookieSecure);
    return cookie;
  }",2,create cookie,"create cookie<CODESPLIT>private Cookie createCookie(String str) throws UnsupportedEncodingException {     if (LOG.isDebugEnabled()) {       LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);     }     Cookie cookie = new Cookie(AUTH_COOKIE, str);      cookie.setMaxAge(cookieMaxAge);     if (cookieDomain != null) {       cookie.setDomain(cookieDomain);     }     if (cookiePath != null) {       cookie.setPath(cookiePath);     }     cookie.setSecure(isCookieSecure);     return cookie;   }"
"private void handleContextMenu(JTree tree, int x, int y) {
		TreePath path = tree.getPathForLocation(x, y);
		tree.setSelectionPath(path);
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();

		if (node == null)
			return;
		if (!node.isLeaf()) {
			tree.setSelectionPath(null);
			return;
		}
		final AppInfo info = (AppInfo) node.getUserObject();

		JMenuItem copyname = new JMenuItem(""Copy Name"");
		copyname.addActionListener(e -> {
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(info.app.getSimpleName()), null);
		});

		JMenuItem copypath = new JMenuItem(""Copy Path"");
		copypath.addActionListener(e -> {
			String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(path1), null);
		});

		JMenuItem github = new JMenuItem(""Go to Github"");
		github.addActionListener(e -> openInGitHub(info));

		JPopupMenu submenu = new JPopupMenu();
		submenu.add(copyname);
		submenu.add(copypath);
		submenu.add(github);
		submenu.show(tree, x, y);
	}",3,copy to clipboard,"copy to clipboard<CODESPLIT>private void handleContextMenu(JTree tree, int x, int y) { 		TreePath path = tree.getPathForLocation(x, y); 		tree.setSelectionPath(path); 		DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();  		if (node == null) 			return; 		if (!node.isLeaf()) { 			tree.setSelectionPath(null); 			return; 		} 		final AppInfo info = (AppInfo) node.getUserObject();  		JMenuItem copyname = new JMenuItem(""Copy Name""); 		copyname.addActionListener(e -> { 			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 			clipboard.setContents(new StringSelection(info.app.getSimpleName()), null); 		});  		JMenuItem copypath = new JMenuItem(""Copy Path""); 		copypath.addActionListener(e -> { 			String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName()); 			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 			clipboard.setContents(new StringSelection(path1), null); 		});  		JMenuItem github = new JMenuItem(""Go to Github""); 		github.addActionListener(e -> openInGitHub(info));  		JPopupMenu submenu = new JPopupMenu(); 		submenu.add(copyname); 		submenu.add(copypath); 		submenu.add(github); 		submenu.show(tree, x, y); 	}"
"@Nonnull
  private static ESuccess _copyFileViaChannel (@Nonnull final File aSrcFile, @Nonnull final File aDestFile)
  {
    final FileChannel aSrcChannel = FileChannelHelper.getFileReadChannel (aSrcFile);
    if (aSrcChannel == null)
      return ESuccess.FAILURE;

    try
    {
      final FileChannel aDstChannel = FileChannelHelper.getFileWriteChannel (aDestFile, EAppend.TRUNCATE);
      if (aDstChannel == null)
        return ESuccess.FAILURE;

      try
      {
        FileLock aSrcLock = null;
        FileLock aDestLock = null;
        try
        {
          final long nBytesToRead = aSrcChannel.size ();

          // Shared read lock and exclusive write lock
          aSrcLock = aSrcChannel.lock (0, nBytesToRead, true);
          aDestLock = aDstChannel.lock ();

          // Main copying - the loop version is much quicker than then
          // transferTo with full size!
          long nBytesWritten = 0;
          final long nChunkSize = 1L * CGlobal.BYTES_PER_MEGABYTE;
          while (nBytesWritten < nBytesToRead)
            nBytesWritten += aSrcChannel.transferTo (nBytesWritten, nChunkSize, aDstChannel);

          if (nBytesToRead != nBytesWritten)
          {
            if (LOGGER.isErrorEnabled ())
              LOGGER.error (""Failed to copy file. Meant to read "" + nBytesToRead + "" bytes but wrote "" + nBytesWritten);
            return ESuccess.FAILURE;
          }
          return ESuccess.SUCCESS;
        }
        catch (final IOException ex)
        {
          throw new IllegalStateException (""Failed to copy from "" + aSrcFile + "" to "" + aDestFile, ex);
        }
        finally
        {
          // Unlock
          ChannelHelper.release (aDestLock);
          ChannelHelper.release (aSrcLock);
        }
      }
      finally
      {
        ChannelHelper.close (aDstChannel);
      }
    }
    finally
    {
      ChannelHelper.close (aSrcChannel);
    }
  }",0,copying a file to a path,"copying a file to a path<CODESPLIT>@Nonnull   private static ESuccess _copyFileViaChannel (@Nonnull final File aSrcFile, @Nonnull final File aDestFile)   {     final FileChannel aSrcChannel = FileChannelHelper.getFileReadChannel (aSrcFile);     if (aSrcChannel == null)       return ESuccess.FAILURE;      try     {       final FileChannel aDstChannel = FileChannelHelper.getFileWriteChannel (aDestFile, EAppend.TRUNCATE);       if (aDstChannel == null)         return ESuccess.FAILURE;        try       {         FileLock aSrcLock = null;         FileLock aDestLock = null;         try         {           final long nBytesToRead = aSrcChannel.size ();            // Shared read lock and exclusive write lock           aSrcLock = aSrcChannel.lock (0, nBytesToRead, true);           aDestLock = aDstChannel.lock ();            // Main copying - the loop version is much quicker than then           // transferTo with full size!           long nBytesWritten = 0;           final long nChunkSize = 1L * CGlobal.BYTES_PER_MEGABYTE;           while (nBytesWritten < nBytesToRead)             nBytesWritten += aSrcChannel.transferTo (nBytesWritten, nChunkSize, aDstChannel);            if (nBytesToRead != nBytesWritten)           {             if (LOGGER.isErrorEnabled ())               LOGGER.error (""Failed to copy file. Meant to read "" + nBytesToRead + "" bytes but wrote "" + nBytesWritten);             return ESuccess.FAILURE;           }           return ESuccess.SUCCESS;         }         catch (final IOException ex)         {           throw new IllegalStateException (""Failed to copy from "" + aSrcFile + "" to "" + aDestFile, ex);         }         finally         {           // Unlock           ChannelHelper.release (aDestLock);           ChannelHelper.release (aSrcLock);         }       }       finally       {         ChannelHelper.close (aDstChannel);       }     }     finally     {       ChannelHelper.close (aSrcChannel);     }   }"
"public <T> List<T> randomElements(List<T> elements, int count) {
		if (elements.size() >= count) {
			return extractRandomList(elements, count);
		} else {
			List<T> randomElements = new ArrayList<T>();
			randomElements.addAll(extractRandomList(elements, count % elements.size()));
			do {
				randomElements.addAll(extractRandomList(elements, elements.size()));
			} while (randomElements.size() < count);
			return randomElements;
		}
	}",1,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public <T> List<T> randomElements(List<T> elements, int count) { 		if (elements.size() >= count) { 			return extractRandomList(elements, count); 		} else { 			List<T> randomElements = new ArrayList<T>(); 			randomElements.addAll(extractRandomList(elements, count % elements.size())); 			do { 				randomElements.addAll(extractRandomList(elements, elements.size())); 			} while (randomElements.size() < count); 			return randomElements; 		} 	}"
"private static String getHttpOnlyCookieHeader(Cookie cookie) {
    NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),
      cookie.getPath(), cookie.getDomain(), cookie.getVersion(),
      cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());
    return newCookie + ""; HttpOnly"";
  }",2,create cookie,"create cookie<CODESPLIT>private static String getHttpOnlyCookieHeader(Cookie cookie) {     NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),       cookie.getPath(), cookie.getDomain(), cookie.getVersion(),       cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());     return newCookie + ""; HttpOnly"";   }"
"public Matrix multiply(Matrix B, ExecutorService threadPool)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C, threadPool);
        return C;
    }",3,matrix multiply,"matrix multiply<CODESPLIT>public Matrix multiply(Matrix B, ExecutorService threadPool)     {         Matrix C = new DenseMatrix(this.rows(), B.cols());         multiply(B, C, threadPool);         return C;     }"
"private Coordinate[] getOrderedNodes( Coordinate c, Coordinate coordinate1, Coordinate coordinate2, Coordinate coordinate3 ) {
        double d = distance3d(c, coordinate1, null);
        Coordinate nearest = coordinate1;
        Coordinate c2 = coordinate2;
        Coordinate c3 = coordinate3;

        double d2 = distance3d(c, coordinate2, null);
        if (d2 < d) {
            nearest = coordinate2;
            d = d2;
            c2 = coordinate1;
            c3 = coordinate3;
        }
        double d3 = distance3d(c, coordinate3, null);
        if (d3 < d) {
            nearest = coordinate3;
            c2 = coordinate1;
            c3 = coordinate2;
        }
        return new Coordinate[]{nearest, c2, c3};
    }",0,heatmap from 3d coordinates,"heatmap from 3d coordinates<CODESPLIT>private Coordinate[] getOrderedNodes( Coordinate c, Coordinate coordinate1, Coordinate coordinate2, Coordinate coordinate3 ) {         double d = distance3d(c, coordinate1, null);         Coordinate nearest = coordinate1;         Coordinate c2 = coordinate2;         Coordinate c3 = coordinate3;          double d2 = distance3d(c, coordinate2, null);         if (d2 < d) {             nearest = coordinate2;             d = d2;             c2 = coordinate1;             c3 = coordinate3;         }         double d3 = distance3d(c, coordinate3, null);         if (d3 < d) {             nearest = coordinate3;             c2 = coordinate1;             c3 = coordinate2;         }         return new Coordinate[]{nearest, c2, c3};     }"
"private static void summarizeNBModel(ModelSummary summary, hex.nb.NBModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""Naive Bayes"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, NB_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, NB_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, NB_expert_params);
  }",1,print model summary,"print model summary<CODESPLIT>private static void summarizeNBModel(ModelSummary summary, hex.nb.NBModel model) {     // add generic fields such as column names     summarizeModelCommonFields(summary, model);      summary.model_algorithm = ""Naive Bayes"";      JsonObject all_params = (model.get_params()).toJSON();     summary.critical_parameters = whitelistJsonObject(all_params, NB_critical_params);     summary.secondary_parameters = whitelistJsonObject(all_params, NB_secondary_params);     summary.expert_parameters = whitelistJsonObject(all_params, NB_expert_params);   }"
"public static void concatenate(List<File> files, File concatenatedFile) {

        BufferedWriter writer;
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(concatenatedFile.getAbsoluteFile(),
                    false), DataUtilDefaults.charSet));

            FileInputStream inputStream;
            for(File input : files) {
                inputStream = new FileInputStream(input);
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, ""UTF-8""));
                String line;
                while((line = reader.readLine()) != null) {
                    writer.write(line + DataUtilDefaults.lineTerminator);
                }
                inputStream.close();
            }
            writer.flush();
            writer.close();
        } catch (UnsupportedEncodingException e) {
            throw new DataUtilException(e);
        } catch (FileNotFoundException e) {
            throw new DataUtilException(e);
        } catch (IOException e) {
            throw new DataUtilException(e);
        }
    }",2,concatenate several file remove header lines,"concatenate several file remove header lines<CODESPLIT>public static void concatenate(List<File> files, File concatenatedFile) {          BufferedWriter writer;         try {             writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(concatenatedFile.getAbsoluteFile(),                     false), DataUtilDefaults.charSet));              FileInputStream inputStream;             for(File input : files) {                 inputStream = new FileInputStream(input);                 BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, ""UTF-8""));                 String line;                 while((line = reader.readLine()) != null) {                     writer.write(line + DataUtilDefaults.lineTerminator);                 }                 inputStream.close();             }             writer.flush();             writer.close();         } catch (UnsupportedEncodingException e) {             throw new DataUtilException(e);         } catch (FileNotFoundException e) {             throw new DataUtilException(e);         } catch (IOException e) {             throw new DataUtilException(e);         }     }"
"public static long binCoeff(int n, int k) {
                if (k > n) {
                        return 0;
                }
                if (k == 0 || k == n) {
                        return 1;
                }
                long result = 1;
                for (int i = 1; i <= k; i++) {
                        result *= (n - i + 1) / i;
                }
                return result;
        }",3,binomial distribution,"binomial distribution<CODESPLIT>public static long binCoeff(int n, int k) {                 if (k > n) {                         return 0;                 }                 if (k == 0 || k == n) {                         return 1;                 }                 long result = 1;                 for (int i = 1; i <= k; i++) {                         result *= (n - i + 1) / i;                 }                 return result;         }"
"private void convertHTMLCode(ArrayList<ArrayList<TextPiece>> wordsByPage) {
	DocInfo docInfo = new DocInfo();
	String[] html2Char = docInfo.getHtml2CharMapping(); // Only define this
							    // mapping string
							    // when we detect
							    // the files in HTML
							    // codes
	int pageNum = 0;

	for (ArrayList<TextPiece> wordsOfAPage : wordsByPage) {
	    pageNum++;
	    for (int i = 0; i < wordsOfAPage.size(); i++) {
		TextPiece currentWord = wordsOfAPage.get(i);
		String realText = """";
		String textinHTMLCode = currentWord.getText();

	    }
	}
    }",0,convert html to pdf,"convert html to pdf<CODESPLIT>private void convertHTMLCode(ArrayList<ArrayList<TextPiece>> wordsByPage) { 	DocInfo docInfo = new DocInfo(); 	String[] html2Char = docInfo.getHtml2CharMapping(); // Only define this 							    // mapping string 							    // when we detect 							    // the files in HTML 							    // codes 	int pageNum = 0;  	for (ArrayList<TextPiece> wordsOfAPage : wordsByPage) { 	    pageNum++; 	    for (int i = 0; i < wordsOfAPage.size(); i++) { 		TextPiece currentWord = wordsOfAPage.get(i); 		String realText = """"; 		String textinHTMLCode = currentWord.getText();  	    } 	}     }"
"public Matrix multiply(Matrix B)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C);
        return C;
    }",1,matrix multiply,"matrix multiply<CODESPLIT>public Matrix multiply(Matrix B)     {         Matrix C = new DenseMatrix(this.rows(), B.cols());         multiply(B, C);         return C;     }"
"public static Date formatToStartOfDay(final Date date) {

    try {
      SimpleDateFormat dateFormat = buildDateFormat(DEFAULT_DATE_SIMPLE_PATTERN);
      String formattedDate = dateFormat.format(date);
      return dateFormat.parse(formattedDate);
    } catch (ParseException pe) {
      throw new DateException(""Unparseable date specified."", pe);
    }
  }",2,format date,"format date<CODESPLIT>public static Date formatToStartOfDay(final Date date) {      try {       SimpleDateFormat dateFormat = buildDateFormat(DEFAULT_DATE_SIMPLE_PATTERN);       String formattedDate = dateFormat.format(date);       return dateFormat.parse(formattedDate);     } catch (ParseException pe) {       throw new DateException(""Unparseable date specified."", pe);     }   }"
"public void printHtmlFooter(PrintWriter out, ResourceBundle reg)
    {
        String strHTML = reg.getString(""htmlFooter"");
        if ((strHTML == null) || (strHTML.length() == 0))
            strHTML = ""</body>\n</html>"";
        out.println(strHTML);
        out.flush();
    }",3,output to html file,"output to html file<CODESPLIT>public void printHtmlFooter(PrintWriter out, ResourceBundle reg)     {         String strHTML = reg.getString(""htmlFooter"");         if ((strHTML == null) || (strHTML.length() == 0))             strHTML = ""</body>\n</html>"";         out.println(strHTML);         out.flush();     }"
"public static void replaceFile(String fileName, final Map<String, List<Replacer>> profiles, Charset charset)
      throws Exception, FileNotFoundException {
    File file = new File(fileName);
    if (file.isFile() && !file.isHidden()) {
      List<Replacer> replacers = profiles.get(Strings.substringAfterLast(fileName, "".""));
      if (null == replacers) { return; }
      logger.info(""processing {}"", fileName);
      String filecontent = Files.readFileToString(file, charset);
      filecontent = Replacer.process(filecontent, replacers);
      writeToFile(filecontent, fileName, charset);
    } else {
      String[] subFiles = file.list(new FilenameFilter() {
        public boolean accept(File dir, String name) {
          if (dir.isDirectory()) return true;
          boolean matched = false;
          for (String key : profiles.keySet()) {
            matched = name.endsWith(key);
            if (matched) return true;
          }
          return false;
        }
      });
      if (null != subFiles) {
        for (int i = 0; i < subFiles.length; i++) {
          replaceFile(fileName + '/' + subFiles[i], profiles, charset);
        }
      }
    }
  }",0,replace in file,"replace in file<CODESPLIT>public static void replaceFile(String fileName, final Map<String, List<Replacer>> profiles, Charset charset)       throws Exception, FileNotFoundException {     File file = new File(fileName);     if (file.isFile() && !file.isHidden()) {       List<Replacer> replacers = profiles.get(Strings.substringAfterLast(fileName, "".""));       if (null == replacers) { return; }       logger.info(""processing {}"", fileName);       String filecontent = Files.readFileToString(file, charset);       filecontent = Replacer.process(filecontent, replacers);       writeToFile(filecontent, fileName, charset);     } else {       String[] subFiles = file.list(new FilenameFilter() {         public boolean accept(File dir, String name) {           if (dir.isDirectory()) return true;           boolean matched = false;           for (String key : profiles.keySet()) {             matched = name.endsWith(key);             if (matched) return true;           }           return false;         }       });       if (null != subFiles) {         for (int i = 0; i < subFiles.length; i++) {           replaceFile(fileName + '/' + subFiles[i], profiles, charset);         }       }     }   }"
"public static byte[] decryptAES(SecretKey key, byte[] iv, byte[] encryptedBytes) throws
            NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        IvParameterSpec ivParameter = new IvParameterSpec(iv);
        // see http://stackoverflow.com/a/11506343
        Key encryptionKey = new SecretKeySpec(key.getEncoded(),""AES"");
        aesCipher.init(Cipher.DECRYPT_MODE, encryptionKey, ivParameter);
        return aesCipher.doFinal(encryptedBytes);
    }",1,aes encryption,"aes encryption<CODESPLIT>public static byte[] decryptAES(SecretKey key, byte[] iv, byte[] encryptedBytes) throws             NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,             InvalidKeyException, BadPaddingException, IllegalBlockSizeException {         Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");         IvParameterSpec ivParameter = new IvParameterSpec(iv);         // see http://stackoverflow.com/a/11506343         Key encryptionKey = new SecretKeySpec(key.getEncoded(),""AES"");         aesCipher.init(Cipher.DECRYPT_MODE, encryptionKey, ivParameter);         return aesCipher.doFinal(encryptedBytes);     }"
"public long getElapsedTicks() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerTick;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedTicks() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerTick; 	}
"public boolean verifyChecked(final By checkboxBy) {
		WebElement element = driver.findElement(checkboxBy);

		if (element.isSelected()) {
			LOG.info(""Checkbox: "" + element + "" is checked!"");
			return true;
		}

		LOG.info(""Checkbox: "" + element + "" is NOT checked!"");
		return false;
	}",3,how to check if a checkbox is checked,"how to check if a checkbox is checked<CODESPLIT>public boolean verifyChecked(final By checkboxBy) { 		WebElement element = driver.findElement(checkboxBy);  		if (element.isSelected()) { 			LOG.info(""Checkbox: "" + element + "" is checked!""); 			return true; 		}  		LOG.info(""Checkbox: "" + element + "" is NOT checked!""); 		return false; 	}"
"public <S> T manyToOneWithoutControl(final S source) {
		try{ return this.<T,S>getJMapper(relationalManyToOneMapper,source).getDestinationWithoutControl(source); }
		catch (Exception e) { return logAndReturnNull(e); }
	}",0,reading element from html - <td>,"reading element from html - <td><CODESPLIT>public <S> T manyToOneWithoutControl(final S source) { 		try{ return this.<T,S>getJMapper(relationalManyToOneMapper,source).getDestinationWithoutControl(source); } 		catch (Exception e) { return logAndReturnNull(e); } 	}"
"public static double similarDamerauLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - getDamerauLevenshteinDistance(s2, s1)) / (double) bigLength;
    }",1,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarDamerauLevenshtein(String s1, String s2) {         if (s1.equals(s2)) {             return 1.0;         }          // Make sure s1 is the longest string         if (s1.length() < s2.length()) {             String swap = s1;             s1 = s2;             s2 = swap;         }          int bigLength = s1.length();         return (bigLength - getDamerauLevenshteinDistance(s2, s1)) / (double) bigLength;     }"
"public long getElapsedSeconds() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerSs;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedSeconds() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerSs; 	}
"static String urlencode(final String s) {
		try {
			return URLEncoder.encode(s, CHARSET_NAME);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
	}",3,encode url,"encode url<CODESPLIT>static String urlencode(final String s) { 		try { 			return URLEncoder.encode(s, CHARSET_NAME); 		} catch (UnsupportedEncodingException e) { 			throw new RuntimeException(e); 		} 	}"
"public static void xmlConversionTypeIncorrect(String conversionName,String xmlPath,String className,String type){
		throw new XmlConversionTypeException(MSG.INSTANCE.message(xmlConversionTypeException,conversionName,xmlPath,className,type));
	}",0,json to xml conversion,"json to xml conversion<CODESPLIT>public static void xmlConversionTypeIncorrect(String conversionName,String xmlPath,String className,String type){ 		throw new XmlConversionTypeException(MSG.INSTANCE.message(xmlConversionTypeException,conversionName,xmlPath,className,type)); 	}"
"private CFile parseCFile( JSONObject jObj )
    {
        CFile cfile;

        if ( jObj.optBoolean( ""is_dir"", false ) ) {
            cfile = new CFolder( new CPath( jObj.getString( ""path"" ) ) );

        } else {
            cfile = new CBlob( new CPath( jObj.getString( ""path"" ) ), jObj.getLong( ""bytes"" ), jObj.getString( ""mime_type"" ) );
            String stringDate = jObj.getString( ""modified"" );

            try {
                // stringDate looks like: ""Fri, 07 Mar 2014 17:47:55 +0000""
                SimpleDateFormat sdf = new SimpleDateFormat( ""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US );
                Date modified = sdf.parse( stringDate );
                cfile.setModificationDate( modified );

            } catch ( ParseException ex ) {
                throw new CStorageException( ""Can't parse date modified: "" + stringDate + "" ("" + ex.getMessage() + "")"", ex );
            }
        }

        return cfile;
    }",1,parse json file,"parse json file<CODESPLIT>private CFile parseCFile( JSONObject jObj )     {         CFile cfile;          if ( jObj.optBoolean( ""is_dir"", false ) ) {             cfile = new CFolder( new CPath( jObj.getString( ""path"" ) ) );          } else {             cfile = new CBlob( new CPath( jObj.getString( ""path"" ) ), jObj.getLong( ""bytes"" ), jObj.getString( ""mime_type"" ) );             String stringDate = jObj.getString( ""modified"" );              try {                 // stringDate looks like: ""Fri, 07 Mar 2014 17:47:55 +0000""                 SimpleDateFormat sdf = new SimpleDateFormat( ""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US );                 Date modified = sdf.parse( stringDate );                 cfile.setModificationDate( modified );              } catch ( ParseException ex ) {                 throw new CStorageException( ""Can't parse date modified: "" + stringDate + "" ("" + ex.getMessage() + "")"", ex );             }         }          return cfile;     }"
"public long getElapsedHours() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerHh;
	}",2,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedHours() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerHh; 	}
"public void post(String jsonBody, Integer expectedResponseCode) throws IOException {
    HttpURLConnection conn = getUrlConnection();

    try {
      // send post request with json body for the topology
      if (!NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, jsonBody.getBytes())) {
        throw new IOException(""Failed to send POST to "" + endpointURI);
      }

      // check the response
      if (!NetworkUtils.checkHttpResponseCode(conn, expectedResponseCode)) {
        byte[] bytes = NetworkUtils.readHttpResponse(conn);
        LOG.log(Level.SEVERE, ""Failed to send POST request to endpoint"");
        LOG.log(Level.SEVERE, new String(bytes));
        throw new IOException(""Unexpected response from connection. Expected ""
            + expectedResponseCode + "" but received "" + conn.getResponseCode());
      }
    } finally {
      conn.disconnect();
    }
  }",3,httpclient post json,"httpclient post json<CODESPLIT>public void post(String jsonBody, Integer expectedResponseCode) throws IOException {     HttpURLConnection conn = getUrlConnection();      try {       // send post request with json body for the topology       if (!NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, jsonBody.getBytes())) {         throw new IOException(""Failed to send POST to "" + endpointURI);       }        // check the response       if (!NetworkUtils.checkHttpResponseCode(conn, expectedResponseCode)) {         byte[] bytes = NetworkUtils.readHttpResponse(conn);         LOG.log(Level.SEVERE, ""Failed to send POST request to endpoint"");         LOG.log(Level.SEVERE, new String(bytes));         throw new IOException(""Unexpected response from connection. Expected ""             + expectedResponseCode + "" but received "" + conn.getResponseCode());       }     } finally {       conn.disconnect();     }   }"
"public D getDestinationWithoutControl(D destination,final S source){
        try {
            return mapper.vVNotAllAll(destination, source);
        } catch (Exception e) { 
        	JmapperLog.error(e); 
        }
        return null;
	}",0,reading element from html - <td>,"reading element from html - <td><CODESPLIT>public D getDestinationWithoutControl(D destination,final S source){         try {             return mapper.vVNotAllAll(destination, source);         } catch (Exception e) {          	JmapperLog.error(e);          }         return null; 	}"
"public static CheckBox newCheckBox(final String id, final IModel<Boolean> model)
	{
		final CheckBox checkBox = new CheckBox(id, model);
		checkBox.setOutputMarkupId(true);
		return checkBox;
	}",1,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>public static CheckBox newCheckBox(final String id, final IModel<Boolean> model) 	{ 		final CheckBox checkBox = new CheckBox(id, model); 		checkBox.setOutputMarkupId(true); 		return checkBox; 	}"
"public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {

        if (port.startsWith(""["")) {
            port = port.substring(1, port.length() - 1);
        }
        if (!secure) {
            if (password == null) {
                password = ""stratio"";
            }
            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, user, password);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        } else {
            Properties props = new Properties();
            if (user != null) {
                props.setProperty(""user"", user);
            }
            if (ca != null) {
                props.setProperty(""sslrootcert"", ca);
            }
            if (crt != null) {
                props.setProperty(""sslcert"", crt);
            }
            if (key != null) {
                props.setProperty(""sslkey"", key);
            }
            props.setProperty(""password"", ""null"");
            props.setProperty(""ssl"", ""true"");
            props.setProperty(""sslmode"", ""verify-full"");


            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, props);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        }
    }",2,postgresql connection,"postgresql connection<CODESPLIT>public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {          if (port.startsWith(""["")) {             port = port.substring(1, port.length() - 1);         }         if (!secure) {             if (password == null) {                 password = ""stratio"";             }             try {                 myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, user, password);             } catch (SQLException se) {                 // log the exception                 this.getLogger().error(se.getMessage());                 // re-throw the exception                 throw se;             }          } else {             Properties props = new Properties();             if (user != null) {                 props.setProperty(""user"", user);             }             if (ca != null) {                 props.setProperty(""sslrootcert"", ca);             }             if (crt != null) {                 props.setProperty(""sslcert"", crt);             }             if (key != null) {                 props.setProperty(""sslkey"", key);             }             props.setProperty(""password"", ""null"");             props.setProperty(""ssl"", ""true"");             props.setProperty(""sslmode"", ""verify-full"");               try {                 myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, props);             } catch (SQLException se) {                 // log the exception                 this.getLogger().error(se.getMessage());                 // re-throw the exception                 throw se;             }          }     }"
"public static double kMeans(List<double[]> centroids, List<double[]> input) {
		int k = centroids.size();
		assert (k > 0);
		int d = centroids.get(0).length;
		int size = input.size();

		double[][] center = new double[k][];
		Iterator<double[]> iIter = centroids.iterator();
		for (int i = 0; i < k; i++) {
			center[i] = iIter.next();
		}

		double[][] newCenter = new double[k][d];
		double[] newCenterWeight = new double[k];
		int[] nearestCluster = new int[size];
		boolean converged;
		do {
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					newCenter[i][j] = 0.0;
				}
				newCenterWeight[i] = 0.0;
			}
			Iterator<double[]> lIter = input.iterator();
			for (int l = 0; l < size; l++) {
				// Calculates the distance from all points to all centroids
				double[] point = lIter.next();
				assert (d == point.length - 1);
				double minDistance = Double.POSITIVE_INFINITY;
				int closestCluster = -1;
				for (int i = 0; i < k; i++) {
					double distance = Metric.distance(center[i], point, 1);
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				// Sums up all points for the new centroids
				assert (closestCluster >= 0 && closestCluster < k);
				for (int j = 0; j < d; j++) {
					newCenter[closestCluster][j] += point[0] * point[j + 1];
				}
				newCenterWeight[closestCluster] += point[0];
				nearestCluster[l] = closestCluster;
			}

			// Calculates the new centroids
			converged = true;
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					if (newCenterWeight[i] != 0.0) {
						double newValue = newCenter[i][j] / newCenterWeight[i];
						if (newValue != center[i][j]) {
							converged = false;
						}
						center[i][j] = newValue;
					}
				}
			}
		} while (!converged);
		// Replaces the old centroids with the new ones
		for (int i = 0; i < k; i++) {
			centroids.set(i, center[i]);
		}

		// Calculates the costs of the solution
		double costs = 0.0;
		Iterator<double[]> lIter = input.iterator();
		for (int l = 0; l < size; l++) {
			double[] point = lIter.next();
			costs += point[0]
					* Metric.distanceSquared(center[nearestCluster[l]], point,
							1);
		}
		return costs;
	}",3,k means clustering,"k means clustering<CODESPLIT>public static double kMeans(List<double[]> centroids, List<double[]> input) { 		int k = centroids.size(); 		assert (k > 0); 		int d = centroids.get(0).length; 		int size = input.size();  		double[][] center = new double[k][]; 		Iterator<double[]> iIter = centroids.iterator(); 		for (int i = 0; i < k; i++) { 			center[i] = iIter.next(); 		}  		double[][] newCenter = new double[k][d]; 		double[] newCenterWeight = new double[k]; 		int[] nearestCluster = new int[size]; 		boolean converged; 		do { 			for (int i = 0; i < k; i++) { 				for (int j = 0; j < d; j++) { 					newCenter[i][j] = 0.0; 				} 				newCenterWeight[i] = 0.0; 			} 			Iterator<double[]> lIter = input.iterator(); 			for (int l = 0; l < size; l++) { 				// Calculates the distance from all points to all centroids 				double[] point = lIter.next(); 				assert (d == point.length - 1); 				double minDistance = Double.POSITIVE_INFINITY; 				int closestCluster = -1; 				for (int i = 0; i < k; i++) { 					double distance = Metric.distance(center[i], point, 1); 					if (distance < minDistance) { 						closestCluster = i; 						minDistance = distance; 					} 				}  				// Sums up all points for the new centroids 				assert (closestCluster >= 0 && closestCluster < k); 				for (int j = 0; j < d; j++) { 					newCenter[closestCluster][j] += point[0] * point[j + 1]; 				} 				newCenterWeight[closestCluster] += point[0]; 				nearestCluster[l] = closestCluster; 			}  			// Calculates the new centroids 			converged = true; 			for (int i = 0; i < k; i++) { 				for (int j = 0; j < d; j++) { 					if (newCenterWeight[i] != 0.0) { 						double newValue = newCenter[i][j] / newCenterWeight[i]; 						if (newValue != center[i][j]) { 							converged = false; 						} 						center[i][j] = newValue; 					} 				} 			} 		} while (!converged); 		// Replaces the old centroids with the new ones 		for (int i = 0; i < k; i++) { 			centroids.set(i, center[i]); 		}  		// Calculates the costs of the solution 		double costs = 0.0; 		Iterator<double[]> lIter = input.iterator(); 		for (int l = 0; l < size; l++) { 			double[] point = lIter.next(); 			costs += point[0] 					* Metric.distanceSquared(center[nearestCluster[l]], point, 							1); 		} 		return costs; 	}"
"public ArrayList<Duration> segmentWork(ProjectCalendar projectCalendar, List<TimephasedWork> work, TimescaleUnits rangeUnits, List<DateRange> dateList)
   {
      ArrayList<Duration> result = new ArrayList<Duration>(dateList.size());
      int lastStartIndex = 0;

      //
      // Iterate through the list of dates range we are interested in.
      // Each date range in this list corresponds to a column
      // shown on the ""timescale"" view by MS Project
      //
      for (DateRange range : dateList)
      {
         //
         // If the current date range does not intersect with any of the
         // assignment date ranges in the list, then we show a zero
         // duration for this date range.
         //
         int startIndex = lastStartIndex == -1 ? -1 : getStartIndex(range, work, lastStartIndex);
         if (startIndex == -1)
         {
            result.add(Duration.getInstance(0, TimeUnit.HOURS));
         }
         else
         {
            //
            // We have found an assignment which intersects with the current
            // date range, call the method below to determine how
            // much time from this resource assignment can be allocated
            // to the current date range.
            //
            result.add(getRangeDuration(projectCalendar, rangeUnits, range, work, startIndex));
            lastStartIndex = startIndex;
         }
      }

      return result;
   }",0,how to get current date,"how to get current date<CODESPLIT>public ArrayList<Duration> segmentWork(ProjectCalendar projectCalendar, List<TimephasedWork> work, TimescaleUnits rangeUnits, List<DateRange> dateList)    {       ArrayList<Duration> result = new ArrayList<Duration>(dateList.size());       int lastStartIndex = 0;        //       // Iterate through the list of dates range we are interested in.       // Each date range in this list corresponds to a column       // shown on the ""timescale"" view by MS Project       //       for (DateRange range : dateList)       {          //          // If the current date range does not intersect with any of the          // assignment date ranges in the list, then we show a zero          // duration for this date range.          //          int startIndex = lastStartIndex == -1 ? -1 : getStartIndex(range, work, lastStartIndex);          if (startIndex == -1)          {             result.add(Duration.getInstance(0, TimeUnit.HOURS));          }          else          {             //             // We have found an assignment which intersects with the current             // date range, call the method below to determine how             // much time from this resource assignment can be allocated             // to the current date range.             //             result.add(getRangeDuration(projectCalendar, rangeUnits, range, work, startIndex));             lastStartIndex = startIndex;          }       }        return result;    }"
"private List decodeSort(String value) {
        ArrayList sorts = new ArrayList();

        String[] nameAndSorts = value.split(DELIM_GRID_NAME);
        if(nameAndSorts.length != 2)
            return null;

        String namespace = nameAndSorts[0];
        String[] sortStrings = nameAndSorts[1].split(DELIM_SORT_TERM);

        // find the list of sorted columns
        // two columns of the bugs grid would be sorted as:
        //
        // netui_sort=bugs~id,-priority
        for(int i = 0; i < sortStrings.length; i++) {
            String sort = sortStrings[i];
            SortDirection sortDirection = SortDirection.NONE;
            if(sort.startsWith(""-""))
                sortDirection = SortDirection.DESCENDING;
            else
                sortDirection = SortDirection.ASCENDING;
            String sortExpression = (sortDirection == SortDirection.DESCENDING ? sort.substring(1) : sort);
            Sort gridSort = _config.createSort();
            gridSort.setSortExpression(sortExpression);
            gridSort.setDirection(sortDirection);
            sorts.add(gridSort);
        }

        return sorts;
    }",1,sort string list,"sort string list<CODESPLIT>private List decodeSort(String value) {         ArrayList sorts = new ArrayList();          String[] nameAndSorts = value.split(DELIM_GRID_NAME);         if(nameAndSorts.length != 2)             return null;          String namespace = nameAndSorts[0];         String[] sortStrings = nameAndSorts[1].split(DELIM_SORT_TERM);          // find the list of sorted columns         // two columns of the bugs grid would be sorted as:         //         // netui_sort=bugs~id,-priority         for(int i = 0; i < sortStrings.length; i++) {             String sort = sortStrings[i];             SortDirection sortDirection = SortDirection.NONE;             if(sort.startsWith(""-""))                 sortDirection = SortDirection.DESCENDING;             else                 sortDirection = SortDirection.ASCENDING;             String sortExpression = (sortDirection == SortDirection.DESCENDING ? sort.substring(1) : sort);             Sort gridSort = _config.createSort();             gridSort.setSortExpression(sortExpression);             gridSort.setDirection(sortDirection);             sorts.add(gridSort);         }          return sorts;     }"
"protected Socket acceptSocket(int timeout)
    {
        try
        {
            Socket s = null;

            if (_listen != null)
            {
                if (_soTimeOut != timeout)
                {
                    _soTimeOut = timeout;
                    _listen.setSoTimeout(_soTimeOut);
                }

                s = _listen.accept();

                try
                {
                    if (getMaxIdleTimeMs() >= 0) s.setSoTimeout(getMaxIdleTimeMs());
                    if (_lingerTimeSecs >= 0)
                        s.setSoLinger(true, _lingerTimeSecs);
                    else
                        s.setSoLinger(false, 0);
                }
                catch (Exception e)
                {
                    LogSupport.ignore(log, e);
                }
            }
            return s;
        }
        catch (java.net.SocketException e)
        {
            // TODO - this is caught and ignored due strange
            // exception from linux java1.2.v1a
            LogSupport.ignore(log, e);
        }
        catch (InterruptedIOException e)
        {
            LogSupport.ignore(log, e);
        }
        catch (IOException e)
        {
            log.warn(LogSupport.EXCEPTION, e);
        }
        return null;
    }",2,socket recv timeout,"socket recv timeout<CODESPLIT>protected Socket acceptSocket(int timeout)     {         try         {             Socket s = null;              if (_listen != null)             {                 if (_soTimeOut != timeout)                 {                     _soTimeOut = timeout;                     _listen.setSoTimeout(_soTimeOut);                 }                  s = _listen.accept();                  try                 {                     if (getMaxIdleTimeMs() >= 0) s.setSoTimeout(getMaxIdleTimeMs());                     if (_lingerTimeSecs >= 0)                         s.setSoLinger(true, _lingerTimeSecs);                     else                         s.setSoLinger(false, 0);                 }                 catch (Exception e)                 {                     LogSupport.ignore(log, e);                 }             }             return s;         }         catch (java.net.SocketException e)         {             // TODO - this is caught and ignored due strange             // exception from linux java1.2.v1a             LogSupport.ignore(log, e);         }         catch (InterruptedIOException e)         {             LogSupport.ignore(log, e);         }         catch (IOException e)         {             log.warn(LogSupport.EXCEPTION, e);         }         return null;     }"
"public static <T> List<T> randomSample(Collection<T> collection, int n) {
		List<T> list = new ArrayList<T>(collection);
		List<T> sample = new ArrayList<T>(n);
		Random random = new Random();
		while(n > 0  &&  !list.isEmpty()) {
			int index = random.nextInt(list.size());
			sample.add(list.get(index));
			int indexLast = list.size() - 1;
			T last = list.remove(indexLast);
			if(index < indexLast) {
				list.set(index, last);
			}
			n--;
		}
		return sample;
	}",3,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public static <T> List<T> randomSample(Collection<T> collection, int n) { 		List<T> list = new ArrayList<T>(collection); 		List<T> sample = new ArrayList<T>(n); 		Random random = new Random(); 		while(n > 0  &&  !list.isEmpty()) { 			int index = random.nextInt(list.size()); 			sample.add(list.get(index)); 			int indexLast = list.size() - 1; 			T last = list.remove(indexLast); 			if(index < indexLast) { 				list.set(index, last); 			} 			n--; 		} 		return sample; 	}"
"private static boolean matchRuleRegex(String regex, String value) {

        if (value == null) {
            value = """";
        }

        if (regex == null) {
            return true;
        }
        if ((regex.length() > 0) && (regex.charAt(0) == '!')) {
            return !value.matches(regex.substring(1));
        } else {
            return value.matches(regex);
        }
    }",0,regex case insensitive,"regex case insensitive<CODESPLIT>private static boolean matchRuleRegex(String regex, String value) {          if (value == null) {             value = """";         }          if (regex == null) {             return true;         }         if ((regex.length() > 0) && (regex.charAt(0) == '!')) {             return !value.matches(regex.substring(1));         } else {             return value.matches(regex);         }     }"
"private void cut(XYChartLabel label, double maxWidth, double maxHeight, double rotation)
    {
        String text = label.getLabel().getText();

        // Cut text.
        cutLabelText(label, maxWidth - 5, maxHeight - 5, rotation);

        String cutText = label.getLabel().getText();

        // If text is cut, add suffix characters.
        if (text.length() != cutText.length())
        {
            label.getLabel().setText(label.getLabel().getText() + ""..."");
        }
        // TODO: Animate.
        // animate(label, text, cutText, originalRotation);

        // Move label to top.
        label.getLabelContainer().moveToTop();
    }",1,underline text in label widget,"underline text in label widget<CODESPLIT>private void cut(XYChartLabel label, double maxWidth, double maxHeight, double rotation)     {         String text = label.getLabel().getText();          // Cut text.         cutLabelText(label, maxWidth - 5, maxHeight - 5, rotation);          String cutText = label.getLabel().getText();          // If text is cut, add suffix characters.         if (text.length() != cutText.length())         {             label.getLabel().setText(label.getLabel().getText() + ""..."");         }         // TODO: Animate.         // animate(label, text, cutText, originalRotation);          // Move label to top.         label.getLabelContainer().moveToTop();     }"
"InputStream getInputStream() throws IOException {
        switch (filetype) {
            case GZ:
                LOG.debug(""Decompressing .gz file"");
                return new GzipCompressorInputStream(new FileInputStream(compressedFile));
            case BZ2:
                LOG.debug(""Decompressing .bz2 file"");
                return new BZip2CompressorInputStream(new FileInputStream(compressedFile));
        }
        return null;
    }",2,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>InputStream getInputStream() throws IOException {         switch (filetype) {             case GZ:                 LOG.debug(""Decompressing .gz file"");                 return new GzipCompressorInputStream(new FileInputStream(compressedFile));             case BZ2:                 LOG.debug(""Decompressing .bz2 file"");                 return new BZip2CompressorInputStream(new FileInputStream(compressedFile));         }         return null;     }"
"public static String getEnumName(Enum[] e, int value) {
        if (e != null) {
            int toCompareValue;
            for (Enum en : e) {
                if (en instanceof EnumReadable) {
                    toCompareValue = ((EnumReadable) en).value();
                } else {
                    toCompareValue = en.ordinal();
                }
                if (value == toCompareValue) {
                    return en.name();
                }
            }
        }
        return """";
    }",3,get name of enumerated value,"get name of enumerated value<CODESPLIT>public static String getEnumName(Enum[] e, int value) {         if (e != null) {             int toCompareValue;             for (Enum en : e) {                 if (en instanceof EnumReadable) {                     toCompareValue = ((EnumReadable) en).value();                 } else {                     toCompareValue = en.ordinal();                 }                 if (value == toCompareValue) {                     return en.name();                 }             }         }         return """";     }"
"public static String stripHtml(String html) {

        if (html == null) {
            return null;
        }
        Element el = DOM.createDiv();
        el.setInnerHTML(html);
        return el.getInnerText();
    }",0,get inner html,get inner html<CODESPLIT>public static String stripHtml(String html) {          if (html == null) {             return null;         }         Element el = DOM.createDiv();         el.setInnerHTML(html);         return el.getInnerText();     }
"public static Builder running(File executable) {
        checkArgument(executable.isFile(), ""file not found: %s"", executable);
        checkArgument(executable.canExecute(), ""executable.canExecute"");
        return running(executable.getPath());
    }",1,get executable path,"get executable path<CODESPLIT>public static Builder running(File executable) {         checkArgument(executable.isFile(), ""file not found: %s"", executable);         checkArgument(executable.canExecute(), ""executable.canExecute"");         return running(executable.getPath());     }"
"private void extract(String htmlDoc) {

    //now extract the contents of <body>...
    int bodyStart = htmlDoc.indexOf(BODY_BEGIN) + BODY_BEGIN.length();

    //scan for end of the <body> start tag (beginning of body content)
    char quote = NOT_IN_QUOTE;
    for (int body = bodyStart; body < htmlDoc.length(); body++) {
      final char c = htmlDoc.charAt(body);
      if (isQuoteChar(c)) {
        if (quote == NOT_IN_QUOTE)
          quote = c;
        else if (quote == c)
          quote = NOT_IN_QUOTE;
      }

      if ('>' == c && NOT_IN_QUOTE == quote) {
        bodyStart = body + 1;
        break;
      }
    }

    int bodyEnd = htmlDoc.indexOf(BODY_END, bodyStart);

    //if there was no body tag, just embed whatever was rendered directly
    if (-1 == bodyEnd) {
      EmbeddedRespond.this.body = htmlDoc;
    } else
      EmbeddedRespond.this.body = htmlDoc.substring(bodyStart, bodyEnd);
  }",2,extract data from html content,"extract data from html content<CODESPLIT>private void extract(String htmlDoc) {      //now extract the contents of <body>...     int bodyStart = htmlDoc.indexOf(BODY_BEGIN) + BODY_BEGIN.length();      //scan for end of the <body> start tag (beginning of body content)     char quote = NOT_IN_QUOTE;     for (int body = bodyStart; body < htmlDoc.length(); body++) {       final char c = htmlDoc.charAt(body);       if (isQuoteChar(c)) {         if (quote == NOT_IN_QUOTE)           quote = c;         else if (quote == c)           quote = NOT_IN_QUOTE;       }        if ('>' == c && NOT_IN_QUOTE == quote) {         bodyStart = body + 1;         break;       }     }      int bodyEnd = htmlDoc.indexOf(BODY_END, bodyStart);      //if there was no body tag, just embed whatever was rendered directly     if (-1 == bodyEnd) {       EmbeddedRespond.this.body = htmlDoc;     } else       EmbeddedRespond.this.body = htmlDoc.substring(bodyStart, bodyEnd);   }"
"public boolean isCheckBoxChecked(String text)
	{
		if(config.commandLogging){
			Log.d(config.commandLoggingTag, ""isCheckBoxChecked(\""""+text+""\"")"");
		}
		
		return checker.isButtonChecked(CheckBox.class, text);
	}",3,how to check if a checkbox is checked,"how to check if a checkbox is checked<CODESPLIT>public boolean isCheckBoxChecked(String text) 	{ 		if(config.commandLogging){ 			Log.d(config.commandLoggingTag, ""isCheckBoxChecked(\""""+text+""\"")""); 		} 		 		return checker.isButtonChecked(CheckBox.class, text); 	}"
"private CmsSearchIndexSource createDummyIndexSource() {

        CmsSearchIndexSource result = new CmsSearchIndexSource();
        result.setName(""default"");
        result.setIndexerClassName(""org.opencms.search.CmsVfsIndexer"");
        result.addDocumentType(""html"");
        result.addDocumentType(""generic"");
        result.addDocumentType(""pdf"");
        // add search index source to config:
        m_searchManager.addSearchIndexSource(result);
        return result;
    }",0,convert html to pdf,"convert html to pdf<CODESPLIT>private CmsSearchIndexSource createDummyIndexSource() {          CmsSearchIndexSource result = new CmsSearchIndexSource();         result.setName(""default"");         result.setIndexerClassName(""org.opencms.search.CmsVfsIndexer"");         result.addDocumentType(""html"");         result.addDocumentType(""generic"");         result.addDocumentType(""pdf"");         // add search index source to config:         m_searchManager.addSearchIndexSource(result);         return result;     }"
"public void save(File file) throws IOException {
        try (FileOutputStream fout = new FileOutputStream(file)) {
            save(fout);
        }
    }",1,save list to file,save list to file<CODESPLIT>public void save(File file) throws IOException {         try (FileOutputStream fout = new FileOutputStream(file)) {             save(fout);         }     }
"public static String reverse(final String s) {
		StringBuilder result = new StringBuilder(s.length());
		for (int i = s.length() -1; i >= 0; i--) {
			result.append(s.charAt(i));
		}
		return result.toString();
	}",2,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(final String s) { 		StringBuilder result = new StringBuilder(s.length()); 		for (int i = s.length() -1; i >= 0; i--) { 			result.append(s.charAt(i)); 		} 		return result.toString(); 	}
"public static File getExecutableLocation(final String exeName) {
    //
    // must add current working directory to the
    // from of the path from the ""path"" environment variable
    final File currentDir = new File(System.getProperty(""user.dir""));
    if (new File(currentDir, exeName).exists()) {
      return currentDir;
    }
    final File[] envPath = CUtil.getPathFromEnvironment(""PATH"", File.pathSeparator);
    for (final File element : envPath) {
      if (new File(element, exeName).exists()) {
        return element;
      }
    }
    return null;
  }",3,get executable path,"get executable path<CODESPLIT>public static File getExecutableLocation(final String exeName) {     //     // must add current working directory to the     // from of the path from the ""path"" environment variable     final File currentDir = new File(System.getProperty(""user.dir""));     if (new File(currentDir, exeName).exists()) {       return currentDir;     }     final File[] envPath = CUtil.getPathFromEnvironment(""PATH"", File.pathSeparator);     for (final File element : envPath) {       if (new File(element, exeName).exists()) {         return element;       }     }     return null;   }"
"public void sortIndices(SortCoupledArray_F64 sorter ) {
        if( sorter == null )
            sorter = new SortCoupledArray_F64();

        sorter.quick(col_idx,numCols+1,nz_rows,nz_values);
        indicesSorted = true;
    }",0,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public void sortIndices(SortCoupledArray_F64 sorter ) {         if( sorter == null )             sorter = new SortCoupledArray_F64();          sorter.quick(col_idx,numCols+1,nz_rows,nz_values);         indicesSorted = true;     }"
"private Date toDate(final String pStringDate) {

        // weird manipulation to parse the date... remove ':' from the timezone
        // before: 2011-07-12T22:42:40.000+02:00
        // after: 2011-07-12T22:42:40.000+0200
        final StringBuilder _date = new StringBuilder();
        _date.append(pStringDate.substring(0, pStringDate.length() - 3));
        _date.append(pStringDate.substring(pStringDate.length() - 2));
        try {
            return new SimpleDateFormat(RFC_339_DATE_FORMAT).parse(_date.toString());
        } catch (final ParseException e) {
            throw new IllegalArgumentException(
                    ""The given spreadsheet ListEntry usercrashdate field value is malformed"", e);
        }
    }",1,string to date,"string to date<CODESPLIT>private Date toDate(final String pStringDate) {          // weird manipulation to parse the date... remove ':' from the timezone         // before: 2011-07-12T22:42:40.000+02:00         // after: 2011-07-12T22:42:40.000+0200         final StringBuilder _date = new StringBuilder();         _date.append(pStringDate.substring(0, pStringDate.length() - 3));         _date.append(pStringDate.substring(pStringDate.length() - 2));         try {             return new SimpleDateFormat(RFC_339_DATE_FORMAT).parse(_date.toString());         } catch (final ParseException e) {             throw new IllegalArgumentException(                     ""The given spreadsheet ListEntry usercrashdate field value is malformed"", e);         }     }"
"public static void forHtmlUnquotedAttribute(Writer out, String input)
        throws IOException
    {
        encode(Encoders.HTML_UNQUOTED_ATTRIBUTE_ENCODER, out, input);
    }",2,html encode string,"html encode string<CODESPLIT>public static void forHtmlUnquotedAttribute(Writer out, String input)         throws IOException     {         encode(Encoders.HTML_UNQUOTED_ATTRIBUTE_ENCODER, out, input);     }"
"private void replaceInFile(String oldText, String newText) {
        StringBuilder oldContent = new StringBuilder();

        try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                oldContent.append(line);
                oldContent.append(""\r\n"");
            }
        } catch (IOException e) {
            log.error(e);
        }

        // replace a word in a file
        String newContent = oldContent.toString().replaceAll(oldText, newText);

        try (FileWriter writer = new FileWriter(file)) {
            writer.write(newContent);
        } catch (IOException ioe) {
            log.error(ioe);
        }
    }",3,replace in file,"replace in file<CODESPLIT>private void replaceInFile(String oldText, String newText) {         StringBuilder oldContent = new StringBuilder();          try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {             String line;             while ((line = reader.readLine()) != null) {                 oldContent.append(line);                 oldContent.append(""\r\n"");             }         } catch (IOException e) {             log.error(e);         }          // replace a word in a file         String newContent = oldContent.toString().replaceAll(oldText, newText);          try (FileWriter writer = new FileWriter(file)) {             writer.write(newContent);         } catch (IOException ioe) {             log.error(ioe);         }     }"
"private String listToCSV(List<String> list) {
        String csvStr = """";
        for (String item : list) {
            csvStr += "","" + item;
        }

        return csvStr.length() > 1 ? csvStr.substring(1) : csvStr;
    }",0,convert json to csv,"convert json to csv<CODESPLIT>private String listToCSV(List<String> list) {         String csvStr = """";         for (String item : list) {             csvStr += "","" + item;         }          return csvStr.length() > 1 ? csvStr.substring(1) : csvStr;     }"
"public static byte[] fromHex(String hex) {
        try {
            return Hex.decodeHex(hex.toCharArray());
        } catch (DecoderException e) {
            return null;
        }
    }",1,convert decimal to hex,convert decimal to hex<CODESPLIT>public static byte[] fromHex(String hex) {         try {             return Hex.decodeHex(hex.toCharArray());         } catch (DecoderException e) {             return null;         }     }
"public HtmlElement findHtmlElementById(String elementId) {
        try {
            return htmlPage.getHtmlElementById(elementId);
        } catch (ElementNotFoundException e) {
            return null;
        }
    }",2,reading element from html - <td>,reading element from html - <td><CODESPLIT>public HtmlElement findHtmlElementById(String elementId) {         try {             return htmlPage.getHtmlElementById(elementId);         } catch (ElementNotFoundException e) {             return null;         }     }
"public void writeExcelFile() throws IOException, WriteException {
        WritableWorkbook excelWrkBook = null;
        int curDsPointer = 0;

        try {
            final String[] columnNames = ds.getColumns();
            final List<String> exportOnlyColumnsList = getExportOnlyColumns() != null ? Arrays.asList(exportOnlyColumns) : null;
            final List<String> excludeFromExportColumnsList = getExcludeFromExportColumns() != null ? Arrays.asList(excludeFromExportColumns) : null;
            final List<String> numericColumnList = getNumericColumns() != null ? Arrays.asList(getNumericColumns()) : new ArrayList<>();
            // get the current position of the DataSet. We have to go to the top
            // to do this write,
            // and we will put the pionter back where it was after we are done
            curDsPointer = ds.getIndex();
            ds.goTop();

            excelWrkBook = Workbook.createWorkbook(xlsFile);
            final WritableSheet wrkSheet = excelWrkBook.createSheet(""results"", 0);

            final WritableFont times10ptBold = new WritableFont(WritableFont.TIMES, 10, WritableFont.BOLD);
            final WritableFont times10pt = new WritableFont(WritableFont.TIMES, 10, WritableFont.NO_BOLD);
            // write the column headings in the spreadsheet
            WritableCellFormat cellFormat = new WritableCellFormat(times10ptBold);
            int colOffset = 0;
            for (int i = 0; i < columnNames.length; i++) {
                if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                        || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                    colOffset++;
                    continue;
                }

                final Label xlsTextLbl = new Label(i - colOffset, 0, columnNames[i], cellFormat);
                wrkSheet.addCell(xlsTextLbl);
            }

            cellFormat = new WritableCellFormat(times10pt);
            int row = 1;
            while (ds.next()) {
                if (!ds.isRecordID(FPConstants.DETAIL_ID)) {
                    continue;
                }

                colOffset = 0;
                for (int i = 0; i < columnNames.length; i++) {
                    if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                            || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                        colOffset++;
                        continue;
                    }

                    WritableCell wc = null;
                    if (numericColumnList.contains(columnNames[i])) {
                        wc = new Number(i - colOffset, row, ds.getDouble(columnNames[i]), cellFormat);
                    } else {
                        wc = new Label(i - colOffset, row, ds.getString(columnNames[i]), cellFormat);
                    }

                    wrkSheet.addCell(wc);
                }

                row++;
            }

            excelWrkBook.write();

        } finally {
            if (curDsPointer > -1) {
                ds.absolute(curDsPointer);
            }
            if (excelWrkBook != null) {
                excelWrkBook.close();
            }
        }

    }",3,export to excel,"export to excel<CODESPLIT>public void writeExcelFile() throws IOException, WriteException {         WritableWorkbook excelWrkBook = null;         int curDsPointer = 0;          try {             final String[] columnNames = ds.getColumns();             final List<String> exportOnlyColumnsList = getExportOnlyColumns() != null ? Arrays.asList(exportOnlyColumns) : null;             final List<String> excludeFromExportColumnsList = getExcludeFromExportColumns() != null ? Arrays.asList(excludeFromExportColumns) : null;             final List<String> numericColumnList = getNumericColumns() != null ? Arrays.asList(getNumericColumns()) : new ArrayList<>();             // get the current position of the DataSet. We have to go to the top             // to do this write,             // and we will put the pionter back where it was after we are done             curDsPointer = ds.getIndex();             ds.goTop();              excelWrkBook = Workbook.createWorkbook(xlsFile);             final WritableSheet wrkSheet = excelWrkBook.createSheet(""results"", 0);              final WritableFont times10ptBold = new WritableFont(WritableFont.TIMES, 10, WritableFont.BOLD);             final WritableFont times10pt = new WritableFont(WritableFont.TIMES, 10, WritableFont.NO_BOLD);             // write the column headings in the spreadsheet             WritableCellFormat cellFormat = new WritableCellFormat(times10ptBold);             int colOffset = 0;             for (int i = 0; i < columnNames.length; i++) {                 if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])                         || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {                     colOffset++;                     continue;                 }                  final Label xlsTextLbl = new Label(i - colOffset, 0, columnNames[i], cellFormat);                 wrkSheet.addCell(xlsTextLbl);             }              cellFormat = new WritableCellFormat(times10pt);             int row = 1;             while (ds.next()) {                 if (!ds.isRecordID(FPConstants.DETAIL_ID)) {                     continue;                 }                  colOffset = 0;                 for (int i = 0; i < columnNames.length; i++) {                     if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])                             || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {                         colOffset++;                         continue;                     }                      WritableCell wc = null;                     if (numericColumnList.contains(columnNames[i])) {                         wc = new Number(i - colOffset, row, ds.getDouble(columnNames[i]), cellFormat);                     } else {                         wc = new Label(i - colOffset, row, ds.getString(columnNames[i]), cellFormat);                     }                      wrkSheet.addCell(wc);                 }                  row++;             }              excelWrkBook.write();          } finally {             if (curDsPointer > -1) {                 ds.absolute(curDsPointer);             }             if (excelWrkBook != null) {                 excelWrkBook.close();             }         }      }"
"public static <T, U> Function<T, U> memoize(final Function<T, U> function) {
    return new Memoizer<T, U>().doMemoize(function);
  }",0,memoize to disk  - persistent memoization,"memoize to disk  - persistent memoization<CODESPLIT>public static <T, U> Function<T, U> memoize(final Function<T, U> function) {     return new Memoizer<T, U>().doMemoize(function);   }"
"public static <T> T deserialize(byte[] input, Class<T> classType)
            throws JsonParseException, JsonMappingException, IOException {
        return mapper.readValue(input, classType);
    }",1,deserialize json,"deserialize json<CODESPLIT>public static <T> T deserialize(byte[] input, Class<T> classType)             throws JsonParseException, JsonMappingException, IOException {         return mapper.readValue(input, classType);     }"
"public static String readTextFile(File file) throws IOException
    {
        //create reader to file (with default encoding)
        InputStream inputStream=new FileInputStream(file);
        Reader reader=IOHelper.createReader(inputStream,null);

        //read text
        String text=IOHelper.readTextStream(reader);
        
        return text;
    }",2,buffered file reader read text,"buffered file reader read text<CODESPLIT>public static String readTextFile(File file) throws IOException     {         //create reader to file (with default encoding)         InputStream inputStream=new FileInputStream(file);         Reader reader=IOHelper.createReader(inputStream,null);          //read text         String text=IOHelper.readTextStream(reader);                  return text;     }"
"public static double binomial(int k, double p, int n) {
        if(k<0 ||  p<0 || n<1) {
            throw new IllegalArgumentException(""All the parameters must be positive and n larger than 1."");
        }
        
        k = Math.min(k, n); 
        
        /*
        //Slow and can't handle large numbers
        $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);
        */

        //fast and can handle large numbers
        //Cdf(k)-Cdf(k-1)
        double probability = approxBinomialCdf(k,p,n); 
        if(k>0) {
            probability -= approxBinomialCdf(k-1,p,n);
        }
        
        return probability;
    }",3,binomial distribution,"binomial distribution<CODESPLIT>public static double binomial(int k, double p, int n) {         if(k<0 ||  p<0 || n<1) {             throw new IllegalArgumentException(""All the parameters must be positive and n larger than 1."");         }                  k = Math.min(k, n);                   /*         //Slow and can't handle large numbers         $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);         */          //fast and can handle large numbers         //Cdf(k)-Cdf(k-1)         double probability = approxBinomialCdf(k,p,n);          if(k>0) {             probability -= approxBinomialCdf(k-1,p,n);         }                  return probability;     }"
"@Override
  public List<Assignment> assign(Collection<String> suiteNames, int slaves, long seed) {
    // Read hints first.
    final Map<String,List<Long>> hints = ExecutionTimesReport.mergeHints(resources, suiteNames);

    // Preprocess and sort costs. Take the median for each suite's measurements as the 
    // weight to avoid extreme measurements from screwing up the average.
    final List<SuiteHint> costs = new ArrayList<>();
    for (String suiteName : suiteNames) {
      final List<Long> suiteHint = hints.get(suiteName);
      if (suiteHint != null) {
        // Take the median for each suite's measurements as the weight
        // to avoid extreme measurements from screwing up the average.
        Collections.sort(suiteHint);
        final Long median = suiteHint.get(suiteHint.size() / 2);
        costs.add(new SuiteHint(suiteName, median));
      }
    }
    Collections.sort(costs, SuiteHint.DESCENDING_BY_WEIGHT);

    // Apply the assignment heuristic.
    final PriorityQueue<SlaveLoad> pq = new PriorityQueue<SlaveLoad>(
        slaves, SlaveLoad.ASCENDING_BY_ESTIMATED_FINISH);
    for (int i = 0; i < slaves; i++) {
      pq.add(new SlaveLoad(i));
    }

    final List<Assignment> assignments = new ArrayList<>();
    for (SuiteHint hint : costs) {
      SlaveLoad slave = pq.remove();
      slave.estimatedFinish += hint.cost;
      pq.add(slave);

      owner.log(""Expected execution time for "" + hint.suiteName + "": "" +
          Duration.toHumanDuration(hint.cost),
          Project.MSG_DEBUG);

      assignments.add(new Assignment(hint.suiteName, slave.id, (int) hint.cost));
    }

    // Dump estimated execution times.
    TreeMap<Integer, SlaveLoad> ordered = new TreeMap<Integer, SlaveLoad>();
    while (!pq.isEmpty()) {
      SlaveLoad slave = pq.remove();
      ordered.put(slave.id, slave);
    }
    for (Integer id : ordered.keySet()) {
      final SlaveLoad slave = ordered.get(id);
      owner.log(String.format(Locale.ROOT, 
          ""Expected execution time on JVM J%d: %8.2fs"",
          slave.id,
          slave.estimatedFinish / 1000.0f), 
          verbose ? Project.MSG_INFO : Project.MSG_DEBUG);
    }

    return assignments;
  }",0,deducting the median from each column,"deducting the median from each column<CODESPLIT>@Override   public List<Assignment> assign(Collection<String> suiteNames, int slaves, long seed) {     // Read hints first.     final Map<String,List<Long>> hints = ExecutionTimesReport.mergeHints(resources, suiteNames);      // Preprocess and sort costs. Take the median for each suite's measurements as the      // weight to avoid extreme measurements from screwing up the average.     final List<SuiteHint> costs = new ArrayList<>();     for (String suiteName : suiteNames) {       final List<Long> suiteHint = hints.get(suiteName);       if (suiteHint != null) {         // Take the median for each suite's measurements as the weight         // to avoid extreme measurements from screwing up the average.         Collections.sort(suiteHint);         final Long median = suiteHint.get(suiteHint.size() / 2);         costs.add(new SuiteHint(suiteName, median));       }     }     Collections.sort(costs, SuiteHint.DESCENDING_BY_WEIGHT);      // Apply the assignment heuristic.     final PriorityQueue<SlaveLoad> pq = new PriorityQueue<SlaveLoad>(         slaves, SlaveLoad.ASCENDING_BY_ESTIMATED_FINISH);     for (int i = 0; i < slaves; i++) {       pq.add(new SlaveLoad(i));     }      final List<Assignment> assignments = new ArrayList<>();     for (SuiteHint hint : costs) {       SlaveLoad slave = pq.remove();       slave.estimatedFinish += hint.cost;       pq.add(slave);        owner.log(""Expected execution time for "" + hint.suiteName + "": "" +           Duration.toHumanDuration(hint.cost),           Project.MSG_DEBUG);        assignments.add(new Assignment(hint.suiteName, slave.id, (int) hint.cost));     }      // Dump estimated execution times.     TreeMap<Integer, SlaveLoad> ordered = new TreeMap<Integer, SlaveLoad>();     while (!pq.isEmpty()) {       SlaveLoad slave = pq.remove();       ordered.put(slave.id, slave);     }     for (Integer id : ordered.keySet()) {       final SlaveLoad slave = ordered.get(id);       owner.log(String.format(Locale.ROOT,            ""Expected execution time on JVM J%d: %8.2fs"",           slave.id,           slave.estimatedFinish / 1000.0f),            verbose ? Project.MSG_INFO : Project.MSG_DEBUG);     }      return assignments;   }"
"@Override
    public void write(byte[] data, int offset, int length) throws IllegalStateException, IOException{
        // validate state
        if (isClosed()) {
            throw new IllegalStateException(""Serial connection is not open; cannot 'write()'."");
        }

        // write serial data to transmit buffer
        com.pi4j.jni.Serial.write(fileDescriptor, data, offset, length);
    }",1,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>@Override     public void write(byte[] data, int offset, int length) throws IllegalStateException, IOException{         // validate state         if (isClosed()) {             throw new IllegalStateException(""Serial connection is not open; cannot 'write()'."");         }          // write serial data to transmit buffer         com.pi4j.jni.Serial.write(fileDescriptor, data, offset, length);     }"
"public static <T> T pickRandom (List<T> values, T skip, Random r)
    {
        int size = values.size();
        if (size < 2) {
            throw new IllegalArgumentException(
                ""Must have at least two elements [size="" + size + ""]"");
        }

        int pick = r.nextInt(size - 1);
        for (int ii = 0; ii < size; ii++) {
            T val = values.get(ii);
            if ((val != skip) && (pick-- == 0)) {
                return val;
            }
        }
        return null;
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static <T> T pickRandom (List<T> values, T skip, Random r)     {         int size = values.size();         if (size < 2) {             throw new IllegalArgumentException(                 ""Must have at least two elements [size="" + size + ""]"");         }          int pick = r.nextInt(size - 1);         for (int ii = 0; ii < size; ii++) {             T val = values.get(ii);             if ((val != skip) && (pick-- == 0)) {                 return val;             }         }         return null;     }"
"public static <T> Collection<List<T>> permutations(Collection<T> elements) {
        Collection<List<T>> result = new ArrayList<>();
        if (elements.isEmpty()) {
            result.add(new LinkedList<>());
            return result;
        }

        List<T> rest = new LinkedList<>(elements);
        T head = rest.remove(0);
        for (List<T> permutations : permutations(rest)) {
            List<List<T>> subLists = new ArrayList<>();
            for (int i = 0; i <= permutations.size(); i++) {
                List<T> subList = new ArrayList<>();
                subList.addAll(permutations);
                subList.add(i, head);
                subLists.add(subList);
            }
            result.addAll(subLists);
        }
        return result;
    }",3,all permutations of a list,"all permutations of a list<CODESPLIT>public static <T> Collection<List<T>> permutations(Collection<T> elements) {         Collection<List<T>> result = new ArrayList<>();         if (elements.isEmpty()) {             result.add(new LinkedList<>());             return result;         }          List<T> rest = new LinkedList<>(elements);         T head = rest.remove(0);         for (List<T> permutations : permutations(rest)) {             List<List<T>> subLists = new ArrayList<>();             for (int i = 0; i <= permutations.size(); i++) {                 List<T> subList = new ArrayList<>();                 subList.addAll(permutations);                 subList.add(i, head);                 subLists.add(subList);             }             result.addAll(subLists);         }         return result;     }"
"public List<T> nextPermutationAsList()
    {
        List<T> permutation = new ArrayList<T>(elements.length);
        return nextPermutationAsList(permutation);
    }",0,all permutations of a list,all permutations of a list<CODESPLIT>public List<T> nextPermutationAsList()     {         List<T> permutation = new ArrayList<T>(elements.length);         return nextPermutationAsList(permutation);     }
"protected static Clustering cleanUpKMeans(Clustering kMeansResult, ArrayList<CFCluster> microclusters) {
		/* Convert k-means result to CFClusters */
		int k = kMeansResult.size();
		CFCluster[] converted = new CFCluster[k];

		for (CFCluster mc : microclusters) {
		    // Find closest kMeans cluster
		    double minDistance = Double.MAX_VALUE;
		    int closestCluster = 0;
		    for (int i = 0; i < k; i++) {
		    	double distance = distance(kMeansResult.get(i).getCenter(), mc.getCenter());
				if (distance < minDistance) {
				    closestCluster = i;
				    minDistance = distance;
				}
		    }

		    // Add to cluster
		    if ( converted[closestCluster] == null ) {
		    	converted[closestCluster] = (CFCluster)mc.copy();
		    } else {
		    	converted[closestCluster].add(mc);
		    }
		}

		// Clean up
		int count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			count++;
		}

		CFCluster[] cleaned = new CFCluster[count];
		count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			cleaned[count++] = converted[i];
		}

		return new Clustering(cleaned);
	}",1,k means clustering,"k means clustering<CODESPLIT>protected static Clustering cleanUpKMeans(Clustering kMeansResult, ArrayList<CFCluster> microclusters) { 		/* Convert k-means result to CFClusters */ 		int k = kMeansResult.size(); 		CFCluster[] converted = new CFCluster[k];  		for (CFCluster mc : microclusters) { 		    // Find closest kMeans cluster 		    double minDistance = Double.MAX_VALUE; 		    int closestCluster = 0; 		    for (int i = 0; i < k; i++) { 		    	double distance = distance(kMeansResult.get(i).getCenter(), mc.getCenter()); 				if (distance < minDistance) { 				    closestCluster = i; 				    minDistance = distance; 				} 		    }  		    // Add to cluster 		    if ( converted[closestCluster] == null ) { 		    	converted[closestCluster] = (CFCluster)mc.copy(); 		    } else { 		    	converted[closestCluster].add(mc); 		    } 		}  		// Clean up 		int count = 0; 		for (int i = 0; i < converted.length; i++) { 		    if (converted[i] != null) 			count++; 		}  		CFCluster[] cleaned = new CFCluster[count]; 		count = 0; 		for (int i = 0; i < converted.length; i++) { 		    if (converted[i] != null) 			cleaned[count++] = converted[i]; 		}  		return new Clustering(cleaned); 	}"
"public byte[] getHardwareAddress()
  {
    if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {
      return new byte[] { 10, 0, 0, 0, 0, 10 };
    }
    
    for (NetworkInterfaceBase nic : getNetworkInterfaces()) {
      if (! nic.isLoopback()) {
        return nic.getHardwareAddress();
      }
    }
    
    try {
      InetAddress localHost = InetAddress.getLocalHost();
      
      return localHost.getAddress();
    } catch (Exception e) {
      log.log(Level.FINER, e.toString(), e);
    }
    
    return new byte[0];
  }",2,get current ip address,"get current ip address<CODESPLIT>public byte[] getHardwareAddress()   {     if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {       return new byte[] { 10, 0, 0, 0, 0, 10 };     }          for (NetworkInterfaceBase nic : getNetworkInterfaces()) {       if (! nic.isLoopback()) {         return nic.getHardwareAddress();       }     }          try {       InetAddress localHost = InetAddress.getLocalHost();              return localHost.getAddress();     } catch (Exception e) {       log.log(Level.FINER, e.toString(), e);     }          return new byte[0];   }"
"public String extract(String html, CETR.Parameters parameters) {
        html = clearText(html); //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines
        List<String> rows = extractRows(html); //
        
        List<Integer> selectedRowIds = selectRows(rows, parameters);
        
        StringBuilder sb = new StringBuilder(html.length());
        for(Integer rowId : selectedRowIds) {
            String row = rows.get(rowId);
            
            //extract the clear text from the selected row
            row = StringCleaner.removeExtraSpaces(HTMLParser.extractText(row));
            if(row.isEmpty()) {
                continue;
            }
            sb.append(row).append("" "");
        }
        
        return sb.toString().trim();
    }",3,extract data from html content,"extract data from html content<CODESPLIT>public String extract(String html, CETR.Parameters parameters) {         html = clearText(html); //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines         List<String> rows = extractRows(html); //                  List<Integer> selectedRowIds = selectRows(rows, parameters);                  StringBuilder sb = new StringBuilder(html.length());         for(Integer rowId : selectedRowIds) {             String row = rows.get(rowId);                          //extract the clear text from the selected row             row = StringCleaner.removeExtraSpaces(HTMLParser.extractText(row));             if(row.isEmpty()) {                 continue;             }             sb.append(row).append("" "");         }                  return sb.toString().trim();     }"
"public Closure<V> memoizeAtLeast(final int protectedCacheSize) {
        if (protectedCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the protectedCacheSize parameter for memoizeAtLeast."");

        return Memoize.buildSoftReferenceMemoizeFunction(protectedCacheSize, new ConcurrentSoftCache<Object, Object>(), this);
    }",0,memoize to disk  - persistent memoization,"memoize to disk  - persistent memoization<CODESPLIT>public Closure<V> memoizeAtLeast(final int protectedCacheSize) {         if (protectedCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the protectedCacheSize parameter for memoizeAtLeast."");          return Memoize.buildSoftReferenceMemoizeFunction(protectedCacheSize, new ConcurrentSoftCache<Object, Object>(), this);     }"
"public static String sort(String list, String sortType, String sortOrder, String delimiter) throws PageException {
	return _sort(toStringArray(listToArray(list, delimiter)), sortType, sortOrder, delimiter);
    }",1,sort string list,"sort string list<CODESPLIT>public static String sort(String list, String sortType, String sortOrder, String delimiter) throws PageException { 	return _sort(toStringArray(listToArray(list, delimiter)), sortType, sortOrder, delimiter);     }"
"public static void copyToClipboard(String text) {
		final StringSelection stringSelection = new StringSelection(text);
		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(stringSelection, stringSelection);
	}",2,copy to clipboard,"copy to clipboard<CODESPLIT>public static void copyToClipboard(String text) { 		final StringSelection stringSelection = new StringSelection(text); 		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); 		clipboard.setContents(stringSelection, stringSelection); 	}"
"public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {
    Preconditions.checkNotNull(csvData, ""Null CSV data"");
    Preconditions.checkNotNull(fileName, ""Null file name"");

    CSVWriter writer = null;
    try {
      writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));
      for (String[] line : csvData) {
        writer.writeNext(line);
      }
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }",3,write csv,"write csv<CODESPLIT>public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {     Preconditions.checkNotNull(csvData, ""Null CSV data"");     Preconditions.checkNotNull(fileName, ""Null file name"");      CSVWriter writer = null;     try {       writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));       for (String[] line : csvData) {         writer.writeNext(line);       }     } finally {       if (writer != null) {         writer.close();       }     }   }"
"public static String[] splitString(final String s, final char c) {
    final char[] chars = s.toCharArray();
    int num_substrings = 1;
    for (final char x : chars) {
      if (x == c) {
        num_substrings++;
      }
    }
    final String[] result = new String[num_substrings];
    final int len = chars.length;
    int start = 0;  // starting index in chars of the current substring.
    int pos = 0;    // current index in chars.
    int i = 0;      // number of the current substring.
    for (; pos < len; pos++) {
      if (chars[pos] == c) {
        result[i++] = new String(chars, start, pos - start);
        start = pos + 1;
      }
    }
    result[i] = new String(chars, start, pos - start);
    return result;
  }",0,positions of substrings in string,"positions of substrings in string<CODESPLIT>public static String[] splitString(final String s, final char c) {     final char[] chars = s.toCharArray();     int num_substrings = 1;     for (final char x : chars) {       if (x == c) {         num_substrings++;       }     }     final String[] result = new String[num_substrings];     final int len = chars.length;     int start = 0;  // starting index in chars of the current substring.     int pos = 0;    // current index in chars.     int i = 0;      // number of the current substring.     for (; pos < len; pos++) {       if (chars[pos] == c) {         result[i++] = new String(chars, start, pos - start);         start = pos + 1;       }     }     result[i] = new String(chars, start, pos - start);     return result;   }"
"public void completeGroup() {
		// Copy initial set to allow permutations to grow
		List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations);
		// Keep HashSet version of permutations for fast lookup.
		Set<List<Integer>> known = new HashSet<List<Integer>>(permutations);
		//breadth-first search through the map of all members
		List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations);
		while( currentLevel.size() > 0) {
			List<List<Integer>> nextLevel = new ArrayList<List<Integer>>();
			for( List<Integer> p : currentLevel) {
				for(List<Integer> gen : gens) {
					List<Integer> y = combine(p,gen);
					if(!known.contains(y)) {
						nextLevel.add(y);
						//bypass addPermutation(y) for performance
						permutations.add(y);
						known.add(y);
					}
				}
			}
			currentLevel = nextLevel;
		}
	}",1,all permutations of a list,"all permutations of a list<CODESPLIT>public void completeGroup() { 		// Copy initial set to allow permutations to grow 		List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations); 		// Keep HashSet version of permutations for fast lookup. 		Set<List<Integer>> known = new HashSet<List<Integer>>(permutations); 		//breadth-first search through the map of all members 		List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations); 		while( currentLevel.size() > 0) { 			List<List<Integer>> nextLevel = new ArrayList<List<Integer>>(); 			for( List<Integer> p : currentLevel) { 				for(List<Integer> gen : gens) { 					List<Integer> y = combine(p,gen); 					if(!known.contains(y)) { 						nextLevel.add(y); 						//bypass addPermutation(y) for performance 						permutations.add(y); 						known.add(y); 					} 				} 			} 			currentLevel = nextLevel; 		} 	}"
"public S animate(Timer timer)
	{
		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay);
		started = elapsed > transform.getDelay();
		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;

		if (!started && !renderBefore)
			return null;
		if (finished && !renderAfter)
			return null;

		transform.transform(transformable, elapsed);
		return transformable;
	}",2,finding time elapsed using a timer,"finding time elapsed using a timer<CODESPLIT>public S animate(Timer timer) 	{ 		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay); 		started = elapsed > transform.getDelay(); 		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;  		if (!started && !renderBefore) 			return null; 		if (finished && !renderAfter) 			return null;  		transform.transform(transformable, elapsed); 		return transformable; 	}"
"public static String reverse(String str) {
      if (str == null) {
          return null;
      }
      return new StringBuffer(str).reverse().toString();
  }",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(String str) {       if (str == null) {           return null;       }       return new StringBuffer(str).reverse().toString();   }
"public static <Key, Value, DistinctType> Aggregation<Key, Value, Set<DistinctType>> distinctValues() {
        AggType<Key, Value, Integer, DistinctType, Set<DistinctType>, Set<DistinctType>, Set<DistinctType>> aggType;
        aggType = new DistinctValuesAggregation<Key, Value, DistinctType>();
        return new AggregationAdapter<Key, Value, Set<DistinctType>>(aggType);
    }",0,hash set for counting distinct elements,"hash set for counting distinct elements<CODESPLIT>public static <Key, Value, DistinctType> Aggregation<Key, Value, Set<DistinctType>> distinctValues() {         AggType<Key, Value, Integer, DistinctType, Set<DistinctType>, Set<DistinctType>, Set<DistinctType>> aggType;         aggType = new DistinctValuesAggregation<Key, Value, DistinctType>();         return new AggregationAdapter<Key, Value, Set<DistinctType>>(aggType);     }"
"public static void main(String[] args) throws IOException {

        Arguments arguments = new Arguments().parse(args);

        if (arguments.isUseCommonsLang3()) {
            System.err.println(""--commons-lang3 is deprecated. Please remove the argument from your command-line arguments."");
        }

        Jsonschema2Pojo.generate(arguments);
    }",1,parse command line argument,"parse command line argument<CODESPLIT>public static void main(String[] args) throws IOException {          Arguments arguments = new Arguments().parse(args);          if (arguments.isUseCommonsLang3()) {             System.err.println(""--commons-lang3 is deprecated. Please remove the argument from your command-line arguments."");         }          Jsonschema2Pojo.generate(arguments);     }"
"public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {
        return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );
    }",2,deserialize json,"deserialize json<CODESPLIT>public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {         return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );     }"
"public Matrix multiply(Matrix m) throws MatrixException
    {
        // Validate m's dimensions.
        if (nCols != m.nRows) {
            throw new MatrixException(
                                MatrixException.INVALID_DIMENSIONS);
        }

        double pv[][] = new double[nRows][m.nCols];  // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < m.nCols; ++c) {
                double dot = 0;
                for (int k = 0; k < nCols; ++k) {
                    dot += values[r][k] * m.values[k][c];
                }
                pv[r][c] = dot;
            }
        }

        return new Matrix(pv);
    }",3,matrix multiply,matrix multiply<CODESPLIT>public Matrix multiply(Matrix m) throws MatrixException     {         // Validate m's dimensions.         if (nCols != m.nRows) {             throw new MatrixException(                                 MatrixException.INVALID_DIMENSIONS);         }          double pv[][] = new double[nRows][m.nCols];  // product values          // Compute values of the product.         for (int r = 0; r < nRows; ++r) {             for (int c = 0; c < m.nCols; ++c) {                 double dot = 0;                 for (int k = 0; k < nCols; ++k) {                     dot += values[r][k] * m.values[k][c];                 }                 pv[r][c] = dot;             }         }          return new Matrix(pv);     }
"public void groupsCountByComponentIdAndPermission(DbSession dbSession, List<Long> componentIds, ResultHandler resultHandler) {
    Map<String, Object> parameters = new HashMap<>(2);
    parameters.put(ANYONE_GROUP_PARAMETER, DefaultGroups.ANYONE);

    executeLargeInputsWithoutOutput(
      componentIds,
      partitionedComponentIds -> {
        parameters.put(""componentIds"", partitionedComponentIds);
        mapper(dbSession).groupsCountByProjectIdAndPermission(parameters, resultHandler);
      });
  }",0,group by count,"group by count<CODESPLIT>public void groupsCountByComponentIdAndPermission(DbSession dbSession, List<Long> componentIds, ResultHandler resultHandler) {     Map<String, Object> parameters = new HashMap<>(2);     parameters.put(ANYONE_GROUP_PARAMETER, DefaultGroups.ANYONE);      executeLargeInputsWithoutOutput(       componentIds,       partitionedComponentIds -> {         parameters.put(""componentIds"", partitionedComponentIds);         mapper(dbSession).groupsCountByProjectIdAndPermission(parameters, resultHandler);       });   }"
"public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) {
		((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution);
	}",1,binomial distribution,"binomial distribution<CODESPLIT>public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) { 		((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution); 	}"
"public static String getHttpStatusCodeText(int sc) {
        HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);
        if (sCode == null) {
            return sc + "" <unknown status code>"";
        } else {
            return sCode.toString();
        }
    }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getHttpStatusCodeText(int sc) {         HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);         if (sCode == null) {             return sc + "" <unknown status code>"";         } else {             return sCode.toString();         }     }"
"public static double[] linearReg(double[] xData, double[] yData) {
        sameArrayLen(xData, yData);
        double sumYValue = 0;
        double meanYValue = 0;
        double sumXValue = 0;
        double meanXValue = 0;
        double sumX = 0;
        double sumY = 0;
        double prod = 0;
        double NODATA = -9999;
        int nstat = xData.length;
        double[] regCoef = new double[3]; //(intercept, gradient, r?)
        int counter = 0;
        //calculating sums
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumYValue += yData[i];
                sumXValue += xData[i];
                counter++;
            }
        }
        //calculating means
        meanYValue = sumYValue / counter;
        meanXValue = sumXValue / counter;

        //calculating regression coefficients
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumX += Math.pow((xData[i] - meanXValue), 2);
                sumY += Math.pow((yData[i] - meanYValue), 2);
                prod += ((xData[i] - meanXValue) * (yData[i] - meanYValue));
            }
        }
        if (sumX > 0 && sumY > 0) {
            regCoef[1] = prod / sumX;  //gradient
            regCoef[0] = meanYValue - regCoef[1] * meanXValue; //intercept
            regCoef[2] = Math.pow((prod / Math.sqrt(sumX * sumY)), 2); //r?
        } else {
            regCoef[1] = 0;
            regCoef[0] = 0;
            regCoef[2] = 0;
        }
        return regCoef;
    }",3,linear regression,"linear regression<CODESPLIT>public static double[] linearReg(double[] xData, double[] yData) {         sameArrayLen(xData, yData);         double sumYValue = 0;         double meanYValue = 0;         double sumXValue = 0;         double meanXValue = 0;         double sumX = 0;         double sumY = 0;         double prod = 0;         double NODATA = -9999;         int nstat = xData.length;         double[] regCoef = new double[3]; //(intercept, gradient, r?)         int counter = 0;         //calculating sums         for (int i = 0; i < nstat; i++) {             if ((yData[i] != NODATA) && (xData[i] != NODATA)) {                 sumYValue += yData[i];                 sumXValue += xData[i];                 counter++;             }         }         //calculating means         meanYValue = sumYValue / counter;         meanXValue = sumXValue / counter;          //calculating regression coefficients         for (int i = 0; i < nstat; i++) {             if ((yData[i] != NODATA) && (xData[i] != NODATA)) {                 sumX += Math.pow((xData[i] - meanXValue), 2);                 sumY += Math.pow((yData[i] - meanYValue), 2);                 prod += ((xData[i] - meanXValue) * (yData[i] - meanYValue));             }         }         if (sumX > 0 && sumY > 0) {             regCoef[1] = prod / sumX;  //gradient             regCoef[0] = meanYValue - regCoef[1] * meanXValue; //intercept             regCoef[2] = Math.pow((prod / Math.sqrt(sumX * sumY)), 2); //r?         } else {             regCoef[1] = 0;             regCoef[0] = 0;             regCoef[2] = 0;         }         return regCoef;     }"
"public StaircasePlot staircase(String id, double[][] data, Color color) {
        if (data[0].length != 2 && data[0].length != 3) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        StaircasePlot plot = new StaircasePlot(data);
        plot.setID(id);
        plot.setColor(color);
        add(plot);
        return plot;
    }",0,scatter plot,"scatter plot<CODESPLIT>public StaircasePlot staircase(String id, double[][] data, Color color) {         if (data[0].length != 2 && data[0].length != 3) {             throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);         }          StaircasePlot plot = new StaircasePlot(data);         plot.setID(id);         plot.setColor(color);         add(plot);         return plot;     }"
"public static Date getDateWithPrevDays(int noOfDays) throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        currentDate.add(Calendar.DATE, -noOfDays);
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }",1,how to get current date,"how to get current date<CODESPLIT>public static Date getDateWithPrevDays(int noOfDays) throws ParseException {         Calendar currentDate = Calendar.getInstance();         currentDate.add(Calendar.DATE, -noOfDays);         SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);         String dateNow = formatter.format(currentDate.getTime());         return getDateFromString(dateNow);     }"
"private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {
    	JSONObject json = null;
        HttpClient postClient = HttpClientBuilder.create().build();
        HttpResponse response;
        
        try {
            response = postClient.execute(httpPost);
            
            if(response.getStatusLine().getStatusCode() == 200) {
                HttpEntity entity = response.getEntity();
                
                if (entity != null) {
                    InputStream instream = entity.getContent();  
                    String result = convertStreamToString(instream);
                    instream.close();
                    
                    json = new JSONObject(result);
                }
            } else {
            	json = UpworkRestClient.genError(response);
            }
        } catch (ClientProtocolException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");
        } catch (IOException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");
        } catch (JSONException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");  
        } catch (Exception e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());
        } finally {
            httpPost.abort();
        }
        
        return json;
    }",2,httpclient post json,"httpclient post json<CODESPLIT>private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {     	JSONObject json = null;         HttpClient postClient = HttpClientBuilder.create().build();         HttpResponse response;                  try {             response = postClient.execute(httpPost);                          if(response.getStatusLine().getStatusCode() == 200) {                 HttpEntity entity = response.getEntity();                                  if (entity != null) {                     InputStream instream = entity.getContent();                       String result = convertStreamToString(instream);                     instream.close();                                          json = new JSONObject(result);                 }             } else {             	json = UpworkRestClient.genError(response);             }         } catch (ClientProtocolException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");         } catch (IOException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");         } catch (JSONException e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");           } catch (Exception e) {             json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());         } finally {             httpPost.abort();         }                  return json;     }"
"private void parseCommandLineArgs(String[] args) throws ConfigurationException {
        if (args == null || args.length == 0) {
            return;
        }
        logger.info(""Parsing command line arguments"");
        m_commandLineArgs = args;
        
        try {
            for (int inx = 0; inx < args.length; inx++) {
                String arg = args[inx];
                if (arg.equals(""-?"") || arg.equalsIgnoreCase(""-h"") || arg.equalsIgnoreCase(""-help"")) {
                    System.out.println(""See documentation and doradus.yaml for help."");
                    System.exit(0);
                }
                Utils.require(arg.charAt(0) == '-', ""Unrecognized argument: %s"", arg);
                Utils.require(inx + 1 < args.length, ""A value is expected after: %s"", arg);
                String name = arg.substring(1);
                String value = args[++inx];
                setCommandLineParam(name, value);
            }
        } catch (Exception e) {
            logger.error(""Failed to parse command line arguments"", e);
            throw new ConfigurationException(""Failed to parse command line arguments"", e);
        }
    }",3,parse command line argument,"parse command line argument<CODESPLIT>private void parseCommandLineArgs(String[] args) throws ConfigurationException {         if (args == null || args.length == 0) {             return;         }         logger.info(""Parsing command line arguments"");         m_commandLineArgs = args;                  try {             for (int inx = 0; inx < args.length; inx++) {                 String arg = args[inx];                 if (arg.equals(""-?"") || arg.equalsIgnoreCase(""-h"") || arg.equalsIgnoreCase(""-help"")) {                     System.out.println(""See documentation and doradus.yaml for help."");                     System.exit(0);                 }                 Utils.require(arg.charAt(0) == '-', ""Unrecognized argument: %s"", arg);                 Utils.require(inx + 1 < args.length, ""A value is expected after: %s"", arg);                 String name = arg.substring(1);                 String value = args[++inx];                 setCommandLineParam(name, value);             }         } catch (Exception e) {             logger.error(""Failed to parse command line arguments"", e);             throw new ConfigurationException(""Failed to parse command line arguments"", e);         }     }"
"public NumberExpression<Long> countDistinct() {
        if (countDistinct == null) {
            countDistinct = Expressions.numberOperation(Long.class, Ops.AggOps.COUNT_DISTINCT_AGG, mixin);
        }
        return countDistinct;
    }",0,hash set for counting distinct elements,"hash set for counting distinct elements<CODESPLIT>public NumberExpression<Long> countDistinct() {         if (countDistinct == null) {             countDistinct = Expressions.numberOperation(Long.class, Ops.AggOps.COUNT_DISTINCT_AGG, mixin);         }         return countDistinct;     }"
"public String generateBsn() {
        String Result1 = """";
        int Nr9 = randomUtil.random(3);
        int Nr8 = randomUtil.random(10);
        int Nr7 = randomUtil.random(10);
        int Nr6 = randomUtil.random(10);
        int Nr5 = randomUtil.random(10);
        int Nr4 = randomUtil.random(10);
        int Nr3 = randomUtil.random(10);
        int Nr2 = randomUtil.random(10);
        int Nr1 = 0;
        int SofiNr = 0;
        if ((Nr9 == 0) && (Nr8 == 0) && (Nr7 == 0)) {
            Nr8 = 1;
        }
        SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2;
        Nr1 = floor(SofiNr - (floor(SofiNr / 11)) * 11);
        if (Nr1 > 9) {
            if (Nr2 > 0) {
                Nr2 -= 1;
                Nr1 = 8;
            } else {
                Nr2 += 1;
                Nr1 = 1;
            }
        }
        Result1 += Nr9;
        Result1 += Nr8;
        Result1 += Nr7;
        Result1 += Nr6;
        Result1 += Nr5;
        Result1 += Nr4;
        Result1 += Nr3;
        Result1 += Nr2;
        Result1 += Nr1;
        return Result1;
    }",1,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public String generateBsn() {         String Result1 = """";         int Nr9 = randomUtil.random(3);         int Nr8 = randomUtil.random(10);         int Nr7 = randomUtil.random(10);         int Nr6 = randomUtil.random(10);         int Nr5 = randomUtil.random(10);         int Nr4 = randomUtil.random(10);         int Nr3 = randomUtil.random(10);         int Nr2 = randomUtil.random(10);         int Nr1 = 0;         int SofiNr = 0;         if ((Nr9 == 0) && (Nr8 == 0) && (Nr7 == 0)) {             Nr8 = 1;         }         SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2;         Nr1 = floor(SofiNr - (floor(SofiNr / 11)) * 11);         if (Nr1 > 9) {             if (Nr2 > 0) {                 Nr2 -= 1;                 Nr1 = 8;             } else {                 Nr2 += 1;                 Nr1 = 1;             }         }         Result1 += Nr9;         Result1 += Nr8;         Result1 += Nr7;         Result1 += Nr6;         Result1 += Nr5;         Result1 += Nr4;         Result1 += Nr3;         Result1 += Nr2;         Result1 += Nr1;         return Result1;     }"
"@Override
  public EventRequest deserialize(JsonElement json, Type typeOfT,
      JsonDeserializationContext context)
      throws JsonParseException {
    Gson gson = new GsonBuilder()
        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
        .create();

    // API versions 2017-05-25 and earlier render `request` as a string
    // instead of a JSON object
    if (json.isJsonPrimitive()) {
      EventRequest request = new EventRequest();
      request.setId(json.getAsString());
      return request;
    } else {
      return gson.fromJson(json, typeOfT);
    }
  }",2,deserialize json,"deserialize json<CODESPLIT>@Override   public EventRequest deserialize(JsonElement json, Type typeOfT,       JsonDeserializationContext context)       throws JsonParseException {     Gson gson = new GsonBuilder()         .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)         .create();      // API versions 2017-05-25 and earlier render `request` as a string     // instead of a JSON object     if (json.isJsonPrimitive()) {       EventRequest request = new EventRequest();       request.setId(json.getAsString());       return request;     } else {       return gson.fromJson(json, typeOfT);     }   }"
"public static void extractZip(File zip, File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		try (ZipFile zipFile = new ZipFile(zip)) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();

			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();

				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName());
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					continue;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				//logger.info(""Extracting file: "" + entry.getName());
				try (InputStream inputStream = zipFile.getInputStream(entry)) {
					try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
						IOUtils.copy(inputStream, outputStream);
					}
				}
			}
		} catch (FileNotFoundException | NoSuchFileException e) {
			throw e;
		} catch (IOException e) {
			throw new IOException(""While extracting file "" + zip + "" to "" + toDir, e);
		}
	}",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(File zip, File toDir) throws IOException{ 		if(!toDir.exists()) { 			throw new IOException(""Directory '"" + toDir + ""' does not exist.""); 		}  		try (ZipFile zipFile = new ZipFile(zip)) { 			Enumeration<? extends ZipEntry> entries = zipFile.entries();  			while (entries.hasMoreElements()) { 				ZipEntry entry = entries.nextElement();  				File target = new File(toDir, entry.getName()); 				if (entry.isDirectory()) { 					// Assume directories are stored parents first then children. 					//logger.info(""Extracting directory: "" + entry.getName()); 					// This is not robust, just for demonstration purposes. 					if(!target.mkdirs()) { 						logger.warning(""Could not create directory "" + target); 					} 					continue; 				}  				// zips can contain nested files in sub-dirs without separate entries for the directories 				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) { 					logger.warning(""Could not create directory "" + target.getParentFile()); 				}  				//logger.info(""Extracting file: "" + entry.getName()); 				try (InputStream inputStream = zipFile.getInputStream(entry)) { 					try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) { 						IOUtils.copy(inputStream, outputStream); 					} 				} 			} 		} catch (FileNotFoundException | NoSuchFileException e) { 			throw e; 		} catch (IOException e) { 			throw new IOException(""While extracting file "" + zip + "" to "" + toDir, e); 		} 	}"
"public static <T extends EurekaEndpoint> List<T> randomize(List<T> list) {
        List<T> randomList = new ArrayList<>(list);
        if (randomList.size() < 2) {
            return randomList;
        }
        Random random = new Random(LOCAL_IPV4_ADDRESS.hashCode());
        int last = randomList.size() - 1;
        for (int i = 0; i < last; i++) {
            int pos = random.nextInt(randomList.size() - i);
            if (pos != i) {
                Collections.swap(randomList, i, pos);
            }
        }
        return randomList;
    }",0,randomly extract x items from a list,"randomly extract x items from a list<CODESPLIT>public static <T extends EurekaEndpoint> List<T> randomize(List<T> list) {         List<T> randomList = new ArrayList<>(list);         if (randomList.size() < 2) {             return randomList;         }         Random random = new Random(LOCAL_IPV4_ADDRESS.hashCode());         int last = randomList.size() - 1;         for (int i = 0; i < last; i++) {             int pos = random.nextInt(randomList.size() - i);             if (pos != i) {                 Collections.swap(randomList, i, pos);             }         }         return randomList;     }"
"public void check() {
        getDispatcher().beforeCheck(this);
        
        RemoteWebElement e = (RemoteWebElement) getElement();
        while (!e.isSelected()) {
            e.click();
        }
        if (Config.getBoolConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING)) {
            logUIAction(UIActions.CHECKED);
        }
        
        getDispatcher().afterCheck(this);
    }",1,how to check if a checkbox is checked,how to check if a checkbox is checked<CODESPLIT>public void check() {         getDispatcher().beforeCheck(this);                  RemoteWebElement e = (RemoteWebElement) getElement();         while (!e.isSelected()) {             e.click();         }         if (Config.getBoolConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING)) {             logUIAction(UIActions.CHECKED);         }                  getDispatcher().afterCheck(this);     }
"@Override
    public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {

        // need to use boxed primitives as we can't customise sorting of int primitives
        Integer[] indexes = new Integer[atomContainerCount];
        for (int i = 0; i < indexes.length; i++)
            indexes[i] = i;

        // proxy the index comparison to the atom container comparator
        Arrays.sort(indexes, new Comparator<Integer>() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return comparator.compare(atomContainers[o1], atomContainers[o2]);
            }
        });

        // copy the original arrays (we could modify in place with swaps but this is cleaner)
        IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
        Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);

        // order the arrays based on the order of the indices
        for (int i = 0; i < indexes.length; i++) {
            atomContainers[i] = containersTmp[indexes[i]];
            multipliers[i] = multipliersTmp[indexes[i]];
        }

    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>@Override     public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {          // need to use boxed primitives as we can't customise sorting of int primitives         Integer[] indexes = new Integer[atomContainerCount];         for (int i = 0; i < indexes.length; i++)             indexes[i] = i;          // proxy the index comparison to the atom container comparator         Arrays.sort(indexes, new Comparator<Integer>() {              @Override             public int compare(Integer o1, Integer o2) {                 return comparator.compare(atomContainers[o1], atomContainers[o2]);             }         });          // copy the original arrays (we could modify in place with swaps but this is cleaner)         IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);         Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);          // order the arrays based on the order of the indices         for (int i = 0; i < indexes.length; i++) {             atomContainers[i] = containersTmp[indexes[i]];             multipliers[i] = multipliersTmp[indexes[i]];         }      }"
"public static void extractZip(InputStream zip, final File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		// Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create
		// directories and files accordingly
		new ZipFileVisitor() {
			@Override
			public void visit(ZipEntry entry, InputStream data) throws IOException {
				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName() + "" to "" + target);
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					return;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				// it seems we cannot use IOUtils/FileUtils to copy as they close the stream
				int size;
				byte[] buffer = new byte[2048];
				try (OutputStream fout = new BufferedOutputStream(new FileOutputStream(target), buffer.length)) {
	                while ((size = data.read(buffer, 0, buffer.length)) != -1) {
	                    fout.write(buffer, 0, size);
	                }
				}
			}
		}.walk(zip);
	}",3,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(InputStream zip, final File toDir) throws IOException{ 		if(!toDir.exists()) { 			throw new IOException(""Directory '"" + toDir + ""' does not exist.""); 		}  		// Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create 		// directories and files accordingly 		new ZipFileVisitor() { 			@Override 			public void visit(ZipEntry entry, InputStream data) throws IOException { 				File target = new File(toDir, entry.getName()); 				if (entry.isDirectory()) { 					// Assume directories are stored parents first then children. 					//logger.info(""Extracting directory: "" + entry.getName() + "" to "" + target); 					// This is not robust, just for demonstration purposes. 					if(!target.mkdirs()) { 						logger.warning(""Could not create directory "" + target); 					} 					return; 				}  				// zips can contain nested files in sub-dirs without separate entries for the directories 				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) { 					logger.warning(""Could not create directory "" + target.getParentFile()); 				}  				// it seems we cannot use IOUtils/FileUtils to copy as they close the stream 				int size; 				byte[] buffer = new byte[2048]; 				try (OutputStream fout = new BufferedOutputStream(new FileOutputStream(target), buffer.length)) { 	                while ((size = data.read(buffer, 0, buffer.length)) != -1) { 	                    fout.write(buffer, 0, size); 	                } 				} 			} 		}.walk(zip); 	}"
"public void save(@NonNull File meanFile, @NonNull File stdFile) throws IOException {
        Nd4j.saveBinary(getMean(), meanFile);
        Nd4j.saveBinary(getStd(), stdFile);
    }",0,save list to file,"save list to file<CODESPLIT>public void save(@NonNull File meanFile, @NonNull File stdFile) throws IOException {         Nd4j.saveBinary(getMean(), meanFile);         Nd4j.saveBinary(getStd(), stdFile);     }"
"public void uncheckCheckboxInCell(int row, int column) {
        String checkboxLocator = getXPathBase() + ""tr["" + row + ""]/td["" + column + ""]/input"";
        CheckBox cb = new CheckBox(checkboxLocator);
        cb.uncheck();
    }",1,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>public void uncheckCheckboxInCell(int row, int column) {         String checkboxLocator = getXPathBase() + ""tr["" + row + ""]/td["" + column + ""]/input"";         CheckBox cb = new CheckBox(checkboxLocator);         cb.uncheck();     }"
"@SuppressWarnings(""unchecked"")
    public final T[] filter(final T[] objects) {
        final Collection<T> filtered = filter(Arrays.asList(objects));
        try {
            return filtered.toArray((T[]) Array.newInstance(objects
                    .getClass(), filtered.size()));
        } catch (ArrayStoreException ase) {
            Logger log = LoggerFactory.getLogger(Filter.class);
            log.warn(""Error converting to array - using default approach"", ase);
        }
        return (T[]) filtered.toArray();
    }",2,filter array,"filter array<CODESPLIT>@SuppressWarnings(""unchecked"")     public final T[] filter(final T[] objects) {         final Collection<T> filtered = filter(Arrays.asList(objects));         try {             return filtered.toArray((T[]) Array.newInstance(objects                     .getClass(), filtered.size()));         } catch (ArrayStoreException ase) {             Logger log = LoggerFactory.getLogger(Filter.class);             log.warn(""Error converting to array - using default approach"", ase);         }         return (T[]) filtered.toArray();     }"
"private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {
    try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName(""UTF-8""))) {
      CSVWriter csvWriter = new CSVWriter(streamWriter, ',');

      csvWriter.writeNext(columnHeaders);
      
      for (String[] row : rows) {
        csvWriter.writeNext(row);
      }

      csvWriter.close();
      
      return csvStream.toByteArray();
    }
  }",3,write csv,"write csv<CODESPLIT>private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {     try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName(""UTF-8""))) {       CSVWriter csvWriter = new CSVWriter(streamWriter, ',');        csvWriter.writeNext(columnHeaders);              for (String[] row : rows) {         csvWriter.writeNext(row);       }        csvWriter.close();              return csvStream.toByteArray();     }   }"
"public static double score(MultiLayerNetwork model, DataSetIterator testSet, RegressionValue regressionValue) {
        RegressionEvaluation eval = model.evaluateRegression(testSet);
        return getScoreFromRegressionEval(eval, regressionValue);
    }",0,linear regression,"linear regression<CODESPLIT>public static double score(MultiLayerNetwork model, DataSetIterator testSet, RegressionValue regressionValue) {         RegressionEvaluation eval = model.evaluateRegression(testSet);         return getScoreFromRegressionEval(eval, regressionValue);     }"
"public static IPAddressType getAddressType(String ipAddress)
    {
    	if(IPAddressUtil.isIPv4LiteralAddress(ipAddress))
    		return IPAddressType.IPV4;
    	
    	if(IPAddressUtil.isIPv6LiteralAddress(ipAddress))
    		return IPAddressType.IPV6;
    	
    	return IPAddressType.INVALID;
    }",1,get current ip address,get current ip address<CODESPLIT>public static IPAddressType getAddressType(String ipAddress)     {     	if(IPAddressUtil.isIPv4LiteralAddress(ipAddress))     		return IPAddressType.IPV4;     	     	if(IPAddressUtil.isIPv6LiteralAddress(ipAddress))     		return IPAddressType.IPV6;     	     	return IPAddressType.INVALID;     }
"public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {
        return seq(random.ints(randomNumberOrigin, randomNumberBound));
    }",2,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {         return seq(random.ints(randomNumberOrigin, randomNumberBound));     }"
"public void doAESEncryption() throws Exception{
		if(!initAESDone)
			initAES();
		cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
		//System.out.println(secretKey.getEncoded());
		cipher.init(Cipher.ENCRYPT_MODE, secretKey);
		AlgorithmParameters params = cipher.getParameters();
		iv = params.getParameterSpec(IvParameterSpec.class).getIV();
		secretCipher = cipher.doFinal(secretPlain);
		clearPlain();
	}",3,aes encryption,"aes encryption<CODESPLIT>public void doAESEncryption() throws Exception{ 		if(!initAESDone) 			initAES(); 		cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); 		//System.out.println(secretKey.getEncoded()); 		cipher.init(Cipher.ENCRYPT_MODE, secretKey); 		AlgorithmParameters params = cipher.getParameters(); 		iv = params.getParameterSpec(IvParameterSpec.class).getIV(); 		secretCipher = cipher.doFinal(secretPlain); 		clearPlain(); 	}"
"private File[] accept(File file, final boolean recursive) {
        // Custom filtering rules If you can loop (include subdirectories) or is the end of the file. Class (compiled java class file)
        return file.listFiles(file1 -> (recursive && file1.isDirectory()) || (file1.getName().endsWith("".class"")));
    }",0,parse binary file to custom class,"parse binary file to custom class<CODESPLIT>private File[] accept(File file, final boolean recursive) {         // Custom filtering rules If you can loop (include subdirectories) or is the end of the file. Class (compiled java class file)         return file.listFiles(file1 -> (recursive && file1.isDirectory()) || (file1.getName().endsWith("".class"")));     }"
"public TernaryVector generate() {
        HashSet<Integer> pos = new HashSet<Integer>();
        HashSet<Integer> neg = new HashSet<Integer>();
        
        // Randomly decide how many bits to set in the index vector based on the
        // variance.
        int bitsToSet = numVectorValues +
            (int)(RANDOM.nextDouble() * variance *
                  ((RANDOM.nextDouble() > .5) ? 1 : -1));

        for (int i = 0; i < bitsToSet; ++i) {
            boolean picked = false;
            // loop to ensure we actually pick the full number of bits
            while (!picked) {
                // pick some random index
                int index = RANDOM.nextInt(indexVectorLength);
                    
                // check that we haven't already added this index
                if (pos.contains(index) || neg.contains(index))
                    continue;
                    
                // decide positive or negative
                ((RANDOM.nextDouble() > .5) ? pos : neg).add(index);
                picked = true;
            }
        }
            
        int[] positive = new int[pos.size()];
        int[] negative = new int[neg.size()];

        Iterator<Integer> it = pos.iterator();
        for (int i = 0; i < positive.length; ++i) 
            positive[i] = it.next();

        it = neg.iterator();
        for (int i = 0; i < negative.length; ++i) 
            negative[i] = it.next();                

        // sort so we can use a binary search in getValue()
        Arrays.sort(positive);
        Arrays.sort(negative);
        return new TernaryVector(indexVectorLength, positive, negative);
    }",1,how to randomly pick a number,"how to randomly pick a number<CODESPLIT>public TernaryVector generate() {         HashSet<Integer> pos = new HashSet<Integer>();         HashSet<Integer> neg = new HashSet<Integer>();                  // Randomly decide how many bits to set in the index vector based on the         // variance.         int bitsToSet = numVectorValues +             (int)(RANDOM.nextDouble() * variance *                   ((RANDOM.nextDouble() > .5) ? 1 : -1));          for (int i = 0; i < bitsToSet; ++i) {             boolean picked = false;             // loop to ensure we actually pick the full number of bits             while (!picked) {                 // pick some random index                 int index = RANDOM.nextInt(indexVectorLength);                                      // check that we haven't already added this index                 if (pos.contains(index) || neg.contains(index))                     continue;                                      // decide positive or negative                 ((RANDOM.nextDouble() > .5) ? pos : neg).add(index);                 picked = true;             }         }                      int[] positive = new int[pos.size()];         int[] negative = new int[neg.size()];          Iterator<Integer> it = pos.iterator();         for (int i = 0; i < positive.length; ++i)              positive[i] = it.next();          it = neg.iterator();         for (int i = 0; i < negative.length; ++i)              negative[i] = it.next();                          // sort so we can use a binary search in getValue()         Arrays.sort(positive);         Arrays.sort(negative);         return new TernaryVector(indexVectorLength, positive, negative);     }"
"static
	public double probability(ContinuousDistribution distribution, Number x){

		if(distribution instanceof GaussianDistribution){
			return probability((GaussianDistribution)distribution, x);
		} else

		if(distribution instanceof PoissonDistribution){
			return probability((PoissonDistribution)distribution, x);
		}

		throw new UnsupportedElementException(distribution);
	}",2,normal distribution,"normal distribution<CODESPLIT>static 	public double probability(ContinuousDistribution distribution, Number x){  		if(distribution instanceof GaussianDistribution){ 			return probability((GaussianDistribution)distribution, x); 		} else  		if(distribution instanceof PoissonDistribution){ 			return probability((PoissonDistribution)distribution, x); 		}  		throw new UnsupportedElementException(distribution); 	}"
"private String formatDate(Date value)
   {
      return (value == null ? null : m_formats.getDateFormat().format(value));
   }",3,format date,format date<CODESPLIT>private String formatDate(Date value)    {       return (value == null ? null : m_formats.getDateFormat().format(value));    }
"public void setWorkDir(String dir) throws IOException
    {
        File workDir = new File(dir);

        if (!workDir.exists() || !workDir.canWrite() || !workDir.canRead())
        {
            throw new IOException(""Cannot access directory ""+dir);
        }
        _workDir = workDir;
    }",0,set working directory,"set working directory<CODESPLIT>public void setWorkDir(String dir) throws IOException     {         File workDir = new File(dir);          if (!workDir.exists() || !workDir.canWrite() || !workDir.canRead())         {             throw new IOException(""Cannot access directory ""+dir);         }         _workDir = workDir;     }"
"public JsonResponse apiPost(ApiParams data, ApiFileParams fileParams) throws IOException {
        return httpRequestJson(HttpRequestMethod.POST, data, fileParams);
    }",1,httpclient post json,"httpclient post json<CODESPLIT>public JsonResponse apiPost(ApiParams data, ApiFileParams fileParams) throws IOException {         return httpRequestJson(HttpRequestMethod.POST, data, fileParams);     }"
"public static double similarLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;
    }",2,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarLevenshtein(String s1, String s2) {         if (s1.equals(s2)) {             return 1.0;         }          // Make sure s1 is the longest string         if (s1.length() < s2.length()) {             String swap = s1;             s1 = s2;             s2 = swap;         }          int bigLength = s1.length();         return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;     }"
"public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {
        if (data[0].length != 2 && data[0].length != 3) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data, y, legend, palette);
        plot.setID(id);
        canvas.add(plot);

        return canvas;
    }",3,scatter plot,"scatter plot<CODESPLIT>public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {         if (data[0].length != 2 && data[0].length != 3) {             throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);         }          double[] lowerBound = Math.colMin(data);         double[] upperBound = Math.colMax(data);         PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);          ScatterPlot plot = new ScatterPlot(data, y, legend, palette);         plot.setID(id);         canvas.add(plot);          return canvas;     }"
"public static <E> Distribution<E> getDistributionFromPartiallySpecifiedCounter(Counter<E> c, int numKeys){
    Distribution<E> d;
    double total = c.totalCount();
    if (total >= 1.0){
      d = getDistribution(c);
      d.numberOfKeys = numKeys;
    } else {
      d = new Distribution<E>();
      d.numberOfKeys = numKeys;
      d.counter = c;
      d.reservedMass = 1.0 - total;
    }
    return d;
  }",0,normal distribution,"normal distribution<CODESPLIT>public static <E> Distribution<E> getDistributionFromPartiallySpecifiedCounter(Counter<E> c, int numKeys){     Distribution<E> d;     double total = c.totalCount();     if (total >= 1.0){       d = getDistribution(c);       d.numberOfKeys = numKeys;     } else {       d = new Distribution<E>();       d.numberOfKeys = numKeys;       d.counter = c;       d.reservedMass = 1.0 - total;     }     return d;   }"
"public Matrix multiply(double k)
    {
        double pv[][] = new double[nRows][nCols]; // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < nCols; ++c) {
                pv[r][c] = k*values[r][c];
            }
        }

        return new Matrix(pv);
    }",1,matrix multiply,matrix multiply<CODESPLIT>public Matrix multiply(double k)     {         double pv[][] = new double[nRows][nCols]; // product values          // Compute values of the product.         for (int r = 0; r < nRows; ++r) {             for (int c = 0; c < nCols; ++c) {                 pv[r][c] = k*values[r][c];             }         }          return new Matrix(pv);     }
"public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {
        if (!this.timeCharts.containsKey(scatterID)) {
            ScatterPlotGenerator scatter = new ScatterPlotGenerator();
            scatter.setTitle(scatterID);
            scatter.setXAxisLabel(xAxisLabel);
            scatter.setYAxisLabel(yAxisLabel);
            this.scatterPlots.put(scatterID, scatter);
        } else {
            throw new DuplicatedChartIDException(scatterID);
        }
    }",2,scatter plot,"scatter plot<CODESPLIT>public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {         if (!this.timeCharts.containsKey(scatterID)) {             ScatterPlotGenerator scatter = new ScatterPlotGenerator();             scatter.setTitle(scatterID);             scatter.setXAxisLabel(xAxisLabel);             scatter.setYAxisLabel(yAxisLabel);             this.scatterPlots.put(scatterID, scatter);         } else {             throw new DuplicatedChartIDException(scatterID);         }     }"
"public ScatterPlot points(String id, double[][] data, Color color) {
        if (data[0].length != base.dimension) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        extendBound(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data);
        plot.setID(id);
        plot.setColor(color);
        add(plot);

        return plot;
    }",3,scatter plot,"scatter plot<CODESPLIT>public ScatterPlot points(String id, double[][] data, Color color) {         if (data[0].length != base.dimension) {             throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);         }          double[] lowerBound = Math.colMin(data);         double[] upperBound = Math.colMax(data);         extendBound(lowerBound, upperBound);          ScatterPlot plot = new ScatterPlot(data);         plot.setID(id);         plot.setColor(color);         add(plot);          return plot;     }"
"private int _checkInlineHtml (final MarkdownHCStack out, final String in, final int nStart)
  {
    final StringBuilder aTmp = new StringBuilder ();

    // Check for auto links
    aTmp.setLength (0);
    int nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, ':', ' ', '>', '\n');
    if (nPos != -1 && in.charAt (nPos) == ':' && MarkdownHTML.isLinkPrefix (aTmp.toString ()))
    {
      nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');
      if (nPos != -1)
      {
        final String sLink = aTmp.toString ();
        final HCA aLink = m_aConfig.getDecorator ().openLink (out);
        aLink.setHref (new SimpleURL (sLink)).addChild (sLink);
        m_aConfig.getDecorator ().closeLink (out);
        return nPos;
      }
    }

    // Check for mailto or address auto link
    aTmp.setLength (0);
    nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, '@', ' ', '>', '\n');
    if (nPos != -1 && in.charAt (nPos) == '@')
    {
      nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');
      if (nPos != -1)
      {
        final String sLink = aTmp.toString ();
        final HCA aLink = m_aConfig.getDecorator ().openLink (out);
        if (sLink.startsWith (""@""))
        {
          // address auto links
          final String sAddress = sLink.substring (1);
          final ISimpleURL aUrl = new SimpleURL (""https://maps.google.com/maps"").add (""q"", sAddress);
          aLink.setHref (aUrl).addChild (sAddress);
        }
        else
        {
          // mailto auto links
          aLink.setHref (new SimpleURL (""mailto:"" + sLink)).addChild (sLink);
        }
        m_aConfig.getDecorator ().closeLink (out);
        return nPos;
      }
    }

    // Check for inline html
    if (nStart + 2 < in.length ())
    {
      nPos = nStart;
      if (nStart + 3 < in.length () &&
          in.charAt (nStart + 1) == '!' &&
          in.charAt (nStart + 2) == '-' &&
          in.charAt (nStart + 3) == '-')
      {
        nPos = nStart + 4;
        final int nCommentStartPos = nPos;
        while (true)
        {
          while (nPos < in.length () && in.charAt (nPos) != '-')
            nPos++;

          if (nPos == in.length ())
          {
            // FIXME End of line in comment
            return -1;
          }
          if (nPos + 2 < in.length () && in.charAt (nPos + 1) == '-' && in.charAt (nPos + 2) == '>')
          {
            // XML comment inline
            out.append (new HCCommentNode (in.substring (nCommentStartPos, nPos)));
            return nPos + 2;
          }
          nPos++;
        }
      }

      aTmp.setLength (0);
      final int nNewPos = MarkdownHelper.readXMLElement (aTmp, in, nStart, m_aConfig.isSafeMode ());
      if (nNewPos != -1)
      {
        final String sElement = aTmp.toString ();
        if (sElement.endsWith (""/>""))
        {
          // Self closed tag - can be parsed
          final IMicroDocument aXML = MicroReader.readMicroXML (sElement);
          if (aXML == null)
            throw new MarkdownException (""Failed to parse XML: "" + sElement);
          // And use the root element
          out.append (new HCDOMWrapper (aXML.getDocumentElement ().detachFromParent ()));
        }
        else
          if (sElement.startsWith (""</""))
          {
            // Closing tag
            out.pop ();
          }
          else
          {
            // Opening tag - parse as self-closed tag and push to stack
            final String sParseCode = sElement.substring (0, sElement.length () - 1) + ""/>"";
            final IMicroDocument aXML = MicroReader.readMicroXML (sParseCode);
            if (aXML == null)
              throw new MarkdownException (""Failed to parse XML: "" + sParseCode);
            final IMicroElement eRoot = aXML.getDocumentElement ();

            // And use the root element
            final IHCElement <?> aHC = HCExtHelper.createHCElementFromName (eRoot.getTagName ());
            if (aHC == null)
              throw new MarkdownException (""Failed to get HC element: "" + eRoot.getTagName ());

            // Clone all attributes
            eRoot.forAllAttributes (aAttr -> aHC.customAttrs ().putIn (aAttr.getAttributeQName (),
                                                                       aAttr.getAttributeValue ()));

            if (aHC.getElement ().mayBeSelfClosed ())
            {
              // e.g. <hr />
              out.append (aHC);
            }
            else
            {
              // Push
              out.push (aHC);
            }
          }

        return nNewPos - 1;
      }
    }

    return -1;
  }",0,reading element from html - <td>,"reading element from html - <td><CODESPLIT>private int _checkInlineHtml (final MarkdownHCStack out, final String in, final int nStart)   {     final StringBuilder aTmp = new StringBuilder ();      // Check for auto links     aTmp.setLength (0);     int nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, ':', ' ', '>', '\n');     if (nPos != -1 && in.charAt (nPos) == ':' && MarkdownHTML.isLinkPrefix (aTmp.toString ()))     {       nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');       if (nPos != -1)       {         final String sLink = aTmp.toString ();         final HCA aLink = m_aConfig.getDecorator ().openLink (out);         aLink.setHref (new SimpleURL (sLink)).addChild (sLink);         m_aConfig.getDecorator ().closeLink (out);         return nPos;       }     }      // Check for mailto or address auto link     aTmp.setLength (0);     nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, '@', ' ', '>', '\n');     if (nPos != -1 && in.charAt (nPos) == '@')     {       nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');       if (nPos != -1)       {         final String sLink = aTmp.toString ();         final HCA aLink = m_aConfig.getDecorator ().openLink (out);         if (sLink.startsWith (""@""))         {           // address auto links           final String sAddress = sLink.substring (1);           final ISimpleURL aUrl = new SimpleURL (""https://maps.google.com/maps"").add (""q"", sAddress);           aLink.setHref (aUrl).addChild (sAddress);         }         else         {           // mailto auto links           aLink.setHref (new SimpleURL (""mailto:"" + sLink)).addChild (sLink);         }         m_aConfig.getDecorator ().closeLink (out);         return nPos;       }     }      // Check for inline html     if (nStart + 2 < in.length ())     {       nPos = nStart;       if (nStart + 3 < in.length () &&           in.charAt (nStart + 1) == '!' &&           in.charAt (nStart + 2) == '-' &&           in.charAt (nStart + 3) == '-')       {         nPos = nStart + 4;         final int nCommentStartPos = nPos;         while (true)         {           while (nPos < in.length () && in.charAt (nPos) != '-')             nPos++;            if (nPos == in.length ())           {             // FIXME End of line in comment             return -1;           }           if (nPos + 2 < in.length () && in.charAt (nPos + 1) == '-' && in.charAt (nPos + 2) == '>')           {             // XML comment inline             out.append (new HCCommentNode (in.substring (nCommentStartPos, nPos)));             return nPos + 2;           }           nPos++;         }       }        aTmp.setLength (0);       final int nNewPos = MarkdownHelper.readXMLElement (aTmp, in, nStart, m_aConfig.isSafeMode ());       if (nNewPos != -1)       {         final String sElement = aTmp.toString ();         if (sElement.endsWith (""/>""))         {           // Self closed tag - can be parsed           final IMicroDocument aXML = MicroReader.readMicroXML (sElement);           if (aXML == null)             throw new MarkdownException (""Failed to parse XML: "" + sElement);           // And use the root element           out.append (new HCDOMWrapper (aXML.getDocumentElement ().detachFromParent ()));         }         else           if (sElement.startsWith (""</""))           {             // Closing tag             out.pop ();           }           else           {             // Opening tag - parse as self-closed tag and push to stack             final String sParseCode = sElement.substring (0, sElement.length () - 1) + ""/>"";             final IMicroDocument aXML = MicroReader.readMicroXML (sParseCode);             if (aXML == null)               throw new MarkdownException (""Failed to parse XML: "" + sParseCode);             final IMicroElement eRoot = aXML.getDocumentElement ();              // And use the root element             final IHCElement <?> aHC = HCExtHelper.createHCElementFromName (eRoot.getTagName ());             if (aHC == null)               throw new MarkdownException (""Failed to get HC element: "" + eRoot.getTagName ());              // Clone all attributes             eRoot.forAllAttributes (aAttr -> aHC.customAttrs ().putIn (aAttr.getAttributeQName (),                                                                        aAttr.getAttributeValue ()));              if (aHC.getElement ().mayBeSelfClosed ())             {               // e.g. <hr />               out.append (aHC);             }             else             {               // Push               out.push (aHC);             }           }          return nNewPos - 1;       }     }      return -1;   }"
"@Override
	public String getRequestValue(final Request request) {
		if (isPresent(request)) {
			// User entered a valid date
			String dateParam = request.getParameter(getId() + ""-date"");
			if (dateParam == null) {
				return null;
			}

			// Validate Transfer Date Format - YYYY-MM-DD
			if (dateParam.length() != INTERNAL_DATE_TOTAL_CHARS || dateParam.charAt(
					INTERNAL_DASH1_POS) != '-'
					|| dateParam.charAt(INTERNAL_DASH2_POS) != '-') {
				LOG.warn(""Date parameter is not in the format yyyy-MM-dd ("" + dateParam
						+ "") and will be treated as null."");
				return null;
			}

			// Transform YYYY-MM-DD to YYYYMMDD
			StringBuffer buf = new StringBuffer(DATE_TOTAL_CHARS);
			buf.append(dateParam.substring(INTERNAL_YEAR_START, INTERNAL_YEAR_END));
			buf.append(dateParam.substring(INTERNAL_MONTH_START, INTERNAL_MONTH_END));
			buf.append(dateParam.substring(INTERNAL_DAY_START, INTERNAL_DAY_END));

			String dateFormat = buf.toString();

			// Validate the date
			if (!isValidPartialDateStringFormat(dateFormat, THEME_PADDING_CHAR)) {
				LOG.warn(""Date parameter (""
						+ dateParam
						+ "") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null."");
				return null;
			}

			// Convert from Theme padding character to the correct padding character
			return dateFormat.replace(THEME_PADDING_CHAR, getPaddingChar());
		} else {
			return getValue();
		}
	}",1,convert a date string into yyyymmdd,"convert a date string into yyyymmdd<CODESPLIT>@Override 	public String getRequestValue(final Request request) { 		if (isPresent(request)) { 			// User entered a valid date 			String dateParam = request.getParameter(getId() + ""-date""); 			if (dateParam == null) { 				return null; 			}  			// Validate Transfer Date Format - YYYY-MM-DD 			if (dateParam.length() != INTERNAL_DATE_TOTAL_CHARS || dateParam.charAt( 					INTERNAL_DASH1_POS) != '-' 					|| dateParam.charAt(INTERNAL_DASH2_POS) != '-') { 				LOG.warn(""Date parameter is not in the format yyyy-MM-dd ("" + dateParam 						+ "") and will be treated as null.""); 				return null; 			}  			// Transform YYYY-MM-DD to YYYYMMDD 			StringBuffer buf = new StringBuffer(DATE_TOTAL_CHARS); 			buf.append(dateParam.substring(INTERNAL_YEAR_START, INTERNAL_YEAR_END)); 			buf.append(dateParam.substring(INTERNAL_MONTH_START, INTERNAL_MONTH_END)); 			buf.append(dateParam.substring(INTERNAL_DAY_START, INTERNAL_DAY_END));  			String dateFormat = buf.toString();  			// Validate the date 			if (!isValidPartialDateStringFormat(dateFormat, THEME_PADDING_CHAR)) { 				LOG.warn(""Date parameter ("" 						+ dateParam 						+ "") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null.""); 				return null; 			}  			// Convert from Theme padding character to the correct padding character 			return dateFormat.replace(THEME_PADDING_CHAR, getPaddingChar()); 		} else { 			return getValue(); 		} 	}"
"public static Properties readPropertiesFromFile(String _fileName, Properties _props) {
        Properties props = _props == null ? new Properties() : _props;

        LOGGER.debug(""Trying to read properties from file: "" + _fileName);
        Properties newProperties = readProperties(new File(_fileName));
        if (newProperties != null) {
            LOGGER.debug(""Successfully read properties from file: "" + _fileName);
            props.putAll(newProperties);
        }

        return props;
    }",2,read properties file,"read properties file<CODESPLIT>public static Properties readPropertiesFromFile(String _fileName, Properties _props) {         Properties props = _props == null ? new Properties() : _props;          LOGGER.debug(""Trying to read properties from file: "" + _fileName);         Properties newProperties = readProperties(new File(_fileName));         if (newProperties != null) {             LOGGER.debug(""Successfully read properties from file: "" + _fileName);             props.putAll(newProperties);         }          return props;     }"
"protected PlotCanvas paintOnCanvas(double[][] data, int[] label) {
        PlotCanvas canvas = ScatterPlot.plot(data, pointLegend);
        for (int i = 0; i < data.length; i++) {
            canvas.point(pointLegend, Palette.COLORS[label[i]], data[i]);
        }
        return canvas;
    }",3,scatter plot,"scatter plot<CODESPLIT>protected PlotCanvas paintOnCanvas(double[][] data, int[] label) {         PlotCanvas canvas = ScatterPlot.plot(data, pointLegend);         for (int i = 0; i < data.length; i++) {             canvas.point(pointLegend, Palette.COLORS[label[i]], data[i]);         }         return canvas;     }"
"@HtmlSafe
	public String getBodyHtml()
	{
		String body = execution.getResults().trim();

		return body.replaceAll(""<html>"", """").replaceAll(""</html>"", """");
	}",0,how to get html of website,"how to get html of website<CODESPLIT>@HtmlSafe 	public String getBodyHtml() 	{ 		String body = execution.getResults().trim();  		return body.replaceAll(""<html>"", """").replaceAll(""</html>"", """"); 	}"
"public String getCsv() {

        StringWriter writer = new StringWriter();
        try (CSVWriter csv = new CSVWriter(writer)) {
            List<String> headers = new ArrayList<>();
            for (String col : m_columns) {
                headers.add(col);
            }
            csv.writeNext(headers.toArray(new String[] {}));
            for (List<Object> row : m_data) {
                List<String> colCsv = new ArrayList<>();
                for (Object col : row) {
                    colCsv.add(String.valueOf(col));
                }
                csv.writeNext(colCsv.toArray(new String[] {}));
            }
            return writer.toString();
        } catch (IOException e) {
            return null;
        }
    }",1,convert json to csv,convert json to csv<CODESPLIT>public String getCsv() {          StringWriter writer = new StringWriter();         try (CSVWriter csv = new CSVWriter(writer)) {             List<String> headers = new ArrayList<>();             for (String col : m_columns) {                 headers.add(col);             }             csv.writeNext(headers.toArray(new String[] {}));             for (List<Object> row : m_data) {                 List<String> colCsv = new ArrayList<>();                 for (Object col : row) {                     colCsv.add(String.valueOf(col));                 }                 csv.writeNext(colCsv.toArray(new String[] {}));             }             return writer.toString();         } catch (IOException e) {             return null;         }     }
"private void readPropertyFile()
	{
		java.util.Properties props = new java.util.Properties();
	    try
	    {
	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME);
	        if (propertyFile.exists())
	        {
	        	java.io.FileInputStream fis = null;
	        	try
	        	{
			    	fis = new java.io.FileInputStream(propertyFile);
			        props.load(fis);
	        	}
	        	finally
	        	{
	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); }
	        	}
	        }

	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR);
			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR);
			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName());
			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE""));
			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0""));
			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0""));
			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES);
			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++)
			{
				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null);
				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null);
			}
			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE"")));
			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1""));
			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410""));
			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1""));
			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230""));
			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false""));
			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1""));
			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630""));
			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false""));
			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1""));
			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400""));
			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false""));
			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1""));
			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470""));
			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false""));
			
			if (currentEqualizer!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE""));
				currentEqualizer.setIsActive(isActive);
				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0""));
				currentEqualizer.setPreAmp(preAmpValueDB);
				for (int i=0; i<currentEqualizer.getBandCount(); i++)
				{
					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0""));
					currentEqualizer.setBand(i, bandValueDB);
				}
			}
			if (currentPitchShift!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE""));
				currentPitchShift.setIsActive(isActive);
				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0""));
				currentPitchShift.setPitchScale(pitchValue);
				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0""));
				currentPitchShift.setSampleScale(scaleValue);
				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32""));
				currentPitchShift.setFFTOversampling(overSampling);
				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192""));
				currentPitchShift.setFFTFrameSize(frameSize);
			}

			MultimediaContainerManager.configureContainer(props);
	    }
	    catch (Throwable ex)
	    {
			Log.error(""[MainForm]"", ex);
	    }
	}",2,read properties file,"read properties file<CODESPLIT>private void readPropertyFile() 	{ 		java.util.Properties props = new java.util.Properties(); 	    try 	    { 	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME); 	        if (propertyFile.exists()) 	        { 	        	java.io.FileInputStream fis = null; 	        	try 	        	{ 			    	fis = new java.io.FileInputStream(propertyFile); 			        props.load(fis); 	        	} 	        	finally 	        	{ 	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); } 	        	} 	        }  	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR); 			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR); 			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName()); 			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE"")); 			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0"")); 			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0"")); 			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES); 			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++) 			{ 				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null); 				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null); 			} 			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE""))); 			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1"")); 			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410"")); 			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1"")); 			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230"")); 			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false"")); 			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1"")); 			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630"")); 			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false"")); 			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1"")); 			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400"")); 			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false"")); 			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1"")); 			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470"")); 			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false"")); 			 			if (currentEqualizer!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE"")); 				currentEqualizer.setIsActive(isActive); 				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0"")); 				currentEqualizer.setPreAmp(preAmpValueDB); 				for (int i=0; i<currentEqualizer.getBandCount(); i++) 				{ 					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0"")); 					currentEqualizer.setBand(i, bandValueDB); 				} 			} 			if (currentPitchShift!=null) 			{ 				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE"")); 				currentPitchShift.setIsActive(isActive); 				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0"")); 				currentPitchShift.setPitchScale(pitchValue); 				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0"")); 				currentPitchShift.setSampleScale(scaleValue); 				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32"")); 				currentPitchShift.setFFTOversampling(overSampling); 				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192"")); 				currentPitchShift.setFFTFrameSize(frameSize); 			}  			MultimediaContainerManager.configureContainer(props); 	    } 	    catch (Throwable ex) 	    { 			Log.error(""[MainForm]"", ex); 	    } 	}"
"public void csv(String file) throws IOException {
        CsvWriteOptions options = CsvWriteOptions.builder(file).build();
        new CsvWriter().write(table, options);
    }",3,write csv,"write csv<CODESPLIT>public void csv(String file) throws IOException {         CsvWriteOptions options = CsvWriteOptions.builder(file).build();         new CsvWriter().write(table, options);     }"
"public String find(PushbackReader in, int size) throws IOException, SyntaxErrorException
    {
        if (acceptEmpty)
        {
            throw new IllegalArgumentException(""using find for  '"" + expression + ""'  that accepts empty string"");
        }
        InputReader reader = Input.getInstance(in, size);
        int rc = find(reader);
        reader.release();
        if (rc == 1)
        {
            return reader.getString();
        }
        else
        {
            throw new SyntaxErrorException(""string matching  '"" + expression + ""'  not found"");
        }
    }",0,find int in string,"find int in string<CODESPLIT>public String find(PushbackReader in, int size) throws IOException, SyntaxErrorException     {         if (acceptEmpty)         {             throw new IllegalArgumentException(""using find for  '"" + expression + ""'  that accepts empty string"");         }         InputReader reader = Input.getInstance(in, size);         int rc = find(reader);         reader.release();         if (rc == 1)         {             return reader.getString();         }         else         {             throw new SyntaxErrorException(""string matching  '"" + expression + ""'  not found"");         }     }"
"protected Widget addMarker(String text) {

        Label label = new Label(text);
        label.addStyleName(CSS.marker());
        getListItemWidget().addButton(label);
        return label;
    }",1,underline text in label widget,underline text in label widget<CODESPLIT>protected Widget addMarker(String text) {          Label label = new Label(text);         label.addStyleName(CSS.marker());         getListItemWidget().addButton(label);         return label;     }
"public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{

        // write each byte buffer to the serial port
        for(ByteBuffer single : data) {

            // read the byte buffer from the current position up to the limit
            byte[] payload = new byte[single.remaining()];
            single.get(payload);

            // write the data contents to the serial port via JNI native method
            write(fd, payload, payload.length);
        }
    }",2,sending binary data over a serial connection,"sending binary data over a serial connection<CODESPLIT>public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{          // write each byte buffer to the serial port         for(ByteBuffer single : data) {              // read the byte buffer from the current position up to the limit             byte[] payload = new byte[single.remaining()];             single.get(payload);              // write the data contents to the serial port via JNI native method             write(fd, payload, payload.length);         }     }"
"public static void copy(Path sourcePath, Path targetPath, boolean executable) throws IOException {
		// we unwrap the file system to get raw streams without safety net
		FileSystem sFS = FileSystem.getUnguardedFileSystem(sourcePath.toUri());
		FileSystem tFS = FileSystem.getUnguardedFileSystem(targetPath.toUri());
		if (!tFS.exists(targetPath)) {
			if (sFS.getFileStatus(sourcePath).isDir()) {
				internalCopyDirectory(sourcePath, targetPath, executable, sFS, tFS);
			} else {
				internalCopyFile(sourcePath, targetPath, executable, sFS, tFS);
			}
		}
	}",3,get executable path,"get executable path<CODESPLIT>public static void copy(Path sourcePath, Path targetPath, boolean executable) throws IOException { 		// we unwrap the file system to get raw streams without safety net 		FileSystem sFS = FileSystem.getUnguardedFileSystem(sourcePath.toUri()); 		FileSystem tFS = FileSystem.getUnguardedFileSystem(targetPath.toUri()); 		if (!tFS.exists(targetPath)) { 			if (sFS.getFileStatus(sourcePath).isDir()) { 				internalCopyDirectory(sourcePath, targetPath, executable, sFS, tFS); 			} else { 				internalCopyFile(sourcePath, targetPath, executable, sFS, tFS); 			} 		} 	}"
"public static String urlEncode(String str)
    {
        String ret = str;

        try 
        {
            ret = URLEncoder.encode(str, ""UTF-8"");
        } 
        catch (UnsupportedEncodingException e) 
        {
            logger.severe(""Failed to encode value: ""+str);
        }

        return ret;
    }",0,html encode string,"html encode string<CODESPLIT>public static String urlEncode(String str)     {         String ret = str;          try          {             ret = URLEncoder.encode(str, ""UTF-8"");         }          catch (UnsupportedEncodingException e)          {             logger.severe(""Failed to encode value: ""+str);         }          return ret;     }"
"protected String getJavaExecutablePath() {
        String executableName = isWindows() ? ""bin/java.exe"" : ""bin/java"";
        return PROPERTIES.getJavaHome().resolve(executableName).toAbsolutePath().toString();
    }",1,get executable path,"get executable path<CODESPLIT>protected String getJavaExecutablePath() {         String executableName = isWindows() ? ""bin/java.exe"" : ""bin/java"";         return PROPERTIES.getJavaHome().resolve(executableName).toAbsolutePath().toString();     }"
"public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) {
		
		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();
        for (int i = 0; i < clustering.size(); i++) {
            if (clustering.get(i) instanceof CFCluster) {
                microclusters.add((CFCluster)clustering.get(i));
            } else {
                System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");
            }
        }
        
        int n = microclusters.size();
		assert (k <= n);
		
		/* k-means */
		Random random = new Random(0);
		Cluster[] centers = new Cluster[k];
		int K = gtClustering.size();
		
		for (int i = 0; i < k; i++) {
			if (i < K) {	// GT-aided
				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0);
			} else {		// Randomized
				int rid = random.nextInt(n);
				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0);
			}
		}
		
		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters);
	}",2,k means clustering,"k means clustering<CODESPLIT>public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) { 		 		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();         for (int i = 0; i < clustering.size(); i++) {             if (clustering.get(i) instanceof CFCluster) {                 microclusters.add((CFCluster)clustering.get(i));             } else {                 System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");             }         }                  int n = microclusters.size(); 		assert (k <= n); 		 		/* k-means */ 		Random random = new Random(0); 		Cluster[] centers = new Cluster[k]; 		int K = gtClustering.size(); 		 		for (int i = 0; i < k; i++) { 			if (i < K) {	// GT-aided 				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0); 			} else {		// Randomized 				int rid = random.nextInt(n); 				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0); 			} 		} 		 		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters); 	}"
"public synchronized void save() {
        if (BulkChange.contains(this)) {
            return;
        }
        
        File file = getConfigFile();
        try {
            List<String> allSignatures = new ArrayList<>(whitelistSignaturesFromUserControlledList);
            blacklistSignaturesFromUserControlledList.stream()
                    .map(signature -> ""!"" + signature)
                    .forEach(allSignatures::add);
            
            FileUtils.writeLines(file, allSignatures);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, ""Failed to save "" + file.getAbsolutePath(), e);
        }
    }",3,save list to file,"save list to file<CODESPLIT>public synchronized void save() {         if (BulkChange.contains(this)) {             return;         }                  File file = getConfigFile();         try {             List<String> allSignatures = new ArrayList<>(whitelistSignaturesFromUserControlledList);             blacklistSignaturesFromUserControlledList.stream()                     .map(signature -> ""!"" + signature)                     .forEach(allSignatures::add);                          FileUtils.writeLines(file, allSignatures);         } catch (IOException e) {             LOGGER.log(Level.WARNING, ""Failed to save "" + file.getAbsolutePath(), e);         }     }"
"private String convertToJson(Map<String, ?> map) throws MovieDbException {
        try {
            return MAPPER.writeValueAsString(map);
        } catch (JsonProcessingException ex) {
            throw new MovieDbException(ApiExceptionType.MAPPING_FAILED, ""JSON conversion failed"", """", ex);
        }
    }",0,convert json to csv,"convert json to csv<CODESPLIT>private String convertToJson(Map<String, ?> map) throws MovieDbException {         try {             return MAPPER.writeValueAsString(map);         } catch (JsonProcessingException ex) {             throw new MovieDbException(ApiExceptionType.MAPPING_FAILED, ""JSON conversion failed"", """", ex);         }     }"
"public static <T> Observable<T> map(Observable<?> fromObservable, final T toValue) {
        if (fromObservable != null) {
            return fromObservable.subscribeOn(Schedulers.io())
                    .map(new RXMapper<T>(toValue));
        } else {
            return Observable.empty();
        }
    }",1,get current observable value,"get current observable value<CODESPLIT>public static <T> Observable<T> map(Observable<?> fromObservable, final T toValue) {         if (fromObservable != null) {             return fromObservable.subscribeOn(Schedulers.io())                     .map(new RXMapper<T>(toValue));         } else {             return Observable.empty();         }     }"
"protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) {
		assert (centers.length == k);
		assert (k > 0);

		int dimensions = centers[0].getCenter().length;

		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>();
		for (int i = 0; i < k; i++) {
			clustering.add(new ArrayList<Cluster>());
		}

		while (true) {
			// Assign points to clusters
			for (Cluster point : data) {
				double minDistance = distance(point.getCenter(), centers[0].getCenter());
				int closestCluster = 0;
				for (int i = 1; i < k; i++) {
					double distance = distance(point.getCenter(), centers[i].getCenter());
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				clustering.get(closestCluster).add(point);
			}

			// Calculate new centers and clear clustering lists
			SphereCluster[] newCenters = new SphereCluster[centers.length];
			for (int i = 0; i < k; i++) {
				newCenters[i] = calculateCenter(clustering.get(i), dimensions);
				clustering.get(i).clear();
			}
			
			// Convergence check
			boolean converged = true;
			for (int i = 0; i < k; i++) {
				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) {
					converged = false;
					break;
				}
			}
			
			if (converged) {
				break;
			} else {
				centers = newCenters;
			}
		}

		return new Clustering(centers);
	}",2,k means clustering,"k means clustering<CODESPLIT>protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) { 		assert (centers.length == k); 		assert (k > 0);  		int dimensions = centers[0].getCenter().length;  		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>(); 		for (int i = 0; i < k; i++) { 			clustering.add(new ArrayList<Cluster>()); 		}  		while (true) { 			// Assign points to clusters 			for (Cluster point : data) { 				double minDistance = distance(point.getCenter(), centers[0].getCenter()); 				int closestCluster = 0; 				for (int i = 1; i < k; i++) { 					double distance = distance(point.getCenter(), centers[i].getCenter()); 					if (distance < minDistance) { 						closestCluster = i; 						minDistance = distance; 					} 				}  				clustering.get(closestCluster).add(point); 			}  			// Calculate new centers and clear clustering lists 			SphereCluster[] newCenters = new SphereCluster[centers.length]; 			for (int i = 0; i < k; i++) { 				newCenters[i] = calculateCenter(clustering.get(i), dimensions); 				clustering.get(i).clear(); 			} 			 			// Convergence check 			boolean converged = true; 			for (int i = 0; i < k; i++) { 				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) { 					converged = false; 					break; 				} 			} 			 			if (converged) { 				break; 			} else { 				centers = newCenters; 			} 		}  		return new Clustering(centers); 	}"
"public static InputStream decompress(final InputStream in, final String fileName) throws IOException
  {
    if (fileName.endsWith(GZ_SUFFIX)) {
      return gzipInputStream(in);
    } else if (fileName.endsWith(BZ2_SUFFIX)) {
      return new BZip2CompressorInputStream(in, true);
    } else if (fileName.endsWith(XZ_SUFFIX)) {
      return new XZCompressorInputStream(in, true);
    } else if (fileName.endsWith(SNAPPY_SUFFIX)) {
      return new FramedSnappyCompressorInputStream(in);
    } else if (fileName.endsWith(ZSTD_SUFFIX)) {
      return new ZstdCompressorInputStream(in);
    } else if (fileName.endsWith(ZIP_SUFFIX)) {
      // This reads the first file in the archive.
      final ZipInputStream zipIn = new ZipInputStream(in, StandardCharsets.UTF_8);
      try {
        final ZipEntry nextEntry = zipIn.getNextEntry();
        if (nextEntry == null) {
          zipIn.close();

          // No files in the archive - return an empty stream.
          return new ByteArrayInputStream(new byte[0]);
        }
        return zipIn;
      }
      catch (IOException e) {
        try {
          zipIn.close();
        }
        catch (IOException e2) {
          e.addSuppressed(e2);
        }
        throw e;
      }
    } else {
      return in;
    }
  }",3,how to read the contents of a .gz compressed file?,"how to read the contents of a .gz compressed file?<CODESPLIT>public static InputStream decompress(final InputStream in, final String fileName) throws IOException   {     if (fileName.endsWith(GZ_SUFFIX)) {       return gzipInputStream(in);     } else if (fileName.endsWith(BZ2_SUFFIX)) {       return new BZip2CompressorInputStream(in, true);     } else if (fileName.endsWith(XZ_SUFFIX)) {       return new XZCompressorInputStream(in, true);     } else if (fileName.endsWith(SNAPPY_SUFFIX)) {       return new FramedSnappyCompressorInputStream(in);     } else if (fileName.endsWith(ZSTD_SUFFIX)) {       return new ZstdCompressorInputStream(in);     } else if (fileName.endsWith(ZIP_SUFFIX)) {       // This reads the first file in the archive.       final ZipInputStream zipIn = new ZipInputStream(in, StandardCharsets.UTF_8);       try {         final ZipEntry nextEntry = zipIn.getNextEntry();         if (nextEntry == null) {           zipIn.close();            // No files in the archive - return an empty stream.           return new ByteArrayInputStream(new byte[0]);         }         return zipIn;       }       catch (IOException e) {         try {           zipIn.close();         }         catch (IOException e2) {           e.addSuppressed(e2);         }         throw e;       }     } else {       return in;     }   }"
"public static EncryptionMode getEncryptionModeCipher(String encryptionMode) {
	if (encryptionMode==null) {
		return null;
	}
	switch (encryptionMode) {
		case ""agile"": return EncryptionMode.agile;
		case ""binaryRC4"": return EncryptionMode.binaryRC4;
		case ""cryptoAPI"": return EncryptionMode.cryptoAPI;
		case ""standard"": return EncryptionMode.standard;
		default:
			LOG.error(""Uknown enncryption mode \""""+encryptionMode+""\"""");
			break;
		//case ""xor"": return EncryptionMode.xor; // does not seem to be supported anymore
	}
	return null;
}",0,encrypt aes ctr mode,"encrypt aes ctr mode<CODESPLIT>public static EncryptionMode getEncryptionModeCipher(String encryptionMode) { 	if (encryptionMode==null) { 		return null; 	} 	switch (encryptionMode) { 		case ""agile"": return EncryptionMode.agile; 		case ""binaryRC4"": return EncryptionMode.binaryRC4; 		case ""cryptoAPI"": return EncryptionMode.cryptoAPI; 		case ""standard"": return EncryptionMode.standard; 		default: 			LOG.error(""Uknown enncryption mode \""""+encryptionMode+""\""""); 			break; 		//case ""xor"": return EncryptionMode.xor; // does not seem to be supported anymore 	} 	return null; }"
"public Closure<V> memoizeAtMost(final int maxCacheSize) {
        if (maxCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the maxCacheSize parameter for memoizeAtMost."");

        return Memoize.buildMemoizeFunction(new LRUCache(maxCacheSize), this);
    }",1,memoize to disk  - persistent memoization,"memoize to disk  - persistent memoization<CODESPLIT>public Closure<V> memoizeAtMost(final int maxCacheSize) {         if (maxCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the maxCacheSize parameter for memoizeAtMost."");          return Memoize.buildMemoizeFunction(new LRUCache(maxCacheSize), this);     }"
"public static HttpRequest head(final CharSequence baseUrl,
      final Map<?, ?> params, final boolean encode) {
    String url = append(baseUrl, params);
    return head(encode ? encode(url) : url);
  }",2,encode url,"encode url<CODESPLIT>public static HttpRequest head(final CharSequence baseUrl,       final Map<?, ?> params, final boolean encode) {     String url = append(baseUrl, params);     return head(encode ? encode(url) : url);   }"
"private static String reverseString(String in) {
        StringBuilder out = new StringBuilder(in).reverse();
        return out.toString();
    }",3,how to reverse a string,how to reverse a string<CODESPLIT>private static String reverseString(String in) {         StringBuilder out = new StringBuilder(in).reverse();         return out.toString();     }
"public static Long[] nullToEmpty(Long[] array) {
        if (array == null || array.length == 0) {
            return EMPTY_LONG_OBJECT_ARRAY;
        }
        return array;
    }",0,how to empty array,how to empty array<CODESPLIT>public static Long[] nullToEmpty(Long[] array) {         if (array == null || array.length == 0) {             return EMPTY_LONG_OBJECT_ARRAY;         }         return array;     }
"public static BufferedReader newReader(Path self) throws IOException {
        return Files.newBufferedReader(self, Charset.defaultCharset());
    }",1,buffered file reader read text,"buffered file reader read text<CODESPLIT>public static BufferedReader newReader(Path self) throws IOException {         return Files.newBufferedReader(self, Charset.defaultCharset());     }"
"public static Date getCurrentDateTime() throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }",2,how to get current date,how to get current date<CODESPLIT>public static Date getCurrentDateTime() throws ParseException {         Calendar currentDate = Calendar.getInstance();         SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);         String dateNow = formatter.format(currentDate.getTime());         return getDateFromString(dateNow);     }
"public static String replaceHtmlEntities(String content, Map<String, Character> map) {
    
    for (Entry<String, Character> entry : escapeStrings.entrySet()) {
      
      if (content.indexOf(entry.getKey()) != -1) {
        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));
      }
      
    }
    
    return content;
  }",3,html entities replace,"html entities replace<CODESPLIT>public static String replaceHtmlEntities(String content, Map<String, Character> map) {          for (Entry<String, Character> entry : escapeStrings.entrySet()) {              if (content.indexOf(entry.getKey()) != -1) {         content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));       }            }          return content;   }"
"public static Double[] nullToEmpty(Double[] array) {
        if (array == null || array.length == 0) {
            return EMPTY_DOUBLE_OBJECT_ARRAY;
        }
        return array;
    }",0,how to empty array,how to empty array<CODESPLIT>public static Double[] nullToEmpty(Double[] array) {         if (array == null || array.length == 0) {             return EMPTY_DOUBLE_OBJECT_ARRAY;         }         return array;     }
"public static DocumentContext parse(File json, Configuration configuration) throws IOException {
        return new ParseContextImpl(configuration).parse(json);
    }",1,parse json file,"parse json file<CODESPLIT>public static DocumentContext parse(File json, Configuration configuration) throws IOException {         return new ParseContextImpl(configuration).parse(json);     }"
"public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException {
		try {
			logger.debug(""Json string to deserialize {} "", json);
			return mapper.readValue(json, typeReference);
		} catch (IOException e) {
			logger.error(""SerializationException {}"", e.getMessage());
			SerializationException serializationException = new SerializationException(e);
			throw serializationException;
		}
	}",2,deserialize json,"deserialize json<CODESPLIT>public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException { 		try { 			logger.debug(""Json string to deserialize {} "", json); 			return mapper.readValue(json, typeReference); 		} catch (IOException e) { 			logger.error(""SerializationException {}"", e.getMessage()); 			SerializationException serializationException = new SerializationException(e); 			throw serializationException; 		} 	}"
"public final void fileCopy(File in, File out) throws IOException {
		assert in != null;
		assert out != null;
		getLog().debug(""Copying file: "" + in.toString() + "" into "" + out.toString()); //$NON-NLS-1$ //$NON-NLS-2$
		try (FileInputStream fis = new FileInputStream(in)) {
			try (FileChannel inChannel = fis.getChannel()) {
				try (FileOutputStream fos = new FileOutputStream(out)) {
					try (FileChannel outChannel = fos.getChannel()) {
						inChannel.transferTo(0, inChannel.size(), outChannel);
					}
				}
			}
		} finally {
			getBuildContext().refresh(out);
		}
	}",3,copying a file to a path,"copying a file to a path<CODESPLIT>public final void fileCopy(File in, File out) throws IOException { 		assert in != null; 		assert out != null; 		getLog().debug(""Copying file: "" + in.toString() + "" into "" + out.toString()); //$NON-NLS-1$ //$NON-NLS-2$ 		try (FileInputStream fis = new FileInputStream(in)) { 			try (FileChannel inChannel = fis.getChannel()) { 				try (FileOutputStream fos = new FileOutputStream(out)) { 					try (FileChannel outChannel = fos.getChannel()) { 						inChannel.transferTo(0, inChannel.size(), outChannel); 					} 				} 			} 		} finally { 			getBuildContext().refresh(out); 		} 	}"
"public Result<String> convertToHtml(File file) throws IOException {
        return new InternalDocumentConverter(options).convertToHtml(file).toResult();
    }",0,convert html to pdf,convert html to pdf<CODESPLIT>public Result<String> convertToHtml(File file) throws IOException {         return new InternalDocumentConverter(options).convertToHtml(file).toResult();     }
"public static <T extends Comparable<? super T>>  int[] sort(T[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }",1,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public static <T extends Comparable<? super T>>  int[] sort(T[] arr) {         int[] order = new int[arr.length];         for (int i = 0; i < order.length; i++) {             order[i] = i;         }         sort(arr, order);         return order;     }"
"private void generatePdf() {
        File pdfFile = new File(directory, filename + "".pdf"");
        try (OutputStream os = new FileOutputStream(pdfFile)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()
                    .replaceAll("" "", ""%20""));
            builder.toStream(os);
            builder.run();
        } catch (Exception e) {
            log.error(e);
        }
    }",2,convert html to pdf,"convert html to pdf<CODESPLIT>private void generatePdf() {         File pdfFile = new File(directory, filename + "".pdf"");         try (OutputStream os = new FileOutputStream(pdfFile)) {             PdfRendererBuilder builder = new PdfRendererBuilder();             builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()                     .replaceAll("" "", ""%20""));             builder.toStream(os);             builder.run();         } catch (Exception e) {             log.error(e);         }     }"
"@SuppressWarnings(""unchecked"")
  public static <T> T[] filter(T[] array, Filter<T> filter) {

    Assert.notNull(array, ""Array is required"");
    Assert.notNull(filter, ""Filter is required"");

    List<T> arrayList = stream(array).filter(filter::accept).collect(Collectors.toList());

    return arrayList.toArray((T[]) Array.newInstance(array.getClass().getComponentType(), arrayList.size()));
  }",3,filter array,"filter array<CODESPLIT>@SuppressWarnings(""unchecked"")   public static <T> T[] filter(T[] array, Filter<T> filter) {      Assert.notNull(array, ""Array is required"");     Assert.notNull(filter, ""Filter is required"");      List<T> arrayList = stream(array).filter(filter::accept).collect(Collectors.toList());      return arrayList.toArray((T[]) Array.newInstance(array.getClass().getComponentType(), arrayList.size()));   }"
"public Result<String> extractRawText(File file) throws IOException {
        return new InternalDocumentConverter(options).extractRawText(file).toResult();
    }",0,extracting data from a text file,extracting data from a text file<CODESPLIT>public Result<String> extractRawText(File file) throws IOException {         return new InternalDocumentConverter(options).extractRawText(file).toResult();     }
"public void setWorkingDirectory(String path) {
        if (path != null) {
            File dir = new File(path);
            checkWorkingDir(dir);
            workingDir = dir;
        } else {
            workingDir = null;
        }
    }",1,set working directory,set working directory<CODESPLIT>public void setWorkingDirectory(String path) {         if (path != null) {             File dir = new File(path);             checkWorkingDir(dir);             workingDir = dir;         } else {             workingDir = null;         }     }
"public static Map<String, List<String>> extractHTMLheaders(String html) {
        Map<String, List<String>> hxtagsMap = new HashMap<>();
        for(int i=1;i<=6;++i) {
            hxtagsMap.put(""H""+i, new ArrayList<>());
        }
                
        Matcher m = HX_PATTERN.matcher(html);
        while (m.find()) {
            if(m.groupCount()==2) {
                String tagType = m.group(1).toUpperCase(Locale.ENGLISH);
                String content = m.group(2);
                hxtagsMap.get(tagType).add(clear(content));
            }
        }
        return hxtagsMap;
    }",2,extract data from html content,"extract data from html content<CODESPLIT>public static Map<String, List<String>> extractHTMLheaders(String html) {         Map<String, List<String>> hxtagsMap = new HashMap<>();         for(int i=1;i<=6;++i) {             hxtagsMap.put(""H""+i, new ArrayList<>());         }                          Matcher m = HX_PATTERN.matcher(html);         while (m.find()) {             if(m.groupCount()==2) {                 String tagType = m.group(1).toUpperCase(Locale.ENGLISH);                 String content = m.group(2);                 hxtagsMap.get(tagType).add(clear(content));             }         }         return hxtagsMap;     }"
"public long getElapsedMinutes() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerMm;
	}",3,finding time elapsed using a timer,finding time elapsed using a timer<CODESPLIT>public long getElapsedMinutes() { 		long elapsed; 		if (running) { 			elapsed = (System.nanoTime() - startTime); 		} else { 			elapsed = (stopTime - startTime); 		} 		return elapsed / nsPerMm; 	}
"public static BigDecimal decimalPart(final BigDecimal val) {
        return BigDecimalUtil.subtract(val, val.setScale(0, BigDecimal.ROUND_DOWN));
    }",0,convert decimal to hex,"convert decimal to hex<CODESPLIT>public static BigDecimal decimalPart(final BigDecimal val) {         return BigDecimalUtil.subtract(val, val.setScale(0, BigDecimal.ROUND_DOWN));     }"
"CommandLine parse(DefaultCommandLine cl, String[] args) {
        parseInternal(cl, args, true);
        return cl;
    }",1,parse command line argument,"parse command line argument<CODESPLIT>CommandLine parse(DefaultCommandLine cl, String[] args) {         parseInternal(cl, args, true);         return cl;     }"
"protected int getCurrentProcessID() throws ProcessHandlerException {
        int pid;
        // Not ideal but using JNA failed on RHEL5.
        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
        Field jvm = null;
        try {
            jvm = runtime.getClass().getDeclaredField(""jvm"");
            jvm.setAccessible(true);
            VMManagement mgmt = (VMManagement) jvm.get(runtime);
            Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");
            pid_method.setAccessible(true);
            pid = (Integer) pid_method.invoke(mgmt);
        } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new ProcessHandlerException(e);
        }
        return pid;
    }",2,get current process id,"get current process id<CODESPLIT>protected int getCurrentProcessID() throws ProcessHandlerException {         int pid;         // Not ideal but using JNA failed on RHEL5.         RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();         Field jvm = null;         try {             jvm = runtime.getClass().getDeclaredField(""jvm"");             jvm.setAccessible(true);             VMManagement mgmt = (VMManagement) jvm.get(runtime);             Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");             pid_method.setAccessible(true);             pid = (Integer) pid_method.invoke(mgmt);         } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {             throw new ProcessHandlerException(e);         }         return pid;     }"
"private List<File> unzipCorpus(File outDir, ZipFile zip)
  {
    List<File> rootDirs = new ArrayList<>();

    Enumeration<? extends ZipEntry> zipEnum = zip.entries();
    while (zipEnum.hasMoreElements())
    {
      ZipEntry e = zipEnum.nextElement();
      File outFile = new File(outDir, e.getName().replaceAll(""\\/"", ""/""));

      if (e.isDirectory())
      {
        if (!outFile.mkdirs())
        {
          log.warn(""Could not create output directory "" + outFile.
            getAbsolutePath());
        }
      } // end if directory
      else
      {
        if (""corpus.tab"".equals(outFile.getName()) || ""corpus.annis"".equals(
          outFile.getName()))
        {
          rootDirs.add(outFile.getParentFile());
        }

        if (!outFile.getParentFile().isDirectory())
        {
          if (!outFile.getParentFile().mkdirs())
          {
            {
              log.warn(
                ""Could not create output directory for file "" + outFile.
                getAbsolutePath());
            }
          }
        }
        try (FileOutputStream outStream = new FileOutputStream(outFile);)
        {

          ByteStreams.copy(zip.getInputStream(e), outStream);
        }
        catch (FileNotFoundException ex)
        {
          log.error(null, ex);
        }
        catch (IOException ex)
        {
          log.error(null, ex);
        }
      } // end else is file
    } // end for each entry in zip file

    return rootDirs;
  }",3,unzipping large files,"unzipping large files<CODESPLIT>private List<File> unzipCorpus(File outDir, ZipFile zip)   {     List<File> rootDirs = new ArrayList<>();      Enumeration<? extends ZipEntry> zipEnum = zip.entries();     while (zipEnum.hasMoreElements())     {       ZipEntry e = zipEnum.nextElement();       File outFile = new File(outDir, e.getName().replaceAll(""\\/"", ""/""));        if (e.isDirectory())       {         if (!outFile.mkdirs())         {           log.warn(""Could not create output directory "" + outFile.             getAbsolutePath());         }       } // end if directory       else       {         if (""corpus.tab"".equals(outFile.getName()) || ""corpus.annis"".equals(           outFile.getName()))         {           rootDirs.add(outFile.getParentFile());         }          if (!outFile.getParentFile().isDirectory())         {           if (!outFile.getParentFile().mkdirs())           {             {               log.warn(                 ""Could not create output directory for file "" + outFile.                 getAbsolutePath());             }           }         }         try (FileOutputStream outStream = new FileOutputStream(outFile);)         {            ByteStreams.copy(zip.getInputStream(e), outStream);         }         catch (FileNotFoundException ex)         {           log.error(null, ex);         }         catch (IOException ex)         {           log.error(null, ex);         }       } // end else is file     } // end for each entry in zip file      return rootDirs;   }"
"public static byte[] build(String className, String superName) {
		ByteBuffer bb = ByteBuffer.allocate(1000);
		bb.put(BA0_1);
		
		//bb.put(BA2);
		writeUtf8(bb, convertDots(className));
		
		bb.put(BA3);
		
		//bb.put(BA4);
		writeUtf8(bb, convertDots(superName));
		
		bb.put(BA5_12);
		
		//bb.put(BA13);
		writeUtf8(bb, ""L"" + convertDots(className) + "";"");
		
		bb.put(BA14);
		
		//bb.put(BA15);
		String fName = convertDots(className);
		fName = fName.substring(fName.lastIndexOf('/') + 1);
		fName += "".java"";
		writeUtf8(bb, fName);
		
		bb.put(BA_end);
		
		byte[] ba = new byte[bb.position()];
		bb.rewind();
		bb.get(ba);
		return ba;
	}",0,parse binary file to custom class,"parse binary file to custom class<CODESPLIT>public static byte[] build(String className, String superName) { 		ByteBuffer bb = ByteBuffer.allocate(1000); 		bb.put(BA0_1); 		 		//bb.put(BA2); 		writeUtf8(bb, convertDots(className)); 		 		bb.put(BA3); 		 		//bb.put(BA4); 		writeUtf8(bb, convertDots(superName)); 		 		bb.put(BA5_12); 		 		//bb.put(BA13); 		writeUtf8(bb, ""L"" + convertDots(className) + "";""); 		 		bb.put(BA14); 		 		//bb.put(BA15); 		String fName = convertDots(className); 		fName = fName.substring(fName.lastIndexOf('/') + 1); 		fName += "".java""; 		writeUtf8(bb, fName); 		 		bb.put(BA_end); 		 		byte[] ba = new byte[bb.position()]; 		bb.rewind(); 		bb.get(ba); 		return ba; 	}"
"public static double similarity(String s1, String s2) {
    if (s1.equals(s2))
      return 1.0;

    // ensure that s1 is shorter than or same length as s2
    if (s1.length() > s2.length()) {
      String tmp = s2;
      s2 = s1;
      s1 = tmp;
    }
    /*
     * this list of Boolean values is used for avoiding duplicated count of
     * common characters in S2
     */
    List<Boolean> isCommonCharInS2 = new ArrayList<Boolean>();
    for (int i=0; i<s2.length(); i++) {
      isCommonCharInS2.add(false);
    }

    // (1) find the number of characters the two strings have in common.
    // note that matching characters can only be half the length of the
    // longer string apart.
    int maxdist = (int) Math.floor(s2.length() / 2) ;
    int c = 0; // count of common characters
    int t = 0; // count of transpositions
    int prevpos = -1;
    for (int ix = 0; ix < s1.length(); ix++) {
      char ch = s1.charAt(ix);

      // now try to find it in s2
      for (int ix2 = Math.max(0, ix - maxdist);
           ix2 < Math.min(s2.length(), ix + maxdist);
           ix2++) {
        if (ch == s2.charAt(ix2) && !isCommonCharInS2.get(ix2)) {
          c++; // we found a common character
          isCommonCharInS2.set(ix2, true);
          if (prevpos != -1 && ix2 < prevpos)
            t++; // moved back before earlier
          prevpos = ix2;
          break;
        }
      }
    }

    // we don't divide t by 2 because as far as we can tell, the above
    // code counts transpositions directly.

    // System.out.println(""c: "" + c);
    // System.out.println(""t: "" + t);
    // System.out.println(""c/m: "" + (c / (double) s1.length()));
    // System.out.println(""c/n: "" + (c / (double) s2.length()));
    // System.out.println(""(c-t)/c: "" + ((c - t) / (double) c));

    // we might have to give up right here
    if (c == 0)
      return 0.0;

    // first compute the score
    double score = ((c / (double) s1.length()) +
            (c / (double) s2.length()) +
            ((c - t) / (double) c)) / 3.0;

    // (2) common prefix modification
    int p = 0; // length of prefix
    int last = Math.min(4, s1.length());
    for (; p < last && s1.charAt(p) == s2.charAt(p); p++)
      ;

    score = score + ((p * (1 - score)) / 10);

    // (3) longer string adjustment
    // I'm confused about this part. Winkler's original source code includes
    // it, and Yancey's 2005 paper describes it. However, Winkler's list of
    // test cases in his 2006 paper does not include this modification. So
    // is this part of Jaro-Winkler, or is it not? Hard to say.
    //
    //   if (s1.length() >= 5 && // both strings at least 5 characters long
    //       c - p >= 2 && // at least two common characters besides prefix
    //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars
    //     {
    //     System.out.println(""ADJUSTED!"");
    //     score = score + ((1 - score) * ((c - (p + 1)) /
    //                                     ((double) ((s1.length() + s2.length())
    //                                                - (2 * (p - 1))))));
    // }

    // (4) similar characters adjustment
    // the same holds for this as for (3) above.

    return score;
  }",1,string similarity levenshtein,"string similarity levenshtein<CODESPLIT>public static double similarity(String s1, String s2) {     if (s1.equals(s2))       return 1.0;      // ensure that s1 is shorter than or same length as s2     if (s1.length() > s2.length()) {       String tmp = s2;       s2 = s1;       s1 = tmp;     }     /*      * this list of Boolean values is used for avoiding duplicated count of      * common characters in S2      */     List<Boolean> isCommonCharInS2 = new ArrayList<Boolean>();     for (int i=0; i<s2.length(); i++) {       isCommonCharInS2.add(false);     }      // (1) find the number of characters the two strings have in common.     // note that matching characters can only be half the length of the     // longer string apart.     int maxdist = (int) Math.floor(s2.length() / 2) ;     int c = 0; // count of common characters     int t = 0; // count of transpositions     int prevpos = -1;     for (int ix = 0; ix < s1.length(); ix++) {       char ch = s1.charAt(ix);        // now try to find it in s2       for (int ix2 = Math.max(0, ix - maxdist);            ix2 < Math.min(s2.length(), ix + maxdist);            ix2++) {         if (ch == s2.charAt(ix2) && !isCommonCharInS2.get(ix2)) {           c++; // we found a common character           isCommonCharInS2.set(ix2, true);           if (prevpos != -1 && ix2 < prevpos)             t++; // moved back before earlier           prevpos = ix2;           break;         }       }     }      // we don't divide t by 2 because as far as we can tell, the above     // code counts transpositions directly.      // System.out.println(""c: "" + c);     // System.out.println(""t: "" + t);     // System.out.println(""c/m: "" + (c / (double) s1.length()));     // System.out.println(""c/n: "" + (c / (double) s2.length()));     // System.out.println(""(c-t)/c: "" + ((c - t) / (double) c));      // we might have to give up right here     if (c == 0)       return 0.0;      // first compute the score     double score = ((c / (double) s1.length()) +             (c / (double) s2.length()) +             ((c - t) / (double) c)) / 3.0;      // (2) common prefix modification     int p = 0; // length of prefix     int last = Math.min(4, s1.length());     for (; p < last && s1.charAt(p) == s2.charAt(p); p++)       ;      score = score + ((p * (1 - score)) / 10);      // (3) longer string adjustment     // I'm confused about this part. Winkler's original source code includes     // it, and Yancey's 2005 paper describes it. However, Winkler's list of     // test cases in his 2006 paper does not include this modification. So     // is this part of Jaro-Winkler, or is it not? Hard to say.     //     //   if (s1.length() >= 5 && // both strings at least 5 characters long     //       c - p >= 2 && // at least two common characters besides prefix     //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars     //     {     //     System.out.println(""ADJUSTED!"");     //     score = score + ((1 - score) * ((c - (p + 1)) /     //                                     ((double) ((s1.length() + s2.length())     //                                                - (2 * (p - 1))))));     // }      // (4) similar characters adjustment     // the same holds for this as for (3) above.      return score;   }"
"public static String getStatusDescription(int status)
   {
      String description = """";

      Integer statusKey = new Integer(status);
      if (statusDescriptions.containsKey(statusKey))
      {
         description = statusDescriptions.get(statusKey);
      }

      return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);
   }",2,get the description of a http status code,"get the description of a http status code<CODESPLIT>public static String getStatusDescription(int status)    {       String description = """";        Integer statusKey = new Integer(status);       if (statusDescriptions.containsKey(statusKey))       {          description = statusDescriptions.get(statusKey);       }        return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);    }"
"public boolean copyTopicsToClipboard(final boolean cut, @Nonnull @MustNotContainNull final Topic... topics) {
    boolean result = false;

    if (this.lockIfNotDisposed()) {
      try {
        if (topics.length > 0) {
          final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
          clipboard.setContents(new MMDTopicsTransferable(topics), this);

          if (cut) {
            deleteTopics(true, ensureNoRootInArray(topics));
          }

          result = true;
        }
      } finally {
        this.unlock();
      }
    }

    return result;
  }",3,copy to clipboard,"copy to clipboard<CODESPLIT>public boolean copyTopicsToClipboard(final boolean cut, @Nonnull @MustNotContainNull final Topic... topics) {     boolean result = false;      if (this.lockIfNotDisposed()) {       try {         if (topics.length > 0) {           final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();           clipboard.setContents(new MMDTopicsTransferable(topics), this);            if (cut) {             deleteTopics(true, ensureNoRootInArray(topics));           }            result = true;         }       } finally {         this.unlock();       }     }      return result;   }"
"public static File earlHtmlReport( String outputDir )
                    throws FileNotFoundException {

        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        String resourceDir = cl.getResource( ""com/occamlab/te/earl/lib"" ).getPath();
        String earlXsl = cl.getResource( ""com/occamlab/te/earl_html_report.xsl"" ).toString();

        File htmlOutput = new File( outputDir, ""result"" );
        htmlOutput.mkdir();
        LOGR.fine( ""HTML output is written to directory "" + htmlOutput );
        File earlResult = new File( outputDir, ""earl-results.rdf"" );

        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            Transformer transformer = tf.newTransformer( new StreamSource( earlXsl ) );
            transformer.setParameter( ""outputDir"", htmlOutput );
            File indexHtml = new File( htmlOutput, ""index.html"" );
            indexHtml.createNewFile();
            FileOutputStream outputStream = new FileOutputStream( indexHtml );
            transformer.transform( new StreamSource( earlResult ), new StreamResult( outputStream ) );
            // Foritfy Mod: Close the outputStream releasing its resources
            outputStream.close();
            FileUtils.copyDirectory( new File( resourceDir ), htmlOutput );
        } catch ( Exception e ) {
            LOGR.log( Level.SEVERE, ""Transformation of EARL to HTML failed."", e );
            throw new RuntimeException( e );
        }
        if ( !htmlOutput.exists() ) {
            throw new FileNotFoundException( ""HTML results not found at "" + htmlOutput.getAbsolutePath() );
        }
        return htmlOutput;
    }",0,output to html file,"output to html file<CODESPLIT>public static File earlHtmlReport( String outputDir )                     throws FileNotFoundException {          ClassLoader cl = Thread.currentThread().getContextClassLoader();         String resourceDir = cl.getResource( ""com/occamlab/te/earl/lib"" ).getPath();         String earlXsl = cl.getResource( ""com/occamlab/te/earl_html_report.xsl"" ).toString();          File htmlOutput = new File( outputDir, ""result"" );         htmlOutput.mkdir();         LOGR.fine( ""HTML output is written to directory "" + htmlOutput );         File earlResult = new File( outputDir, ""earl-results.rdf"" );          try {             TransformerFactory tf = TransformerFactory.newInstance();             Transformer transformer = tf.newTransformer( new StreamSource( earlXsl ) );             transformer.setParameter( ""outputDir"", htmlOutput );             File indexHtml = new File( htmlOutput, ""index.html"" );             indexHtml.createNewFile();             FileOutputStream outputStream = new FileOutputStream( indexHtml );             transformer.transform( new StreamSource( earlResult ), new StreamResult( outputStream ) );             // Foritfy Mod: Close the outputStream releasing its resources             outputStream.close();             FileUtils.copyDirectory( new File( resourceDir ), htmlOutput );         } catch ( Exception e ) {             LOGR.log( Level.SEVERE, ""Transformation of EARL to HTML failed."", e );             throw new RuntimeException( e );         }         if ( !htmlOutput.exists() ) {             throw new FileNotFoundException( ""HTML results not found at "" + htmlOutput.getAbsolutePath() );         }         return htmlOutput;     }"
"@SuppressWarnings(""unchecked"")
  public static Map<String, String> parseCommandLineArguments(String[] args) {
    return (Map)parseCommandLineArguments(args, false);
  }",1,parse command line argument,"parse command line argument<CODESPLIT>@SuppressWarnings(""unchecked"")   public static Map<String, String> parseCommandLineArguments(String[] args) {     return (Map)parseCommandLineArguments(args, false);   }"
"public static Date getDay(String string) {
		if (string == null) {
			return null;
		}
		Date date = null;
		try {
			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string));
		}
		catch (ParseException ex) {
			return null;
		}
		return date;
	}",2,convert a date string into yyyymmdd,"convert a date string into yyyymmdd<CODESPLIT>public static Date getDay(String string) { 		if (string == null) { 			return null; 		} 		Date date = null; 		try { 			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string)); 		} 		catch (ParseException ex) { 			return null; 		} 		return date; 	}"
"public static <T> T[] filter(T array[], Filter<T> filter){
        List<T> filteredList = new ArrayList<T>(array.length);
        for(T element: array){
            if(filter.select(element))
                filteredList.add(element);
        }
        @SuppressWarnings(""unchecked"")
        T filteredArray[] = (T[])Array.newInstance(array.getClass().getComponentType(), filteredList.size());
        return filteredList.toArray(filteredArray);
    }",3,filter array,"filter array<CODESPLIT>public static <T> T[] filter(T array[], Filter<T> filter){         List<T> filteredList = new ArrayList<T>(array.length);         for(T element: array){             if(filter.select(element))                 filteredList.add(element);         }         @SuppressWarnings(""unchecked"")         T filteredArray[] = (T[])Array.newInstance(array.getClass().getComponentType(), filteredList.size());         return filteredList.toArray(filteredArray);     }"
"private boolean isBinary() {
        try (InputStream in = getInputStream()) {
            long size = Files.size(file.toPath());
            if (size == 0) {
                // Empty file, so no need to check
                return true;
            }

            byte[] b = new byte[( size < StreamUtils.DEFAULT_PROBE_SIZE ? (int)size : StreamUtils.DEFAULT_PROBE_SIZE)];
            int read = in.read(b);
            if (read != b.length) {
                // Something went wrong, so better not to read line by line
                return true;
            }

            return StreamUtils.isNonWhitespaceControlCharacter(b);
        } catch (IOException e) {
            // If cannot be checked, then considered as binary, so we do not
            // read line by line
            return true;
        }
    }",0,read text file line by line,"read text file line by line<CODESPLIT>private boolean isBinary() {         try (InputStream in = getInputStream()) {             long size = Files.size(file.toPath());             if (size == 0) {                 // Empty file, so no need to check                 return true;             }              byte[] b = new byte[( size < StreamUtils.DEFAULT_PROBE_SIZE ? (int)size : StreamUtils.DEFAULT_PROBE_SIZE)];             int read = in.read(b);             if (read != b.length) {                 // Something went wrong, so better not to read line by line                 return true;             }              return StreamUtils.isNonWhitespaceControlCharacter(b);         } catch (IOException e) {             // If cannot be checked, then considered as binary, so we do not             // read line by line             return true;         }     }"
"public static String getClipboardText(final Context context) {
        final ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        final ClipData clipData = clipboard.getPrimaryClip();
        if(clipData != null && clipData.getItemCount() > 0) {
            final CharSequence clipboardText = clipData.getItemAt(0).getText();
            if(clipboardText != null) {
                return clipboardText.toString();
            }
        }
        return null;
    }",1,copy to clipboard,copy to clipboard<CODESPLIT>public static String getClipboardText(final Context context) {         final ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);         final ClipData clipData = clipboard.getPrimaryClip();         if(clipData != null && clipData.getItemCount() > 0) {             final CharSequence clipboardText = clipData.getItemAt(0).getText();             if(clipboardText != null) {                 return clipboardText.toString();             }         }         return null;     }
"public static String getText(Reader reader) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(reader);
        return getText(bufferedReader);
    }",2,buffered file reader read text,buffered file reader read text<CODESPLIT>public static String getText(Reader reader) throws IOException {         BufferedReader bufferedReader = new BufferedReader(reader);         return getText(bufferedReader);     }
"protected void selectCheckbox(PageElement element, String valueKeyOrKey, Map<String, Boolean> values) throws TechnicalException, FailureException {
        final String valueKey = Context.getValue(valueKeyOrKey) != null ? Context.getValue(valueKeyOrKey) : valueKeyOrKey;
        try {
            final WebElement webElement = Context.waitUntil(ExpectedConditions.elementToBeClickable(Utilities.getLocator(element)));
            Boolean checkboxValue = values.get(valueKey);
            if (checkboxValue == null) {
                checkboxValue = values.get(""Default"");
            }
            if (webElement.isSelected() != checkboxValue.booleanValue()) {
                webElement.click();
            }
        } catch (final Exception e) {
            new Result.Failure<>(e.getMessage(), Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT), element, element.getPage().getApplication()), true,
                    element.getPage().getCallBack());
        }
    }",3,how to make the checkbox checked,"how to make the checkbox checked<CODESPLIT>protected void selectCheckbox(PageElement element, String valueKeyOrKey, Map<String, Boolean> values) throws TechnicalException, FailureException {         final String valueKey = Context.getValue(valueKeyOrKey) != null ? Context.getValue(valueKeyOrKey) : valueKeyOrKey;         try {             final WebElement webElement = Context.waitUntil(ExpectedConditions.elementToBeClickable(Utilities.getLocator(element)));             Boolean checkboxValue = values.get(valueKey);             if (checkboxValue == null) {                 checkboxValue = values.get(""Default"");             }             if (webElement.isSelected() != checkboxValue.booleanValue()) {                 webElement.click();             }         } catch (final Exception e) {             new Result.Failure<>(e.getMessage(), Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT), element, element.getPage().getApplication()), true,                     element.getPage().getCallBack());         }     }"
"public void save() {
    if (catListBox != null) catListBox.save();

    if (prefs != null) {
      if (fileChooser != null)
        fileChooser.save();
      if (catgenFileChooser != null)
        catgenFileChooser.save();
      prefs.putInt(HDIVIDER, split.getDividerLocation());
    }
  }",0,save list to file,"save list to file<CODESPLIT>public void save() {     if (catListBox != null) catListBox.save();      if (prefs != null) {       if (fileChooser != null)         fileChooser.save();       if (catgenFileChooser != null)         catgenFileChooser.save();       prefs.putInt(HDIVIDER, split.getDividerLocation());     }   }"
"public CloseableHttpResponse postJson(String url, String json, Map<String, String> reqHeaders) throws IOException {
        CloseableHttpClient req = getClient();
        CloseableHttpResponse resp = null;
        HttpPost post = new HttpPost(url);
        addHeaders(post, reqHeaders);
        post.setHeader(json, url);
        StringEntity input = new StringEntity(json, ContentType.APPLICATION_JSON);
        post.setEntity(input);
        resp = req.execute(post);
        return resp;
    }",1,httpclient post json,"httpclient post json<CODESPLIT>public CloseableHttpResponse postJson(String url, String json, Map<String, String> reqHeaders) throws IOException {         CloseableHttpClient req = getClient();         CloseableHttpResponse resp = null;         HttpPost post = new HttpPost(url);         addHeaders(post, reqHeaders);         post.setHeader(json, url);         StringEntity input = new StringEntity(json, ContentType.APPLICATION_JSON);         post.setEntity(input);         resp = req.execute(post);         return resp;     }"
"public static int[] sort(double[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }",2,sorting multiple arrays based on another arrays sorted order,"sorting multiple arrays based on another arrays sorted order<CODESPLIT>public static int[] sort(double[] arr) {         int[] order = new int[arr.length];         for (int i = 0; i < order.length; i++) {             order[i] = i;         }         sort(arr, order);         return order;     }"
"public static String format(Date date, String format)
	{
		Parameters.checkNotNull(date);
		return new SimpleDateFormat(format).format(date);
	}",3,format date,"format date<CODESPLIT>public static String format(Date date, String format) 	{ 		Parameters.checkNotNull(date); 		return new SimpleDateFormat(format).format(date); 	}"
"public FilterReply getFilterChainDecision(E event) {
    final Filter<E>[] filterArrray = filterList.asTypedArray();
    final int len = filterArrray.length;

    for (int i = 0; i < len; i++) {
      final FilterReply r = filterArrray[i].decide(event);
      if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {
        return r;
      }
    }

    // no decision
    return FilterReply.NEUTRAL;
  }",0,filter array,filter array<CODESPLIT>public FilterReply getFilterChainDecision(E event) {     final Filter<E>[] filterArrray = filterList.asTypedArray();     final int len = filterArrray.length;      for (int i = 0; i < len; i++) {       final FilterReply r = filterArrray[i].decide(event);       if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {         return r;       }     }      // no decision     return FilterReply.NEUTRAL;   }
"public static String getCurrentDate() {
		long now = System.currentTimeMillis();

		if ((now - currentDateGenerated) > 1000) {
			synchronized (format) {
				if ((now - currentDateGenerated) > 1000) {
					currentDateGenerated = now;
					currentDate = format.format(new Date(now));
				}
			}
		}

		return currentDate;
	}",1,how to get current date,how to get current date<CODESPLIT>public static String getCurrentDate() { 		long now = System.currentTimeMillis();  		if ((now - currentDateGenerated) > 1000) { 			synchronized (format) { 				if ((now - currentDateGenerated) > 1000) { 					currentDateGenerated = now; 					currentDate = format.format(new Date(now)); 				} 			} 		}  		return currentDate; 	}
"public static void extractZip(File file) throws FileNotFoundException, IOException {
        final String originalPath = file.getPath();
        final File zip = new File(originalPath + "".zip"");
        if (zip.isFile() && !zip.delete()) {
            LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());
            zip.deleteOnExit();
        }
        if (!file.renameTo(zip)) {
            throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");
        }
        final File newFile = new File(originalPath);
        try (FileInputStream fis = new FileInputStream(zip);
                ZipInputStream cin = new ZipInputStream(fis);
                FileOutputStream out = new FileOutputStream(newFile)) {
            cin.getNextEntry();
            IOUtils.copy(cin, out);
        } finally {
            if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {
                LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());
                zip.deleteOnExit();
            }
        }
    }",2,how to extract zip file recursively,"how to extract zip file recursively<CODESPLIT>public static void extractZip(File file) throws FileNotFoundException, IOException {         final String originalPath = file.getPath();         final File zip = new File(originalPath + "".zip"");         if (zip.isFile() && !zip.delete()) {             LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());             zip.deleteOnExit();         }         if (!file.renameTo(zip)) {             throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");         }         final File newFile = new File(originalPath);         try (FileInputStream fis = new FileInputStream(zip);                 ZipInputStream cin = new ZipInputStream(fis);                 FileOutputStream out = new FileOutputStream(newFile)) {             cin.getNextEntry();             IOUtils.copy(cin, out);         } finally {             if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {                 LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());                 zip.deleteOnExit();             }         }     }"
"public static <A> A[] arrayFilter(A[] arr, Predicate<A> accept) {
		if (arr == null || arr.length == 0)
			return arr;
		A[] accepted = newArray(arr, arr.length);
		int j = 0;
		for (int i = 0; i < arr.length; i++)
			if (accept.test(arr[i]))
				accepted[j++] = arr[i];
		return j == arr.length ? arr : copyOf(accepted, j);
	}",3,filter array,"filter array<CODESPLIT>public static <A> A[] arrayFilter(A[] arr, Predicate<A> accept) { 		if (arr == null || arr.length == 0) 			return arr; 		A[] accepted = newArray(arr, arr.length); 		int j = 0; 		for (int i = 0; i < arr.length; i++) 			if (accept.test(arr[i])) 				accepted[j++] = arr[i]; 		return j == arr.length ? arr : copyOf(accepted, j); 	}"
"private File extractFile(String fileName, JarFile containingJar, File dstDir)
			throws DeploymentException {

		ZipEntry zipFileEntry = containingJar.getEntry(fileName);
		logger.trace(""Extracting file "" + fileName + "" from ""
				+ containingJar.getName());
		if (zipFileEntry == null) {
			throw new DeploymentException(""Error extracting jar file  ""
					+ fileName + "" from "" + containingJar.getName());
		}
		File extractedFile = new File(dstDir, new File(zipFileEntry.getName())
				.getName());
		try {
			pipeStream(containingJar.getInputStream(zipFileEntry),
					new FileOutputStream(extractedFile));
		} catch (FileNotFoundException e) {
			throw new DeploymentException(""file "" + fileName + "" not found in ""
					+ containingJar.getName(), e);
		} catch (IOException e) {
			throw new DeploymentException(""erro extracting file "" + fileName
					+ "" from "" + containingJar.getName(), e);
		}
		logger.debug(""Extracted file "" + extractedFile.getName());
		return extractedFile;
	}",0,extracting data from a text file,"extracting data from a text file<CODESPLIT>private File extractFile(String fileName, JarFile containingJar, File dstDir) 			throws DeploymentException {  		ZipEntry zipFileEntry = containingJar.getEntry(fileName); 		logger.trace(""Extracting file "" + fileName + "" from "" 				+ containingJar.getName()); 		if (zipFileEntry == null) { 			throw new DeploymentException(""Error extracting jar file  "" 					+ fileName + "" from "" + containingJar.getName()); 		} 		File extractedFile = new File(dstDir, new File(zipFileEntry.getName()) 				.getName()); 		try { 			pipeStream(containingJar.getInputStream(zipFileEntry), 					new FileOutputStream(extractedFile)); 		} catch (FileNotFoundException e) { 			throw new DeploymentException(""file "" + fileName + "" not found in "" 					+ containingJar.getName(), e); 		} catch (IOException e) { 			throw new DeploymentException(""erro extracting file "" + fileName 					+ "" from "" + containingJar.getName(), e); 		} 		logger.debug(""Extracted file "" + extractedFile.getName()); 		return extractedFile; 	}"
"public static String[] split(final String src, final String delimiter) {
		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last
		int[] positions = new int[maxparts];
		int dellen = delimiter.length();

		int i, j = 0;
		int count = 0;
		positions[0] = - dellen;
		while ((i = src.indexOf(delimiter, j)) != -1) {
			count++;
			positions[count] = i;
			j = i + dellen;
		}
		count++;
		positions[count] = src.length();

		String[] result = new String[count];

		for (i = 0; i < count; i++) {
			result[i] = src.substring(positions[i] + dellen, positions[i + 1]);
		}
		return result;
	}",1,positions of substrings in string,"positions of substrings in string<CODESPLIT>public static String[] split(final String src, final String delimiter) { 		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last 		int[] positions = new int[maxparts]; 		int dellen = delimiter.length();  		int i, j = 0; 		int count = 0; 		positions[0] = - dellen; 		while ((i = src.indexOf(delimiter, j)) != -1) { 			count++; 			positions[count] = i; 			j = i + dellen; 		} 		count++; 		positions[count] = src.length();  		String[] result = new String[count];  		for (i = 0; i < count; i++) { 			result[i] = src.substring(positions[i] + dellen, positions[i + 1]); 		} 		return result; 	}"
"private CommandLine parseArgs(String[] args) throws ParseException {
        final CommandLineParser parser = new DefaultParser();
        final Options options = createCommandLineOptions();
        return parser.parse(options, args);
    }",2,parse command line argument,"parse command line argument<CODESPLIT>private CommandLine parseArgs(String[] args) throws ParseException {         final CommandLineParser parser = new DefaultParser();         final Options options = createCommandLineOptions();         return parser.parse(options, args);     }"
"private void init(final int var) {
        // creates and/or resizes the initializations array if necessary
        if (initializations == null) {
            initializations = new int[2];
        }
        int n = initializations.length;
        if (initializationCount >= n) {
            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
            System.arraycopy(initializations, 0, t, 0, n);
            initializations = t;
        }
        // stores the type to be initialized
        initializations[initializationCount++] = var;
    }",3,initializing array,"initializing array<CODESPLIT>private void init(final int var) {         // creates and/or resizes the initializations array if necessary         if (initializations == null) {             initializations = new int[2];         }         int n = initializations.length;         if (initializationCount >= n) {             int[] t = new int[Math.max(initializationCount + 1, 2 * n)];             System.arraycopy(initializations, 0, t, 0, n);             initializations = t;         }         // stores the type to be initialized         initializations[initializationCount++] = var;     }"
"@Implementation
  protected List<Address> getFromLocation(double latitude, double longitude, int maxResults)
      throws IOException {
    Preconditions.checkArgument(
        -90 <= latitude && latitude <= 90, ""Latitude must be between -90 and 90, got %s"", latitude);
    Preconditions.checkArgument(
        -180 <= longitude && longitude <= 180,
        ""Longitude must be between -180 and 180, got %s"",
        longitude);
    return fromLocation.subList(0, Math.min(maxResults, fromLocation.size()));
  }",0,extract latitude and longitude from given input,"extract latitude and longitude from given input<CODESPLIT>@Implementation   protected List<Address> getFromLocation(double latitude, double longitude, int maxResults)       throws IOException {     Preconditions.checkArgument(         -90 <= latitude && latitude <= 90, ""Latitude must be between -90 and 90, got %s"", latitude);     Preconditions.checkArgument(         -180 <= longitude && longitude <= 180,         ""Longitude must be between -180 and 180, got %s"",         longitude);     return fromLocation.subList(0, Math.min(maxResults, fromLocation.size()));   }"
"static void readWmoXmlTableB(InputStream ios, TableB b) throws IOException {
    org.jdom2.Document doc;
    try {
      SAXBuilder builder = new SAXBuilder();
      doc = builder.build(ios);
    } catch (JDOMException e) {
      throw new IOException(e.getMessage());
    }

    Element root = doc.getRootElement();

    String[] elems = null;
    for (Version v : Version.values()) {
      elems = v.getElemNamesB();
      List<Element> featList = root.getChildren(elems[0]);
      if (featList != null && featList.size() > 0) {
        break;
      }
    }

    // if not found using element name, assume its BUFR_WMO
    if (elems == null) {
      elems = Version.BUFR_WMO.getElemNamesB();
    }

    List<Element> featList = root.getChildren();
    for (Element elem : featList) {
      Element ce = elem.getChild(elems[1]);
      if (ce == null) continue;

      String name = Util.cleanName(elem.getChildTextNormalize(elems[1]));
      String units = cleanUnit(elem.getChildTextNormalize(""BUFR_Unit""));
      int x = 0, y = 0, scale = 0, reference = 0, width = 0;

      String fxy = null;
      String s = null;
      try {
        fxy = elem.getChildTextNormalize(""FXY"");
        int xy = Integer.parseInt(cleanNumber(fxy));
        x = xy / 1000;
        y = xy % 1000;

      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' fails parsing %n"", fxy, name);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_Scale"");
        scale = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad scale='%s'%n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_ReferenceValue"");
        reference = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad reference='%s' %n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_DataWidth_Bits"");
        width = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad width='%s' %n"", fxy, name, s);
      }

      b.addDescriptor((short) x, (short) y, scale, reference, width, name, units, null);
    }
    ios.close();
  }",1,reading element from html - <td>,"reading element from html - <td><CODESPLIT>static void readWmoXmlTableB(InputStream ios, TableB b) throws IOException {     org.jdom2.Document doc;     try {       SAXBuilder builder = new SAXBuilder();       doc = builder.build(ios);     } catch (JDOMException e) {       throw new IOException(e.getMessage());     }      Element root = doc.getRootElement();      String[] elems = null;     for (Version v : Version.values()) {       elems = v.getElemNamesB();       List<Element> featList = root.getChildren(elems[0]);       if (featList != null && featList.size() > 0) {         break;       }     }      // if not found using element name, assume its BUFR_WMO     if (elems == null) {       elems = Version.BUFR_WMO.getElemNamesB();     }      List<Element> featList = root.getChildren();     for (Element elem : featList) {       Element ce = elem.getChild(elems[1]);       if (ce == null) continue;        String name = Util.cleanName(elem.getChildTextNormalize(elems[1]));       String units = cleanUnit(elem.getChildTextNormalize(""BUFR_Unit""));       int x = 0, y = 0, scale = 0, reference = 0, width = 0;        String fxy = null;       String s = null;       try {         fxy = elem.getChildTextNormalize(""FXY"");         int xy = Integer.parseInt(cleanNumber(fxy));         x = xy / 1000;         y = xy % 1000;        } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' fails parsing %n"", fxy, name);       }        try {         s = elem.getChildTextNormalize(""BUFR_Scale"");         scale = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad scale='%s'%n"", fxy, name, s);       }        try {         s = elem.getChildTextNormalize(""BUFR_ReferenceValue"");         reference = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad reference='%s' %n"", fxy, name, s);       }        try {         s = elem.getChildTextNormalize(""BUFR_DataWidth_Bits"");         width = Integer.parseInt(cleanNumber(s));       } catch (NumberFormatException e) {         System.out.printf("" key %s name '%s' has bad width='%s' %n"", fxy, name, s);       }        b.addDescriptor((short) x, (short) y, scale, reference, width, name, units, null);     }     ios.close();   }"
"public void parse(File file) throws UpdateException {
        LOGGER.debug(""Parsing "" + file.getName());
        try (InputStream fin = new FileInputStream(file);
                InputStream in = new GZIPInputStream(fin);
                InputStreamReader isr = new InputStreamReader(in, UTF_8);
                JsonReader reader = new JsonReader(isr)) {
            final Gson gson = new GsonBuilder().create();

            reader.beginObject();

            while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
                reader.skipValue();
            }
            reader.beginArray();
            while (reader.hasNext()) {
                final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);

                //cve.getCve().getCVEDataMeta().getSTATE();
                if (testCveCpeStartWithFilter(cve)) {
                    cveDB.updateVulnerability(cve);
                }
            }
        } catch (FileNotFoundException ex) {
            LOGGER.error(ex.getMessage());
            throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);
        } catch (IOException ex) {
            LOGGER.error(""Error reading NVD JSON data: {}"", file);
            LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);
            throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);
        }
    }",2,parse json file,"parse json file<CODESPLIT>public void parse(File file) throws UpdateException {         LOGGER.debug(""Parsing "" + file.getName());         try (InputStream fin = new FileInputStream(file);                 InputStream in = new GZIPInputStream(fin);                 InputStreamReader isr = new InputStreamReader(in, UTF_8);                 JsonReader reader = new JsonReader(isr)) {             final Gson gson = new GsonBuilder().create();              reader.beginObject();              while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {                 reader.skipValue();             }             reader.beginArray();             while (reader.hasNext()) {                 final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);                  //cve.getCve().getCVEDataMeta().getSTATE();                 if (testCveCpeStartWithFilter(cve)) {                     cveDB.updateVulnerability(cve);                 }             }         } catch (FileNotFoundException ex) {             LOGGER.error(ex.getMessage());             throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);         } catch (IOException ex) {             LOGGER.error(""Error reading NVD JSON data: {}"", file);             LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);             throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);         }     }"
"public int randomChooseFromDistribution(double... probs) {
		int result = -1;
		int[] range = new int[probs.length];
		double accuracy = 1000;
		int total = 0;

		for (int i = 0; i < probs.length; i++) {
			range[i] = (int) (probs[i] * accuracy);
			total += range[i];
		}

		int randNum = (int) (rng.nextDouble() * total);
		for (int i = 0; i < range.length; i++) {
			randNum -= range[i];
			if (randNum <= 0) {
				result = i;
				break;
			}
		}
		return result;
	}",3,how to randomly pick a number,how to randomly pick a number<CODESPLIT>public int randomChooseFromDistribution(double... probs) { 		int result = -1; 		int[] range = new int[probs.length]; 		double accuracy = 1000; 		int total = 0;  		for (int i = 0; i < probs.length; i++) { 			range[i] = (int) (probs[i] * accuracy); 			total += range[i]; 		}  		int randNum = (int) (rng.nextDouble() * total); 		for (int i = 0; i < range.length; i++) { 			randNum -= range[i]; 			if (randNum <= 0) { 				result = i; 				break; 			} 		} 		return result; 	}
"private void inspectBinaryFile(byte[] bytes) {
		for (int i = 0; i < bytes.length; i += width) {
			out.print(String.format(""0x%04X "", i));
			// Print out databytes
			for (int j = 0; j < width; ++j) {
				if(j+i < bytes.length) {
					out.print(String.format(""%02X "", bytes[i+j]));
				} else {
					out.print(""   "");
				}
			}
			//
			for (int j = 0; j < width; ++j) {
				if(j+i < bytes.length) {
					char c = (char) bytes[i+j];
					if(c >= 32 && c < 128) {
						out.print(c);
					} else {
						out.print(""."");
					}
				}
			}
			//
			out.println();
		}
	}",0,parse binary file to custom class,"parse binary file to custom class<CODESPLIT>private void inspectBinaryFile(byte[] bytes) { 		for (int i = 0; i < bytes.length; i += width) { 			out.print(String.format(""0x%04X "", i)); 			// Print out databytes 			for (int j = 0; j < width; ++j) { 				if(j+i < bytes.length) { 					out.print(String.format(""%02X "", bytes[i+j])); 				} else { 					out.print(""   ""); 				} 			} 			// 			for (int j = 0; j < width; ++j) { 				if(j+i < bytes.length) { 					char c = (char) bytes[i+j]; 					if(c >= 32 && c < 128) { 						out.print(c); 					} else { 						out.print("".""); 					} 				} 			} 			// 			out.println(); 		} 	}"
"public static void sort(List list, Sort... sorts) {
        Sort.sorts(sorts).sort(list);
    }",1,sort string list,"sort string list<CODESPLIT>public static void sort(List list, Sort... sorts) {         Sort.sorts(sorts).sort(list);     }"
"private static String coerceToEpoch(String s) {
		Long epoch = parseEpochSecond(s);
		if (epoch != null) {
			return String.valueOf(epoch);
		}
		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"");
		try {
			return String.valueOf(format.parse(s).getTime());
		}
		catch (ParseException ex) {
			return s;
		}
	}",2,convert a utc time to epoch,"convert a utc time to epoch<CODESPLIT>private static String coerceToEpoch(String s) { 		Long epoch = parseEpochSecond(s); 		if (epoch != null) { 			return String.valueOf(epoch); 		} 		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ""); 		try { 			return String.valueOf(format.parse(s).getTime()); 		} 		catch (ParseException ex) { 			return s; 		} 	}"
"public static HtmlPage toHtmlPage(String string) {
        try {
            URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");
            return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from String."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(String string) {         try {             URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");             return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from String."", e);         }     }"
"public List<IHidden> getHidden()
    {
        for (final IHidden hidden : this.hidden) {
            hidden.setAdded(false);
        }
        return this.hidden;
    }",0,set file attrib hidden,set file attrib hidden<CODESPLIT>public List<IHidden> getHidden()     {         for (final IHidden hidden : this.hidden) {             hidden.setAdded(false);         }         return this.hidden;     }
"@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                Is24CsvWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<Is24CsvRecord> records = new ArrayList<>();
        records.add(createHausKaufRecord());
        records.add(createHausKaufRecord());
        records.add(createWohnungMieteRecord());
        records.add(createWohnungMieteRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }",1,write csv,"write csv<CODESPLIT>@SuppressWarnings(""Duplicates"")     public static void main(String[] args) {         // init logging         PropertyConfigurator.configure(                 Is24CsvWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));          // create some CSV records         List<Is24CsvRecord> records = new ArrayList<>();         records.add(createHausKaufRecord());         records.add(createHausKaufRecord());         records.add(createWohnungMieteRecord());         records.add(createWohnungMieteRecord());          // write CSV records into a java.io.File         try {             write(records, File.createTempFile(""output-"", "".csv""));         } catch (IOException ex) {             LOGGER.error(""Can't create temporary file!"");             LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);             System.exit(1);         }          // write CSV records into a java.io.OutputStream         write(records, new NullOutputStream());          // write CSV records into a java.io.Writer         write(records, new NullWriter());          // write CSV records into a string and send it to the console         writeToConsole(records);     }"
"private Cookie createCookie(String str) throws UnsupportedEncodingException {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);
    }
    Cookie cookie = new Cookie(AUTH_COOKIE, str);

    cookie.setMaxAge(cookieMaxAge);
    if (cookieDomain != null) {
      cookie.setDomain(cookieDomain);
    }
    if (cookiePath != null) {
      cookie.setPath(cookiePath);
    }
    cookie.setSecure(isCookieSecure);
    return cookie;
  }",2,create cookie,"create cookie<CODESPLIT>private Cookie createCookie(String str) throws UnsupportedEncodingException {     if (LOG.isDebugEnabled()) {       LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);     }     Cookie cookie = new Cookie(AUTH_COOKIE, str);      cookie.setMaxAge(cookieMaxAge);     if (cookieDomain != null) {       cookie.setDomain(cookieDomain);     }     if (cookiePath != null) {       cookie.setPath(cookiePath);     }     cookie.setSecure(isCookieSecure);     return cookie;   }"
"public static HtmlPage toHtmlPage(WebDriver webDriver) {
        try {
            return HTMLParser.parseHtml(
                    new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),
                    new WebClient().getCurrentWindow()
            );
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);
        }
    }",3,how to get html of website,"how to get html of website<CODESPLIT>public static HtmlPage toHtmlPage(WebDriver webDriver) {         try {             return HTMLParser.parseHtml(                     new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),                     new WebClient().getCurrentWindow()             );         } catch (IOException e) {             throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);         }     }"
"public Path withFile(final String file) {
		final Path result = new Path(this);
		result.setFile(file);
		return result;
	}",0,copying a file to a path,copying a file to a path<CODESPLIT>public Path withFile(final String file) { 		final Path result = new Path(this); 		result.setFile(file); 		return result; 	}
"@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                IdxWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<IdxRecord> records = new ArrayList<>();
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }",1,write csv,"write csv<CODESPLIT>@SuppressWarnings(""Duplicates"")     public static void main(String[] args) {         // init logging         PropertyConfigurator.configure(                 IdxWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));          // create some CSV records         List<IdxRecord> records = new ArrayList<>();         records.add(createRecord());         records.add(createRecord());         records.add(createRecord());         records.add(createRecord());          // write CSV records into a java.io.File         try {             write(records, File.createTempFile(""output-"", "".csv""));         } catch (IOException ex) {             LOGGER.error(""Can't create temporary file!"");             LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);             System.exit(1);         }          // write CSV records into a java.io.OutputStream         write(records, new NullOutputStream());          // write CSV records into a java.io.Writer         write(records, new NullWriter());          // write CSV records into a string and send it to the console         writeToConsole(records);     }"
"private static String getHttpOnlyCookieHeader(Cookie cookie) {
    NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),
      cookie.getPath(), cookie.getDomain(), cookie.getVersion(),
      cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());
    return newCookie + ""; HttpOnly"";
  }",2,create cookie,"create cookie<CODESPLIT>private static String getHttpOnlyCookieHeader(Cookie cookie) {     NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),       cookie.getPath(), cookie.getDomain(), cookie.getVersion(),       cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());     return newCookie + ""; HttpOnly"";   }"
"public static String reverse(String string) {
		if(string != null) {
			return new StringBuilder(string).reverse().toString();
		}
		return null;
	}",3,how to reverse a string,how to reverse a string<CODESPLIT>public static String reverse(String string) { 		if(string != null) { 			return new StringBuilder(string).reverse().toString(); 		} 		return null; 	}
