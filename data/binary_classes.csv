label,text
1,"Creates a {@link HtmlPage} from a given {@link String} that contains the HTML code for that page.

@param string {@link String} that contains the HTML code
@return {@link HtmlPage} for this {@link String}[SEP]public static HtmlPage toHtmlPage(String string) {
        try {
            URL url = new URL(""http://bitvunit.codescape.de/some_page.html"");
            return HTMLParser.parseHtml(new StringWebResponse(string, url), new WebClient().getCurrentWindow());
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from String."", e);
        }
    }"
1,"Create a {@link HtmlPage} from a given {@link WebDriver} that has been navigated to a HTML page.

@param webDriver {@link WebDriver} that has been navigated to a HTML page
@return {@link HtmlPage} for the {@link WebDriver}[SEP]public static HtmlPage toHtmlPage(WebDriver webDriver) {
        try {
            return HTMLParser.parseHtml(
                    new StringWebResponse(webDriver.getPageSource(), new URL(webDriver.getCurrentUrl())),
                    new WebClient().getCurrentWindow()
            );
        } catch (IOException e) {
            throw new RuntimeException(""Error creating HtmlPage from WebDriver."", e);
        }
    }"
1,"Reverses the input string.

@param string
the string to be reversed.
@return
the reversed string.[SEP]public static String reverse(String string) {
		if(string != null) {
			return new StringBuilder(string).reverse().toString();
		}
		return null;
	}"
1,"Returns the {@link HtmlElement} with the given id.

@param elementId id to search for on the HTML page
@return {@link HtmlElement} with the given id[SEP]public HtmlElement findHtmlElementById(String elementId) {
        try {
            return htmlPage.getHtmlElementById(elementId);
        } catch (ElementNotFoundException e) {
            return null;
        }
    }"
1,"Format the current time in the specified format.

@return the time string.[SEP]@NonNull
    public static String getNowDateTime(@NonNull String format) {
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        Date curDate = new Date(System.currentTimeMillis());
        return formatter.format(curDate);
    }"
0,"Converts the given postgresql seconds to java seconds. Reverse engineered by inserting varying
dates to postgresql and tuning the formula until the java dates matched. See {@link #toPgSecs}
for the reverse operation.

@param secs Postgresql seconds.
@return Java seconds.[SEP]private static long toJavaSecs(long secs) {
    // postgres epoc to java epoc
    secs += 946684800L;

    // Julian/Gregorian calendar cutoff point
    if (secs < -12219292800L) { // October 4, 1582 -> October 15, 1582
      secs += 86400 * 10;
      if (secs < -14825808000L) { // 1500-02-28 -> 1500-03-01
        int extraLeaps = (int) ((secs + 14825808000L) / 3155760000L);
        extraLeaps--;
        extraLeaps -= extraLeaps / 4;
        secs += extraLeaps * 86400L;
      }
    }
    return secs;
  }"
0,"Converts the given java seconds to postgresql seconds. See {@link #toJavaSecs} for the reverse
operation. The conversion is valid for any year 100 BC onwards.

@param secs Postgresql seconds.
@return Java seconds.[SEP]private static long toPgSecs(long secs) {
    // java epoc to postgres epoc
    secs -= 946684800L;

    // Julian/Greagorian calendar cutoff point
    if (secs < -13165977600L) { // October 15, 1582 -> October 4, 1582
      secs -= 86400 * 10;
      if (secs < -15773356800L) { // 1500-03-01 -> 1500-02-28
        int years = (int) ((secs + 15773356800L) / -3155823050L);
        years++;
        years -= years / 4;
        secs += years * 86400;
      }
    }

    return secs;
  }"
0,"Replaces positional substitution patterns of the form %{\d} with
corresponding element of the given subs array.
Note that %{\d} numbers are 1-based, so we lok for subs[x-1].[SEP]public String posSubst(String s, String[] subs, int behavior) {
        Matcher matcher = posPattern.matcher(s);
        int previousEnd = 0;
        StringBuffer sb = new StringBuffer();
        String varValue;
        int varIndex;
        String condlVal;  // Conditional : value
        while (matcher.find()) {
            varIndex = Integer.parseInt(matcher.group(1)) - 1;
            condlVal = ((matcher.groupCount() > 1) ? matcher.group(2) : null);
            varValue = ((varIndex < subs.length) ? subs[varIndex] : null);
            if (condlVal != null) {
                // Replace varValue (the value to be substituted), with
                // the post-:+ portion of the expression.
                varValue = ((varValue == null)
                        ? """"
                        : condlVal.replaceAll(""\\Q%"" + (varIndex+1) + ""\\E\\b"",
                                RefCapablePropertyResourceBundle.literalize(
                                        varValue)));
            }
            // System.err.println(""Behavior: "" + behavior);
            if (varValue == null) switch (behavior) {
                case THROW_BEHAVIOR:
                    throw new RuntimeException(
                            Integer.toString(subs.length)
                            + "" positional values given, but property string ""
                            + ""contains ("" + matcher.group() + "")."");
                case EMPTYSTRING_BEHAVIOR:
                    varValue = """";
                case NOOP_BEHAVIOR:
                    break;
                default:
                    throw new RuntimeException(
                            ""Undefined value for behavior: "" + behavior);
            }
            sb.append(s.substring(previousEnd, matcher.start())
                        + ((varValue == null) ? matcher.group() : varValue));
            previousEnd = matcher.end();
        }
        return (previousEnd < 1) ? s
                                 : (sb.toString() + s.substring(previousEnd));
    }"
0,"Converts the decoded buffer into a BufferedImage.
precision: 16 bit, componentCount = 1

@param decoded data buffer
@param precision
@param width   of the image
@param height  of the image   @return a BufferedImage.TYPE_USHORT_GRAY[SEP]private BufferedImage to16Bit1ComponentGrayScale(int[][] decoded, int precision, int width, int height) {
        BufferedImage image;
        if (precision == 16) {
            image = new BufferedImage(width, height, BufferedImage.TYPE_USHORT_GRAY);
        }
        else {
            ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), new int[] {precision}, false, false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);
            image = new BufferedImage(colorModel, colorModel.createCompatibleWritableRaster(width, height), colorModel.isAlphaPremultiplied(), null);
        }

        short[] imageBuffer = ((DataBufferUShort) image.getRaster().getDataBuffer()).getData();

        for (int i = 0; i < imageBuffer.length; i++) {
            imageBuffer[i] = (short) decoded[0][i];
        }

        return image;
    }"
1,"Receive a UDP packet from the tracker.

@param attempt The attempt number, used to calculate the timeout for the
receive operation.
@retun Returns a {@link ByteBuffer} containing the packet data.[SEP]private ByteBuffer recv(int attempt)
          throws IOException, SocketException, SocketTimeoutException {
    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);
    logger.trace(""Setting receive timeout to {}s for attempt {}..."",
            timeout, attempt);
    this.socket.setSoTimeout(timeout * 1000);

    try {
      DatagramPacket p = new DatagramPacket(
              new byte[UDP_PACKET_LENGTH],
              UDP_PACKET_LENGTH);
      this.socket.receive(p);
      return ByteBuffer.wrap(p.getData(), 0, p.getLength());
    } catch (SocketTimeoutException ste) {
      throw ste;
    }
  }"
1,"Internal method to call recv on the socket.
Does not trap any ZMQExceptions but expects caling routine to handle them.
@param socket
0MQ socket to read from
@return
byte[] data[SEP]private byte[] recv(Socket socket, int flags)
    {
        Utils.checkArgument(socket != null, ""socket parameter must not be null"");
        data = socket.recv(flags);
        more = socket.hasReceiveMore();
        return data;
    }"
1,"Compute the median of an array efficiently using the QuickSelect method.

Note: the array is <b>modified</b> by this.

@param <T> object type
@param data Data to process
@param comparator Comparator to use
@return Median value[SEP]public static <T> T median(List<? extends T> data, Comparator<? super T> comparator) {
    return median(data, comparator, 0, data.size());
  }"
1,"Computes log likelihood of an entire clustering.
<p>
Version as used by Zhao et al.

@param relation Data relation
@param clustering Clustering
@param distanceFunction Distance function
@param <V> Vector type
@return Log Likelihood.[SEP]public static <V extends NumberVector> double logLikelihoodZhao(Relation<V> relation, Clustering<? extends MeanModel> clustering, NumberVectorDistanceFunction<? super V> distanceFunction) {
    List<? extends Cluster<? extends MeanModel>> clusters = clustering.getAllClusters();
    // number of clusters
    final int m = clusters.size();

    // number of objects in the clustering
    int n = 0;
    // cluster sizes
    int[] n_i = new int[m];
    // variances
    double[] d_i = new double[m];

    // Iterate over clusters:
    Iterator<? extends Cluster<? extends MeanModel>> it = clusters.iterator();
    for(int i = 0; it.hasNext(); ++i) {
      Cluster<? extends MeanModel> cluster = it.next();
      n += n_i[i] = cluster.size();
      // Note: the paper used 1/(n-m) but that is probably a typo
      // as it will cause divisions by zero.
      d_i[i] = varianceOfCluster(cluster, distanceFunction, relation) / (double) n_i[i];
    }

    final int dim = RelationUtil.dimensionality(relation);

    // log likelihood of this clustering
    double logLikelihood = 0.;
    // Aggregate
    for(int i = 0; i < m; i++) {
      logLikelihood += n_i[i] * FastMath.log(n_i[i] / (double) n) // ni log ni/n
          - n_i[i] * dim * .5 * MathUtil.LOGTWOPI // ni*d/2 log2pi
          - n_i[i] * .5 * FastMath.log(d_i[i]) // ni/2 log sigma_i
          - (n_i[i] - m) * .5; // (ni-m)/2
    }
    return logLikelihood;
  }"
0,"Run k-means with cluster size constraints.

@param database Database
@param relation relation to use
@return result[SEP]@Override
  public Clustering<MeanModel> run(Database database, Relation<V> relation) {
    // Database objects to process
    final DBIDs ids = relation.getDBIDs();
    // Choose initial means
    double[][] means = initializer.chooseInitialMeans(database, relation, k, getDistanceFunction());
    // Setup cluster assignment store
    List<ModifiableDBIDs> clusters = new ArrayList<>();
    for(int i = 0; i < k; i++) {
      clusters.add(DBIDUtil.newHashSet(relation.size() / k + 2));
    }

    // Meta data storage
    final WritableDataStore<Meta> metas = initializeMeta(relation, means);
    // Perform the initial assignment
    ArrayModifiableDBIDs tids = initialAssignment(clusters, metas, ids);
    // Recompute the means after the initial assignment
    means = means(clusters, means, relation);
    // Refine the result via k-means like iterations
    means = refineResult(relation, means, clusters, metas, tids);

    // Wrap result
    Clustering<MeanModel> result = new Clustering<>(""k-Means Samesize Clustering"", ""kmeans-samesize-clustering"");
    for(int i = 0; i < clusters.size(); i++) {
      result.addToplevelCluster(new Cluster<>(clusters.get(i), new MeanModel(means[i])));
    }
    return result;
  }"
0,"Evaluate a single clustering.

@param db Database
@param rel Data relation
@param c Clustering
@return Mean simplified silhouette[SEP]public double evaluateClustering(Database db, Relation<? extends NumberVector> rel, Clustering<?> c) {
    List<? extends Cluster<?>> clusters = c.getAllClusters();
    NumberVector[] centroids = new NumberVector[clusters.size()];
    int ignorednoise = centroids(rel, clusters, centroids, noiseOption);

    MeanVariance mssil = new MeanVariance();

    Iterator<? extends Cluster<?>> ci = clusters.iterator();
    for(int i = 0; ci.hasNext(); i++) {
      Cluster<?> cluster = ci.next();
      if(cluster.size() <= 1) {
        // As suggested in Rousseeuw, we use 0 for singletons.
        mssil.put(0., cluster.size());
        continue;
      }
      if(cluster.isNoise()) {
        switch(noiseOption){
        case IGNORE_NOISE:
          continue; // Ignore elements
        case TREAT_NOISE_AS_SINGLETONS:
          // As suggested in Rousseeuw, we use 0 for singletons.
          mssil.put(0., cluster.size());
          continue;
        case MERGE_NOISE:
          break; // Treat as cluster below
        }
      }

      // Cluster center:
      final NumberVector center = centroids[i];
      assert (center != null);
      for(DBIDIter it = cluster.getIDs().iter(); it.valid(); it.advance()) {
        NumberVector obj = rel.get(it);
        // a: Distance to own centroid
        double a = distance.distance(center, obj);

        // b: Distance to other clusters centroids:
        double min = Double.POSITIVE_INFINITY;
        Iterator<? extends Cluster<?>> cj = clusters.iterator();
        for(int j = 0; cj.hasNext(); j++) {
          Cluster<?> ocluster = cj.next();
          if(i == j) {
            continue;
          }
          NumberVector other = centroids[j];
          if(other == null) { // Noise!
            switch(noiseOption){
            case IGNORE_NOISE:
              continue;
            case TREAT_NOISE_AS_SINGLETONS:
              // Treat each object like a centroid!
              for(DBIDIter it2 = ocluster.getIDs().iter(); it2.valid(); it2.advance()) {
                double dist = distance.distance(rel.get(it2), obj);
                min = dist < min ? dist : min;
              }
              continue;
            case MERGE_NOISE:
              break; // Treat as cluster below, but should not be reachable.
            }
          }
          // Clusters: use centroid.
          double dist = distance.distance(other, obj);
          min = dist < min ? dist : min;
        }

        // One 'real' cluster only?
        min = min < Double.POSITIVE_INFINITY ? min : a;
        mssil.put((min - a) / (min > a ? min : a));
      }
    }

    double penalty = 1.;
    // Only if {@link NoiseHandling#IGNORE_NOISE}:
    if(penalize && ignorednoise > 0) {
      penalty = (rel.size() - ignorednoise) / (double) rel.size();
    }
    final double meanssil = penalty * mssil.getMean();
    final double stdssil = penalty * mssil.getSampleStddev();
    if(LOG.isStatistics()) {
      LOG.statistics(new StringStatistic(key + "".simplified-silhouette.noise-handling"", noiseOption.toString()));
      if(ignorednoise > 0) {
        LOG.statistics(new LongStatistic(key + "".simplified-silhouette.ignored"", ignorednoise));
      }
      LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.mean"", meanssil));
      LOG.statistics(new DoubleStatistic(key + "".simplified-silhouette.stddev"", stdssil));
    }

    EvaluationResult ev = EvaluationResult.findOrCreate(db.getHierarchy(), c, ""Internal Clustering Evaluation"", ""internal evaluation"");
    MeasurementGroup g = ev.findOrCreateGroup(""Distance-based Evaluation"");
    g.addMeasure(""Simp. Silhouette +-"" + FormatUtil.NF2.format(stdssil), meanssil, -1., 1., 0., false);
    db.getHierarchy().resultChanged(ev);
    return meanssil;
  }"
1,"Cumulative probability density function (CDF) of a normal distribution.

@param x value to evaluate CDF at
@param mu Mean value
@param sigma Standard deviation.
@return The CDF of the given normal distribution at x.[SEP]public static double cdf(double x, double mu, double sigma) {
    if(x <= 0.) {
      return 0.;
    }
    return .5 * (1 + NormalDistribution.erf((FastMath.log(x) - mu) / (MathUtil.SQRT2 * sigma)));
  }"
1,"Inverse cumulative probability density function (probit) of a normal
distribution.

@param x value to evaluate probit function at
@param mu Mean value
@param sigma Standard deviation.
@return The probit of the given normal distribution at x.[SEP]public static double quantile(double x, double mu, double sigma) {
    return FastMath.exp(mu + sigma * NormalDistribution.standardNormalQuantile(x));
  }"
0,"Map the coordinates. Note: vec will be overwritten!

@param camera Camera
@param point2d Input point
@param vec Output vector[SEP]private void mapMouseToPlane(Simple1DOFCamera camera, Point point2d, double[] vec) {
    // Far plane
    camera.unproject(point2d.x, point2d.y, -100., far);
    // Near plane
    camera.unproject(point2d.x, point2d.y, 1., near);
    // Delta vector: far -= near.
    VMath.minusEquals(far, near);
    // Intersection with z=0 plane:
    // far.z - a * near.z = 0 -> a = far.z / near.z
    if (near[2] < 0 || near[2] > 0) {
      double a = far[2] / near[2];
      vec[0] = far[0] - a * near[0];
      vec[1] = far[1] - a * near[1];
      vec[2] = 0;
    }
  }"
0,"/*
(non-Javadoc)

@seecom.ibm.wsspi.webcontainer.collaborator.ICollaboratorHelper#
processSecurityPreInvokeException
(com.ibm.wsspi.webcontainer.security.SecurityViolationException,
com.ibm.wsspi.webcontainer.RequestProcessor,
javax.servlet.http.HttpServletRequest,
javax.servlet.http.HttpServletResponse,
com.ibm.ws.webcontainer.webapp.WebAppDispatcherContext,
com.ibm.ws.webcontainer.webapp.WebApp, java.lang.String)[SEP]public Object processSecurityPreInvokeException(SecurityViolationException sve, RequestProcessor requestProcessor, HttpServletRequest request,
            HttpServletResponse response, WebAppDispatcherContext dispatchContext, WebApp context, String name) throws ServletErrorReport {

        Object secObject = null;

        // begin pq56177

        secObject = sve.getWebSecurityContext();
        int sc = sve.getStatusCode(); // access status code directly. Is
                                      // SC_FORBIDDEN the default?
        // if (sc==null){
        // if
        // (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable
        // (Level.FINE) == true)
        // {
        // logger.logp(Level.FINE,
        // CLASS_NAME,""processSecurityPreInvokeException"",
        // ""webReply is null, default to 403 status code"");
        // }
        // sc = HttpServletResponse.SC_FORBIDDEN;
        // }
        Throwable cause = sve.getCause();

        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
            logger.entering(CLASS_NAME, ""processSecurityPreInvokeException"");
            logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                    ""SecurityCollaboratorHelper.processPreInvokeException():  WebSecurityException thrown ("" + sve.toString()
                            + "").  HTTP status code: "" + sc + ""resource : "" + name);

        } // end if

        if (sc == HttpServletResponse.SC_FORBIDDEN) {
            // If the user has defined a custom error page for
            // SC_FORBIDDEN (HTTP status code 403) then send
            // it to the client ...
            if (context.isErrorPageDefined(sc) == true) {
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""
                            + sc);
                }

                WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);
                wErrorReport.setErrorCode(sc);
                context.sendError(request, response, wErrorReport);
            } else {
                // ... otherwise, use the one provided by the
                // SecurityCollaborator
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                            ""Using default security error page for HTTP status code "" + sc);
                }

                try {
                    securityCollaborator.handleException(request, response, cause);
                } catch (Exception ex) {
                    if (requestProcessor != null) {
                        throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                    } else {
                        throw WebAppErrorReport.constructErrorReport(ex, name);
                    }
                }
                // reply.sendError(wResp);
            } // end if-else
        } else if (sc == HttpServletResponse.SC_UNAUTHORIZED) {
            // Invoking handleException will add the necessary headers
            // to the response ...
            try {
                securityCollaborator.handleException(request, response, cause);
            } catch (Exception ex) {
                if (requestProcessor != null) {
                    throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                } else {
                    throw WebAppErrorReport.constructErrorReport(ex, name);
                }
            }

            // ... if the user has defined a custom error page for
            // SC_UNAUTHORIZED (HTTP status code 401) then
            // send it to the client
            if (context.isErrorPageDefined(sc) == true) {
            	
            	WebContainerRequestState reqState = com.ibm.wsspi.webcontainer.WebContainerRequestState.getInstance(false);
    			boolean errorPageAlreadySent = false;
    			if (reqState!=null) {
    				String spnegoErrorPageAlreadySent = (String)reqState.getAttribute(""spnego.error.page"");
    				reqState.removeAttribute(""spnego.error.page"");
    				if (spnegoErrorPageAlreadySent != null && spnegoErrorPageAlreadySent.equalsIgnoreCase(""true"")) {  					    		
    					errorPageAlreadySent = true; 
    				    if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable (Level.FINE) == true) {
    				         logger.logp(Level.FINE, CLASS_NAME,""processSecurityPreInvokeException"", ""skip error page - already created by spego code"");
    				    }	
    				}    
    			} 

    			if (!errorPageAlreadySent) {

    				if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
    					logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""Using user defined error page for HTTP status code ""
    							+ sc);
    				}

    				WebAppErrorReport wErrorReport = new WebAppErrorReport(cause);
    				wErrorReport.setErrorCode(sc);
    				context.sendError(request, response, wErrorReport);
    				
    			}	
            } else {
                if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
                    logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"",
                            ""Using default security error page for HTTP status code "" + sc);
                }
                // reply.sendError(wResp); comment-out 140967
            }

        } else {
            // Unexpected status code ... not SC_UNAUTHORIZED or SC_FORBIDDEN
            if ((logger.isLoggable(Level.FINE) == true)) {
                logger.logp(Level.FINE, CLASS_NAME, ""processSecurityPreInvokeException"", ""HTTP status code: "" + sc);
            }
            try {
                securityCollaborator.handleException(request, response, cause);
            } catch (Exception ex) {
                if (requestProcessor != null) {
                    throw WebAppErrorReport.constructErrorReport(ex, requestProcessor);
                } else {
                    throw WebAppErrorReport.constructErrorReport(ex, name);
                }
            }
        }
        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && logger.isLoggable(Level.FINE) == true) {
            logger.exiting(CLASS_NAME, ""processSecurityPreInvokeException"");
        }
        return secObject;
    }"
1,"/*
In case, the ReferrerURLCookieHandler is dynamic in every request, then we will need to make this into
OidcClientRequest. And do not do static.[SEP]public static Cookie createCookie(String cookieName, @Sensitive String cookieValue, HttpServletRequest req) {
        return createCookie(cookieName, cookieValue, -1, req);
    }"
1,"utility used to gather metadata info and issue doConnectionSetup.[SEP]private void postGetConnectionHandling(Connection conn) throws SQLException {
        helper.doConnectionSetup(conn);

        String[] sqlCommands = dsConfig.get().onConnect;
        if (sqlCommands != null && sqlCommands.length > 0)
            onConnect(conn, sqlCommands);

        // Log the database and driver versions on first getConnection.
        if (!wasUsedToGetAConnection) {
            // Wait until after the connection succeeds to set the indicator.
            // This accounts for the scenario where the first connection attempt is bad.
            // The information needs to be read again on the second attempt.
            helper.gatherAndDisplayMetaDataInfo(conn, this);
            wasUsedToGetAConnection = true;
        }
    }"
1,"Replaces all occurrences of the strings included in {@code replaceValues} within the file specified by {@code filePath}.
If {@code outputFilePath} is null or empty, the resulting text will be output to the same path as {@code filePath}.

@param filePath
File in which the string will be replaced.
@param replaceValues
Map of strings to be replaced.
@param outputFilePath
File to which results will be written if a change was made. If null or empty, this is set to the
value of {@code filePath}.
@return[SEP]public boolean replaceStringsInFile(String filePath, Map<String, String> replaceValues) {
        return replaceStringsInFile(filePath, replaceValues, null);
    }"
0,"Send a message to a given endpoint. This method adheres to the fire and forget
style messaging.

@param message messages to be sent.
@param to      endpoint to which the message needs to be sent[SEP]public void sendOneWay(MessageOut message, int id, InetAddress to)
    {
        if (logger.isTraceEnabled())
            logger.trace(FBUtilities.getBroadcastAddress() + "" sending "" + message.verb + "" to "" + id + ""@"" + to);

        if (to.equals(FBUtilities.getBroadcastAddress()))
            logger.trace(""Message-to-self {} going over MessagingService"", message);

        // message sinks are a testing hook
        MessageOut processedMessage = SinkManager.processOutboundMessage(message, id, to);
        if (processedMessage == null)
        {
            return;
        }

        // get pooled connection (really, connection queue)
        OutboundTcpConnection connection = getConnection(to, processedMessage);

        // write it
        connection.enqueue(processedMessage, id);
    }"
0,"Fix style property names.[SEP]public String fixPropertyName(String name) {
    if (""float"".equalsIgnoreCase(name)) {
      return ""cssFloat"";
    } else if (""for"".equalsIgnoreCase(name)) {
      return ""htmlFor"";
    }
    return JsUtils.camelize(name);
  }"
1,"/*
Calculates the co-ordinates of some key positions.[SEP]private void updateCoordinates() {
    // Top-left of heat map.
    int x = margin + axisThickness + yAxisLabelSize.height;
    x += (yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight);
    int y = titleSize.height + margin;
    heatMapTL = new Point(x, y);

    // Top-right of heat map.
    x = heatMapTL.x + heatMapSize.width;
    y = heatMapTL.y + heatMapSize.height;
    heatMapBR = new Point(x, y);

    // Centre of heat map.
    x = heatMapTL.x + (heatMapSize.width / 2);
    y = heatMapTL.y + (heatMapSize.height / 2);
    heatMapC = new Point(x, y);
  }"
1,"Reads the text from the file.

@param   file
The text file
@return  The text read from the provided file
@throws  IOException
Any IO exception[SEP]public static String readTextFile(File file) throws IOException
    {
        //create reader to file (with default encoding)
        InputStream inputStream=new FileInputStream(file);
        Reader reader=IOHelper.createReader(inputStream,null);

        //read text
        String text=IOHelper.readTextStream(reader);
        
        return text;
    }"
0,"Detects if a particular word in a sentence is a name.[SEP]private static boolean detectNameWordInSentenceByPosition(final List<Token> _text, final int _pos) {
        boolean isFirstWord = false;
        boolean nextWordIsName = false;
        if (_pos == 0 || !isLetterOrDigit((_text.get(_pos - 1).text.charAt(0)))) {
            isFirstWord = true;
            //noinspection SimplifiableIfStatement
            if (_text.size() > _pos + 1) {
                final String plus1 = _text.get(_pos + 1).text;
                nextWordIsName = (""of"".equalsIgnoreCase(plus1) || ""'s"".equalsIgnoreCase(plus1))
                                 ? ((_text.size() > (_pos + 2)) && isName(_text.get(_pos + 2).text, false, false))
                                 : isName(plus1, false, false);
            }
            else nextWordIsName = false;
        }
        //noinspection UnnecessaryLocalVariable
        final boolean isName = isName(_text.get(_pos).text, isFirstWord, nextWordIsName);

        /*
        String wordType = dict.checkup(Strings.toEngLowerCase(_text.get(_pos));
        if (isFirstWord && !isName && wordType != null && wordType.startsWith(""JJ"")) {
            // if the first word is determined not to be a name but it is an adj.,
            // and if the second word is a name, we consider the first word to be a name as well.
            if (isName(_text.get(_pos + 1), false))
                return true;
        }
        */

        return isName;
    }"
0,"<p>Converts a Boolean to an int specifying the conversion values.</p>

<pre>
BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1
BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0
BooleanUtils.toInteger(null, 1, 0, 2)          = 2
</pre>

@param bool  the Boolean to convert
@param trueValue  the value to return if {@code true}
@param falseValue  the value to return if {@code false}
@param nullValue  the value to return if {@code null}
@return the appropriate value[SEP]public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {
        if (bool == null) {
            return nullValue;
        }
        return bool.booleanValue() ? trueValue : falseValue;
    }"
1,"<p>Reverses a String as per {@link StringBuilder#reverse()}.</p>

<p>A {@code null} String returns {@code null}.</p>

<pre>
StringUtils.reverse(null)  = null
StringUtils.reverse("""")    = """"
StringUtils.reverse(""bat"") = ""tab""
</pre>

@param str  the String to reverse, may be null
@return the reversed String, {@code null} if null String input[SEP]public static String reverse(final String str) {
        if (str == null) {
            return null;
        }
        return new StringBuilder(str).reverse().toString();
    }"
1,"Extracts a zip file specified by the zipFilePath to a directory specified by
destDirectory (will be created if does not exists)[SEP]public static void unzip(File file, File destDir) throws IOException {
        if (!destDir.exists()) {
            destDir.mkdir();
        }
        ZipInputStream zipIn = new ZipInputStream(new FileInputStream(file));
        ZipEntry entry = zipIn.getNextEntry();
        // iterates over entries in the zip file
        while (entry != null) {
            File entryFile = new File(destDir, entry.getName());
            if (!entry.isDirectory()) {
                // if the entry is a file, extracts it
                extractFile(zipIn, entryFile);
            } else {
                // if the entry is a directory, make the directory
                entryFile.mkdir();
            }
            zipIn.closeEntry();
            entry = zipIn.getNextEntry();
        }
        zipIn.close();
    }"
1,"Picks a random object from the supplied List. The specified skip object will be skipped when
selecting a random value. The skipped object must exist exactly once in the List.

@param r the random number generator to use.

@return a randomly selected item.[SEP]public static <T> T pickRandom (List<T> values, T skip, Random r)
    {
        int size = values.size();
        if (size < 2) {
            throw new IllegalArgumentException(
                ""Must have at least two elements [size="" + size + ""]"");
        }

        int pick = r.nextInt(size - 1);
        for (int ii = 0; ii < size; ii++) {
            T val = values.get(ii);
            if ((val != skip) && (pick-- == 0)) {
                return val;
            }
        }
        return null;
    }"
1,"Reads the Properties from a file that was created by the
{@link #writePropertiesToFile(Properties, File) writePropertiesToFile}
method.

@param file file to read the Properties object from.
@return the Properties object in the file
@throws IOException if an I/O error occurs.[SEP]public static Properties readPropertiesFromFile(File file)
      throws IOException {
    try (FileInputStream fis = new FileInputStream(file)) {
      Properties prop = new Properties();
      prop.load(fis);
      return prop;
    }
  }"
0,"Replaces all occurrences of a String with a String
Please consider the variant with the Appendable for higher performance.[SEP]public static String replace(final String string, final String find, final String replacement) {
		int pos = string.indexOf(find);
		//System.out.println(string+"": ""+find+"" at ""+pos);
		if (pos == -1) return string;
		StringBuilder SB = new StringBuilder();
		int lastpos = 0;
		final int findLen = find.length();
		do {
			SB.append(string, lastpos, pos).append(replacement);
			lastpos = pos + findLen;
			pos = string.indexOf(find, lastpos);
		} while (pos != -1);
		int len = string.length();
		if(lastpos<len) SB.append(string, lastpos, len);
		return SB.toString();
	}"
1,"Returns a unique identifying byte array for the server, generally
the mac address.[SEP]public byte[] getHardwareAddress()
  {
    if (CurrentTime.isTest() || System.getProperty(""test.mac"") != null) {
      return new byte[] { 10, 0, 0, 0, 0, 10 };
    }
    
    for (NetworkInterfaceBase nic : getNetworkInterfaces()) {
      if (! nic.isLoopback()) {
        return nic.getHardwareAddress();
      }
    }
    
    try {
      InetAddress localHost = InetAddress.getLocalHost();
      
      return localHost.getAddress();
    } catch (Exception e) {
      log.log(Level.FINER, e.toString(), e);
    }
    
    return new byte[0];
  }"
0,"This method ranks the given {@code element} as {@link #RANK_UNACCEPTABLE unacceptable}. After the call of this
method the {@link #getRank(Object) rank} of the given {@code element} is set to {@link #RANK_UNACCEPTABLE} and can
NOT be changed again.

@param element is the unacceptable element.[SEP]public void setUnacceptable(E element) {

    Ranking ranking = this.map.get(element);
    if (ranking == null) {
      ranking = new Ranking();
      this.map.put(element, ranking);
    }
    ranking.setUnacceptable();
  }"
0,"This method gets all elements with a {@link #getRank(Object) rank} greater or equal to the given {@code threshold}.

@param threshold is the minimum accepted {@link #getRank(Object) rank}.
@return the list with all elements better or equal to the given {@code threshold}.[SEP]public List<E> getBetterOrEqual(int threshold) {

    List<E> bests = new ArrayList<>();
    for (E element : this.map.keySet()) {
      Ranking ranking = this.map.get(element);
      if ((ranking != null) && (ranking.rank >= threshold)) {
        bests.add(element);
      }
    }
    return bests;
  }"
1,"Copy to clipboard.

@param text the text[SEP]public static void copyToClipboard(String text) {
		final StringSelection stringSelection = new StringSelection(text);
		final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(stringSelection, stringSelection);
	}"
0,"Read the cmap table,
return false if the table is not present or only unsupported
tables are present. Currently only unicode cmaps are supported.
Set the unicodeIndex in the TTFMtxEntries and fills in the
cmaps vector.

@param in The reader to get the table from
@return True if the table has been read
@throws IOException Indicates a failure to read the table[SEP]private boolean readCMAP(FontFileReader in) throws IOException {

        unicodeMapping = new java.util.ArrayList();

        //Read CMAP table and correct mtxTab.index
        int mtxPtr = 0;

        seekTab(in, ""cmap"", 2);
        int numCMap = in.readTTFUShort();    // Number of cmap subtables
        long cmapUniOffset = 0;

        log.info(numCMap + "" cmap tables"");

        //Read offset for all tables. We are only interested in the unicode table
        for (int i = 0; i < numCMap; i++) {
            int cmapPID = in.readTTFUShort();
            int cmapEID = in.readTTFUShort();
            long cmapOffset = in.readTTFULong();

            log.debug(""Platform ID: "" + cmapPID + "" Encoding: "" + cmapEID);

            if (cmapPID == 3 && cmapEID == 1) {
                cmapUniOffset = cmapOffset;
            }
        }

        if (cmapUniOffset <= 0) {
            log.fatal(""Unicode cmap table not present"");
            log.fatal(""Unsupported format: Aborting"");
            return false;
        }

        // Read unicode cmap
        seekTab(in, ""cmap"", cmapUniOffset);
        int cmapFormat = in.readTTFUShort();
        /*int cmap_length =*/ in.readTTFUShort(); //skip cmap length

        log.info(""CMAP format: "" + cmapFormat);

        if (cmapFormat == 4) {
            in.skip(2);    // Skip version number
            int cmapSegCountX2 = in.readTTFUShort();
            int cmapSearchRange = in.readTTFUShort();
            int cmapEntrySelector = in.readTTFUShort();
            int cmapRangeShift = in.readTTFUShort();

            if (log.isDebugEnabled()) {
                log.debug(""segCountX2   : "" + cmapSegCountX2);
                log.debug(""searchRange  : "" + cmapSearchRange);
                log.debug(""entrySelector: "" + cmapEntrySelector);
                log.debug(""rangeShift   : "" + cmapRangeShift);
            }


            int[] cmapEndCounts = new int[cmapSegCountX2 / 2];
            int[] cmapStartCounts = new int[cmapSegCountX2 / 2];
            int[] cmapDeltas = new int[cmapSegCountX2 / 2];
            int[] cmapRangeOffsets = new int[cmapSegCountX2 / 2];

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapEndCounts[i] = in.readTTFUShort();
            }

            in.skip(2);    // Skip reservedPad

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapStartCounts[i] = in.readTTFUShort();
            }

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapDeltas[i] = in.readTTFShort();
            }

            //int startRangeOffset = in.getCurrentPos();

            for (int i = 0; i < (cmapSegCountX2 / 2); i++) {
                cmapRangeOffsets[i] = in.readTTFUShort();
            }

            int glyphIdArrayOffset = in.getCurrentPos();

            // Insert the unicode id for the glyphs in mtxTab
            // and fill in the cmaps ArrayList

            for (int i = 0; i < cmapStartCounts.length; i++) {

                if (log.isTraceEnabled()) {
                    log.trace(i + "": "" + cmapStartCounts[i]
                                                         + "" - "" + cmapEndCounts[i]);
                }

                for (int j = cmapStartCounts[i]; j <= cmapEndCounts[i]; j++) {

                    // Update lastChar
                    if (j < 256 && j > lastChar) {
                        lastChar = (short)j;
                    }

                    if (mtxPtr < mtxTab.length) {
                        int glyphIdx;
                        // the last character 65535 = .notdef
                        // may have a range offset
                        if (cmapRangeOffsets[i] != 0 && j != 65535) {
                            int glyphOffset = glyphIdArrayOffset
                                + ((cmapRangeOffsets[i] / 2)
                                    + (j - cmapStartCounts[i])
                                    + (i)
                                    - cmapSegCountX2 / 2) * 2;
                            in.seekSet(glyphOffset);
                            glyphIdx = (in.readTTFUShort() + cmapDeltas[i])
                                       & 0xffff;

                            unicodeMapping.add(new UnicodeMapping(glyphIdx, j));
                            mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));


                            // Also add winAnsiWidth
                            List v = (List)ansiIndex.get(new Integer(j));
                            if (v != null) {
                                Iterator e = v.listIterator();
                                while (e.hasNext()) {
                                    Integer aIdx = (Integer)e.next();
                                    ansiWidth[aIdx.intValue()] 
                                        = mtxTab[glyphIdx].getWx();

                                    if (log.isTraceEnabled()) {
                                        log.trace(""Added width ""
                                                + mtxTab[glyphIdx].getWx()
                                                + "" uni: "" + j
                                                + "" ansi: "" + aIdx.intValue());
                                    }
                                }
                            }

                            if (log.isTraceEnabled()) {
                                log.trace(""Idx: ""
                                        + glyphIdx
                                        + "" Delta: "" + cmapDeltas[i]
                                        + "" Unicode: "" + j
                                        + "" name: "" + mtxTab[glyphIdx].getName());
                            }
                        } else {
                            glyphIdx = (j + cmapDeltas[i]) & 0xffff;

                            if (glyphIdx < mtxTab.length) {
                                mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));
                            } else {
                                log.debug(""Glyph "" + glyphIdx
                                                   + "" out of range: ""
                                                   + mtxTab.length);
                            }

                            unicodeMapping.add(new UnicodeMapping(glyphIdx, j));
                            if (glyphIdx < mtxTab.length) {
                                mtxTab[glyphIdx].getUnicodeIndex().add(new Integer(j));
                            } else {
                                log.debug(""Glyph "" + glyphIdx
                                                   + "" out of range: ""
                                                   + mtxTab.length);
                            }

                            // Also add winAnsiWidth
                            List v = (List)ansiIndex.get(new Integer(j));
                            if (v != null) {
                                Iterator e = v.listIterator();
                                while (e.hasNext()) {
                                    Integer aIdx = (Integer)e.next();
                                    ansiWidth[aIdx.intValue()] = mtxTab[glyphIdx].getWx();
                                }
                            }

                            //getLogger().debug(""IIdx: "" +
                            //    mtxPtr +
                            //    "" Delta: "" + cmap_deltas[i] +
                            //    "" Unicode: "" + j +
                            //    "" name: "" +
                            //    mtxTab[(j+cmap_deltas[i]) & 0xffff].name);

                        }
                        if (glyphIdx < mtxTab.length) {
                            if (mtxTab[glyphIdx].getUnicodeIndex().size() < 2) {
                                mtxPtr++;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }"
1,"Link this set of controls to a linear interpolater within the particle emitter

@param name The name of the article emitter being linked
@param interpol The interpolator being configured[SEP]private void linkToEmitter(String name, LinearInterpolator interpol) {
		// put to value map
		valueMap.put(name, interpol);

		// now update the checkbox to represent the state of the given
		// interpolator
		boolean checked = interpol.isActive();
		JCheckBox enableControl = (JCheckBox) valueNameToControl.get(name);
		enableControl.setSelected(false);
		if (checked)
			enableControl.setSelected(checked);
	}"
1,"Start add a unique constraint in DDL, detail usage see demo[SEP]public UniqueModel unique() {
		checkReadOnly();
		UniqueModel unique = new UniqueModel();
		unique.setTableModel(this);
		getUniqueConsts().add(unique);
		return unique;
	}"
1,"Load a text from the specified reader and put it in the provided StringBuffer.

@param source source reader.
@param buffer buffer to load text into.
@return the buffer
@throws IOException if there is a problem to deal with.[SEP]public StringBuffer append(Reader source, StringBuffer buffer) throws IOException
	{
		BufferedReader _bufferedReader = new BufferedReader(source);
		char[] _buffer = new char[getBufferSize()]; // load by chunk of 4 ko
		try
		{
			for (int _countReadChars = 0; _countReadChars >= 0;)
			{
				buffer.append(_buffer, 0, _countReadChars);
				_countReadChars = _bufferedReader.read(_buffer);
			}
		}
		finally
		{
			_bufferedReader.close();
		}
		return buffer;
	}"
1,"Animates this {@link Animation}.<br>
Sets the {@link #started} and {@link #finished} status.

@param timer the timer
@return the s[SEP]public S animate(Timer timer)
	{
		long elapsed = timer.elapsedTime() - Timer.tickToTime(delay);
		started = elapsed > transform.getDelay();
		finished = elapsed > transform.totalDuration() && transform.getLoops() != -1;

		if (!started && !renderBefore)
			return null;
		if (finished && !renderAfter)
			return null;

		transform.transform(transformable, elapsed);
		return transformable;
	}"
0,"Gets value from SharedPreferences with a given key and type
as a RxJava Observable, which can be subscribed.
If value is not found, we can return defaultValue.
Emit preference as first element of the stream even if preferences wasn't changed.

@param key key of the preference
@param classOfT class of T (e.g. String.class)
@param defaultValue default value of the preference (e.g. """" or ""undefined"")
@param <T> return type of the preference (e.g. String)
@return Observable value from SharedPreferences associated with given key or default value[SEP]public <T> Observable<T> getAndObserve(String key, Class<T> classOfT, T defaultValue) {
    return getAndObserve(key, TypeToken.fromClass(classOfT), defaultValue);
  }"
1,"Deserializes a JSON input into an object.

@param reader {@link JsonReader} used to read the JSON input
@param ctx Context for the full deserialization process
@return the deserialized object
@throws com.github.nmorel.gwtjackson.client.exception.JsonDeserializationException if an error occurs during the deserialization[SEP]public T deserialize( JsonReader reader, JsonDeserializationContext ctx ) throws JsonDeserializationException {
        return deserialize( reader, ctx, JsonDeserializerParameters.DEFAULT );
    }"
0,"Encrypts or decrypts a byte[].

@param crypt byte[] to encrypt or decrypt
@param key   key to use
@param mode  {@link Cipher#DECRYPT_MODE} to decrypt or {@link Cipher#ENCRYPT_MODE} to encrypt
@return byte[] encrypted or decrypted[SEP]private byte[] doEncryptionOrDecryption(byte[] crypt, Key key, int mode) {
        Cipher rsaCipher;
        try {
            rsaCipher = Cipher.getInstance(CIPHER);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw SeedException.wrap(e, CryptoErrorCode.UNABLE_TO_GET_CIPHER)
                    .put(""alias"", alias)
                    .put(""cipher"", CIPHER);
        }
        try {
            rsaCipher.init(mode, key);
        } catch (InvalidKeyException e) {
            throw SeedException.wrap(e, CryptoErrorCode.INVALID_KEY)
                    .put(""alias"", alias);
        }
        try {
            return rsaCipher.doFinal(crypt);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            throw SeedException.wrap(e, CryptoErrorCode.UNEXPECTED_EXCEPTION);
        }
    }"
0,"Returns a list filled randomly from the given elements.

@param elements elements to randomly fill list from
@param size range that the size of the list will be randomly chosen from
@param <T> the type of elements in the given iterable
@return list filled randomly from the given elements
@throws IllegalArgumentException if the elements to fill list from is empty or if the size
range contains negative integers[SEP]public static <T> List<T> randomListFrom(Iterable<T> elements, Range<Integer> size) {
    checkArgument(!isEmpty(elements), ""Elements to populate from must not be empty"");
    return randomListFrom(() -> IterableUtils.randomFrom(elements), size);
  }"
1,"Case insensitive version of {@link String#indexOf(java.lang.String, int)}. Equivalent to
{@code text.indexOf(str, startIndex)}, except the matching is case insensitive.[SEP]public static int indexOfIgnoreCase(String text, String str, int startIndex) {
        Matcher m = Pattern.compile(Pattern.quote(str), Pattern.CASE_INSENSITIVE).matcher(text);
        return m.find(startIndex) ? m.start() : -1;
    }"
1,"Extracts HTML elements from the main HTML content. The result consists of the extracted HTML
elements and the remainder of HTML content, with these elements removed. Can be limited to a
certain amount, e.g. to extract just the first of selected elements.

@param content
HTML content to extract elements from
@param selector
CSS selector for elements to extract
@param amount
Maximum number of elements to extract
@return HTML content of the extracted elements together with the remainder of the original
content. If no elements are found, the remainder contains the original content.
@since 1.0[SEP]public ExtractResult extract(String content, String selector, int amount) {

		List<Element> extracted = extractElements(content, selector, amount);

		if (extracted.size() > 1) {

			// first element is the remaining body, the rest are extracted
			Element body = extracted.get(0);
			List<Element> elements = extracted.subList(1, extracted.size());

			// convert to HTML
			List<String> elementStr = new ArrayList<String>();
			for (Element el : elements) {
				elementStr.add(el.outerHtml());
			}

			return new DefaultExtractResult(elementStr, body.html());
		} else {
			// nothing to extract
			return new DefaultExtractResult(Collections.<String> emptyList(), content);
		}
	}"
0,"Method allow to find load balancers that contains {@code substring} in description
Filtering is case insensitive.

@param subStrings is a set of descriptions
@return {@link LoadBalancerFilter}[SEP]public LoadBalancerFilter descriptionContains(String... subStrings) {
        allItemsNotNull(subStrings, ""Load balancer description subStrings"");

        predicate = predicate.and(combine(
                LoadBalancerMetadata::getDescription, in(asList(subStrings), Predicates::containsIgnoreCase)
        ));

        return this;
    }"
0,"Method allow to find templates that contains {@code substring} in description
Filtering is case insensitive.

@param substrings is a set of descriptions
@return {@link TemplateFilter}[SEP]public TemplateFilter descriptionContains(String... substrings) {
        allItemsNotNull(substrings, ""Template description substrings"");

        predicate = predicate.and(combine(
            TemplateMetadata::getDescription, in(asList(substrings), Predicates::containsIgnoreCase)
        ));

        return this;
    }"
1,"Sums up all matrices into a new one

@param matrices confusion matrices
@return confusion matrix[SEP]public static ConfusionMatrix createCumulativeMatrix(ConfusionMatrix... matrices)
    {
        ConfusionMatrix result = new ConfusionMatrix();

        for (ConfusionMatrix matrix : matrices) {
            for (Map.Entry<String, Map<String, Integer>> gold : matrix.map.entrySet()) {
                for (Map.Entry<String, Integer> actual : gold.getValue().entrySet()) {
                    result.increaseValue(gold.getKey(), actual.getKey(), actual.getValue());
                }
            }
        }

        return result;
    }"
0,"Returns transposed confusion matrix (gold and predicted are switched)

@return new instance[SEP]public ConfusionMatrix getTransposedMatrix()
    {
        ConfusionMatrix result = new ConfusionMatrix();

        for (Map.Entry<String, Map<String, Integer>> gold : this.map.entrySet()) {
            for (Map.Entry<String, Integer> predicted : gold.getValue().entrySet()) {
                int value = predicted.getValue();

                // add reverted values
                result.increaseValue(predicted.getKey(), gold.getKey(), value);
            }
        }

        return result;
    }"
1,"Gets the numerical HTTP status code concatenated with the
text representing that status code, for example {@code ""403 Forbidden""}.

<p>If the status code is unknown then the text will be
{@code ""<Unknown status code>""}.
@param sc numerical HTTP status code
@return[SEP]public static String getHttpStatusCodeText(int sc) {
        HttpStatusCode sCode = HttpStatusCode.fromNumStatusCode(sc);
        if (sCode == null) {
            return sc + "" <unknown status code>"";
        } else {
            return sCode.toString();
        }
    }"
1,"Read all configuration files available into the application classpath.[SEP]private void readPropertiesFiles() {

        if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {
            // Skip configuration loading
            LOGGER.info(JRebirthMarkers.MESSAGE, ""Messages Loading is skipped"");

        } else {
            // Assemble the regex pattern
            final Pattern filePattern = Pattern.compile(this.messageFileWildcard + ""\\.properties"");

            // Retrieve all resources from default classpath
            final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);

            LOGGER.info(JRebirthMarkers.MESSAGE, ""{} Messages file{} found."", list.size(), list.size() > 1 ? ""s"" : """");

            for (final String rbFilename : list) {
                readPropertiesFile(rbFilename);
            }
        }
    }"
0,"/* (non-Javadoc)
@see javax.jms.MessageProducer#setPriority(int)[SEP]@Override
	public final void setPriority(int priority) throws JMSException
    {
        if (priority < 0 || priority > 9)
            throw new FFMQException(""Invalid priority value : ""+priority,""INVALID_PRIORITY"");
        
        this.defaultPriority = priority;
    }"
1,"Execute POST request

@param   url Request object for POST
@param   method HTTP method
@param   params POST parameters
@throws  JSONException
@return  {@link JSONObject}[SEP]private static JSONObject doPostRequest(HttpPost httpPost, HashMap<String, String> params) throws JSONException {
    	JSONObject json = null;
        HttpClient postClient = HttpClientBuilder.create().build();
        HttpResponse response;
        
        try {
            response = postClient.execute(httpPost);
            
            if(response.getStatusLine().getStatusCode() == 200) {
                HttpEntity entity = response.getEntity();
                
                if (entity != null) {
                    InputStream instream = entity.getContent();  
                    String result = convertStreamToString(instream);
                    instream.close();
                    
                    json = new JSONObject(result);
                }
            } else {
            	json = UpworkRestClient.genError(response);
            }
        } catch (ClientProtocolException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: ClientProtocolException"");
        } catch (IOException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: IOException"");
        } catch (JSONException e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: JSONException"");  
        } catch (Exception e) {
            json = UpworkRestClient.genError(HTTP_RESPONSE_503, ""Exception: Exception "" + e.toString());
        } finally {
            httpPost.abort();
        }
        
        return json;
    }"
0,"makes a String unique by appending a numerical suffix
@param _xElementContainer the com.sun.star.container.XNameAccess container
that the new Element is going to be inserted to
@param _sElementName the StemName of the Element[SEP]public static String createUniqueName(XNameAccess _xElementContainer, String _sElementName) {
        boolean bElementexists = true;
        int i = 1;
        String sIncSuffix = """";
        String BaseName = _sElementName;
        while (bElementexists) {
            bElementexists = _xElementContainer.hasByName(_sElementName);
            if (bElementexists) {
                i += 1;
                _sElementName = BaseName + Integer.toString(i);
            }
        }
        return _sElementName;
    }"
0,"Encode special character in query string to the URL encoded representation.
@param str The input string
@return The encoded String[SEP]public static String encode(String str)
    {
        String encodedValue = str;

        try
        {
            encodedValue = URLEncoder.encode(encodedValue, ""UTF-8"");

            // Spaces in NRQL queries expected to be encoded as ""%20"" instead of ""+"".
            encodedValue = encodedValue.replace(""+"", ""%20"");
        }
        catch (UnsupportedEncodingException e)
        {
            logger.severe(""Failed to encode value: ""+str);
        }

        return encodedValue;
    }"
0,"Manually register the Pippo Error class as  Swagger model.

@param swagger
@return a ref for the Error model[SEP]protected RefProperty registerErrorModel(Swagger swagger) {
        String ref = Error.class.getSimpleName();
        if (swagger.getDefinitions() != null && swagger.getDefinitions().containsKey(ref)) {
            // model already registered
            return new RefProperty(ref);
        }

        ModelImpl model = new ModelImpl();
        swagger.addDefinition(ref, model);

        model.setDescription(""an error message"");

        model.addProperty(""statusCode"", new IntegerProperty().readOnly().description(""http status code""));
        model.addProperty(""statusMessage"", new StringProperty().readOnly().description(""description of the http status code""));
        model.addProperty(""requestMethod"", new StringProperty().readOnly().description(""http request method""));
        model.addProperty(""requestUri"", new StringProperty().readOnly().description(""http request path""));
        model.addProperty(""message"", new StringProperty().readOnly().description(""application message""));

        if (settings.isDev()) {
            // in DEV mode the stacktrace is returned in the error message
            model.addProperty(""stacktrace"", new StringProperty().readOnly().description(""application stacktrace""));
        }

        return new RefProperty(ref);
    }"
0,"This method allows to replace all string children, it will remove any children which are not in the list, add the
new ones and update which are in the list.

@param strings string children list to replace.[SEP]public void replaceStringChildren(List<String> strings) {
		ArrayList<StringEntity> entities = new ArrayList<>();
		for (String string : strings) {
			StringEntity entity = new StringEntity();
			entity.setValue(string);
			entities.add(entity);
		}
		replaceAll(entities);
	}"
0,"Fires the necessary property change event for changes to the readOnly
property. Must be called whenever the value of readOnly is changed.[SEP]protected void readOnlyUpdated() {
		boolean localReadOnly = isReadOnly();
		if (hasChanged(oldReadOnly, localReadOnly)) {
			oldReadOnly = localReadOnly;
			firePropertyChange(READONLY_PROPERTY, !localReadOnly, localReadOnly);
		}
	}"
1,"reverseString[SEP]public static String reverseString(String str) {
        StringBuilder stringBuffer = new StringBuilder(str);
        return stringBuffer.reverse().toString();
    }"
0,"Parse a single attribute definition.

<pre>
[53] AttDef ::= S Name S AttType S DefaultDecl
</pre>[SEP]private void parseAttDef(String elementName) throws Exception {
        String name;
        String type;
        String enumer = null;

        // Read the attribute name.
        name = readNmtoken(true);

        // Read the attribute type.
        requireWhitespace();
        type = readAttType();

        // Get the string of enumerated values if necessary.
        if (handler.stringInterning) {
            if ((""ENUMERATION"" == type) || (""NOTATION"" == type)) {
                enumer = dataBufferToString();
            }
        } else {
            if (""ENUMERATION"".equals(type) || ""NOTATION"".equals(type)) {
                enumer = dataBufferToString();
            }
        }

        // Read the default value.
        requireWhitespace();
        parseDefault(elementName, name, type, enumer);
    }"
0,"/*
helper methods[SEP]@SuppressWarnings({""rawtypes"", ""unchecked""})
    protected Object transform(Object result, QueryResultMapper resultMapper) {
        Object actualResult = null;
        if (result instanceof Collection) {

            if (ProcessInstanceCustomDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceCustomDesc to ProcessInstanceCustomList"");
                actualResult = convertToProcessInstanceCustomVarsList((Collection<ProcessInstanceCustomDesc>) result);
            } else if (ProcessInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceWithVarsDesc to ProcessInstanceList"");
                actualResult = convertToProcessInstanceWithVarsList((Collection<ProcessInstanceWithVarsDesc>) result);
            } else if (ProcessInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ProcessInstanceDesc to ProcessInstanceList"");
                actualResult = convertToProcessInstanceList((Collection<ProcessInstanceDesc>) result);
            } else if (UserTaskInstanceWithVarsDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceWithVarsDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceWithVarsList((Collection<UserTaskInstanceWithVarsDesc>) result);
            } else if (UserTaskInstanceWithPotOwnerDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceWithPotOwnerDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceListPO((Collection<UserTaskInstanceWithPotOwnerDesc>) result);
            } else if (UserTaskInstanceDesc.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of UserTaskInstanceDesc to TaskInstanceList"");
                actualResult = convertToTaskInstanceList((Collection<UserTaskInstanceDesc>) result);
            } else if (TaskSummary.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of TaskSummary to TaskSummaryList"");
                actualResult = convertToTaskSummaryList((Collection<TaskSummary>) result);
            } else if (ExecutionError.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of ExecutionError to ErrorInstanceList"");
                actualResult = convertToErrorInstanceList((List<ExecutionError>) result);
            } else if (List.class.isAssignableFrom(resultMapper.getType())) {

                logger.debug(""Converting collection of List to ArrayList"");
                actualResult = new ArrayList((Collection) result);
            }else {

                logger.debug(""Convert not supported for custom type {}"", resultMapper.getType());
                actualResult = result;
            }

            logger.debug(""Actual result after converting is {}"", actualResult);
        } else {
            logger.debug(""Result is not a collection - {}, skipping any conversion"", result);
            actualResult = result;
        }
        return actualResult;
    }"
0,"Converts all HTML entities to applicable characters.

@param encodedHtml The encoded HTML
@return The decoded HTML[SEP]public static String htmlDecode(final String encodedHtml) {
        validate(encodedHtml, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);
        String[] entities = encodedHtml.split(""&\\W+;"");
        return Arrays.stream(entities).map(e -> HtmlEntities.decodedEntities.get(e)).collect(joining());
    }"
1,"Deserializes the JSON payload contained in an event's {@code request} attribute into an
{@link EventRequest} instance.[SEP]@Override
  public EventRequest deserialize(JsonElement json, Type typeOfT,
      JsonDeserializationContext context)
      throws JsonParseException {
    Gson gson = new GsonBuilder()
        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
        .create();

    // API versions 2017-05-25 and earlier render `request` as a string
    // instead of a JSON object
    if (json.isJsonPrimitive()) {
      EventRequest request = new EventRequest();
      request.setId(json.getAsString());
      return request;
    } else {
      return gson.fromJson(json, typeOfT);
    }
  }"
1,"Generate the whole group from the compact list of permutations.

@return a list of permutations[SEP]public List<Permutation> all() {
        final List<Permutation> permutations = new ArrayList<Permutation>();
        Backtracker counter = new Backtracker() {

            @Override
            public void applyTo(Permutation p) {
                permutations.add(p);
            }

            @Override
            public boolean isFinished() {
                return false;
            }
        };
        this.apply(counter);
        return permutations;
    }"
0,"Create the geometric part of an encoder of 3D configurations

@param i         the central atom (index)
@param adjacent  adjacent atoms (indices)
@param container container
@return geometric parity encoder (or null)[SEP]private static GeometricParity geometric3D(int i, int[] adjacent, IAtomContainer container) {

        IAtom atom = container.getAtom(i);
        Point3d[] coordinates = new Point3d[4];

        // set the forth ligand to centre as default (overwritten if
        // we have 4 neighbors)
        if (atom.getPoint3d() != null)
            coordinates[3] = atom.getPoint3d();
        else
            return null;

        // for each neighboring atom check if we have 3D coordinates
        for (int j = 0; j < adjacent.length; j++) {
            IAtom neighbor = container.getAtom(adjacent[j]);

            if (neighbor.getPoint3d() != null)
                coordinates[j] = neighbor.getPoint3d();
            else
                return null; // skip to next atom
        }

        // add new 3D stereo encoder
        return new Tetrahedral3DParity(coordinates);

    }"
0,"Position the charge label on the top right of either the element or hydrogen label. Where the
charge is placed depends on the number of hydrogens and their position relative to the
element symbol.

@param hydrogens number of hydrogen
@param position  position of hydrogen
@param charge    the charge label outline (to be positioned)
@param element   the element label outline
@param hydrogen  the hydrogen label outline
@return positioned charge label[SEP]TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element,
                                    TextOutline hydrogen) {

        final Rectangle2D chargeBounds = charge.getBounds();

        // the charge is placed to the top right of the element symbol
        // unless either the hydrogen label or the hydrogen count label
        // are in the way - in which case we place it relative to the
        // hydrogen
        Rectangle2D referenceBounds = element.getBounds();
        if (hydrogens > 0 && position == Right)
            referenceBounds = hydrogen.getBounds();
        else if (hydrogens > 1 && position == Above) referenceBounds = hydrogen.getBounds();

        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(),
                                (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    }"
0,"Main method for the calculation of the ligand coordinates for sp3 atoms.
Decides how many coordinates should be created

@param  refAtom            central atom (Atom)
@param  nwanted            how many ligands should be created
@param  length             bond length
@param  angle              angle in a B-A-(X) system; a=central atom;
x=ligand with unknown coordinates
@param  noCoords           Description of the Parameter
@param  withCoords         Description of the Parameter
@param  atomC              Description of the Parameter
@return                    Description of the Return Value[SEP]public Point3d[] get3DCoordinatesForSP3Ligands(IAtom refAtom, IAtomContainer noCoords, IAtomContainer withCoords,
            IAtom atomC, int nwanted, double length, double angle) {
        //logger.debug(""SP3 Ligands start "");
        Point3d newPoints[] = new Point3d[0];
        Point3d aPoint = refAtom.getPoint3d();
        int nwithCoords = withCoords.getAtomCount();
        if (angle < 0) {
            angle = TETRAHEDRAL_ANGLE;
        }
        if (nwithCoords == 0) {
            newPoints = calculate3DCoordinates0(refAtom.getPoint3d(), nwanted, length);
        } else if (nwithCoords == 1) {
            newPoints = calculate3DCoordinates1(aPoint, (withCoords.getAtom(0)).getPoint3d(),
                    (atomC != null) ? atomC.getPoint3d() : null, nwanted, length, angle);
        } else if (nwithCoords == 2) {
            Point3d bPoint = withCoords.getAtom(0).getPoint3d();
            Point3d cPoint = withCoords.getAtom(1).getPoint3d();
            newPoints = calculate3DCoordinates2(aPoint, bPoint, cPoint, nwanted, length, angle);
        } else if (nwithCoords == 3) {
            Point3d bPoint = withCoords.getAtom(0).getPoint3d();
            Point3d cPoint = withCoords.getAtom(1).getPoint3d();
            newPoints = new Point3d[1];
            Point3d dPoint = withCoords.getAtom(2).getPoint3d();
            newPoints[0] = calculate3DCoordinates3(aPoint, bPoint, cPoint, dPoint, length);
        }
        //logger.debug(""...Ready"");
        return newPoints;
    }"
0,"Multiply this permutation by another such that for all i,
this[i] = this[other[i]].

@param other the other permutation to use
@return a new permutation with the result of multiplying the permutations[SEP]public Permutation multiply(Permutation other) {
        Permutation newPermutation = new Permutation(values.length);
        for (int i = 0; i < values.length; i++) {
            newPermutation.values[i] = this.values[other.values[i]];
        }
        return newPermutation;
    }"
1,"Sort the AtomContainers and multipliers using a provided Comparator.
@param comparator defines the sorting method[SEP]@Override
    public void sortAtomContainers(final Comparator<IAtomContainer> comparator) {

        // need to use boxed primitives as we can't customise sorting of int primitives
        Integer[] indexes = new Integer[atomContainerCount];
        for (int i = 0; i < indexes.length; i++)
            indexes[i] = i;

        // proxy the index comparison to the atom container comparator
        Arrays.sort(indexes, new Comparator<Integer>() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return comparator.compare(atomContainers[o1], atomContainers[o2]);
            }
        });

        // copy the original arrays (we could modify in place with swaps but this is cleaner)
        IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
        Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);

        // order the arrays based on the order of the indices
        for (int i = 0; i < indexes.length; i++) {
            atomContainers[i] = containersTmp[indexes[i]];
            multipliers[i] = multipliersTmp[indexes[i]];
        }

    }"
1,"read from classpath, if not found, read from file system. If not found there, throw exception[SEP]private Properties readPropertyFile(String file) throws IOException {
        String fileName = file.startsWith(""/"") ? file : ""/"" + file;
        LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");
        return Util.readProperties(fileName);
    }"
1,"Returns a filtered subset of the specified array.

@param objects an array to filter
@return a filtered array[SEP]@SuppressWarnings(""unchecked"")
    public final T[] filter(final T[] objects) {
        final Collection<T> filtered = filter(Arrays.asList(objects));
        try {
            return filtered.toArray((T[]) Array.newInstance(objects
                    .getClass(), filtered.size()));
        } catch (ArrayStoreException ase) {
            Logger log = LoggerFactory.getLogger(Filter.class);
            log.warn(""Error converting to array - using default approach"", ase);
        }
        return (T[]) filtered.toArray();
    }"
1,"Copy one asset file at a time.

@param asset The asset file to copy[SEP]public void copySingleFile(File asset) {
        try {
            if ( !asset.isDirectory() ) {
                String targetPath = config.getDestinationFolder().getCanonicalPath() + File.separatorChar + assetSubPath(asset);
                LOGGER.info(""Copying single asset file to [{}]"", targetPath);
                copyFile(asset, new File(targetPath));
            } else {
                LOGGER.info(""Skip copying single asset file [{}]. Is a directory."", asset.getPath());
            }
        } catch (IOException io) {
            LOGGER.error(""Failed to copy the asset file."", io);
        }
    }"
0,"Convert hex to number.
@param hex Hex number
@return Decoded[SEP]private static int decode(final int hex) {
        if (hex >= CcHex.BACK.length) {
            throw new DecodingException(
                String.format(""invalid hex char: 0x%2x"", hex)
            );
        }
        final int dec = CcHex.BACK[hex];
        if (dec < 0) {
            throw new DecodingException(
                String.format(""invalid hex character: 0x%2x"", hex)
            );
        }
        return dec;
    }"
0,"Parse the given string as an integer, returning the provided default
value if the string is null.

@param str
The string to parse as an integer.

@param defaultValue
The value to return if <code>str</code> is null.

@return
The parsed value, or the provided default value if <code>str</code>
is null.[SEP]private static int parseInt(String str, int defaultValue) {
        
        if (str == null)
            return defaultValue;
        
        return Integer.parseInt(str);

    }"
1,"Returns an effectively unlimited stream of pseudorandom {@code int}
values, each conforming to the given origin (inclusive) and bound
(exclusive).

@param random a {@link Random} object to produce the stream from
@param randomNumberOrigin the origin (inclusive) of each random value
@param randomNumberBound the bound (exclusive) of each random value
@return a stream of pseudorandom {@code int} values
@see Random#ints(long, int, int)[SEP]public static IntStreamEx of(Random random, int randomNumberOrigin, int randomNumberBound) {
        return seq(random.ints(randomNumberOrigin, randomNumberBound));
    }"
0,"Returns an array containing all the stream elements. If the stream
happens to contain no elements, the supplied empty array is returned
instead. Otherwise the new array is allocated which element type is the
same as the element type of supplied empty array.

<p>
This is a <a href=""package-summary.html#StreamOps"">terminal</a>
operation.

<p>
This method is useful when the stream is expected to return empty arrays
often, so the same instance of empty array (presumably declared in some
static final field) can be reused.

@param <A> the element type of the resulting array
@param emptyArray an empty array of the resulting type
@return an array containing the elements in this stream or the passed
empty array if the stream is empty
@throws ArrayStoreException if the runtime type of the array returned
from the array generator is not a supertype of the runtime type
of every element in this stream
@see #toArray(java.util.function.IntFunction)
@since 0.6.3[SEP]@SuppressWarnings(""unchecked"")
    public <A> A[] toArray(A[] emptyArray) {
        if(emptyArray.length != 0) {
            throw new IllegalArgumentException(""Empty array must be supplied"");
        }
        return stream().toArray(size -> size == 0 ? emptyArray
                : (A[]) Array.newInstance(emptyArray.getClass().getComponentType(), size));
    }"
1,"The Levenshtein distance is a string metric for measuring the difference between two sequences.
Informally, the Levenshtein distance between two words is the minimum number of single-character edits
(i.e. insertions, deletions or substitutions) required to change one word into the other. The phrase
'edit distance' is often used to refer specifically to Levenshtein distance.

@param s String one
@param t String two
@return the 'edit distance' (Levenshtein distance) between the two strings.[SEP]public static int levenshteinDistance(CharSequence s, CharSequence t)
    {
        // degenerate cases          s
        if (s == null || """".equals(s))
        {
            return t == null || """".equals(t) ? 0 : t.length();
        }
        else if (t == null || """".equals(t))
        {
            return s.length();
        }

        // create two work vectors of integer distances
        int[] v0 = new int[t.length() + 1];
        int[] v1 = new int[t.length() + 1];

        // initialize v0 (the previous row of distances)
        // this row is A[0][i]: edit distance for an empty s
        // the distance is just the number of characters to delete from t
        for (int i = 0; i < v0.length; i++)
        {
            v0[i] = i;
        }

        int sLen = s.length();
        int tLen = t.length();
        for (int i = 0; i < sLen; i++)
        {
            // calculate v1 (current row distances) from the previous row v0

            // first element of v1 is A[i+1][0]
            //   edit distance is delete (i+1) chars from s to match empty t
            v1[0] = i + 1;

            // use formula to fill in the rest of the row
            for (int j = 0; j < tLen; j++)
            {
                int cost = (s.charAt(i) == t.charAt(j)) ? 0 : 1;
                v1[j + 1] = (int) MathUtilities.minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
            }

            // copy v1 (current row) to v0 (previous row) for next iteration
            System.arraycopy(v1, 0, v0, 0, v0.length);
        }

        return v1[t.length()];
    }"
1,"Compress a text file using the ZIP compressing algorithm.

@param filename the path to the file to be compressed[SEP]public static void zipCompress(String filename) throws IOException {
    FileOutputStream fos = new FileOutputStream(filename + COMPRESSION_SUFFIX);
    CheckedOutputStream csum = new CheckedOutputStream(fos, new CRC32());
    ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(csum));
    out.setComment(""Failmon records."");

    BufferedReader in = new BufferedReader(new FileReader(filename));
    out.putNextEntry(new ZipEntry(new File(filename).getName()));
    int c;
    while ((c = in.read()) != -1)
      out.write(c);
    in.close();

    out.finish();
    out.close();
  }"
0,"Set the current working directory for the default file system.

@param dir the new current working directory.[SEP]public void setWorkingDirectory(Path dir) {
    if (!dir.isAbsolute()) {
      FileSystem.LogForCollect
          .info(""set job working directory to non absolute path: "" + dir
              + "" working directory: "" + getWorkingDirectory());
    }
    dir = new Path(getWorkingDirectory(), dir);
    set(""mapred.working.dir"", dir.toString());
  }"
1,"Return the number of under replication blocks of priority[SEP]synchronized int size( int priority) {
    if (priority < 0 || priority >= LEVEL) {
      throw new IllegalArgumentException(""Unsupported priority: "" + priority);
    }
    return priorityQueues.get(priority).size();
  }"
1,"Set the current working directory for the default file system.

@param dir the new current working directory.
@throws IllegalStateException if the job is submitted[SEP]public void setWorkingDirectory(Path dir) throws IOException {
    ensureState(JobState.DEFINE);
    conf.setWorkingDirectory(dir);
  }"
0,"Get the process id, either directly from option's ID or by looking up a regular expression for java process name
(but not this java process)

@param pOpts used to get eithe the process Id ({@link OptionsAndArgs#getPid()} or the pattern for matching a
process name ({@link OptionsAndArgs#getProcessPattern()})
@return the numeric id as string
@throws IllegalArgumentException if a pattern is used and no or more than one process name matches.[SEP]private String getProcessId(OptionsAndArgs pOpts) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        if (pOpts.getPid() != null) {
            return pOpts.getPid();
        } else if (pOpts.getProcessPattern() != null) {
            return findProcess(pOpts.getProcessPattern()).getId();
        } else {
            throw new IllegalArgumentException(""No process ID and no process name pattern given"");
        }
    }"
1,"Creates new list being random subset of the passed list

@param <T>      element generic type
@param elements list to process
@param count    returned list size
@return sublist of the elements list[SEP]public <T> List<T> randomElements(List<T> elements, int count) {
		if (elements.size() >= count) {
			return extractRandomList(elements, count);
		} else {
			List<T> randomElements = new ArrayList<T>();
			randomElements.addAll(extractRandomList(elements, count % elements.size()));
			do {
				randomElements.addAll(extractRandomList(elements, elements.size()));
			} while (randomElements.size() < count);
			return randomElements;
		}
	}"
0,"Create regular expression equivalent to any like operator string match
function.

@param expr
the expr
@param ignoreCase
whether to ignore the case
@return the string[SEP]public static String createLikeRegex(String expr, boolean ignoreCase)
    {
        String regex = createRegex(expr, ignoreCase);
        regex = regex.replace(""_"", ""."").replace(""%"", "".*?"");

        return regex;
    }"
0,"Formats a date in a specific format.
@param format the date format
@param loc the locale instance
@return a formatted date[SEP]public String formatDate(String format, Locale loc) {
		MultivaluedMap<String, String> params = new MultivaluedHashMap<>();
		params.putSingle(""format"", format);
		params.putSingle(""locale"", loc == null ? null : loc.toString());
		return getEntity(invokeGet(""utils/formatdate"", params), String.class);
	}"
1,"Converts a string to a number using the narrowest possible type. Possible
returns for this function are BigDecimal, Double, BigInteger, Long, and Integer.
When a Double is returned, it should always be a valid Double and not NaN or +-infinity.

@param val value to convert
@return Number representation of the value.
@throws NumberFormatException thrown if the value is not a valid number. A public
caller should catch this and wrap it in a {@link JSONException} if applicable.[SEP]protected static Number stringToNumber(final String val) throws NumberFormatException {
        char initial = val.charAt(0);
        if ((initial >= '0' && initial <= '9') || initial == '-') {
            // decimal representation
            if (isDecimalNotation(val)) {
                // quick dirty way to see if we need a BigDecimal instead of a Double
                // this only handles some cases of overflow or underflow
                if (val.length()>14) {
                    return new BigDecimal(val);
                }
                final Double d = Double.valueOf(val);
                if (d.isInfinite() || d.isNaN()) {
                    // if we can't parse it as a double, go up to BigDecimal
                    // this is probably due to underflow like 4.32e-678
                    // or overflow like 4.65e5324. The size of the string is small
                    // but can't be held in a Double.
                    return new BigDecimal(val);
                }
                return d;
            }
            // integer representation.
            // This will narrow any values to the smallest reasonable Object representation
            // (Integer, Long, or BigInteger)
            
            // string version
            // The compare string length method reduces GC,
            // but leads to smaller integers being placed in larger wrappers even though not
            // needed. i.e. 1,000,000,000 -> Long even though it's an Integer
            // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long
            //if(val.length()<=9){
            //    return Integer.valueOf(val);
            //}
            //if(val.length()<=18){
            //    return Long.valueOf(val);
            //}
            //return new BigInteger(val);
            
            // BigInteger version: We use a similar bitLenth compare as
            // BigInteger#intValueExact uses. Increases GC, but objects hold
            // only what they need. i.e. Less runtime overhead if the value is
            // long lived. Which is the better tradeoff? This is closer to what's
            // in stringToValue.
            BigInteger bi = new BigInteger(val);
            if(bi.bitLength()<=31){
                return Integer.valueOf(bi.intValue());
            }
            if(bi.bitLength()<=63){
                return Long.valueOf(bi.longValue());
            }
            return bi;
        }
        throw new NumberFormatException(""val [""+val+""] is not a valid number."");
    }"
1,"<p>
Calculates the value of the specified probability function at the specified point.
</p>[SEP]static
	public double probability(ContinuousDistribution distribution, Number x){

		if(distribution instanceof GaussianDistribution){
			return probability((GaussianDistribution)distribution, x);
		} else

		if(distribution instanceof PoissonDistribution){
			return probability((PoissonDistribution)distribution, x);
		}

		throw new UnsupportedElementException(distribution);
	}"
0,"POST to the given URI the passed {@link JsonPayload}.[SEP]public Observable<HttpClientResponse<ByteBuf>>
  postSmile(String uriStr, JsonPayload payload) {
    byte[] entity = toByteArray(SMILE_FACTORY, payload);
    URI uri = URI.create(uriStr);
    return rxHttp.post(uri, SMILE_CONTENT_TYPE, entity);
  }"
0,"Remove permutations, if present.[SEP]public void removePermutations(List<Integer> removed) {

		int[] permutations = new int[this.permutations.length];

		int index = 0;
		permutations:
		for (int j : this.permutations) {
			for (int i = 0; i < removed.size(); i++) {
				if(removed.get(i) == j) {
					// skip this
					removed.remove(i);

					continue permutations;
				}
			}

			permutations[index] = j;

			index++;
		}

		int[] effectivePermutations = new int[index];
		System.arraycopy(permutations, 0, effectivePermutations, 0, index);
		
		this.rotations = new int[permutations.length];
		this.reset = new int[permutations.length];
		this.permutations = effectivePermutations;
		Arrays.sort(permutations); // ascending order to make the permutation logic work
	}"
0,"Generates synthetic observations randomly in front of the camera.  Observations are in normalized image
coordinates and not pixels!  See {@link PerspectiveOps#convertPixelToNorm} for how to go from pixels
to normalized image coordinates.[SEP]public List<Point2D3D> createObservations( Se3_F64 worldToCamera , int total ) {

		Se3_F64 cameraToWorld = worldToCamera.invert(null);

		// transform from pixel coordinates to normalized pixel coordinates, which removes lens distortion
		Point2Transform2_F64 pixelToNorm = LensDistortionFactory.narrow(intrinsic).undistort_F64(true,false);

		List<Point2D3D> observations = new ArrayList<>();

		Point2D_F64 norm = new Point2D_F64();
		for (int i = 0; i < total; i++) {
			// randomly pixel a point inside the image
			double x = rand.nextDouble()*intrinsic.width;
			double y = rand.nextDouble()*intrinsic.height;

			// Convert to normalized image coordinates because that's what PNP needs.
			// it can't process pixel coordinates
			pixelToNorm.compute(x,y,norm);

			// Randomly pick a depth and compute 3D coordinate
			double Z = rand.nextDouble()+4;
			double X = norm.x*Z;
			double Y = norm.y*Z;

			// Change the point's reference frame from camera to world
			Point3D_F64 cameraPt = new Point3D_F64(X,Y,Z);
			Point3D_F64 worldPt = new Point3D_F64();

			SePointOps_F64.transform(cameraToWorld,cameraPt,worldPt);

			// Save the perfect noise free observation
			Point2D3D o = new Point2D3D();
			o.getLocation().set(worldPt);
			o.getObservation().set(norm.x,norm.y);

			observations.add(o);
		}

		return observations;
	}"
1,"Displays a context menu for a class leaf node
Allows copying of the name and the path to the source[SEP]private void handleContextMenu(JTree tree, int x, int y) {
		TreePath path = tree.getPathForLocation(x, y);
		tree.setSelectionPath(path);
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();

		if (node == null)
			return;
		if (!node.isLeaf()) {
			tree.setSelectionPath(null);
			return;
		}
		final AppInfo info = (AppInfo) node.getUserObject();

		JMenuItem copyname = new JMenuItem(""Copy Name"");
		copyname.addActionListener(e -> {
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(info.app.getSimpleName()), null);
		});

		JMenuItem copypath = new JMenuItem(""Copy Path"");
		copypath.addActionListener(e -> {
			String path1 = UtilIO.getSourcePath(info.app.getPackage().getName(), info.app.getSimpleName());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(path1), null);
		});

		JMenuItem github = new JMenuItem(""Go to Github"");
		github.addActionListener(e -> openInGitHub(info));

		JPopupMenu submenu = new JPopupMenu();
		submenu.add(copyname);
		submenu.add(copypath);
		submenu.add(github);
		submenu.show(tree, x, y);
	}"
0,"Summarize fields which are specific to hex.glm.GLMModel.[SEP]private static void summarizeGLMModel(ModelSummary summary, hex.glm.GLMModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""GLM"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, GLM_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, GLM_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, GLM_expert_params);
  }"
0,"Summarize fields which are specific to hex.deeplearning.DeepLearningModel.[SEP]private static void summarizeDeepLearningModel(ModelSummary summary, hex.deeplearning.DeepLearningModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""DeepLearning"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, DL_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, DL_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, DL_expert_params);
  }"
1,"Summarize fields which are specific to hex.nb.NBModel.[SEP]private static void summarizeNBModel(ModelSummary summary, hex.nb.NBModel model) {
    // add generic fields such as column names
    summarizeModelCommonFields(summary, model);

    summary.model_algorithm = ""Naive Bayes"";

    JsonObject all_params = (model.get_params()).toJSON();
    summary.critical_parameters = whitelistJsonObject(all_params, NB_critical_params);
    summary.secondary_parameters = whitelistJsonObject(all_params, NB_secondary_params);
    summary.expert_parameters = whitelistJsonObject(all_params, NB_expert_params);
  }"
0,"Force session to read-only according to options.

@param mustBeReadOnly is read-only flag
@throws SQLException if a connection error occur[SEP]public void switchReadOnlyConnection(Boolean mustBeReadOnly) throws SQLException {
    if (urlParser.getOptions().assureReadOnly && currentReadOnlyAsked != mustBeReadOnly) {
      proxy.lock.lock();
      try {
        // verify not updated now that hold lock, double check safe due to volatile
        if (currentReadOnlyAsked != mustBeReadOnly) {
          currentReadOnlyAsked = mustBeReadOnly;
          setSessionReadOnly(mustBeReadOnly, currentProtocol);
        }
      } finally {
        proxy.lock.unlock();
      }
    }
  }"
1,"Creates a new matrix that stores <i>A*B</i>
@param B the matrix to multiply by
@return a new matrix <i>A*B</i>[SEP]public Matrix multiply(Matrix B)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C);
        return C;
    }"
1,"Creates a new matrix that stores <i>A*B</i>
@param B the matrix to multiply by
@param threadPool the source of threads to do computation in parallel
@return a new matrix <i>A*B</i>[SEP]public Matrix multiply(Matrix B, ExecutorService threadPool)
    {
        Matrix C = new DenseMatrix(this.rows(), B.cols());
        multiply(B, C, threadPool);
        return C;
    }"
0,"Get the indicator if the value is case sensitive

@return boolean indicating if the value is case sensitive[SEP]public boolean isCaseSensitive() {
        switch (getJcrType()) {
            case PropertyType.DOUBLE:
            case PropertyType.LONG:
            case PropertyType.DECIMAL:
            case PropertyType.WEAKREFERENCE:
            case PropertyType.REFERENCE: // conversion is case-insensitive
            case PropertyType.BOOLEAN: // conversion is case-insensitive
                return false;
        }
        return true;
    }"
1,"Decrypt an AES encrypted byte array

@param key            The encryption key
@param iv             The iv
@param encryptedBytes The data to decrypt
@return The decrypted data
@throws NoSuchPaddingException
@throws NoSuchAlgorithmException
@throws InvalidAlgorithmParameterException
@throws InvalidKeyException
@throws BadPaddingException
@throws IllegalBlockSizeException[SEP]public static byte[] decryptAES(SecretKey key, byte[] iv, byte[] encryptedBytes) throws
            NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        IvParameterSpec ivParameter = new IvParameterSpec(iv);
        // see http://stackoverflow.com/a/11506343
        Key encryptionKey = new SecretKeySpec(key.getEncoded(),""AES"");
        aesCipher.init(Cipher.DECRYPT_MODE, encryptionKey, ivParameter);
        return aesCipher.doFinal(encryptedBytes);
    }"
1,"Checks to see how similar two strings are using the Levenshtein distance algorithm.

@param s1 The first string to compare against.
@param s2 The second string to compare against.
@return A value between 0 and 1.0, where 1.0 is an exact match and 0 is no match at all.[SEP]public static double similarLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - StringUtils.getLevenshteinDistance(s2, s1)) / (double) bigLength;
    }"
1,"Checks to see how similar two strings are using the Damerau-Levenshtein distance algorithm.

@param s1 The first string to compare against.
@param s2 The second string to compare against.
@return A value between 0 and 1.0, where 1.0 is an exact match and 0 is no match at all.[SEP]public static double similarDamerauLevenshtein(String s1, String s2) {
        if (s1.equals(s2)) {
            return 1.0;
        }

        // Make sure s1 is the longest string
        if (s1.length() < s2.length()) {
            String swap = s1;
            s1 = s2;
            s2 = swap;
        }

        int bigLength = s1.length();
        return (bigLength - getDamerauLevenshteinDistance(s2, s1)) / (double) bigLength;
    }"
1,"Add a ScatterPlot to the simulation

@param scatterID - An ID for the ScatterPlot
@param xAxisLabel - The name of the x axis
@param yAxisLabel - The name of the y axis
@throws ShanksException[SEP]public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {
        if (!this.timeCharts.containsKey(scatterID)) {
            ScatterPlotGenerator scatter = new ScatterPlotGenerator();
            scatter.setTitle(scatterID);
            scatter.setXAxisLabel(xAxisLabel);
            scatter.setYAxisLabel(yAxisLabel);
            this.scatterPlots.put(scatterID, scatter);
        } else {
            throw new DuplicatedChartIDException(scatterID);
        }
    }"
1,"Generates a CFile from its json representation

@param jObj JSON object representing a CFile
@return the CFile object corresponding to the JSON object[SEP]private CFile parseCFile( JSONObject jObj )
    {
        CFile cfile;

        if ( jObj.optBoolean( ""is_dir"", false ) ) {
            cfile = new CFolder( new CPath( jObj.getString( ""path"" ) ) );

        } else {
            cfile = new CBlob( new CPath( jObj.getString( ""path"" ) ), jObj.getLong( ""bytes"" ), jObj.getString( ""mime_type"" ) );
            String stringDate = jObj.getString( ""modified"" );

            try {
                // stringDate looks like: ""Fri, 07 Mar 2014 17:47:55 +0000""
                SimpleDateFormat sdf = new SimpleDateFormat( ""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.US );
                Date modified = sdf.parse( stringDate );
                cfile.setModificationDate( modified );

            } catch ( ParseException ex ) {
                throw new CStorageException( ""Can't parse date modified: "" + stringDate + "" ("" + ex.getMessage() + "")"", ex );
            }
        }

        return cfile;
    }"
1,"Factory method for create a new {@link CheckBox}.

@param id
the id
@param model
the model
@return the new {@link CheckBox}[SEP]public static CheckBox newCheckBox(final String id, final IModel<Boolean> model)
	{
		final CheckBox checkBox = new CheckBox(id, model);
		checkBox.setOutputMarkupId(true);
		return checkBox;
	}"
1,"/*
Sort handling[SEP]private List decodeSort(String value) {
        ArrayList sorts = new ArrayList();

        String[] nameAndSorts = value.split(DELIM_GRID_NAME);
        if(nameAndSorts.length != 2)
            return null;

        String namespace = nameAndSorts[0];
        String[] sortStrings = nameAndSorts[1].split(DELIM_SORT_TERM);

        // find the list of sorted columns
        // two columns of the bugs grid would be sorted as:
        //
        // netui_sort=bugs~id,-priority
        for(int i = 0; i < sortStrings.length; i++) {
            String sort = sortStrings[i];
            SortDirection sortDirection = SortDirection.NONE;
            if(sort.startsWith(""-""))
                sortDirection = SortDirection.DESCENDING;
            else
                sortDirection = SortDirection.ASCENDING;
            String sortExpression = (sortDirection == SortDirection.DESCENDING ? sort.substring(1) : sort);
            Sort gridSort = _config.createSort();
            gridSort.setSortExpression(sortExpression);
            gridSort.setDirection(sortDirection);
            sorts.add(gridSort);
        }

        return sorts;
    }"
0,"Initializing method.

@return[SEP]public AbstractJdbcHelper init() {
        dataSources.forEach((key, ds) -> DbcHelper.registerJdbcDataSource(id + ""-"" + key, ds));
        return this;
    }"
0,"Creates a new Regression Suite with title assigned with this Regression Plan.

@param name           Title of the suite.
@param regressionPlan Regression Plan to assign.
@return A newly minted Regression Suite that exists in the VersionOne system.[SEP]public RegressionSuite regressionSuite(String name, RegressionPlan regressionPlan) {
        return regressionSuite(name, regressionPlan, null);
    }"
0,"Convert an array of <code>AbstractFilter</code> objects to a chain of
filters by calling the {@link #setAnd} the method of each filter object.

@param filterArray An array of AbstractFilter objects having length
greater than zero.
@return The first filter in the chain which will be == to filterArray[0][SEP]public static Filter filterArrayToChain(Filter[] filterArray) {
        for (int i = 0; i < (filterArray.length - 1); i++) {
            AbstractFilter thisFilter = (AbstractFilter) filterArray[i];
            thisFilter.setAnd(filterArray[i + 1]);
        }
        AbstractFilter lastFilter = (AbstractFilter) filterArray[filterArray.length - 1];
        lastFilter.setAnd(null);
        return filterArray[0];
    }"
0,"Return an array that contains all of the filters in the chain.[SEP]@Override
    public Filter[] filterChainToArray() {
        int length = chainLength();
        Filter[] array = new Filter[length];
        Filter thisFilter = this;
        for (int i = 0; i < length; i++) {
            array[i] = thisFilter;
            thisFilter = thisFilter.getAnd();
        }
        return array;
    }"
0,"Concats a path from all given parts, using the path delimiter for the currently used platform.
@param _includeTrailingDelimiter include delimiter after last token
@param _parts parts to concat
@return concatinated string[SEP]public static String concatFilePath(boolean _includeTrailingDelimiter, String..._parts) {
        if (_parts == null) {
            return null;
        }
        StringBuilder allParts = new StringBuilder();

        for (int i = 0; i < _parts.length; i++) {
            if (_parts[i] == null) {
                continue;
            }
            allParts.append(_parts[i]);

            if (!_parts[i].endsWith(File.separator)) {
                allParts.append(File.separator);
            }
        }

        if (!_includeTrailingDelimiter && allParts.length() > 0) {
            return allParts.substring(0, allParts.lastIndexOf(File.separator));
        }

        return allParts.toString();
    }"
1,"Read properties from given filename
(returns empty {@link Properties} object on failure).

@param _fileName The properties file to read
@param _props optional properties object, if null a new object created in the method
@return {@link Properties} object[SEP]public static Properties readPropertiesFromFile(String _fileName, Properties _props) {
        Properties props = _props == null ? new Properties() : _props;

        LOGGER.debug(""Trying to read properties from file: "" + _fileName);
        Properties newProperties = readProperties(new File(_fileName));
        if (newProperties != null) {
            LOGGER.debug(""Successfully read properties from file: "" + _fileName);
            props.putAll(newProperties);
        }

        return props;
    }"
1,"Formats the label Text shapes in the given axis by cutting text value.[SEP]private void cut(XYChartLabel label, double maxWidth, double maxHeight, double rotation)
    {
        String text = label.getLabel().getText();

        // Cut text.
        cutLabelText(label, maxWidth - 5, maxHeight - 5, rotation);

        String cutText = label.getLabel().getText();

        // If text is cut, add suffix characters.
        if (text.length() != cutText.length())
        {
            label.getLabel().setText(label.getLabel().getText() + ""..."");
        }
        // TODO: Animate.
        // animate(label, text, cutText, originalRotation);

        // Move label to top.
        label.getLabelContainer().moveToTop();
    }"
1,"Constructs a builder instance that will produce a program that
launches the given executable. Checks that a file exists at the given pathname
and that it is executable by the operating system.
@param executable the executable file
@return a builder instance
@throws IllegalArgumentException if {@link File#canExecute() } is false[SEP]public static Builder running(File executable) {
        checkArgument(executable.isFile(), ""file not found: %s"", executable);
        checkArgument(executable.canExecute(), ""executable.canExecute"");
        return running(executable.getPath());
    }"
1,"Save this XML into the given file.
@param file the file
@throws IOException on error[SEP]public void save(File file) throws IOException {
        try (FileOutputStream fout = new FileOutputStream(file)) {
            save(fout);
        }
    }"
1,"Returns the binomial coefficient.<br>
For any set containing n elements, this is the number of distinct
k-element subsets of it.

@param n Set size
@param k Subset size
@return The binomial coefficient of <code>n</code> and <code>k</code>[SEP]public static long binCoeff(int n, int k) {
                if (k > n) {
                        return 0;
                }
                if (k == 0 || k == n) {
                        return 1;
                }
                long result = 1;
                for (int i = 1; i <= k; i++) {
                        result *= (n - i + 1) / i;
                }
                return result;
        }"
1,"Read the properties from file. Use default values, if not set or file not available
@since 01.07.2006[SEP]private void readPropertyFile()
	{
		java.util.Properties props = new java.util.Properties();
	    try
	    {
	        File propertyFile = new File(propertyFilePath + File.separator + PROPERTYFILENAME);
	        if (propertyFile.exists())
	        {
	        	java.io.FileInputStream fis = null;
	        	try
	        	{
			    	fis = new java.io.FileInputStream(propertyFile);
			        props.load(fis);
	        	}
	        	finally
	        	{
	        		if (fis!=null) try { fis.close(); } catch (IOException ex) { Log.error(""IGNORED"", ex); }
	        	}
	        }

	        searchPath = props.getProperty(PROPERTY_SEARCHPATH, Helpers.HOMEDIR);
			exportPath = props.getProperty(PROPERTY_EXPORTPATH, Helpers.HOMEDIR);
			uiClassName = props.getProperty(PROPERTY_LOOKANDFEEL, javax.swing.UIManager.getSystemLookAndFeelClassName());
			useSystemTray = Boolean.parseBoolean(props.getProperty(PROPERTY_SYSTEMTRAY, ""FALSE""));
			currentVolume = Float.parseFloat(props.getProperty(PROPERTY_VOLUME_VALUE, ""1.0""));
			currentBalance = Float.parseFloat(props.getProperty(PROPERTY_BALANCE_VALUE, ""0.0""));
			lastLoaded = new ArrayList<URL>(PROPERTY_LASTLOADED_MAXENTRIES);
			for (int i=0; i<PROPERTY_LASTLOADED_MAXENTRIES; i++)
			{
				String url = props.getProperty(PROPERTY_LASTLOADED+'.'+i, null);
				if (url!=null) lastLoaded.add(new URL(url)); else lastLoaded.add(null);
			}
			setDSPEnabled(Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECTS_PASSTHROUGH, ""FALSE"")));
			mainDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_MAINDIALOG_POS, ""-1x-1""));
			mainDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_MAINDIALOG_SIZE, ""320x410""));
			playerSetUpDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_SETUPDIALOG_POS, ""-1x-1""));
			playerSetUpDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_SETUPDIALOG_SIZE, ""720x230""));
			playerSetUpDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_SETUPDIALOG_VISABLE, ""false""));
			modInfoDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_POS, ""-1x-1""));
			modInfoDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PROPERTIESDIALOG_SIZE, ""520x630""));
			modInfoDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PROPERTIESDIALOG_VISABLE, ""false""));
			playlistDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_POS, ""-1x-1""));
			playlistDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_PLAYLISTDIALOG_SIZE, ""400x400""));
			playlistDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_PLAYLIST_VISABLE, ""false""));
			effectsDialogLocation = Helpers.getPointFromString(props.getProperty(PROPERTY_EFFECTDIALOG_POS, ""-1x-1""));
			effectsDialogSize = Helpers.getDimensionFromString(props.getProperty(PROPERTY_EFFECTDIALOG_SIZE, ""560x470""));
			effectDialogVisable = Boolean.parseBoolean(props.getProperty(PROPERTY_EFFECT_VISABLE, ""false""));
			
			if (currentEqualizer!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_EQUALIZER_ISACTIVE, ""FALSE""));
				currentEqualizer.setIsActive(isActive);
				float preAmpValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_PREAMP, ""0.0""));
				currentEqualizer.setPreAmp(preAmpValueDB);
				for (int i=0; i<currentEqualizer.getBandCount(); i++)
				{
					float bandValueDB = Float.parseFloat(props.getProperty(PROPERTY_EQUALIZER_BAND_PREFIX + Integer.toString(i), ""0.0""));
					currentEqualizer.setBand(i, bandValueDB);
				}
			}
			if (currentPitchShift!=null)
			{
				boolean isActive = Boolean.parseBoolean(props.getProperty(PROPERTY_PITCHSHIFT_ISACTIVE, ""FALSE""));
				currentPitchShift.setIsActive(isActive);
				float pitchValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_PITCH, ""1.0""));
				currentPitchShift.setPitchScale(pitchValue);
				float scaleValue = Float.parseFloat(props.getProperty(PROPERTY_PITCHSHIFT_SAMPLESCALE, ""1.0""));
				currentPitchShift.setSampleScale(scaleValue);
				int overSampling = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_OVERSAMPLING, ""32""));
				currentPitchShift.setFFTOversampling(overSampling);
				int frameSize = Integer.parseInt(props.getProperty(PROPERTY_PITCHSHIFT_FRAMESIZE, ""8192""));
				currentPitchShift.setFFTFrameSize(frameSize);
			}

			MultimediaContainerManager.configureContainer(props);
	    }
	    catch (Throwable ex)
	    {
			Log.error(""[MainForm]"", ex);
	    }
	}"
0,"Returns the execution path to the direcory of the current Java
application.

@return Execution path as {@link File}.
@throws OSException If the execution path can't be determined.[SEP]public static File getExecutionPath() throws OSException {
        try {
            return new File(OSUtils.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
        } catch (URISyntaxException ex) {
            throw new OSException(ex);
        }
    }"
0,"Save this XML into the given file.
@param file the file
@throws IOException on error[SEP]public void save(File file) throws IOException {
        try (FileOutputStream out = new FileOutputStream(file)) {
            save(out);
        }
    }"
1,"Bottom of HTML form.
@param out The html out stream.
@param reg The resources object.[SEP]public void printHtmlFooter(PrintWriter out, ResourceBundle reg)
    {
        String strHTML = reg.getString(""htmlFooter"");
        if ((strHTML == null) || (strHTML.length() == 0))
            strHTML = ""</body>\n</html>"";
        out.println(strHTML);
        out.flush();
    }"
0,"To pretty json string string.

@param object the object
@return the string[SEP]public static String toPrettyJsonString(Object object) {
        try {
            return jsonMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(object);
        } catch (JsonProcessingException e) {
            return JMExceptionManager.handleExceptionAndReturnNull(log, e,
                    ""toPrettyJsonString"", object);
        }
    }"
1,"Converts a formated date string to a {@link Date}.

@param pStringDate
sample: 2011-07-12T22:42:40.000+02:00
@return the date value[SEP]private Date toDate(final String pStringDate) {

        // weird manipulation to parse the date... remove ':' from the timezone
        // before: 2011-07-12T22:42:40.000+02:00
        // after: 2011-07-12T22:42:40.000+0200
        final StringBuilder _date = new StringBuilder();
        _date.append(pStringDate.substring(0, pStringDate.length() - 3));
        _date.append(pStringDate.substring(pStringDate.length() - 2));
        try {
            return new SimpleDateFormat(RFC_339_DATE_FORMAT).parse(_date.toString());
        } catch (final ParseException e) {
            throw new IllegalArgumentException(
                    ""The given spreadsheet ListEntry usercrashdate field value is malformed"", e);
        }
    }"
1,"recreate a byte array from hexadecimal

@param hex
string data
@return byte[] data[SEP]public static byte[] fromHex(String hex) {
        try {
            return Hex.decodeHex(hex.toCharArray());
        } catch (DecoderException e) {
            return null;
        }
    }"
0,"Get the table name.[SEP]public String getTableNames(boolean bAddQuotes)
    {
        return (m_tableName == null) ? Record.formatTableNames(CLASS_FIELDS_FILE, bAddQuotes) : super.getTableNames(bAddQuotes);
    }"
0,"Get the name of this table.
Override this to supply the name of the table.
Note: This is almost always overidden (except for mapped files)
@param bAddQuotes if the table name contains spaces, add quotes.
@return The name of this table.[SEP]public String getTableNames(boolean bAddQuotes)
    {
        if (m_tableName == null)
        {
            String strDatabaseName = """";
            if (this.getDatabaseName() != null)
                if (!this.getDatabaseName().endsWith(""_"" + this.getDatabaseName()))
                    strDatabaseName = ""_"" + this.getDatabaseName();
            return Record.formatTableNames(DATABASE_INFO_FILE, bAddQuotes) + strDatabaseName;
        }
        return super.getTableNames(bAddQuotes);
    }"
0,"Scalar multiplies each item with c
@param c[SEP]public void scalarMultiply(double c)
    {
        int m = rows;
        int n = cols;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                consumer.set(i, j, c * supplier.get(i, j));
            }
        }
    }"
0,"Returns LocalLongitude instance which is usable about 60 NM around starting
point.
@param longitude
@param latitude
@return[SEP]public static LocalLongitude getInstance(double longitude, double latitude)
    {
        if (Math.abs(longitude) < 179)
        {
            return new LocalLongitude(latitude);
        }
        else
        {
            return new PacificLongitude(latitude);
        }
    }"
1,"Deserialize from byte array.

@param input
the JSON String byte array.
@param classType
the target Object class type.
@return the target Object instance.
@throws JsonParseException
@throws JsonMappingException
@throws IOException[SEP]public static <T> T deserialize(byte[] input, Class<T> classType)
            throws JsonParseException, JsonMappingException, IOException {
        return mapper.readValue(input, classType);
    }"
1,"Verifies that the given checkbox is checked.

@param checkboxBy
the method of identifying the checkbox
@return true if the given checkbox is checked or false otherwise[SEP]public boolean verifyChecked(final By checkboxBy) {
		WebElement element = driver.findElement(checkboxBy);

		if (element.isSelected()) {
			LOG.info(""Checkbox: "" + element + "" is checked!"");
			return true;
		}

		LOG.info(""Checkbox: "" + element + "" is NOT checked!"");
		return false;
	}"
1,"Url-encodes a string.[SEP]static String urlencode(final String s) {
		try {
			return URLEncoder.encode(s, CHARSET_NAME);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
	}"
1,"Make a POST request to a URI

@param jsonBody String form of the jsonBody
@param expectedResponseCode the response code you expect to get from this endpoint[SEP]public void post(String jsonBody, Integer expectedResponseCode) throws IOException {
    HttpURLConnection conn = getUrlConnection();

    try {
      // send post request with json body for the topology
      if (!NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, jsonBody.getBytes())) {
        throw new IOException(""Failed to send POST to "" + endpointURI);
      }

      // check the response
      if (!NetworkUtils.checkHttpResponseCode(conn, expectedResponseCode)) {
        byte[] bytes = NetworkUtils.readHttpResponse(conn);
        LOG.log(Level.SEVERE, ""Failed to send POST request to endpoint"");
        LOG.log(Level.SEVERE, new String(bytes));
        throw new IOException(""Unexpected response from connection. Expected ""
            + expectedResponseCode + "" but received "" + conn.getResponseCode());
      }
    } finally {
      conn.disconnect();
    }
  }"
1,"Read the content of byte buffer and write the data to the serial port transmit buffer.
(The buffer is read from the current position up to the 'limit' value, not the 'capacity'.  You may need to
rewind() or flip() the byte buffer if you have just written to it.)

@param fd
The file descriptor of the serial port/device.
@param data
A ByteBuffer of data to be transmitted.[SEP]public synchronized static void write(int fd, ByteBuffer ... data) throws IOException{

        // write each byte buffer to the serial port
        for(ByteBuffer single : data) {

            // read the byte buffer from the current position up to the limit
            byte[] payload = new byte[single.remaining()];
            single.get(payload);

            // write the data contents to the serial port via JNI native method
            write(fd, payload, payload.length);
        }
    }"
1,"<p>Sends an array of bytes to the serial port/device identified by the given file descriptor.</p>

@param data
A ByteBuffer of data to be transmitted.
@param offset
The starting index (inclusive) in the array to send from.
@param length
The number of bytes from the byte array to transmit to the serial port.
@throws IllegalStateException thrown if the serial port is not already open.
@throws IOException thrown on any error.[SEP]@Override
    public void write(byte[] data, int offset, int length) throws IllegalStateException, IOException{
        // validate state
        if (isClosed()) {
            throw new IllegalStateException(""Serial connection is not open; cannot 'write()'."");
        }

        // write serial data to transmit buffer
        com.pi4j.jni.Serial.write(fileDescriptor, data, offset, length);
    }"
1,"Executes the k-means algorithm with the given initial centroids until the
costs converges.

@param centroids
initial centroids
@param input
input clustering
@return the k-means costs[SEP]public static double kMeans(List<double[]> centroids, List<double[]> input) {
		int k = centroids.size();
		assert (k > 0);
		int d = centroids.get(0).length;
		int size = input.size();

		double[][] center = new double[k][];
		Iterator<double[]> iIter = centroids.iterator();
		for (int i = 0; i < k; i++) {
			center[i] = iIter.next();
		}

		double[][] newCenter = new double[k][d];
		double[] newCenterWeight = new double[k];
		int[] nearestCluster = new int[size];
		boolean converged;
		do {
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					newCenter[i][j] = 0.0;
				}
				newCenterWeight[i] = 0.0;
			}
			Iterator<double[]> lIter = input.iterator();
			for (int l = 0; l < size; l++) {
				// Calculates the distance from all points to all centroids
				double[] point = lIter.next();
				assert (d == point.length - 1);
				double minDistance = Double.POSITIVE_INFINITY;
				int closestCluster = -1;
				for (int i = 0; i < k; i++) {
					double distance = Metric.distance(center[i], point, 1);
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				// Sums up all points for the new centroids
				assert (closestCluster >= 0 && closestCluster < k);
				for (int j = 0; j < d; j++) {
					newCenter[closestCluster][j] += point[0] * point[j + 1];
				}
				newCenterWeight[closestCluster] += point[0];
				nearestCluster[l] = closestCluster;
			}

			// Calculates the new centroids
			converged = true;
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < d; j++) {
					if (newCenterWeight[i] != 0.0) {
						double newValue = newCenter[i][j] / newCenterWeight[i];
						if (newValue != center[i][j]) {
							converged = false;
						}
						center[i][j] = newValue;
					}
				}
			}
		} while (!converged);
		// Replaces the old centroids with the new ones
		for (int i = 0; i < k; i++) {
			centroids.set(i, center[i]);
		}

		// Calculates the costs of the solution
		double costs = 0.0;
		Iterator<double[]> lIter = input.iterator();
		for (int l = 0; l < size; l++) {
			double[] point = lIter.next();
			costs += point[0]
					* Metric.distanceSquared(center[nearestCluster[l]], point,
							1);
		}
		return costs;
	}"
1,"k-means of (micro)clusters, with ground-truth-aided initialization.
(to produce best results)

@param k
@param data
@return (macro)clustering - CFClusters[SEP]public static Clustering kMeans_gta(int k, Clustering clustering, Clustering gtClustering) {
		
		ArrayList<CFCluster> microclusters = new ArrayList<CFCluster>();
        for (int i = 0; i < clustering.size(); i++) {
            if (clustering.get(i) instanceof CFCluster) {
                microclusters.add((CFCluster)clustering.get(i));
            } else {
                System.out.println(""Unsupported Cluster Type:"" + clustering.get(i).getClass() + "". Cluster needs to extend moa.cluster.CFCluster"");
            }
        }
        
        int n = microclusters.size();
		assert (k <= n);
		
		/* k-means */
		Random random = new Random(0);
		Cluster[] centers = new Cluster[k];
		int K = gtClustering.size();
		
		for (int i = 0; i < k; i++) {
			if (i < K) {	// GT-aided
				centers[i] = new SphereCluster(gtClustering.get(i).getCenter(), 0);
			} else {		// Randomized
				int rid = random.nextInt(n);
				centers[i] = new SphereCluster(microclusters.get(rid).getCenter(), 0);
			}
		}
		
		return cleanUpKMeans(kMeans(k, centers, microclusters), microclusters);
	}"
1,"(The Actual Algorithm) k-means of (micro)clusters, with specified initialization points.

@param k
@param centers - initial centers
@param data
@return (macro)clustering - SphereClusters[SEP]protected static Clustering kMeans(int k, Cluster[] centers, List<? extends Cluster> data) {
		assert (centers.length == k);
		assert (k > 0);

		int dimensions = centers[0].getCenter().length;

		ArrayList<ArrayList<Cluster>> clustering = new ArrayList<ArrayList<Cluster>>();
		for (int i = 0; i < k; i++) {
			clustering.add(new ArrayList<Cluster>());
		}

		while (true) {
			// Assign points to clusters
			for (Cluster point : data) {
				double minDistance = distance(point.getCenter(), centers[0].getCenter());
				int closestCluster = 0;
				for (int i = 1; i < k; i++) {
					double distance = distance(point.getCenter(), centers[i].getCenter());
					if (distance < minDistance) {
						closestCluster = i;
						minDistance = distance;
					}
				}

				clustering.get(closestCluster).add(point);
			}

			// Calculate new centers and clear clustering lists
			SphereCluster[] newCenters = new SphereCluster[centers.length];
			for (int i = 0; i < k; i++) {
				newCenters[i] = calculateCenter(clustering.get(i), dimensions);
				clustering.get(i).clear();
			}
			
			// Convergence check
			boolean converged = true;
			for (int i = 0; i < k; i++) {
				if (!Arrays.equals(centers[i].getCenter(), newCenters[i].getCenter())) {
					converged = false;
					break;
				}
			}
			
			if (converged) {
				break;
			} else {
				centers = newCenters;
			}
		}

		return new Clustering(centers);
	}"
1,"Rearrange the k-means result into a set of CFClusters, cleaning up the redundancies.

@param kMeansResult
@param microclusters
@return[SEP]protected static Clustering cleanUpKMeans(Clustering kMeansResult, ArrayList<CFCluster> microclusters) {
		/* Convert k-means result to CFClusters */
		int k = kMeansResult.size();
		CFCluster[] converted = new CFCluster[k];

		for (CFCluster mc : microclusters) {
		    // Find closest kMeans cluster
		    double minDistance = Double.MAX_VALUE;
		    int closestCluster = 0;
		    for (int i = 0; i < k; i++) {
		    	double distance = distance(kMeansResult.get(i).getCenter(), mc.getCenter());
				if (distance < minDistance) {
				    closestCluster = i;
				    minDistance = distance;
				}
		    }

		    // Add to cluster
		    if ( converted[closestCluster] == null ) {
		    	converted[closestCluster] = (CFCluster)mc.copy();
		    } else {
		    	converted[closestCluster].add(mc);
		    }
		}

		// Clean up
		int count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			count++;
		}

		CFCluster[] cleaned = new CFCluster[count];
		count = 0;
		for (int i = 0; i < converted.length; i++) {
		    if (converted[i] != null)
			cleaned[count++] = converted[i];
		}

		return new Clustering(cleaned);
	}"
1,"Randomly chooses elements from the collection.
@param collection The collection.
@param n The number of elements to choose.
@param <T> The type of the elements.
@return A list with the chosen elements.[SEP]public static <T> List<T> randomSample(Collection<T> collection, int n) {
		List<T> list = new ArrayList<T>(collection);
		List<T> sample = new ArrayList<T>(n);
		Random random = new Random();
		while(n > 0  &&  !list.isEmpty()) {
			int index = random.nextInt(list.size());
			sample.add(list.get(index));
			int indexLast = list.size() - 1;
			T last = list.remove(indexLast);
			if(index < indexLast) {
				list.set(index, last);
			}
			n--;
		}
		return sample;
	}"
1,"Gets the enum name.

@param e the e
@param value the value
@return the enum name[SEP]public static String getEnumName(Enum[] e, int value) {
        if (e != null) {
            int toCompareValue;
            for (Enum en : e) {
                if (en instanceof EnumReadable) {
                    toCompareValue = ((EnumReadable) en).value();
                } else {
                    toCompareValue = en.ordinal();
                }
                if (value == toCompareValue) {
                    return en.name();
                }
            }
        }
        return """";
    }"
1,"Checks if a CheckBox displaying the specified text is checked.

@param text the text that the {@link CheckBox} displays, specified as a regular expression
@return {@code true} if a {@link CheckBox} displaying the specified text is checked and {@code false} if it is not checked[SEP]public boolean isCheckBoxChecked(String text)
	{
		if(config.commandLogging){
			Log.d(config.commandLoggingTag, ""isCheckBoxChecked(\""""+text+""\"")"");
		}
		
		return checker.isButtonChecked(CheckBox.class, text);
	}"
1,"sorts a string list

@param list list to sort
@param sortType sort type (numeric,text,textnocase)
@param sortOrder sort order (asc,desc)
@param delimiter list delimiter
@return sorted list
@throws PageException[SEP]public static String sort(String list, String sortType, String sortOrder, String delimiter) throws PageException {
	return _sort(toStringArray(listToArray(list, delimiter)), sortType, sortOrder, delimiter);
    }"
0,"Get the coverage of protein 1 with the alignment

@return percentage of coverage, between 0 and 100.[SEP]public int getCoverage1(){
		if ( myResultsSimilarity1 < 0 ) {
			int distance = ca1Length + ca2Length - 2 * getNrEQR();

			int similarity = (ca1Length + ca2Length - distance ) / 2;

			myResultsSimilarity1 = Math.round(similarity /(float) ca1Length * 100);
		}
		return myResultsSimilarity1;
	}"
1,"Starts with an incomplete set of group generators in `permutations` and
expands it to include all possible combinations.

Ways to complete group:
- combinations of permutations pi x pj
- combinations with itself p^k[SEP]public void completeGroup() {
		// Copy initial set to allow permutations to grow
		List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations);
		// Keep HashSet version of permutations for fast lookup.
		Set<List<Integer>> known = new HashSet<List<Integer>>(permutations);
		//breadth-first search through the map of all members
		List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations);
		while( currentLevel.size() > 0) {
			List<List<Integer>> nextLevel = new ArrayList<List<Integer>>();
			for( List<Integer> p : currentLevel) {
				for(List<Integer> gen : gens) {
					List<Integer> y = combine(p,gen);
					if(!known.contains(y)) {
						nextLevel.add(y);
						//bypass addPermutation(y) for performance
						permutations.add(y);
						known.add(y);
					}
				}
			}
			currentLevel = nextLevel;
		}
	}"
1,"Start a 'HEAD' request to the given URL along with the query params

@param baseUrl
@param params
The query parameters to include as part of the baseUrl
@param encode
true to encode the full URL

@see #append(CharSequence, Map)
@see #encode(CharSequence)

@return request[SEP]public static HttpRequest head(final CharSequence baseUrl,
      final Map<?, ?> params, final boolean encode) {
    String url = append(baseUrl, params);
    return head(encode ? encode(url) : url);
  }"
0,"/*
Format integer number[SEP]private static String numToString(int num, int width) {
        String str = Integer.toString(num);
        int len = str.length();
        if (len >= width) {
            return str.substring(len - width, len);
        }
        StringBuilder sb = new StringBuilder(width);
        for (int i = len; i < width; i++) {
            sb.append('0');
        }
        sb.append(str);
        return sb.toString();
    }"
0,"Read a new array from the receiver. It is assumed the array has not been
read yet (not a cyclic reference). Return the array read.

@param unshared
read the object unshared
@return the array read

@throws IOException
If an IO exception happened when reading the array.
@throws ClassNotFoundException
If a class for one of the objects could not be found
@throws OptionalDataException
If optional data could not be found when reading the array.[SEP]private Object readNewArray(boolean unshared) throws OptionalDataException,
            ClassNotFoundException, IOException {
        ObjectStreamClass classDesc = readClassDesc();

        if (classDesc == null) {
            throw missingClassDescriptor();
        }

        int newHandle = nextHandle();

        // Array size
        int size = input.readInt();
        Class<?> arrayClass = classDesc.forClass();
        Class<?> componentType = arrayClass.getComponentType();
        Object result = Array.newInstance(componentType, size);

        registerObjectRead(result, newHandle, unshared);

        // Now we have code duplication just because Java is typed. We have to
        // read N elements and assign to array positions, but we must typecast
        // the array first, and also call different methods depending on the
        // elements.
        if (componentType.isPrimitive()) {
            if (componentType == int.class) {
                int[] intArray = (int[]) result;
                for (int i = 0; i < size; i++) {
                    intArray[i] = input.readInt();
                }
            } else if (componentType == byte.class) {
                byte[] byteArray = (byte[]) result;
                input.readFully(byteArray, 0, size);
            } else if (componentType == char.class) {
                char[] charArray = (char[]) result;
                for (int i = 0; i < size; i++) {
                    charArray[i] = input.readChar();
                }
            } else if (componentType == short.class) {
                short[] shortArray = (short[]) result;
                for (int i = 0; i < size; i++) {
                    shortArray[i] = input.readShort();
                }
            } else if (componentType == boolean.class) {
                boolean[] booleanArray = (boolean[]) result;
                for (int i = 0; i < size; i++) {
                    booleanArray[i] = input.readBoolean();
                }
            } else if (componentType == long.class) {
                long[] longArray = (long[]) result;
                for (int i = 0; i < size; i++) {
                    longArray[i] = input.readLong();
                }
            } else if (componentType == float.class) {
                float[] floatArray = (float[]) result;
                for (int i = 0; i < size; i++) {
                    floatArray[i] = input.readFloat();
                }
            } else if (componentType == double.class) {
                double[] doubleArray = (double[]) result;
                for (int i = 0; i < size; i++) {
                    doubleArray[i] = input.readDouble();
                }
            } else {
                throw new ClassNotFoundException(""Wrong base type in "" + classDesc.getName());
            }
        } else {
            // Array of Objects
            Object[] objectArray = (Object[]) result;
            for (int i = 0; i < size; i++) {
                // TODO: This place is the opportunity for enhancement
                //      We can implement writing elements through fast-path,
                //      without setting up the context (see readObject()) for
                //      each element with public API
                objectArray[i] = readObject();
            }
        }
        if (enableResolve) {
            result = resolveObject(result);
            registerObjectRead(result, newHandle, false);
        }
        return result;
    }"
1,"Main method, entry point for the application when invoked via the command
line. Arguments are expected in POSIX format, invoke with --help for
details.

@param args
Incoming arguments from the command line
@throws FileNotFoundException
if the paths specified on the command line are not found
@throws IOException
if the application is unable to read data from the paths
specified[SEP]public static void main(String[] args) throws IOException {

        Arguments arguments = new Arguments().parse(args);

        if (arguments.isUseCommonsLang3()) {
            System.err.println(""--commons-lang3 is deprecated. Please remove the argument from your command-line arguments."");
        }

        Jsonschema2Pojo.generate(arguments);
    }"
0,"Attach the specified object to this object, and delegate all indexed property lookups to it. In other words,
if the object has 3 elements, then an attempt to look up or modify ""[0]"", ""[1]"", or ""[2]"" will be delegated
to this object. Additional indexed properties outside the range specified, and additional non-indexed
properties, may still be added. The object specified must implement the ExternalArrayData interface.

@param array the List to use for delegated property access. Set this to null to revert back to regular
property access.
@since 1.7.6[SEP]public void setExternalArrayData(ExternalArrayData array)
    {
        externalData = array;

        if (array == null) {
            delete(""length"");
        } else {
            // Define ""length"" to return whatever length the List gives us.
            defineProperty(""length"", null,
                           GET_ARRAY_LENGTH, null, READONLY | DONTENUM);
        }
    }"
0,"Converts PDF to TIFF format.

@param inputPdfFile input file
@return a multi-page TIFF image
@throws IOException[SEP]public static File convertPdf2Tiff(File inputPdfFile) throws IOException {
        if (PDFBOX.equals(System.getProperty(PDF_LIBRARY))) {
            return PdfBoxUtilities.convertPdf2Tiff(inputPdfFile);
        } else {
            try {
                return PdfGsUtilities.convertPdf2Tiff(inputPdfFile);
            } catch (Exception e) {
                System.setProperty(PDF_LIBRARY, PDFBOX);
                return convertPdf2Tiff(inputPdfFile);
            }
        }
    }"
1,"<!-- begin-user-doc -->
<!-- end-user-doc -->
@generated[SEP]public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) {
		((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution);
	}"
0,"Convert CSV record(List<Strings>) to JsonObject using header(column Names)
@param header record
@param data record
@param column Count
@return JsonObject[SEP]public static JsonObject csvToJsonObject(List<String> bulkRecordHeader, List<String> record, int columnCount) {
    ObjectMapper mapper = new ObjectMapper();
    Map<String, String> resultInfo = new HashMap<>();
    for (int i = 0; i < columnCount; i++) {
      resultInfo.put(bulkRecordHeader.get(i), record.get(i));
    }

    JsonNode json = mapper.valueToTree(resultInfo);
    JsonElement element = GSON.fromJson(json.toString(), JsonObject.class);
    return element.getAsJsonObject();
  }"
1,"Gets the parent directory for the executable file name using the current
directory and system executable path

@param exeName
Name of executable such as ""cl.exe""
@return parent directory or null if not located[SEP]public static File getExecutableLocation(final String exeName) {
    //
    // must add current working directory to the
    // from of the path from the ""path"" environment variable
    final File currentDir = new File(System.getProperty(""user.dir""));
    if (new File(currentDir, exeName).exists()) {
      return currentDir;
    }
    final File[] envPath = CUtil.getPathFromEnvironment(""PATH"", File.pathSeparator);
    for (final File element : envPath) {
      if (new File(element, exeName).exists()) {
        return element;
      }
    }
    return null;
  }"
1,"Method to get the current date time Calendar instance

@return the Date instance
@throws ParseException[SEP]public static Date getCurrentDateTime() throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }"
1,"Method to get the Date instance for the given days to be subtracted to the current date

@param noOfDays
@return the Date instance
@throws ParseException[SEP]public static Date getDateWithPrevDays(int noOfDays) throws ParseException {
        Calendar currentDate = Calendar.getInstance();
        currentDate.add(Calendar.DATE, -noOfDays);
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);
        String dateNow = formatter.format(currentDate.getTime());
        return getDateFromString(dateNow);
    }"
1,"Deserialize String to object of TypeReference

@param json
@param typeReference
@return
@throws SerializationException[SEP]public static Object deserialize(String json, TypeReference<?> typeReference) throws SerializationException {
		try {
			logger.debug(""Json string to deserialize {} "", json);
			return mapper.readValue(json, typeReference);
		} catch (IOException e) {
			logger.error(""SerializationException {}"", e.getMessage());
			SerializationException serializationException = new SerializationException(e);
			throw serializationException;
		}
	}"
1,"Replaces an occurrence of a string within a file

@param oldText - the text to be replaced
@param newText - the text to be replaced with[SEP]private void replaceInFile(String oldText, String newText) {
        StringBuilder oldContent = new StringBuilder();

        try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                oldContent.append(line);
                oldContent.append(""\r\n"");
            }
        } catch (IOException e) {
            log.error(e);
        }

        // replace a word in a file
        String newContent = oldContent.toString().replaceAll(oldText, newText);

        try (FileWriter writer = new FileWriter(file)) {
            writer.write(newContent);
        } catch (IOException ioe) {
            log.error(ioe);
        }
    }"
0,"Removes all elements that cannot be converted to pdf, this method is to be used
before converting the html file to pdf with openhtmltopdf.pdfboxout.PdfRendererBuilder[SEP]private String getHtmlForPDFConversion() throws IOException {
        StringBuilder oldContent = new StringBuilder();

        FileReader fr = new FileReader(file);
        try (BufferedReader reader = new BufferedReader(fr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                oldContent.append(line);
                oldContent.append(""\r\n"");
            }
        }

        // replace all non convertible elements with empty text or modify for conversion
        String str = oldContent.toString()
                .replaceAll(""<script type='text/javascript'>(?s).*</script>"", """")
                .replaceAll(""<tr>\\s*<th>View Results</th>(?s).*?</tr>"", """")
                .replaceAll(""&nbsp;"", "" "");

        String imagePattern = ""(<img(?s).*? src='(.*?)'(?s).*?)</img>"";
        Pattern r = Pattern.compile(imagePattern);
        Matcher m = r.matcher(str);
        int imageCount = 0;
        while (m.find()) {
            str = str.replaceFirst(""<a href='javascript:void\\(0\\)'(?s).*?(<img(?s).*? src='(.*?)'(?s).*?)"" +
                            "" style(?s).*?</img>"",
                    ""<a href=\""#image-"" + imageCount + ""\"">View Screenshot</a>"");
            str = str.replaceFirst(""</body>"", ""<p style='page-break-before: always' id='image-"" + imageCount++ + ""'></p"" +
                    "">"" +
                    m.group().replaceAll(""width='300px' style(?s).*?'>"", ""height='600px' width='1000px'>"") + ""</body>"");
        }
        return str;
    }"
1,"Generates a pdf report in the same directory as the html report[SEP]private void generatePdf() {
        File pdfFile = new File(directory, filename + "".pdf"");
        try (OutputStream os = new FileOutputStream(pdfFile)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.withHtmlContent(getHtmlForPDFConversion(), ""file://"" + pdfFile.getAbsolutePath()
                    .replaceAll("" "", ""%20""));
            builder.toStream(os);
            builder.run();
        } catch (Exception e) {
            log.error(e);
        }
    }"
0,"Determines integer value of String (so relative checks can be done).
@param value string to convert to integer.
@return integer value.[SEP]public Integer convertToInt(String value) {
        Integer result = null;
        if (value != null) {
            result = Integer.valueOf(value);
        }
        return result;
    }"
1,"Generates random number that could be a BSN.
Based on: http://www.testnummers.nl/bsn.js
@return random BSN.[SEP]public String generateBsn() {
        String Result1 = """";
        int Nr9 = randomUtil.random(3);
        int Nr8 = randomUtil.random(10);
        int Nr7 = randomUtil.random(10);
        int Nr6 = randomUtil.random(10);
        int Nr5 = randomUtil.random(10);
        int Nr4 = randomUtil.random(10);
        int Nr3 = randomUtil.random(10);
        int Nr2 = randomUtil.random(10);
        int Nr1 = 0;
        int SofiNr = 0;
        if ((Nr9 == 0) && (Nr8 == 0) && (Nr7 == 0)) {
            Nr8 = 1;
        }
        SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2;
        Nr1 = floor(SofiNr - (floor(SofiNr / 11)) * 11);
        if (Nr1 > 9) {
            if (Nr2 > 0) {
                Nr2 -= 1;
                Nr1 = 8;
            } else {
                Nr2 += 1;
                Nr1 = 1;
            }
        }
        Result1 += Nr9;
        Result1 += Nr8;
        Result1 += Nr7;
        Result1 += Nr6;
        Result1 += Nr5;
        Result1 += Nr4;
        Result1 += Nr3;
        Result1 += Nr2;
        Result1 += Nr1;
        return Result1;
    }"
1,"Writes the Excel file to disk

@throws IOException
@throws WriteException[SEP]public void writeExcelFile() throws IOException, WriteException {
        WritableWorkbook excelWrkBook = null;
        int curDsPointer = 0;

        try {
            final String[] columnNames = ds.getColumns();
            final List<String> exportOnlyColumnsList = getExportOnlyColumns() != null ? Arrays.asList(exportOnlyColumns) : null;
            final List<String> excludeFromExportColumnsList = getExcludeFromExportColumns() != null ? Arrays.asList(excludeFromExportColumns) : null;
            final List<String> numericColumnList = getNumericColumns() != null ? Arrays.asList(getNumericColumns()) : new ArrayList<>();
            // get the current position of the DataSet. We have to go to the top
            // to do this write,
            // and we will put the pionter back where it was after we are done
            curDsPointer = ds.getIndex();
            ds.goTop();

            excelWrkBook = Workbook.createWorkbook(xlsFile);
            final WritableSheet wrkSheet = excelWrkBook.createSheet(""results"", 0);

            final WritableFont times10ptBold = new WritableFont(WritableFont.TIMES, 10, WritableFont.BOLD);
            final WritableFont times10pt = new WritableFont(WritableFont.TIMES, 10, WritableFont.NO_BOLD);
            // write the column headings in the spreadsheet
            WritableCellFormat cellFormat = new WritableCellFormat(times10ptBold);
            int colOffset = 0;
            for (int i = 0; i < columnNames.length; i++) {
                if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                        || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                    colOffset++;
                    continue;
                }

                final Label xlsTextLbl = new Label(i - colOffset, 0, columnNames[i], cellFormat);
                wrkSheet.addCell(xlsTextLbl);
            }

            cellFormat = new WritableCellFormat(times10pt);
            int row = 1;
            while (ds.next()) {
                if (!ds.isRecordID(FPConstants.DETAIL_ID)) {
                    continue;
                }

                colOffset = 0;
                for (int i = 0; i < columnNames.length; i++) {
                    if (exportOnlyColumnsList != null && !exportOnlyColumnsList.contains(columnNames[i])
                            || excludeFromExportColumnsList != null && excludeFromExportColumnsList.contains(columnNames[i])) {
                        colOffset++;
                        continue;
                    }

                    WritableCell wc = null;
                    if (numericColumnList.contains(columnNames[i])) {
                        wc = new Number(i - colOffset, row, ds.getDouble(columnNames[i]), cellFormat);
                    } else {
                        wc = new Label(i - colOffset, row, ds.getString(columnNames[i]), cellFormat);
                    }

                    wrkSheet.addCell(wc);
                }

                row++;
            }

            excelWrkBook.write();

        } finally {
            if (curDsPointer > -1) {
                ds.absolute(curDsPointer);
            }
            if (excelWrkBook != null) {
                excelWrkBook.close();
            }
        }

    }"
1,"Extracts the HTML headers (h1-h6 tags) from an HTML page.

@param html
@return[SEP]public static Map<String, List<String>> extractHTMLheaders(String html) {
        Map<String, List<String>> hxtagsMap = new HashMap<>();
        for(int i=1;i<=6;++i) {
            hxtagsMap.put(""H""+i, new ArrayList<>());
        }
                
        Matcher m = HX_PATTERN.matcher(html);
        while (m.find()) {
            if(m.groupCount()==2) {
                String tagType = m.group(1).toUpperCase(Locale.ENGLISH);
                String content = m.group(2);
                hxtagsMap.get(tagType).add(clear(content));
            }
        }
        return hxtagsMap;
    }"
1,"Returns the probability of k of a specific number of tries n and probability p

@param k
@param p
@param n
@return[SEP]public static double binomial(int k, double p, int n) {
        if(k<0 ||  p<0 || n<1) {
            throw new IllegalArgumentException(""All the parameters must be positive and n larger than 1."");
        }
        
        k = Math.min(k, n); 
        
        /*
        //Slow and can't handle large numbers
        $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);
        */

        //fast and can handle large numbers
        //Cdf(k)-Cdf(k-1)
        double probability = approxBinomialCdf(k,p,n); 
        if(k>0) {
            probability -= approxBinomialCdf(k-1,p,n);
        }
        
        return probability;
    }"
1,"Returns the permutations of a collection.
Ported from:
http://stackoverflow.com/questions/10503392/java-code-for-permutations-of-a-list-of-numbers

@param <T>
@param elements
@return[SEP]public static <T> Collection<List<T>> permutations(Collection<T> elements) {
        Collection<List<T>> result = new ArrayList<>();
        if (elements.isEmpty()) {
            result.add(new LinkedList<>());
            return result;
        }

        List<T> rest = new LinkedList<>(elements);
        T head = rest.remove(0);
        for (List<T> permutations : permutations(rest)) {
            List<List<T>> subLists = new ArrayList<>();
            for (int i = 0; i <= permutations.size(); i++) {
                List<T> subList = new ArrayList<>();
                subList.addAll(permutations);
                subList.add(i, head);
                subLists.add(subList);
            }
            result.addAll(subLists);
        }
        return result;
    }"
0,"Returns the Pvalue for a particular score

@param score
@param n
@param p
@return[SEP]private static double scoreToPvalue(double score, int n, double p) {
        /*
        if(n<=20) {
            //calculate it from binomial distribution
        }
        */

        double z=(score+0.5-n*p)/Math.sqrt(n*p*(1.0-p));

        return ContinuousDistributions.gaussCdf(z);
    }"
0,"Returns the number of words with more than three syllables.

@param   strText                  Text to be measured
@return[SEP]private static int wordsWithThreeSyllables(String strText) {
        int intLongWordCount = 0;
        
        List<String> arrWords = (new WhitespaceTokenizer()).tokenize(strText);
        int intWordCount = arrWords.size();
        for (int i = 0; i < intWordCount; ++i) {
            if(syllableCount(arrWords.get(i)) > 2) {
                ++intLongWordCount; //it also counts the proper nouns which should be excluded for Fog index, but this is not a major issue
            }
        }
        
        return intLongWordCount;
    }"
1,"Extracts the main content for an HTML page.

@param html
@param parameters
@return[SEP]public String extract(String html, CETR.Parameters parameters) {
        html = clearText(html); //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines
        List<String> rows = extractRows(html); //
        
        List<Integer> selectedRowIds = selectRows(rows, parameters);
        
        StringBuilder sb = new StringBuilder(html.length());
        for(Integer rowId : selectedRowIds) {
            String row = rows.get(rowId);
            
            //extract the clear text from the selected row
            row = StringCleaner.removeExtraSpaces(HTMLParser.extractText(row));
            if(row.isEmpty()) {
                continue;
            }
            sb.append(row).append("" "");
        }
        
        return sb.toString().trim();
    }"
1,"The CheckBox check function It invokes selenium session to handle the check action against the element.[SEP]public void check() {
        getDispatcher().beforeCheck(this);
        
        RemoteWebElement e = (RemoteWebElement) getElement();
        while (!e.isSelected()) {
            e.click();
        }
        if (Config.getBoolConfigProperty(ConfigProperty.ENABLE_GUI_LOGGING)) {
            logUIAction(UIActions.CHECKED);
        }
        
        getDispatcher().afterCheck(this);
    }"
1,"Gets the PID for the SeLion-Grid (main) process

@return the PID as an int
@throws ProcessHandlerException[SEP]protected int getCurrentProcessID() throws ProcessHandlerException {
        int pid;
        // Not ideal but using JNA failed on RHEL5.
        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
        Field jvm = null;
        try {
            jvm = runtime.getClass().getDeclaredField(""jvm"");
            jvm.setAccessible(true);
            VMManagement mgmt = (VMManagement) jvm.get(runtime);
            Method pid_method = mgmt.getClass().getDeclaredMethod(""getProcessId"");
            pid_method.setAccessible(true);
            pid = (Integer) pid_method.invoke(mgmt);
        } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new ProcessHandlerException(e);
        }
        return pid;
    }"
1,"Untick a checkbox in a cell of a table indicated by the input row and column indices.

@param row
int number of row for cell
@param column
int number of column for cell[SEP]public void uncheckCheckboxInCell(int row, int column) {
        String checkboxLocator = getXPathBase() + ""tr["" + row + ""]/td["" + column + ""]/input"";
        CheckBox cb = new CheckBox(checkboxLocator);
        cb.uncheck();
    }"
1,"Gets IP address type[SEP]public static IPAddressType getAddressType(String ipAddress)
    {
    	if(IPAddressUtil.isIPv4LiteralAddress(ipAddress))
    		return IPAddressType.IPV4;
    	
    	if(IPAddressUtil.isIPv6LiteralAddress(ipAddress))
    		return IPAddressType.IPV6;
    	
    	return IPAddressType.INVALID;
    }"
0,"Sets the priority of the event.
@param priority the priority (""0"" is undefined, ""1"" is the highest, ""9""
is the lowest) or null to remove
@return the property that was created
@see <a href=""http://tools.ietf.org/html/rfc5545#page-89"">RFC 5545
p.89-90</a>
@see <a href=""http://tools.ietf.org/html/rfc2445#page-85"">RFC 2445
p.85-7</a>
@see <a href=""http://www.imc.org/pdi/vcal-10.doc"">vCal 1.0 p.33</a>[SEP]public Priority setPriority(Integer priority) {
		Priority prop = (priority == null) ? null : new Priority(priority);
		setPriority(prop);
		return prop;
	}"
0,"Helper for getting epoch {@link DateTime} object

@return {@link DateTime} representing epoch[SEP]public static DateTime epoch() {
		 MutableDateTime epoch = new MutableDateTime();
		 
	     epoch.setDate(0); 
	     epoch.setTime(0);
	        
	     return epoch.toDateTime();
	}"
0,"Create a new <em>location</em> object from the given {@code latitude}
and {@code longitude}.

@param latitude the latitude of the location, maybe {@code null}
@param longitude the longitude of the location, maybe {@code null}
@return a new location object from the given input data[SEP]public static Location of(final Latitude latitude, final Longitude longitude) {
		return new Location(latitude, longitude, null);
	}"
1,"Writes the CSV data located in {@code csvData} to the file located at
{@code fileName}.

@param csvData the CSV data including the header
@param fileName the file to write the CSV data to
@throws IOException if there was an error writing to the file
@throws NullPointerException if {@code csvData == null} or {@code fileName == null}[SEP]public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {
    Preconditions.checkNotNull(csvData, ""Null CSV data"");
    Preconditions.checkNotNull(fileName, ""Null file name"");

    CSVWriter writer = null;
    try {
      writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));
      for (String[] line : csvData) {
        writer.writeNext(line);
      }
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }"
1,"<p>Reverses a String as per {@link StringBuffer#reverse()}.</p>

<p>A <code>null</code> String returns <code>null</code>.</p>

<pre>
GosuStringUtil.reverse(null)  = null
GosuStringUtil.reverse("""")    = """"
GosuStringUtil.reverse(""bat"") = ""tab""
</pre>

@param str  the String to reverse, may be null
@return the reversed String, <code>null</code> if null String input[SEP]public static String reverse(String str) {
      if (str == null) {
          return null;
      }
      return new StringBuffer(str).reverse().toString();
  }"
0,"Replaces multiple subsequent slashes with one slash. E.g. ////a//path//
will becaome /a/path/

@param target target sring to be replaced
@return a string where the subsequent slashes are replaced with one slash[SEP]static String replaceSlashes(final String target) {
		String replaced = target;
		if (replaced != null) {
			replaced = replaced.replaceAll(""/+"", ""/"");
		}
		return replaced;
	}"
0,"Search for entries around a given latitude/longitude.

@param radius set the maximum distance in meters. Note: at indexing, geoloc
of an object should be set with _geoloc attribute containing
lat and lng attributes (for example
{""_geoloc"":{""lat"":48.853409, ""lng"":2.348800}})[SEP]public Query aroundLatitudeLongitude(float latitude, float longitude, int radius) {
    aroundLatLong = ""aroundLatLng="" + latitude + "","" + longitude;
    aroundRadius = radius;
    return this;
  }"
0,"Record an error with extra information attached.

@param error  the error.
@param custom the extra information.[SEP]public void error(Throwable error, Map<String, Object> custom) {
    error(error, custom, null);
  }"
0,"Returns the dimension number corresponding to the term at the end of the
provided path.

@param path a path whose end represents a semantic connection

@return the dimension for the occurrence of the last word in the path[SEP]public int getDimension(DependencyPath path) {
        String endToken = path.last().word();

        // Extract out how the current word is related to the last word in the
        // path.  
        String relation = path.getRelation(path.length() - 1);
        return getDimensionInternal(endToken + ""+"" + relation);
    }"
1,"Creates an {@code TernaryVector} with the provided length.

@param length the length of the index vector

@return an index vector[SEP]public TernaryVector generate() {
        HashSet<Integer> pos = new HashSet<Integer>();
        HashSet<Integer> neg = new HashSet<Integer>();
        
        // Randomly decide how many bits to set in the index vector based on the
        // variance.
        int bitsToSet = numVectorValues +
            (int)(RANDOM.nextDouble() * variance *
                  ((RANDOM.nextDouble() > .5) ? 1 : -1));

        for (int i = 0; i < bitsToSet; ++i) {
            boolean picked = false;
            // loop to ensure we actually pick the full number of bits
            while (!picked) {
                // pick some random index
                int index = RANDOM.nextInt(indexVectorLength);
                    
                // check that we haven't already added this index
                if (pos.contains(index) || neg.contains(index))
                    continue;
                    
                // decide positive or negative
                ((RANDOM.nextDouble() > .5) ? pos : neg).add(index);
                picked = true;
            }
        }
            
        int[] positive = new int[pos.size()];
        int[] negative = new int[neg.size()];

        Iterator<Integer> it = pos.iterator();
        for (int i = 0; i < positive.length; ++i) 
            positive[i] = it.next();

        it = neg.iterator();
        for (int i = 0; i < negative.length; ++i) 
            negative[i] = it.next();                

        // sort so we can use a binary search in getValue()
        Arrays.sort(positive);
        Arrays.sort(negative);
        return new TernaryVector(indexVectorLength, positive, negative);
    }"
0,"getDateStringOrSuppliedString, This returns the last valid date in an ISO-8601 formatted
string ""uuuu-MM-dd"". For any CE years that are between 0 and 9999 inclusive, the output will
have a fixed length of 10 characters. Years before or after that range will output longer
strings. If the last valid date is empty, this will return the value of emptyDateString.[SEP]public String getDateStringOrSuppliedString(String emptyDateString) {
        LocalDate date = getDate();
        return (date == null) ? emptyDateString : date.toString();
    }"
0,"Hides the option if set to <code>true</code>.<br>
<br>
Defaults to <code>false</code>.

@param hidden[SEP]public void setHidden(final boolean hidden) {
        if (hidden)
            attrMixin.setAttribute(HIDDEN, Boolean.toString(true));
        else
            attrMixin.removeAttribute(HIDDEN);
    }"
0,"Set current value as Json Array You can also skip this call Arrays can be
create automatically.[SEP]@SuppressWarnings(""unchecked"")
	public JSONNavi<T> array() {
		if (failure)
			return this;
		if (current == null && readonly)
			failure(""Can not create Array child in readonly"", null);
		if (current != null) {
			if (isArray())
				return this;
			if (isObject())
				failure(""can not use Object feature on Array."", null);
			failure(""Can not use current possition as Object"", null);
		} else {
			current = mapper.createArray();
		}
		if (root == null)
			root = (T) current;
		else
			store();
		return this;
	}"
1,"HTTP POST Request with Interface implementation of ApiParams and ApiFileParams
@param data
@param fileParams
@throws IOException[SEP]public JsonResponse apiPost(ApiParams data, ApiFileParams fileParams) throws IOException {
        return httpRequestJson(HttpRequestMethod.POST, data, fileParams);
    }"
0,"Convenience method to set the inner HTML of the given element.[SEP]public static void innerHtml(HTMLElement element, SafeHtml html) {
        if (element != null) {
            element.innerHTML = html.asString();
        }
    }"
0,"Sets the similarity implementation, which will be used for indexing and
searching. The implementation must extend {@link Similarity}.

@param className
a {@link Similarity} implementation.[SEP]public void setSimilarityClass(String className)
   {
      try
      {
         Class<?> similarityClass = ClassLoading.forName(className, this);
         similarity = (Similarity)similarityClass.newInstance();
      }
      catch (ClassNotFoundException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
      catch (InstantiationException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
      catch (IllegalAccessException e)
      {
         log.warn(""Invalid Similarity class: "" + className, e);
      }
   }"
1,"Returns status description by it's code.

@param status Status code
@return Status Description[SEP]public static String getStatusDescription(int status)
   {
      String description = """";

      Integer statusKey = new Integer(status);
      if (statusDescriptions.containsKey(statusKey))
      {
         description = statusDescriptions.get(statusKey);
      }

      return String.format(""%s %d %s"", WebDavConst.HTTPVER, status, description);
   }"
0,"{@inheritDoc}[SEP]public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
   {
      orderNumber = in.readInt();

      // read canonical file path
      int size = in.readInt();
      if (size > 0)
      {
         byte[] buf = new byte[size];
         in.readFully(buf);

         File f = new File(new String(buf, ""UTF-8""));
         // validate if exists
         if (PrivilegedFileHelper.exists(f))
         {
            file = f;
         }
         else
         {
            file = null;
         }
      }
      else
      {
         // should not occurs but since we have a way to recover, it should not be
         // an issue
         file = null;
      }
   }"
0,"Copy the content of the source file to the destination file using
{@link FileChannel}. This version seems to fail with UNC paths.

@param aSrcFile
Source file. May not be <code>null</code>.
@param aDestFile
Destination file. May not be <code>null</code>.
@return {@link ESuccess}[SEP]@Nonnull
  private static ESuccess _copyFileViaChannel (@Nonnull final File aSrcFile, @Nonnull final File aDestFile)
  {
    final FileChannel aSrcChannel = FileChannelHelper.getFileReadChannel (aSrcFile);
    if (aSrcChannel == null)
      return ESuccess.FAILURE;

    try
    {
      final FileChannel aDstChannel = FileChannelHelper.getFileWriteChannel (aDestFile, EAppend.TRUNCATE);
      if (aDstChannel == null)
        return ESuccess.FAILURE;

      try
      {
        FileLock aSrcLock = null;
        FileLock aDestLock = null;
        try
        {
          final long nBytesToRead = aSrcChannel.size ();

          // Shared read lock and exclusive write lock
          aSrcLock = aSrcChannel.lock (0, nBytesToRead, true);
          aDestLock = aDstChannel.lock ();

          // Main copying - the loop version is much quicker than then
          // transferTo with full size!
          long nBytesWritten = 0;
          final long nChunkSize = 1L * CGlobal.BYTES_PER_MEGABYTE;
          while (nBytesWritten < nBytesToRead)
            nBytesWritten += aSrcChannel.transferTo (nBytesWritten, nChunkSize, aDstChannel);

          if (nBytesToRead != nBytesWritten)
          {
            if (LOGGER.isErrorEnabled ())
              LOGGER.error (""Failed to copy file. Meant to read "" + nBytesToRead + "" bytes but wrote "" + nBytesWritten);
            return ESuccess.FAILURE;
          }
          return ESuccess.SUCCESS;
        }
        catch (final IOException ex)
        {
          throw new IllegalStateException (""Failed to copy from "" + aSrcFile + "" to "" + aDestFile, ex);
        }
        finally
        {
          // Unlock
          ChannelHelper.release (aDestLock);
          ChannelHelper.release (aSrcLock);
        }
      }
      finally
      {
        ChannelHelper.close (aDstChannel);
      }
    }
    finally
    {
      ChannelHelper.close (aSrcChannel);
    }
  }"
1,"Returns the day given a string in format dd-MMM-yyyy.[SEP]public static Date getDay(String string) {
		if (string == null) {
			return null;
		}
		Date date = null;
		try {
			date = (new SimpleDateFormat(""dd-MMM-yyyy"").parse(string));
		}
		catch (ParseException ex) {
			return null;
		}
		return date;
	}"
0,"Order coordinates to have the first coordinate in the array as the nearest to a given
coordinate 'c'. The second and third are not ordered, but randomly added.

@param c
@param coordinate1
@param coordinate2
@param coordinate3
@return[SEP]private Coordinate[] getOrderedNodes( Coordinate c, Coordinate coordinate1, Coordinate coordinate2, Coordinate coordinate3 ) {
        double d = distance3d(c, coordinate1, null);
        Coordinate nearest = coordinate1;
        Coordinate c2 = coordinate2;
        Coordinate c3 = coordinate3;

        double d2 = distance3d(c, coordinate2, null);
        if (d2 < d) {
            nearest = coordinate2;
            d = d2;
            c2 = coordinate1;
            c3 = coordinate3;
        }
        double d3 = distance3d(c, coordinate3, null);
        if (d3 < d) {
            nearest = coordinate3;
            c2 = coordinate1;
            c3 = coordinate2;
        }
        return new Coordinate[]{nearest, c2, c3};
    }"
1,"Multiply this matrix by a constant.
@param k the constant
@return the product matrix[SEP]public Matrix multiply(double k)
    {
        double pv[][] = new double[nRows][nCols]; // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < nCols; ++c) {
                pv[r][c] = k*values[r][c];
            }
        }

        return new Matrix(pv);
    }"
1,"Multiply this matrix by another matrix.
@param m the matrix multiplier
@return the product matrix
@throws numbercruncher.MatrixException for invalid size[SEP]public Matrix multiply(Matrix m) throws MatrixException
    {
        // Validate m's dimensions.
        if (nCols != m.nRows) {
            throw new MatrixException(
                                MatrixException.INVALID_DIMENSIONS);
        }

        double pv[][] = new double[nRows][m.nCols];  // product values

        // Compute values of the product.
        for (int r = 0; r < nRows; ++r) {
            for (int c = 0; c < m.nCols; ++c) {
                double dot = 0;
                for (int k = 0; k < nCols; ++k) {
                    dot += values[r][k] * m.values[k][c];
                }
                pv[r][c] = dot;
            }
        }

        return new Matrix(pv);
    }"
1,"Calcs coefficients of linear regression between x, y data
@param xData the independent data array (x)
@param yData the dependent data array (y)
@return (intercept, gradient, r?)[SEP]public static double[] linearReg(double[] xData, double[] yData) {
        sameArrayLen(xData, yData);
        double sumYValue = 0;
        double meanYValue = 0;
        double sumXValue = 0;
        double meanXValue = 0;
        double sumX = 0;
        double sumY = 0;
        double prod = 0;
        double NODATA = -9999;
        int nstat = xData.length;
        double[] regCoef = new double[3]; //(intercept, gradient, r?)
        int counter = 0;
        //calculating sums
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumYValue += yData[i];
                sumXValue += xData[i];
                counter++;
            }
        }
        //calculating means
        meanYValue = sumYValue / counter;
        meanXValue = sumXValue / counter;

        //calculating regression coefficients
        for (int i = 0; i < nstat; i++) {
            if ((yData[i] != NODATA) && (xData[i] != NODATA)) {
                sumX += Math.pow((xData[i] - meanXValue), 2);
                sumY += Math.pow((yData[i] - meanYValue), 2);
                prod += ((xData[i] - meanXValue) * (yData[i] - meanYValue));
            }
        }
        if (sumX > 0 && sumY > 0) {
            regCoef[1] = prod / sumX;  //gradient
            regCoef[0] = meanYValue - regCoef[1] * meanXValue; //intercept
            regCoef[2] = Math.pow((prod / Math.sqrt(sumX * sumY)), 2); //r?
        } else {
            regCoef[1] = 0;
            regCoef[0] = 0;
            regCoef[2] = 0;
        }
        return regCoef;
    }"
1,"Overrides the loaded/default settings by command line arguments.[SEP]private void parseCommandLineArgs(String[] args) throws ConfigurationException {
        if (args == null || args.length == 0) {
            return;
        }
        logger.info(""Parsing command line arguments"");
        m_commandLineArgs = args;
        
        try {
            for (int inx = 0; inx < args.length; inx++) {
                String arg = args[inx];
                if (arg.equals(""-?"") || arg.equalsIgnoreCase(""-h"") || arg.equalsIgnoreCase(""-help"")) {
                    System.out.println(""See documentation and doradus.yaml for help."");
                    System.exit(0);
                }
                Utils.require(arg.charAt(0) == '-', ""Unrecognized argument: %s"", arg);
                Utils.require(inx + 1 < args.length, ""A value is expected after: %s"", arg);
                String name = arg.substring(1);
                String value = args[++inx];
                setCommandLineParam(name, value);
            }
        } catch (Exception e) {
            logger.error(""Failed to parse command line arguments"", e);
            throw new ConfigurationException(""Failed to parse command line arguments"", e);
        }
    }"
1,"{@inheritDoc}[SEP]@Override
	public String getRequestValue(final Request request) {
		if (isPresent(request)) {
			// User entered a valid date
			String dateParam = request.getParameter(getId() + ""-date"");
			if (dateParam == null) {
				return null;
			}

			// Validate Transfer Date Format - YYYY-MM-DD
			if (dateParam.length() != INTERNAL_DATE_TOTAL_CHARS || dateParam.charAt(
					INTERNAL_DASH1_POS) != '-'
					|| dateParam.charAt(INTERNAL_DASH2_POS) != '-') {
				LOG.warn(""Date parameter is not in the format yyyy-MM-dd ("" + dateParam
						+ "") and will be treated as null."");
				return null;
			}

			// Transform YYYY-MM-DD to YYYYMMDD
			StringBuffer buf = new StringBuffer(DATE_TOTAL_CHARS);
			buf.append(dateParam.substring(INTERNAL_YEAR_START, INTERNAL_YEAR_END));
			buf.append(dateParam.substring(INTERNAL_MONTH_START, INTERNAL_MONTH_END));
			buf.append(dateParam.substring(INTERNAL_DAY_START, INTERNAL_DAY_END));

			String dateFormat = buf.toString();

			// Validate the date
			if (!isValidPartialDateStringFormat(dateFormat, THEME_PADDING_CHAR)) {
				LOG.warn(""Date parameter (""
						+ dateParam
						+ "") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null."");
				return null;
			}

			// Convert from Theme padding character to the correct padding character
			return dateFormat.replace(THEME_PADDING_CHAR, getPaddingChar());
		} else {
			return getValue();
		}
	}"
0,"TODO: NOT finished yet Converts HTML code back to the real characters;

@param wordsByPage
the extracted texts in the word level in a document[SEP]private void convertHTMLCode(ArrayList<ArrayList<TextPiece>> wordsByPage) {
	DocInfo docInfo = new DocInfo();
	String[] html2Char = docInfo.getHtml2CharMapping(); // Only define this
							    // mapping string
							    // when we detect
							    // the files in HTML
							    // codes
	int pageNum = 0;

	for (ArrayList<TextPiece> wordsOfAPage : wordsByPage) {
	    pageNum++;
	    for (int i = 0; i < wordsOfAPage.size(); i++) {
		TextPiece currentWord = wordsOfAPage.get(i);
		String realText = """";
		String textinHTMLCode = currentWord.getText();

	    }
	}
    }"
0,"<p>
replaceFile.
</p>

@param fileName a {@link java.lang.String} object.
@param profiles a {@link java.util.Map} object.
@param charset a {@link java.lang.String} object.
@throws java.lang.Exception if any.
@throws java.io.FileNotFoundException if any.[SEP]public static void replaceFile(String fileName, final Map<String, List<Replacer>> profiles, Charset charset)
      throws Exception, FileNotFoundException {
    File file = new File(fileName);
    if (file.isFile() && !file.isHidden()) {
      List<Replacer> replacers = profiles.get(Strings.substringAfterLast(fileName, "".""));
      if (null == replacers) { return; }
      logger.info(""processing {}"", fileName);
      String filecontent = Files.readFileToString(file, charset);
      filecontent = Replacer.process(filecontent, replacers);
      writeToFile(filecontent, fileName, charset);
    } else {
      String[] subFiles = file.list(new FilenameFilter() {
        public boolean accept(File dir, String name) {
          if (dir.isDirectory()) return true;
          boolean matched = false;
          for (String key : profiles.keySet()) {
            matched = name.endsWith(key);
            if (matched) return true;
          }
          return false;
        }
      });
      if (null != subFiles) {
        for (int i = 0; i < subFiles.length; i++) {
          replaceFile(fileName + '/' + subFiles[i], profiles, charset);
        }
      }
    }
  }"
1,"Extracts all files in the specified ZIP file and stores them in the
denoted directory. The directory needs to exist before running this method.

Note: nested ZIP files are not extracted here.

@param zip The zip-file to process
@param toDir Target directory, should already exist.

@throws IOException Thrown if files can not be read or any other error occurs while handling the Zip-files[SEP]public static void extractZip(File zip, File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		try (ZipFile zipFile = new ZipFile(zip)) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();

			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();

				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName());
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					continue;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				//logger.info(""Extracting file: "" + entry.getName());
				try (InputStream inputStream = zipFile.getInputStream(entry)) {
					try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
						IOUtils.copy(inputStream, outputStream);
					}
				}
			}
		} catch (FileNotFoundException | NoSuchFileException e) {
			throw e;
		} catch (IOException e) {
			throw new IOException(""While extracting file "" + zip + "" to "" + toDir, e);
		}
	}"
1,"Extracts all files in the ZIP file passed as InputStream and stores them in the
denoted directory. The directory needs to exist before running this method.

Note: nested ZIP files are not extracted here.

@param zip An {@link InputStream} to read zipped files from
@param toDir Target directory, should already exist.

@throws IOException Thrown if files can not be read or any other error occurs while handling the Zip-files[SEP]public static void extractZip(InputStream zip, final File toDir) throws IOException{
		if(!toDir.exists()) {
			throw new IOException(""Directory '"" + toDir + ""' does not exist."");
		}

		// Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create
		// directories and files accordingly
		new ZipFileVisitor() {
			@Override
			public void visit(ZipEntry entry, InputStream data) throws IOException {
				File target = new File(toDir, entry.getName());
				if (entry.isDirectory()) {
					// Assume directories are stored parents first then children.
					//logger.info(""Extracting directory: "" + entry.getName() + "" to "" + target);
					// This is not robust, just for demonstration purposes.
					if(!target.mkdirs()) {
						logger.warning(""Could not create directory "" + target);
					}
					return;
				}

				// zips can contain nested files in sub-dirs without separate entries for the directories
				if(!target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
					logger.warning(""Could not create directory "" + target.getParentFile());
				}

				// it seems we cannot use IOUtils/FileUtils to copy as they close the stream
				int size;
				byte[] buffer = new byte[2048];
				try (OutputStream fout = new BufferedOutputStream(new FileOutputStream(target), buffer.length)) {
	                while ((size = data.read(buffer, 0, buffer.length)) != -1) {
	                    fout.write(buffer, 0, size);
	                }
				}
			}
		}.walk(zip);
	}"
0,"This method returns a new instance of Configured Class with this setting:
<table summary ="""">
<tr>
<td><code>NullPointerControl</code></td><td><code>NOT_ANY</code></td>
</tr><tr>
<td><code>MappingType</code> of Destination</td><td><code>ALL_FIELDS</code></td>
</tr><tr>
<td><code>MappingType</code> of Source</td><td><code>ALL_FIELDS</code></td>
</tr>
</table>
@param source instance of Target Class type that contains the data
@return new instance of Configured Class
@see NullPointerControl
@see MappingType[SEP]public <S> T manyToOneWithoutControl(final S source) {
		try{ return this.<T,S>getJMapper(relationalManyToOneMapper,source).getDestinationWithoutControl(source); }
		catch (Exception e) { return logAndReturnNull(e); }
	}"
0,"Thrown if conversion type is wrong.
@param conversionName conversion name
@param xmlPath xml path
@param className class name
@param type type[SEP]public static void xmlConversionTypeIncorrect(String conversionName,String xmlPath,String className,String type){
		throw new XmlConversionTypeException(MSG.INSTANCE.message(xmlConversionTypeException,conversionName,xmlPath,className,type));
	}"
0,"This Method returns the destination given in input enriched with data contained in source given in input<br>
with this setting:
<table summary = """">
<tr>
<td><code>NullPointerControl</code></td><td><code>NOT_ANY</code></td>
</tr><tr>
<td><code>MappingType</code> of Destination</td><td><code>ALL_FIELDS</code></td>
</tr><tr>
<td><code>MappingType</code> of Source</td><td><code>ALL_FIELDS</code></td>
</tr>
</table>
@param destination instance to enrich
@param source instance that contains the data
@return destination enriched
@see NullPointerControl
@see MappingType[SEP]public D getDestinationWithoutControl(D destination,final S source){
        try {
            return mapper.vVNotAllAll(destination, source);
        } catch (Exception e) { 
        	JmapperLog.error(e); 
        }
        return null;
	}"
1,"Writes a CSV file

@param columnHeaders headers
@param rows rows
@return CSV file
@throws IOException throws IOException when CSV writing fails[SEP]private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {
    try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName(""UTF-8""))) {
      CSVWriter csvWriter = new CSVWriter(streamWriter, ',');

      csvWriter.writeNext(columnHeaders);
      
      for (String[] row : rows) {
        csvWriter.writeNext(row);
      }

      csvWriter.close();
      
      return csvStream.toByteArray();
    }
  }"
1,"clears all plaintext passwords and secrets. password, secret and initAES must all be set before re-using
@throws Exception[SEP]public void doAESEncryption() throws Exception{
		if(!initAESDone)
			initAES();
		cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
		//System.out.println(secretKey.getEncoded());
		cipher.init(Cipher.ENCRYPT_MODE, secretKey);
		AlgorithmParameters params = cipher.getParameters();
		iv = params.getParameterSpec(IvParameterSpec.class).getIV();
		secretCipher = cipher.doFinal(secretPlain);
		clearPlain();
	}"
1,"This method is called to format a date.

@param value date value
@return formatted date value[SEP]private String formatDate(Date value)
   {
      return (value == null ? null : m_formats.getDateFormat().format(value));
   }"
0,"This is the main entry point used to convert the internal representation
of timephased work into an external form which can
be displayed to the user.

@param projectCalendar calendar used by the resource assignment
@param work timephased resource assignment data
@param rangeUnits timescale units
@param dateList timescale date ranges
@return list of durations, one per timescale date range[SEP]public ArrayList<Duration> segmentWork(ProjectCalendar projectCalendar, List<TimephasedWork> work, TimescaleUnits rangeUnits, List<DateRange> dateList)
   {
      ArrayList<Duration> result = new ArrayList<Duration>(dateList.size());
      int lastStartIndex = 0;

      //
      // Iterate through the list of dates range we are interested in.
      // Each date range in this list corresponds to a column
      // shown on the ""timescale"" view by MS Project
      //
      for (DateRange range : dateList)
      {
         //
         // If the current date range does not intersect with any of the
         // assignment date ranges in the list, then we show a zero
         // duration for this date range.
         //
         int startIndex = lastStartIndex == -1 ? -1 : getStartIndex(range, work, lastStartIndex);
         if (startIndex == -1)
         {
            result.add(Duration.getInstance(0, TimeUnit.HOURS));
         }
         else
         {
            //
            // We have found an assignment which intersects with the current
            // date range, call the method below to determine how
            // much time from this resource assignment can be allocated
            // to the current date range.
            //
            result.add(getRangeDuration(projectCalendar, rangeUnits, range, work, startIndex));
            lastStartIndex = startIndex;
         }
      }

      return result;
   }"
1,"Converts the results to CSV data.

@return the CSV data[SEP]public String getCsv() {

        StringWriter writer = new StringWriter();
        try (CSVWriter csv = new CSVWriter(writer)) {
            List<String> headers = new ArrayList<>();
            for (String col : m_columns) {
                headers.add(col);
            }
            csv.writeNext(headers.toArray(new String[] {}));
            for (List<Object> row : m_data) {
                List<String> colCsv = new ArrayList<>();
                for (Object col : row) {
                    colCsv.add(String.valueOf(col));
                }
                csv.writeNext(colCsv.toArray(new String[] {}));
            }
            return writer.toString();
        } catch (IOException e) {
            return null;
        }
    }"
0,"Matches a string against a regex, and inverts the match if the regex starts with a '!'.<p>

@param regex the regular expression
@param value the string to be matched

@return true if the validation succeeded[SEP]private static boolean matchRuleRegex(String regex, String value) {

        if (value == null) {
            value = """";
        }

        if (regex == null) {
            return true;
        }
        if ((regex.length() > 0) && (regex.charAt(0) == '!')) {
            return !value.matches(regex.substring(1));
        } else {
            return value.matches(regex);
        }
    }"
1,"Helper method for adding the marker widget.<p>

@param text the text for the marker widget

@return the new marker widget[SEP]protected Widget addMarker(String text) {

        Label label = new Label(text);
        label.addStyleName(CSS.marker());
        getListItemWidget().addButton(label);
        return label;
    }"
0,"Returns the text content to any HTML.

@param html the HTML

@return the text content[SEP]public static String stripHtml(String html) {

        if (html == null) {
            return null;
        }
        Element el = DOM.createDiv();
        el.setInnerHTML(html);
        return el.getInnerText();
    }"
0,"Creates a dummy index source.<p>

@return the dummy search index source[SEP]private CmsSearchIndexSource createDummyIndexSource() {

        CmsSearchIndexSource result = new CmsSearchIndexSource();
        result.setName(""default"");
        result.setIndexerClassName(""org.opencms.search.CmsVfsIndexer"");
        result.addDocumentType(""html"");
        result.addDocumentType(""generic"");
        result.addDocumentType(""pdf"");
        // add search index source to config:
        m_searchManager.addSearchIndexSource(result);
        return result;
    }"
1,"Returns the path to java executable.[SEP]protected String getJavaExecutablePath() {
        String executableName = isWindows() ? ""bin/java.exe"" : ""bin/java"";
        return PROPERTIES.getJavaHome().resolve(executableName).toAbsolutePath().toString();
    }"
0,"Sorts the row indices in ascending order.
@param sorter (Optional) Used to sort rows.  If null a new instance will be declared internally.[SEP]public void sortIndices(SortCoupledArray_F64 sorter ) {
        if( sorter == null )
            sorter = new SortCoupledArray_F64();

        sorter.quick(col_idx,numCols+1,nz_rows,nz_values);
        indicesSorted = true;
    }"
1,"Shortcut for mapping the output of an arbitrary observable to one returning an instance of a specific type, using the IO scheduler.
@param fromObservable the source observable
@param toValue the value to emit to the observer
@param <T> the type of the value to emit
@return an observable emitting the specified value[SEP]public static <T> Observable<T> map(Observable<?> fromObservable, final T toValue) {
        if (fromObservable != null) {
            return fromObservable.subscribeOn(Schedulers.io())
                    .map(new RXMapper<T>(toValue));
        } else {
            return Observable.empty();
        }
    }"
0,"Concat a List into a CSV String.
@param list list to concat
@return csv string[SEP]private String listToCSV(List<String> list) {
        String csvStr = """";
        for (String item : list) {
            csvStr += "","" + item;
        }

        return csvStr.length() > 1 ? csvStr.substring(1) : csvStr;
    }"
0,"<p>memoize.</p>

@param function a {@link java.util.function.Function} object.
@param <T> a T object.
@param <U> a U object.
@return a {@link java.util.function.Function} object.[SEP]public static <T, U> Function<T, U> memoize(final Function<T, U> function) {
    return new Memoizer<T, U>().doMemoize(function);
  }"
0,"Assign based on execution time history. The algorithm is a greedy heuristic
assigning the longest remaining test to the slave with the
shortest-completion time so far. This is not optimal but fast and provides
a decent average assignment.[SEP]@Override
  public List<Assignment> assign(Collection<String> suiteNames, int slaves, long seed) {
    // Read hints first.
    final Map<String,List<Long>> hints = ExecutionTimesReport.mergeHints(resources, suiteNames);

    // Preprocess and sort costs. Take the median for each suite's measurements as the 
    // weight to avoid extreme measurements from screwing up the average.
    final List<SuiteHint> costs = new ArrayList<>();
    for (String suiteName : suiteNames) {
      final List<Long> suiteHint = hints.get(suiteName);
      if (suiteHint != null) {
        // Take the median for each suite's measurements as the weight
        // to avoid extreme measurements from screwing up the average.
        Collections.sort(suiteHint);
        final Long median = suiteHint.get(suiteHint.size() / 2);
        costs.add(new SuiteHint(suiteName, median));
      }
    }
    Collections.sort(costs, SuiteHint.DESCENDING_BY_WEIGHT);

    // Apply the assignment heuristic.
    final PriorityQueue<SlaveLoad> pq = new PriorityQueue<SlaveLoad>(
        slaves, SlaveLoad.ASCENDING_BY_ESTIMATED_FINISH);
    for (int i = 0; i < slaves; i++) {
      pq.add(new SlaveLoad(i));
    }

    final List<Assignment> assignments = new ArrayList<>();
    for (SuiteHint hint : costs) {
      SlaveLoad slave = pq.remove();
      slave.estimatedFinish += hint.cost;
      pq.add(slave);

      owner.log(""Expected execution time for "" + hint.suiteName + "": "" +
          Duration.toHumanDuration(hint.cost),
          Project.MSG_DEBUG);

      assignments.add(new Assignment(hint.suiteName, slave.id, (int) hint.cost));
    }

    // Dump estimated execution times.
    TreeMap<Integer, SlaveLoad> ordered = new TreeMap<Integer, SlaveLoad>();
    while (!pq.isEmpty()) {
      SlaveLoad slave = pq.remove();
      ordered.put(slave.id, slave);
    }
    for (Integer id : ordered.keySet()) {
      final SlaveLoad slave = ordered.get(id);
      owner.log(String.format(Locale.ROOT, 
          ""Expected execution time on JVM J%d: %8.2fs"",
          slave.id,
          slave.estimatedFinish / 1000.0f), 
          verbose ? Project.MSG_INFO : Project.MSG_DEBUG);
    }

    return assignments;
  }"
0,"Generate the next permutation and return a list containing
the elements in the appropriate order.
@see #nextPermutationAsList(java.util.List)
@see #nextPermutationAsArray()
@return The next permutation as a list.[SEP]public List<T> nextPermutationAsList()
    {
        List<T> permutation = new ArrayList<T>(elements.length);
        return nextPermutationAsList(permutation);
    }"
1,"Creates a caching variant of the closure with upper limit on the cache size.
Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
making subsequent calls with the same arguments fast.
This variant will keep all values until the upper size limit is reached. Then the values in the cache start rotating
using the LRU (Last Recently Used) strategy.
The returned function can be safely used concurrently from multiple threads, however, the implementation
values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
may not necessarily be able to benefit from each other's cached return value. With this having been mentioned,
the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.

The cache gets garbage-collected together with the memoized closure.

@param maxCacheSize The maximum size the cache can grow to
@return A new function forwarding to the original one while caching the results[SEP]public Closure<V> memoizeAtMost(final int maxCacheSize) {
        if (maxCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the maxCacheSize parameter for memoizeAtMost."");

        return Memoize.buildMemoizeFunction(new LRUCache(maxCacheSize), this);
    }"
0,"Creates a caching variant of the closure with automatic cache size adjustment and lower limit
on the cache size.
Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
making subsequent calls with the same arguments fast.
This variant allows the garbage collector to release entries from the cache and at the same time allows
the user to specify how many entries should be protected from the eventual gc-initiated eviction.
Cached entries exceeding the specified preservation threshold are made available for eviction based on
the LRU (Last Recently Used) strategy.
Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the limits
set by the user if memory is plentiful.
The returned function can be safely used concurrently from multiple threads, however, the implementation
values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter
might not be respected accurately in such scenarios for some periods of time. With this having been mentioned,
the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.

The cache gets garbage-collected together with the memoized closure.
@param protectedCacheSize Number of cached return values to protect from garbage collection
@return A new function forwarding to the original one while caching the results[SEP]public Closure<V> memoizeAtLeast(final int protectedCacheSize) {
        if (protectedCacheSize < 0) throw new IllegalArgumentException(""A non-negative number is required as the protectedCacheSize parameter for memoizeAtLeast."");

        return Memoize.buildSoftReferenceMemoizeFunction(protectedCacheSize, new ConcurrentSoftCache<Object, Object>(), this);
    }"
1,"Create a buffered reader for this file.

@param self a Path
@return a BufferedReader
@throws java.io.IOException if an IOException occurs.
@since 2.3.0[SEP]public static BufferedReader newReader(Path self) throws IOException {
        return Files.newBufferedReader(self, Charset.defaultCharset());
    }"
1,"Read the content of the Reader and return it as a String.  The reader
is closed before this method returns.

@param reader a Reader whose content we want to read
@return a String containing the content of the buffered reader
@throws IOException if an IOException occurs.
@see #getText(java.io.BufferedReader)
@since 1.0[SEP]public static String getText(Reader reader) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(reader);
        return getText(bufferedReader);
    }"
0,"Optimized version of {@code String#split} that doesn't use regexps.
This function works in O(5n) where n is the length of the string to
split.
@param s The string to split.
@param c The separator to use to split the string.
@return A non-null, non-empty array.[SEP]public static String[] splitString(final String s, final char c) {
    final char[] chars = s.toCharArray();
    int num_substrings = 1;
    for (final char x : chars) {
      if (x == c) {
        num_substrings++;
      }
    }
    final String[] result = new String[num_substrings];
    final int len = chars.length;
    int start = 0;  // starting index in chars of the current substring.
    int pos = 0;    // current index in chars.
    int i = 0;      // number of the current substring.
    for (; pos < len; pos++) {
      if (chars[pos] == c) {
        result[i++] = new String(chars, start, pos - start);
        start = pos + 1;
      }
    }
    result[i] = new String(chars, start, pos - start);
    return result;
  }"
1,"Parses the given JSON input using the provided {@link Configuration} and
returns a {@link DocumentContext} for path evaluation

@param json input
@return a read context[SEP]public static DocumentContext parse(File json, Configuration configuration) throws IOException {
        return new ParseContextImpl(configuration).parse(json);
    }"
0,"Returns an aggregation for selecting all distinct values.<br/>
This aggregation is similar to: <pre>SELECT DISTINCT * FROM x</pre>

@param <Key>          the input key type
@param <Value>        the supplied value type
@param <DistinctType> the type of all distinct values
@return a {@link java.util.Set} containing all distinct values[SEP]public static <Key, Value, DistinctType> Aggregation<Key, Value, Set<DistinctType>> distinctValues() {
        AggType<Key, Value, Integer, DistinctType, Set<DistinctType>, Set<DistinctType>, Set<DistinctType>> aggType;
        aggType = new DistinctValuesAggregation<Key, Value, DistinctType>();
        return new AggregationAdapter<Key, Value, Set<DistinctType>>(aggType);
    }"
0,"Each row returns a {@link CountPerProjectPermission}[SEP]public void groupsCountByComponentIdAndPermission(DbSession dbSession, List<Long> componentIds, ResultHandler resultHandler) {
    Map<String, Object> parameters = new HashMap<>(2);
    parameters.put(ANYONE_GROUP_PARAMETER, DefaultGroups.ANYONE);

    executeLargeInputsWithoutOutput(
      componentIds,
      partitionedComponentIds -> {
        parameters.put(""componentIds"", partitionedComponentIds);
        mapper(dbSession).groupsCountByProjectIdAndPermission(parameters, resultHandler);
      });
  }"
1,"Create a plot canvas with the scatter plot of given data with specific legend and color.
@param id the id of the plot.
@param data a n-by-2 or n-by-3 matrix that describes coordinates of points.
@param y the class labels of data.
@param palette the colors for each class.
@param legend the legend used to draw points.
<ul>
<li> . : dot
<li> + : +
<li> - : -
<li> | : |
<li> * : star
<li> x : x
<li> o : circle
<li> O : large circle
<li> @ : solid circle
<li> # : large solid circle
<li> s : square
<li> S : large square
<li> q : solid square
<li> Q : large solid square
<li> others : dot
</ul>[SEP]public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {
        if (data[0].length != 2 && data[0].length != 3) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data, y, legend, palette);
        plot.setID(id);
        canvas.add(plot);

        return canvas;
    }"
1,"Sorts the specified array into ascending numerical order.
@return the original index of elements after sorting in range [0, n).[SEP]public static int[] sort(double[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }"
1,"Sorts the specified array into ascending order.
@return the original index of elements after sorting in range [0, n).[SEP]public static <T extends Comparable<? super T>>  int[] sort(T[] arr) {
        int[] order = new int[arr.length];
        for (int i = 0; i < order.length; i++) {
            order[i] = i;
        }
        sort(arr, order);
        return order;
    }"
1,"Adds a scatter plot to this canvas.
@param id the id of the plot.
@param data a n-by-2 or n-by-3 matrix that describes coordinates of points.
@param color the color used to draw points.
@return the scatter plot for the given points.[SEP]public ScatterPlot points(String id, double[][] data, Color color) {
        if (data[0].length != base.dimension) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        double[] lowerBound = Math.colMin(data);
        double[] upperBound = Math.colMax(data);
        extendBound(lowerBound, upperBound);

        ScatterPlot plot = new ScatterPlot(data);
        plot.setID(id);
        plot.setColor(color);
        add(plot);

        return plot;
    }"
0,"Adds a staircase line plot to this canvas.
@param id the id of the plot.
@param data a n x 2 or n x 3 matrix that describes coordinates of points.
@param color the color of line.[SEP]public StaircasePlot staircase(String id, double[][] data, Color color) {
        if (data[0].length != 2 && data[0].length != 3) {
            throw new IllegalArgumentException(""Invalid data dimension: "" + data[0].length);
        }

        StaircasePlot plot = new StaircasePlot(data);
        plot.setID(id);
        plot.setColor(color);
        add(plot);
        return plot;
    }"
1,"paint given data with label on canvas
@param data the data point(s) to paint, only support 2D or 3D features
@param label the data label for classification[SEP]protected PlotCanvas paintOnCanvas(double[][] data, int[] label) {
        PlotCanvas canvas = ScatterPlot.plot(data, pointLegend);
        for (int i = 0; i < data.length; i++) {
            canvas.point(pointLegend, Palette.COLORS[label[i]], data[i]);
        }
        return canvas;
    }"
1,"Sets execution directory.[SEP]public void setWorkingDirectory(String path) {
        if (path != null) {
            File dir = new File(path);
            checkWorkingDir(dir);
            workingDir = dir;
        } else {
            workingDir = null;
        }
    }"
1,"Extracts the file contained in a Zip archive. The extracted file is
placed in the exact same path as the file specified.

@param file the archive file
@throws FileNotFoundException thrown if the file does not exist
@throws IOException thrown if there is an error extracting the file.[SEP]public static void extractZip(File file) throws FileNotFoundException, IOException {
        final String originalPath = file.getPath();
        final File zip = new File(originalPath + "".zip"");
        if (zip.isFile() && !zip.delete()) {
            LOGGER.debug(""Failed to delete initial temporary file when extracting 'zip' {}"", zip.toString());
            zip.deleteOnExit();
        }
        if (!file.renameTo(zip)) {
            throw new IOException(""Unable to rename '"" + file.getPath() + ""'"");
        }
        final File newFile = new File(originalPath);
        try (FileInputStream fis = new FileInputStream(zip);
                ZipInputStream cin = new ZipInputStream(fis);
                FileOutputStream out = new FileOutputStream(newFile)) {
            cin.getNextEntry();
            IOUtils.copy(cin, out);
        } finally {
            if (zip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(zip)) {
                LOGGER.debug(""Failed to delete temporary file when extracting 'zip' {}"", zip.toString());
                zip.deleteOnExit();
            }
        }
    }"
1,"Parses the command line arguments.

@param args the command line arguments
@return the results of parsing the command line arguments
@throws ParseException if the arguments are invalid[SEP]private CommandLine parseArgs(String[] args) throws ParseException {
        final CommandLineParser parser = new DefaultParser();
        final Options options = createCommandLineOptions();
        return parser.parse(options, args);
    }"
1,"Parses the NVD JSON file and inserts/updates data into the database.

@param file the NVD JSON file to parse
@throws UpdateException thrown if the file could not be read[SEP]public void parse(File file) throws UpdateException {
        LOGGER.debug(""Parsing "" + file.getName());
        try (InputStream fin = new FileInputStream(file);
                InputStream in = new GZIPInputStream(fin);
                InputStreamReader isr = new InputStreamReader(in, UTF_8);
                JsonReader reader = new JsonReader(isr)) {
            final Gson gson = new GsonBuilder().create();

            reader.beginObject();

            while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
                reader.skipValue();
            }
            reader.beginArray();
            while (reader.hasNext()) {
                final DefCveItem cve = gson.fromJson(reader, DefCveItem.class);

                //cve.getCve().getCVEDataMeta().getSTATE();
                if (testCveCpeStartWithFilter(cve)) {
                    cveDB.updateVulnerability(cve);
                }
            }
        } catch (FileNotFoundException ex) {
            LOGGER.error(ex.getMessage());
            throw new UpdateException(""Unable to find the NVD CPE file, `"" + file + ""`, to parse"", ex);
        } catch (IOException ex) {
            LOGGER.error(""Error reading NVD JSON data: {}"", file);
            LOGGER.debug(""Error extracting the NVD JSON data from: "" + file.toString(), ex);
            throw new UpdateException(""Unable to find the NVD CPE file to parse"", ex);
        }
    }"
1,"legacy methods left for backwards compatibility[SEP]public void csv(String file) throws IOException {
        CsvWriteOptions options = CsvWriteOptions.builder(file).build();
        new CsvWriter().write(table, options);
    }"
0,"Get the {@code count(distinct this)} expression

@return count(distinct this)[SEP]public NumberExpression<Long> countDistinct() {
        if (countDistinct == null) {
            countDistinct = Expressions.numberOperation(Long.class, Ops.AggOps.COUNT_DISTINCT_AGG, mixin);
        }
        return countDistinct;
    }"
1,"Attempt to convert the specified value to epoch time. Git properties information
are known to be specified either as epoch time in seconds or using a specific date
format.
@param s the value to coerce to
@return the epoch time in milliseconds or the original value if it couldn't be
converted[SEP]private static String coerceToEpoch(String s) {
		Long epoch = parseEpochSecond(s);
		if (epoch != null) {
			return String.valueOf(epoch);
		}
		SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"");
		try {
			return String.valueOf(format.parse(s).getTime());
		}
		catch (ParseException ex) {
			return s;
		}
	}"
1,"Generate a server side cookie given the cookie value as the input.
@param str Input string token.
@return The generated cookie.
@throws UnsupportedEncodingException[SEP]private Cookie createCookie(String str) throws UnsupportedEncodingException {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Cookie name = "" + AUTH_COOKIE + "" value = "" + str);
    }
    Cookie cookie = new Cookie(AUTH_COOKIE, str);

    cookie.setMaxAge(cookieMaxAge);
    if (cookieDomain != null) {
      cookie.setDomain(cookieDomain);
    }
    if (cookiePath != null) {
      cookie.setPath(cookiePath);
    }
    cookie.setSecure(isCookieSecure);
    return cookie;
  }"
1,"Generate httponly cookie from HS2 cookie
@param cookie HS2 generated cookie
@return The httponly cookie[SEP]private static String getHttpOnlyCookieHeader(Cookie cookie) {
    NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),
      cookie.getPath(), cookie.getDomain(), cookie.getVersion(),
      cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());
    return newCookie + ""; HttpOnly"";
  }"
1,"Copies all files from source to target and sets executable flag. Paths might be on different systems.
@param sourcePath source path to copy from
@param targetPath target path to copy to
@param executable if target file should be executable
@throws IOException if the copy fails[SEP]public static void copy(Path sourcePath, Path targetPath, boolean executable) throws IOException {
		// we unwrap the file system to get raw streams without safety net
		FileSystem sFS = FileSystem.getUnguardedFileSystem(sourcePath.toUri());
		FileSystem tFS = FileSystem.getUnguardedFileSystem(targetPath.toUri());
		if (!tFS.exists(targetPath)) {
			if (sFS.getFileStatus(sourcePath).isDir()) {
				internalCopyDirectory(sourcePath, targetPath, executable, sFS, tFS);
			} else {
				internalCopyFile(sourcePath, targetPath, executable, sFS, tFS);
			}
		}
	}"
1,"Saves the configuration info to the disk.[SEP]public synchronized void save() {
        if (BulkChange.contains(this)) {
            return;
        }
        
        File file = getConfigFile();
        try {
            List<String> allSignatures = new ArrayList<>(whitelistSignaturesFromUserControlledList);
            blacklistSignaturesFromUserControlledList.stream()
                    .map(signature -> ""!"" + signature)
                    .forEach(allSignatures::add);
            
            FileUtils.writeLines(file, allSignatures);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, ""Failed to save "" + file.getAbsolutePath(), e);
        }
    }"
0,"Randomize server list using local IPv4 address hash as a seed.

@return a copy of the original list with elements in the random order[SEP]public static <T extends EurekaEndpoint> List<T> randomize(List<T> list) {
        List<T> randomList = new ArrayList<>(list);
        if (randomList.size() < 2) {
            return randomList;
        }
        Random random = new Random(LOCAL_IPV4_ADDRESS.hashCode());
        int last = randomList.size() - 1;
        for (int i = 0; i < last; i++) {
            int pos = random.nextInt(randomList.size() - i);
            if (pos != i) {
                Collections.swap(randomList, i, pos);
            }
        }
        return randomList;
    }"
1,"Decompress an input stream from a file, based on the filename.[SEP]public static InputStream decompress(final InputStream in, final String fileName) throws IOException
  {
    if (fileName.endsWith(GZ_SUFFIX)) {
      return gzipInputStream(in);
    } else if (fileName.endsWith(BZ2_SUFFIX)) {
      return new BZip2CompressorInputStream(in, true);
    } else if (fileName.endsWith(XZ_SUFFIX)) {
      return new XZCompressorInputStream(in, true);
    } else if (fileName.endsWith(SNAPPY_SUFFIX)) {
      return new FramedSnappyCompressorInputStream(in);
    } else if (fileName.endsWith(ZSTD_SUFFIX)) {
      return new ZstdCompressorInputStream(in);
    } else if (fileName.endsWith(ZIP_SUFFIX)) {
      // This reads the first file in the archive.
      final ZipInputStream zipIn = new ZipInputStream(in, StandardCharsets.UTF_8);
      try {
        final ZipEntry nextEntry = zipIn.getNextEntry();
        if (nextEntry == null) {
          zipIn.close();

          // No files in the archive - return an empty stream.
          return new ByteArrayInputStream(new byte[0]);
        }
        return zipIn;
      }
      catch (IOException e) {
        try {
          zipIn.close();
        }
        catch (IOException e2) {
          e.addSuppressed(e2);
        }
        throw e;
      }
    } else {
      return in;
    }
  }"
0,"Save distribution statistics to the file system

@param meanFile file to contain the means
@param stdFile  file to contain the standard deviations[SEP]public void save(@NonNull File meanFile, @NonNull File stdFile) throws IOException {
        Nd4j.saveBinary(getMean(), meanFile);
        Nd4j.saveBinary(getStd(), stdFile);
    }"
0,"Score the given multi layer network
@param model the model to score
@param testSet the test set
@param regressionValue the regression function to use
@return the score from the given test set[SEP]public static double score(MultiLayerNetwork model, DataSetIterator testSet, RegressionValue regressionValue) {
        RegressionEvaluation eval = model.evaluateRegression(testSet);
        return getScoreFromRegressionEval(eval, regressionValue);
    }"
1,"This method takes a string as input reverses it and returns the result

@param in the string to be reversed
@return the reversed string[SEP]private static String reverseString(String in) {
        StringBuilder out = new StringBuilder(in).reverse();
        return out.toString();
    }"
1,"Parse the command line entry.
@param cl commandLine
@param args args passed in
@return commandLine[SEP]CommandLine parse(DefaultCommandLine cl, String[] args) {
        parseInternal(cl, args, true);
        return cl;
    }"
1,"Returns normalized score, with 0.0 meaning no similarity at all,
and 1.0 meaning full equality.[SEP]public static double similarity(String s1, String s2) {
    if (s1.equals(s2))
      return 1.0;

    // ensure that s1 is shorter than or same length as s2
    if (s1.length() > s2.length()) {
      String tmp = s2;
      s2 = s1;
      s1 = tmp;
    }
    /*
     * this list of Boolean values is used for avoiding duplicated count of
     * common characters in S2
     */
    List<Boolean> isCommonCharInS2 = new ArrayList<Boolean>();
    for (int i=0; i<s2.length(); i++) {
      isCommonCharInS2.add(false);
    }

    // (1) find the number of characters the two strings have in common.
    // note that matching characters can only be half the length of the
    // longer string apart.
    int maxdist = (int) Math.floor(s2.length() / 2) ;
    int c = 0; // count of common characters
    int t = 0; // count of transpositions
    int prevpos = -1;
    for (int ix = 0; ix < s1.length(); ix++) {
      char ch = s1.charAt(ix);

      // now try to find it in s2
      for (int ix2 = Math.max(0, ix - maxdist);
           ix2 < Math.min(s2.length(), ix + maxdist);
           ix2++) {
        if (ch == s2.charAt(ix2) && !isCommonCharInS2.get(ix2)) {
          c++; // we found a common character
          isCommonCharInS2.set(ix2, true);
          if (prevpos != -1 && ix2 < prevpos)
            t++; // moved back before earlier
          prevpos = ix2;
          break;
        }
      }
    }

    // we don't divide t by 2 because as far as we can tell, the above
    // code counts transpositions directly.

    // System.out.println(""c: "" + c);
    // System.out.println(""t: "" + t);
    // System.out.println(""c/m: "" + (c / (double) s1.length()));
    // System.out.println(""c/n: "" + (c / (double) s2.length()));
    // System.out.println(""(c-t)/c: "" + ((c - t) / (double) c));

    // we might have to give up right here
    if (c == 0)
      return 0.0;

    // first compute the score
    double score = ((c / (double) s1.length()) +
            (c / (double) s2.length()) +
            ((c - t) / (double) c)) / 3.0;

    // (2) common prefix modification
    int p = 0; // length of prefix
    int last = Math.min(4, s1.length());
    for (; p < last && s1.charAt(p) == s2.charAt(p); p++)
      ;

    score = score + ((p * (1 - score)) / 10);

    // (3) longer string adjustment
    // I'm confused about this part. Winkler's original source code includes
    // it, and Yancey's 2005 paper describes it. However, Winkler's list of
    // test cases in his 2006 paper does not include this modification. So
    // is this part of Jaro-Winkler, or is it not? Hard to say.
    //
    //   if (s1.length() >= 5 && // both strings at least 5 characters long
    //       c - p >= 2 && // at least two common characters besides prefix
    //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars
    //     {
    //     System.out.println(""ADJUSTED!"");
    //     score = score + ((1 - score) * ((c - (p + 1)) /
    //                                     ((double) ((s1.length() + s2.length())
    //                                                - (2 * (p - 1))))));
    // }

    // (4) similar characters adjustment
    // the same holds for this as for (3) above.

    return score;
  }"
0,"Filter the file rules

@param file
@param recursive
@return[SEP]private File[] accept(File file, final boolean recursive) {
        // Custom filtering rules If you can loop (include subdirectories) or is the end of the file. Class (compiled java class file)
        return file.listFiles(file1 -> (recursive && file1.isDirectory()) || (file1.getName().endsWith("".class"")));
    }"
1,"Replace HTML entities
@param content Content
@param map Map
@return Replaced content[SEP]public static String replaceHtmlEntities(String content, Map<String, Character> map) {
    
    for (Entry<String, Character> entry : escapeStrings.entrySet()) {
      
      if (content.indexOf(entry.getKey()) != -1) {
        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));
      }
      
    }
    
    return content;
  }"
0,"Sets the working directory.

@param dir The directory
@throws IOException If the directory does not exist or cannot be written/read[SEP]public void setWorkDir(String dir) throws IOException
    {
        File workDir = new File(dir);

        if (!workDir.exists() || !workDir.canWrite() || !workDir.canRead())
        {
            throw new IOException(""Cannot access directory ""+dir);
        }
        _workDir = workDir;
    }"
1,"A simpler form of command line argument parsing.
Dan thinks this is highly superior to the overly complexified code that
comes before it.
Parses command line arguments into a Map. Arguments of the form
-flag1 arg1 -flag2 -flag3 arg3
will be parsed so that the flag is a key in the Map (including the hyphen)
and the
optional argument will be its value (if present).

@return A Map from keys to possible values (String or null)[SEP]@SuppressWarnings(""unchecked"")
  public static Map<String, String> parseCommandLineArguments(String[] args) {
    return (Map)parseCommandLineArguments(args, false);
  }"
0,"Assuming that c has a total count < 1, returns a new Distribution using the counts in c as probabilities.
If c has a total count > 1, returns a normalized distribution with no remaining mass.[SEP]public static <E> Distribution<E> getDistributionFromPartiallySpecifiedCounter(Counter<E> c, int numKeys){
    Distribution<E> d;
    double total = c.totalCount();
    if (total >= 1.0){
      d = getDistribution(c);
      d.numberOfKeys = numKeys;
    } else {
      d = new Distribution<E>();
      d.numberOfKeys = numKeys;
      d.counter = c;
      d.reservedMass = 1.0 - total;
    }
    return d;
  }"
1,"Copy a file.

@param in input file.
@param out output file.
@throws IOException on error.[SEP]public final void fileCopy(File in, File out) throws IOException {
		assert in != null;
		assert out != null;
		getLog().debug(""Copying file: "" + in.toString() + "" into "" + out.toString()); //$NON-NLS-1$ //$NON-NLS-2$
		try (FileInputStream fis = new FileInputStream(in)) {
			try (FileChannel inChannel = fis.getChannel()) {
				try (FileOutputStream fos = new FileOutputStream(out)) {
					try (FileChannel outChannel = fos.getChannel()) {
						inChannel.transferTo(0, inChannel.size(), outChannel);
					}
				}
			}
		} finally {
			getBuildContext().refresh(out);
		}
	}"
0,"Check if there is a valid HTML tag here. This method also transforms auto
links and mailto auto links.

@param out
The StringBuilder to write to.
@param in
Input String.
@param nStart
Starting position.
@return The new position or -1 if nothing valid has been found.[SEP]private int _checkInlineHtml (final MarkdownHCStack out, final String in, final int nStart)
  {
    final StringBuilder aTmp = new StringBuilder ();

    // Check for auto links
    aTmp.setLength (0);
    int nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, ':', ' ', '>', '\n');
    if (nPos != -1 && in.charAt (nPos) == ':' && MarkdownHTML.isLinkPrefix (aTmp.toString ()))
    {
      nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');
      if (nPos != -1)
      {
        final String sLink = aTmp.toString ();
        final HCA aLink = m_aConfig.getDecorator ().openLink (out);
        aLink.setHref (new SimpleURL (sLink)).addChild (sLink);
        m_aConfig.getDecorator ().closeLink (out);
        return nPos;
      }
    }

    // Check for mailto or address auto link
    aTmp.setLength (0);
    nPos = MarkdownHelper.readUntil (aTmp, in, nStart + 1, '@', ' ', '>', '\n');
    if (nPos != -1 && in.charAt (nPos) == '@')
    {
      nPos = MarkdownHelper.readUntil (aTmp, in, nPos, '>');
      if (nPos != -1)
      {
        final String sLink = aTmp.toString ();
        final HCA aLink = m_aConfig.getDecorator ().openLink (out);
        if (sLink.startsWith (""@""))
        {
          // address auto links
          final String sAddress = sLink.substring (1);
          final ISimpleURL aUrl = new SimpleURL (""https://maps.google.com/maps"").add (""q"", sAddress);
          aLink.setHref (aUrl).addChild (sAddress);
        }
        else
        {
          // mailto auto links
          aLink.setHref (new SimpleURL (""mailto:"" + sLink)).addChild (sLink);
        }
        m_aConfig.getDecorator ().closeLink (out);
        return nPos;
      }
    }

    // Check for inline html
    if (nStart + 2 < in.length ())
    {
      nPos = nStart;
      if (nStart + 3 < in.length () &&
          in.charAt (nStart + 1) == '!' &&
          in.charAt (nStart + 2) == '-' &&
          in.charAt (nStart + 3) == '-')
      {
        nPos = nStart + 4;
        final int nCommentStartPos = nPos;
        while (true)
        {
          while (nPos < in.length () && in.charAt (nPos) != '-')
            nPos++;

          if (nPos == in.length ())
          {
            // FIXME End of line in comment
            return -1;
          }
          if (nPos + 2 < in.length () && in.charAt (nPos + 1) == '-' && in.charAt (nPos + 2) == '>')
          {
            // XML comment inline
            out.append (new HCCommentNode (in.substring (nCommentStartPos, nPos)));
            return nPos + 2;
          }
          nPos++;
        }
      }

      aTmp.setLength (0);
      final int nNewPos = MarkdownHelper.readXMLElement (aTmp, in, nStart, m_aConfig.isSafeMode ());
      if (nNewPos != -1)
      {
        final String sElement = aTmp.toString ();
        if (sElement.endsWith (""/>""))
        {
          // Self closed tag - can be parsed
          final IMicroDocument aXML = MicroReader.readMicroXML (sElement);
          if (aXML == null)
            throw new MarkdownException (""Failed to parse XML: "" + sElement);
          // And use the root element
          out.append (new HCDOMWrapper (aXML.getDocumentElement ().detachFromParent ()));
        }
        else
          if (sElement.startsWith (""</""))
          {
            // Closing tag
            out.pop ();
          }
          else
          {
            // Opening tag - parse as self-closed tag and push to stack
            final String sParseCode = sElement.substring (0, sElement.length () - 1) + ""/>"";
            final IMicroDocument aXML = MicroReader.readMicroXML (sParseCode);
            if (aXML == null)
              throw new MarkdownException (""Failed to parse XML: "" + sParseCode);
            final IMicroElement eRoot = aXML.getDocumentElement ();

            // And use the root element
            final IHCElement <?> aHC = HCExtHelper.createHCElementFromName (eRoot.getTagName ());
            if (aHC == null)
              throw new MarkdownException (""Failed to get HC element: "" + eRoot.getTagName ());

            // Clone all attributes
            eRoot.forAllAttributes (aAttr -> aHC.customAttrs ().putIn (aAttr.getAttributeQName (),
                                                                       aAttr.getAttributeValue ()));

            if (aHC.getElement ().mayBeSelfClosed ())
            {
              // e.g. <hr />
              out.append (aHC);
            }
            else
            {
              // Push
              out.push (aHC);
            }
          }

        return nNewPos - 1;
      }
    }

    return -1;
  }"
0,"<p>getBodyHtml.</p>

@return a {@link java.lang.String} object.[SEP]@HtmlSafe
	public String getBodyHtml()
	{
		String body = execution.getResults().trim();

		return body.replaceAll(""<html>"", """").replaceAll(""</html>"", """");
	}"
1,"Filters the elements in the array.

@param <T> Class type of the elements in the array.
@param array array to filter.
@param filter {@link Filter} used to filter the array elements.
@return a new array of the array class component type containing only elements from the given array
accepted by the {@link Filter}.
@throws IllegalArgumentException if either the array or {@link Filter} are null.
@see #filterAndTransform(Object[], FilteringTransformer)
@see org.cp.elements.lang.Filter[SEP]@SuppressWarnings(""unchecked"")
  public static <T> T[] filter(T[] array, Filter<T> filter) {

    Assert.notNull(array, ""Array is required"");
    Assert.notNull(filter, ""Filter is required"");

    List<T> arrayList = stream(array).filter(filter::accept).collect(Collectors.toList());

    return arrayList.toArray((T[]) Array.newInstance(array.getClass().getComponentType(), arrayList.size()));
  }"
0,"Finds next match and returns the matched string
@param in
@param size
@return Matched string
@throws IOException
@throws SyntaxErrorException[SEP]public String find(PushbackReader in, int size) throws IOException, SyntaxErrorException
    {
        if (acceptEmpty)
        {
            throw new IllegalArgumentException(""using find for  '"" + expression + ""'  that accepts empty string"");
        }
        InputReader reader = Input.getInstance(in, size);
        int rc = find(reader);
        reader.release();
        if (rc == 1)
        {
            return reader.getString();
        }
        else
        {
            throw new SyntaxErrorException(""string matching  '"" + expression + ""'  not found"");
        }
    }"
1,"This method will concatenate one or more files
@param files files to concatenate
@param concatenatedFile concatenated output file[SEP]public static void concatenate(List<File> files, File concatenatedFile) {

        BufferedWriter writer;
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(concatenatedFile.getAbsoluteFile(),
                    false), DataUtilDefaults.charSet));

            FileInputStream inputStream;
            for(File input : files) {
                inputStream = new FileInputStream(input);
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, ""UTF-8""));
                String line;
                while((line = reader.readLine()) != null) {
                    writer.write(line + DataUtilDefaults.lineTerminator);
                }
                inputStream.close();
            }
            writer.flush();
            writer.close();
        } catch (UnsupportedEncodingException e) {
            throw new DataUtilException(e);
        } catch (FileNotFoundException e) {
            throw new DataUtilException(e);
        } catch (IOException e) {
            throw new DataUtilException(e);
        }
    }"
0,"Encode the special characters in the string to its URL encoded representation.
@param str The string to encode
@return The encoded string[SEP]public static String urlEncode(String str)
    {
        String ret = str;

        try 
        {
            ret = URLEncoder.encode(str, ""UTF-8"");
        } 
        catch (UnsupportedEncodingException e) 
        {
            logger.severe(""Failed to encode value: ""+str);
        }

        return ret;
    }"
1,"Returns the beginning of the given day. <br/>
e.g: '2012-12-21 21:21:21' => '2012-12-21 00:00:00'

@param date date to be handled.
@return a new date is beginning of the given day.
@throws DateException[SEP]public static Date formatToStartOfDay(final Date date) {

    try {
      SimpleDateFormat dateFormat = buildDateFormat(DEFAULT_DATE_SIMPLE_PATTERN);
      String formattedDate = dateFormat.format(date);
      return dateFormat.parse(formattedDate);
    } catch (ParseException pe) {
      throw new DateException(""Unparseable date specified."", pe);
    }
  }"
0,"Use Jackson to convert Map to JSON string.

@param map Map to convert to json
@return json string
@throws MovieDbException exception[SEP]private String convertToJson(Map<String, ?> map) throws MovieDbException {
        try {
            return MAPPER.writeValueAsString(map);
        } catch (JsonProcessingException ex) {
            throw new MovieDbException(ApiExceptionType.MAPPING_FAILED, ""JSON conversion failed"", """", ex);
        }
    }"
0,"Returns the EncryptionMode object matching the String.

@param encryptionMode encryption mode

@return EncryptionMode object corresponding to encryption mode. Null if does not correspond to any mode.[SEP]public static EncryptionMode getEncryptionModeCipher(String encryptionMode) {
	if (encryptionMode==null) {
		return null;
	}
	switch (encryptionMode) {
		case ""agile"": return EncryptionMode.agile;
		case ""binaryRC4"": return EncryptionMode.binaryRC4;
		case ""cryptoAPI"": return EncryptionMode.cryptoAPI;
		case ""standard"": return EncryptionMode.standard;
		default:
			LOG.error(""Uknown enncryption mode \""""+encryptionMode+""\"""");
			break;
		//case ""xor"": return EncryptionMode.xor; // does not seem to be supported anymore
	}
	return null;
}"
1,"Gets the total elapsed time measured by the current instance, in nanoseconds.
1 Tick = 100 nanoseconds[SEP]public long getElapsedTicks() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerTick;
	}"
1,"Gets the total elapsed time measured by the current instance, in seconds.
10000000 Ticks = 1 second (1000 milliseconds)[SEP]public long getElapsedSeconds() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerSs;
	}"
1,"Gets the total elapsed time measured by the current instance, in minutes.
600000000 Ticks = 1 minute (60 seconds)[SEP]public long getElapsedMinutes() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerMm;
	}"
1,"Gets the total elapsed time measured by the current instance, in hours.
36000000000 Ticks = 1 hour (60 minutes)[SEP]public long getElapsedHours() {
		long elapsed;
		if (running) {
			elapsed = (System.nanoTime() - startTime);
		} else {
			elapsed = (stopTime - startTime);
		}
		return elapsed / nsPerHh;
	}"
1,"Extract the zipped ANNIS corpus files to an output directory.

@param outDir The ouput directory.
@param zip ZIP-file to extract.
@return A list of root directories where the tab-files are located if
found, null otherwise.[SEP]private List<File> unzipCorpus(File outDir, ZipFile zip)
  {
    List<File> rootDirs = new ArrayList<>();

    Enumeration<? extends ZipEntry> zipEnum = zip.entries();
    while (zipEnum.hasMoreElements())
    {
      ZipEntry e = zipEnum.nextElement();
      File outFile = new File(outDir, e.getName().replaceAll(""\\/"", ""/""));

      if (e.isDirectory())
      {
        if (!outFile.mkdirs())
        {
          log.warn(""Could not create output directory "" + outFile.
            getAbsolutePath());
        }
      } // end if directory
      else
      {
        if (""corpus.tab"".equals(outFile.getName()) || ""corpus.annis"".equals(
          outFile.getName()))
        {
          rootDirs.add(outFile.getParentFile());
        }

        if (!outFile.getParentFile().isDirectory())
        {
          if (!outFile.getParentFile().mkdirs())
          {
            {
              log.warn(
                ""Could not create output directory for file "" + outFile.
                getAbsolutePath());
            }
          }
        }
        try (FileOutputStream outStream = new FileOutputStream(outFile);)
        {

          ByteStreams.copy(zip.getInputStream(e), outStream);
        }
        catch (FileNotFoundException ex)
        {
          log.error(null, ex);
        }
        catch (IOException ex)
        {
          log.error(null, ex);
        }
      } // end else is file
    } // end for each entry in zip file

    return rootDirs;
  }"
1,"Connect to JDBC secured/not secured database

@param database database connection string
@param host     database host
@param port     database port
@param user     database user
@param password database password
@param ca       trusted certificate authorities (.crt)
@param crt:     server certificate
@param key:     server private key
@throws Exception exception     *[SEP]public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {

        if (port.startsWith(""["")) {
            port = port.substring(1, port.length() - 1);
        }
        if (!secure) {
            if (password == null) {
                password = ""stratio"";
            }
            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, user, password);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        } else {
            Properties props = new Properties();
            if (user != null) {
                props.setProperty(""user"", user);
            }
            if (ca != null) {
                props.setProperty(""sslrootcert"", ca);
            }
            if (crt != null) {
                props.setProperty(""sslcert"", crt);
            }
            if (key != null) {
                props.setProperty(""sslkey"", key);
            }
            props.setProperty(""password"", ""null"");
            props.setProperty(""ssl"", ""true"");
            props.setProperty(""sslmode"", ""verify-full"");


            try {
                myConnection = DriverManager.getConnection(""jdbc:postgresql://"" + host + "":"" + port + ""/"" + database, props);
            } catch (SQLException se) {
                // log the exception
                this.getLogger().error(se.getMessage());
                // re-throw the exception
                throw se;
            }

        }
    }"
1,"Get the current text from the clipboard.

@return Clipboard text or {@code null} if clipboard is empty or unavailable.[SEP]public static String getClipboardText(final Context context) {
        final ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        final ClipData clipData = clipboard.getPrimaryClip();
        if(clipData != null && clipData.getItemCount() > 0) {
            final CharSequence clipboardText = clipData.getItemAt(0).getText();
            if(clipboardText != null) {
                return clipboardText.toString();
            }
        }
        return null;
    }"
1,"Accept socket connection. May be overriden by derived class to create specialist
serversockets (eg SSL).

@param serverSocket
@param timeout The time to wait for a connection. Normally passed the ThreadPool maxIdleTime.
@return Accepted Socket[SEP]protected Socket acceptSocket(int timeout)
    {
        try
        {
            Socket s = null;

            if (_listen != null)
            {
                if (_soTimeOut != timeout)
                {
                    _soTimeOut = timeout;
                    _listen.setSoTimeout(_soTimeOut);
                }

                s = _listen.accept();

                try
                {
                    if (getMaxIdleTimeMs() >= 0) s.setSoTimeout(getMaxIdleTimeMs());
                    if (_lingerTimeSecs >= 0)
                        s.setSoLinger(true, _lingerTimeSecs);
                    else
                        s.setSoLinger(false, 0);
                }
                catch (Exception e)
                {
                    LogSupport.ignore(log, e);
                }
            }
            return s;
        }
        catch (java.net.SocketException e)
        {
            // TODO - this is caught and ignored due strange
            // exception from linux java1.2.v1a
            LogSupport.ignore(log, e);
        }
        catch (InterruptedIOException e)
        {
            LogSupport.ignore(log, e);
        }
        catch (IOException e)
        {
            log.warn(LogSupport.EXCEPTION, e);
        }
        return null;
    }"
1,"Get an InputStream for the decompressed file.

@return An InputStream, the type could be BZip2CompressorInputStream, or GzipCompressorInputStream depending on what type of file was initially supplied
@throws IOException IOException[SEP]InputStream getInputStream() throws IOException {
        switch (filetype) {
            case GZ:
                LOG.debug(""Decompressing .gz file"");
                return new GzipCompressorInputStream(new FileInputStream(compressedFile));
            case BZ2:
                LOG.debug(""Decompressing .bz2 file"");
                return new BZip2CompressorInputStream(new FileInputStream(compressedFile));
        }
        return null;
    }"
1,"Create transferable topic list in system clipboard.

@param cut true shows that remove topics after placing into clipboard
@param topics topics to be placed into clipboard, if there are successors
and ancestors then successors will be removed
@return true if topic array is not empty and operation completed
successfully, false otherwise
@since 1.3.1[SEP]public boolean copyTopicsToClipboard(final boolean cut, @Nonnull @MustNotContainNull final Topic... topics) {
    boolean result = false;

    if (this.lockIfNotDisposed()) {
      try {
        if (topics.length > 0) {
          final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
          clipboard.setContents(new MMDTopicsTransferable(topics), this);

          if (cut) {
            deleteTopics(true, ensureNoRootInArray(topics));
          }

          result = true;
        }
      } finally {
        this.unlock();
      }
    }

    return result;
  }"
0,"<p>Defensive programming technique to change a <code>null</code>
reference to an empty one.</p>
<p>
<p>This method returns an empty array for a <code>null</code> input array.</p>
<p>
<p>As a memory optimizing technique an empty array passed in will be overridden with
the empty <code>public static</code> references in this class.</p>

@param array the array to check for <code>null</code> or empty
@return the same array, <code>public static</code> empty array if <code>null</code> or empty input
@since 2.5[SEP]public static Long[] nullToEmpty(Long[] array) {
        if (array == null || array.length == 0) {
            return EMPTY_LONG_OBJECT_ARRAY;
        }
        return array;
    }"
0,"<p>Defensive programming technique to change a <code>null</code>
reference to an empty one.</p>
<p>
<p>This method returns an empty array for a <code>null</code> input array.</p>
<p>
<p>As a memory optimizing technique an empty array passed in will be overridden with
the empty <code>public static</code> references in this class.</p>

@param array the array to check for <code>null</code> or empty
@return the same array, <code>public static</code> empty array if <code>null</code> or empty input
@since 2.5[SEP]public static Double[] nullToEmpty(Double[] array) {
        if (array == null || array.length == 0) {
            return EMPTY_DOUBLE_OBJECT_ARRAY;
        }
        return array;
    }"
1,"state machine extracts <body> tag content[SEP]private void extract(String htmlDoc) {

    //now extract the contents of <body>...
    int bodyStart = htmlDoc.indexOf(BODY_BEGIN) + BODY_BEGIN.length();

    //scan for end of the <body> start tag (beginning of body content)
    char quote = NOT_IN_QUOTE;
    for (int body = bodyStart; body < htmlDoc.length(); body++) {
      final char c = htmlDoc.charAt(body);
      if (isQuoteChar(c)) {
        if (quote == NOT_IN_QUOTE)
          quote = c;
        else if (quote == c)
          quote = NOT_IN_QUOTE;
      }

      if ('>' == c && NOT_IN_QUOTE == quote) {
        bodyStart = body + 1;
        break;
      }
    }

    int bodyEnd = htmlDoc.indexOf(BODY_END, bodyStart);

    //if there was no body tag, just embed whatever was rendered directly
    if (-1 == bodyEnd) {
      EmbeddedRespond.this.body = htmlDoc;
    } else
      EmbeddedRespond.this.body = htmlDoc.substring(bodyStart, bodyEnd);
  }"
1,"Convenient method for POSTing json strings. It is the responsibility of the
caller to call returnClient() to ensure clean state of the pool.
@param url
@param json
@param reqHeaders
@return
@throws IOException[SEP]public CloseableHttpResponse postJson(String url, String json, Map<String, String> reqHeaders) throws IOException {
        CloseableHttpClient req = getClient();
        CloseableHttpResponse resp = null;
        HttpPost post = new HttpPost(url);
        addHeaders(post, reqHeaders);
        post.setHeader(json, url);
        StringEntity input = new StringEntity(json, ContentType.APPLICATION_JSON);
        post.setEntity(input);
        resp = req.execute(post);
        return resp;
    }"
0,"Converts {@code file} into an HTML string.[SEP]public Result<String> convertToHtml(File file) throws IOException {
        return new InternalDocumentConverter(options).convertToHtml(file).toResult();
    }"
0,"Extract the raw text of the document.
This will ignore all formatting in the document.
Each paragraph is followed by two newlines.[SEP]public Result<String> extractRawText(File file) throws IOException {
        return new InternalDocumentConverter(options).extractRawText(file).toResult();
    }"
0,"Return the decimal part of the value.
@param val[SEP]public static BigDecimal decimalPart(final BigDecimal val) {
        return BigDecimalUtil.subtract(val, val.setScale(0, BigDecimal.ROUND_DOWN));
    }"
1,"Returns new array which contains only those elements from given {@code array}
which are selected by the {@code filter}

@param array the array to be filtered
@param filter filter to use

@return filtered array[SEP]public static <T> T[] filter(T array[], Filter<T> filter){
        List<T> filteredList = new ArrayList<T>(array.length);
        for(T element: array){
            if(filter.select(element))
                filteredList.add(element);
        }
        @SuppressWarnings(""unchecked"")
        T filteredArray[] = (T[])Array.newInstance(array.getClass().getComponentType(), filteredList.size());
        return filteredList.toArray(filteredArray);
    }"
1,"Checks a checkbox type element (value corresponding to key ""valueKey"").

@param element
Target page element
@param valueKeyOrKey
is valueKey (valueKey or key in context (after a save)) to match in values map
@param values
Values map
@throws TechnicalException
is thrown if you have a technical error (format, configuration, datas, ...) in NoraUi.
Failure with {@value com.github.noraui.utils.Messages#FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT} message (with screenshot)
@throws FailureException
if the scenario encounters a functional error[SEP]protected void selectCheckbox(PageElement element, String valueKeyOrKey, Map<String, Boolean> values) throws TechnicalException, FailureException {
        final String valueKey = Context.getValue(valueKeyOrKey) != null ? Context.getValue(valueKeyOrKey) : valueKeyOrKey;
        try {
            final WebElement webElement = Context.waitUntil(ExpectedConditions.elementToBeClickable(Utilities.getLocator(element)));
            Boolean checkboxValue = values.get(valueKey);
            if (checkboxValue == null) {
                checkboxValue = values.get(""Default"");
            }
            if (webElement.isSelected() != checkboxValue.booleanValue()) {
                webElement.click();
            }
        } catch (final Exception e) {
            new Result.Failure<>(e.getMessage(), Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT), element, element.getPage().getApplication()), true,
                    element.getPage().getCallBack());
        }
    }"
0,"}[SEP]public static byte[] build(String className, String superName) {
		ByteBuffer bb = ByteBuffer.allocate(1000);
		bb.put(BA0_1);
		
		//bb.put(BA2);
		writeUtf8(bb, convertDots(className));
		
		bb.put(BA3);
		
		//bb.put(BA4);
		writeUtf8(bb, convertDots(superName));
		
		bb.put(BA5_12);
		
		//bb.put(BA13);
		writeUtf8(bb, ""L"" + convertDots(className) + "";"");
		
		bb.put(BA14);
		
		//bb.put(BA15);
		String fName = convertDots(className);
		fName = fName.substring(fName.lastIndexOf('/') + 1);
		fName += "".java"";
		writeUtf8(bb, fName);
		
		bb.put(BA_end);
		
		byte[] ba = new byte[bb.position()];
		bb.rewind();
		bb.get(ba);
		return ba;
	}"
0,"Convert EARL result into HTML report.

@param outputDir
Location of the test result.
@return
Return the output file.
@throws FileNotFoundException
Throws exception if file is not available.[SEP]public static File earlHtmlReport( String outputDir )
                    throws FileNotFoundException {

        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        String resourceDir = cl.getResource( ""com/occamlab/te/earl/lib"" ).getPath();
        String earlXsl = cl.getResource( ""com/occamlab/te/earl_html_report.xsl"" ).toString();

        File htmlOutput = new File( outputDir, ""result"" );
        htmlOutput.mkdir();
        LOGR.fine( ""HTML output is written to directory "" + htmlOutput );
        File earlResult = new File( outputDir, ""earl-results.rdf"" );

        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            Transformer transformer = tf.newTransformer( new StreamSource( earlXsl ) );
            transformer.setParameter( ""outputDir"", htmlOutput );
            File indexHtml = new File( htmlOutput, ""index.html"" );
            indexHtml.createNewFile();
            FileOutputStream outputStream = new FileOutputStream( indexHtml );
            transformer.transform( new StreamSource( earlResult ), new StreamResult( outputStream ) );
            // Foritfy Mod: Close the outputStream releasing its resources
            outputStream.close();
            FileUtils.copyDirectory( new File( resourceDir ), htmlOutput );
        } catch ( Exception e ) {
            LOGR.log( Level.SEVERE, ""Transformation of EARL to HTML failed."", e );
            throw new RuntimeException( e );
        }
        if ( !htmlOutput.exists() ) {
            throw new FileNotFoundException( ""HTML results not found at "" + htmlOutput.getAbsolutePath() );
        }
        return htmlOutput;
    }"
0,"Check if the file is binary or not[SEP]private boolean isBinary() {
        try (InputStream in = getInputStream()) {
            long size = Files.size(file.toPath());
            if (size == 0) {
                // Empty file, so no need to check
                return true;
            }

            byte[] b = new byte[( size < StreamUtils.DEFAULT_PROBE_SIZE ? (int)size : StreamUtils.DEFAULT_PROBE_SIZE)];
            int read = in.read(b);
            if (read != b.length) {
                // Something went wrong, so better not to read line by line
                return true;
            }

            return StreamUtils.isNonWhitespaceControlCharacter(b);
        } catch (IOException e) {
            // If cannot be checked, then considered as binary, so we do not
            // read line by line
            return true;
        }
    }"
1,"Gets the current date in HTTP format.

@return Current date in HTTP format[SEP]public static String getCurrentDate() {
		long now = System.currentTimeMillis();

		if ((now - currentDateGenerated) > 1000) {
			synchronized (format) {
				if ((now - currentDateGenerated) > 1000) {
					currentDateGenerated = now;
					currentDate = format.format(new Date(now));
				}
			}
		}

		return currentDate;
	}"
1,"Splits a string in several parts (tokens) that are separated by delimiter.
Delimiter is <b>always</b> surrounded by two strings! If there is no
content between two delimiters, empty string will be returned for that
token. Therefore, the length of the returned array will always be:
#delimiters + 1.
<p>
Method is much, much faster then regexp <code>String.split()</code>,
and a bit faster then <code>StringTokenizer</code>.

@param src       string to split
@param delimiter split delimiter

@return array of split strings[SEP]public static String[] split(final String src, final String delimiter) {
		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last
		int[] positions = new int[maxparts];
		int dellen = delimiter.length();

		int i, j = 0;
		int count = 0;
		positions[0] = - dellen;
		while ((i = src.indexOf(delimiter, j)) != -1) {
			count++;
			positions[count] = i;
			j = i + dellen;
		}
		count++;
		positions[count] = src.length();

		String[] result = new String[count];

		for (i = 0; i < count; i++) {
			result[i] = src.substring(positions[i] + dellen, positions[i + 1]);
		}
		return result;
	}"
1,"Reverse a string.[SEP]public static String reverse(final String s) {
		StringBuilder result = new StringBuilder(s.length());
		for (int i = s.length() -1; i >= 0; i--) {
			result.append(s.charAt(i));
		}
		return result.toString();
	}"
0,"Save persistent state.[SEP]public void save() {
    if (catListBox != null) catListBox.save();

    if (prefs != null) {
      if (fileChooser != null)
        fileChooser.save();
      if (catgenFileChooser != null)
        catgenFileChooser.save();
      prefs.putInt(HDIVIDER, split.getDividerLocation());
    }
  }"
1,"/*
14.1
<BC_TableB_BUFR14_1_0_CREX_6_1_0>
<SNo>1</SNo>
<Class>00</Class>
<FXY>000001</FXY>
<ElementName_E>Table A: entry</ElementName_E>
<ElementName_F>Table A : entr?e</ElementName_F>
<ElementName_R>??????? ?: ???????</ElementName_R>
<ElementName_S>Tabla A: elemento</ElementName_S>
<BUFR_Unit>CCITT IA5</BUFR_Unit>
<BUFR_Scale>0</BUFR_Scale>
<BUFR_ReferenceValue>0</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>24</BUFR_DataWidth_Bits>
<CREX_Unit>Character</CREX_Unit>
<CREX_Scale>0</CREX_Scale>
<CREX_DataWidth>3</CREX_DataWidth>
<Status>Operational</Status>
<NotesToTable_E>Notes: (see)#BUFR14_1_0_CREX6_1_0_Notes.doc#BC_Cl000</NotesToTable_E>
</BC_TableB_BUFR14_1_0_CREX_6_1_0>

14.2
<Exporting_BCTableB_E>
<No>2</No>
<ClassNo>00</ClassNo>
<ClassName>BUFR/CREX table entries</ClassName>
<FXY>000002</FXY>
<ElementName>Table A: data category description, line 1 </ElementName>
<BUFR_Unit>CCITT IA5 </BUFR_Unit>
<BUFR_Scale>0</BUFR_Scale>
<BUFR_ReferenceValue>0</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>256</BUFR_DataWidth_Bits>
<CREX_Unit>Character</CREX_Unit>
<CREX_Scale>0</CREX_Scale>
<CREX_DataWidth>32</CREX_DataWidth>
<Status>Operational</Status>
</Exporting_BCTableB_E>

15.1
<Exp_JointTableB_E>
<No>1</No>
<ClassNo>00</ClassNo>
<ClassName_E>BUFR/CREX table entries</ClassName_E>
<FXY>000001</FXY>
<ElementName_E>Table A: entry</ElementName_E>
<BUFR_Unit>CCITT IA5</BUFR_Unit>
<BUFR_Scale>0</BUFR_Scale>
<BUFR_ReferenceValue>0</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>24</BUFR_DataWidth_Bits>
<CREX_Unit>Character</CREX_Unit>
<CREX_Scale>0</CREX_Scale>
<CREX_DataWidth_Char>3</CREX_DataWidth_Char>
<Status>Operational</Status>
</Exp_JointTableB_E>

16.0
<Exp_BUFRCREXTableB_E>
<No>681</No>
<ClassNo>13</ClassNo>
<ClassName_E>Hydrographic and hydrological elements</ClassName_E>
<FXY>013060</FXY>
<ElementName_E>Total accumulated precipitation</ElementName_E>
<BUFR_Unit>kg m-2</BUFR_Unit>
<BUFR_Scale>1</BUFR_Scale>
<BUFR_ReferenceValue>-1</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>17</BUFR_DataWidth_Bits>
<CREX_Unit>kg m-2</CREX_Unit>
<CREX_Scale>1</CREX_Scale>
<CREX_DataWidth_Char>5</CREX_DataWidth_Char>
<Status>Operational</Status>
</Exp_BUFRCREXTableB_E>

<BUFRCREX_17_0_0_TableB_en>
<No>8</No>
<ClassNo>00</ClassNo>
<ClassName_en>BUFR/CREX table entries</ClassName_en>
<FXY>000008</FXY>
<ElementName_en>BUFR Local table version number</ElementName_en>
<Note_en>(see Note 4)</Note_en>
<BUFR_Unit>CCITT IA5</BUFR_Unit>
<BUFR_Scale>0</BUFR_Scale>
<BUFR_ReferenceValue>0</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>16</BUFR_DataWidth_Bits>
<CREX_Unit>Character</CREX_Unit>
<CREX_Scale>0</CREX_Scale>
<CREX_DataWidth_Char>2</CREX_DataWidth_Char>
<Status>Operational</Status>
</BUFRCREX_17_0_0_TableB_en>

<BUFRCREX_22_0_1_TableB_en>
<No>1018</No>
<ClassNo>21</ClassNo>
<ClassName_en>BUFR/CREX Radar data</ClassName_en>
<FXY>021073</FXY>
<ElementName_en>Satellite altimeter instrument mode</ElementName_en>
<BUFR_Unit>Flag table</BUFR_Unit>
<BUFR_Scale>0</BUFR_Scale>
<BUFR_ReferenceValue>0</BUFR_ReferenceValue>
<BUFR_DataWidth_Bits>9</BUFR_DataWidth_Bits>
<CREX_Unit>Flag table</CREX_Unit>
<CREX_Scale>0</CREX_Scale>
<CREX_DataWidth_Char>3</CREX_DataWidth_Char>
<Status>Operational</Status>
</BUFRCREX_22_0_1_TableB_en>[SEP]static void readWmoXmlTableB(InputStream ios, TableB b) throws IOException {
    org.jdom2.Document doc;
    try {
      SAXBuilder builder = new SAXBuilder();
      doc = builder.build(ios);
    } catch (JDOMException e) {
      throw new IOException(e.getMessage());
    }

    Element root = doc.getRootElement();

    String[] elems = null;
    for (Version v : Version.values()) {
      elems = v.getElemNamesB();
      List<Element> featList = root.getChildren(elems[0]);
      if (featList != null && featList.size() > 0) {
        break;
      }
    }

    // if not found using element name, assume its BUFR_WMO
    if (elems == null) {
      elems = Version.BUFR_WMO.getElemNamesB();
    }

    List<Element> featList = root.getChildren();
    for (Element elem : featList) {
      Element ce = elem.getChild(elems[1]);
      if (ce == null) continue;

      String name = Util.cleanName(elem.getChildTextNormalize(elems[1]));
      String units = cleanUnit(elem.getChildTextNormalize(""BUFR_Unit""));
      int x = 0, y = 0, scale = 0, reference = 0, width = 0;

      String fxy = null;
      String s = null;
      try {
        fxy = elem.getChildTextNormalize(""FXY"");
        int xy = Integer.parseInt(cleanNumber(fxy));
        x = xy / 1000;
        y = xy % 1000;

      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' fails parsing %n"", fxy, name);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_Scale"");
        scale = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad scale='%s'%n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_ReferenceValue"");
        reference = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad reference='%s' %n"", fxy, name, s);
      }

      try {
        s = elem.getChildTextNormalize(""BUFR_DataWidth_Bits"");
        width = Integer.parseInt(cleanNumber(s));
      } catch (NumberFormatException e) {
        System.out.printf("" key %s name '%s' has bad width='%s' %n"", fxy, name, s);
      }

      b.addDescriptor((short) x, (short) y, scale, reference, width, name, units, null);
    }
    ios.close();
  }"
0,"Loop through the filters in the list. As soon as a filter decides on
ACCEPT or DENY, then that value is returned. If all of the filters return
NEUTRAL, then NEUTRAL is returned.[SEP]public FilterReply getFilterChainDecision(E event) {
    final Filter<E>[] filterArrray = filterList.asTypedArray();
    final int len = filterArrray.length;

    for (int i = 0; i < len; i++) {
      final FilterReply r = filterArrray[i].decide(event);
      if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {
        return r;
      }
    }

    // no decision
    return FilterReply.NEUTRAL;
  }"
0,"Extracts the file with name <code>fileName</code> out of the
<code>containingJar</code> archive and stores it in <code>dstDir</code>.

@param fileName
the name of the file to extract.
@param containingJar
the archive where to extract it from.
@param dstDir
the location where the extracted file should be stored.
@return a <code>java.io.File</code> reference to the extracted file.
@throws DeploymentException[SEP]private File extractFile(String fileName, JarFile containingJar, File dstDir)
			throws DeploymentException {

		ZipEntry zipFileEntry = containingJar.getEntry(fileName);
		logger.trace(""Extracting file "" + fileName + "" from ""
				+ containingJar.getName());
		if (zipFileEntry == null) {
			throw new DeploymentException(""Error extracting jar file  ""
					+ fileName + "" from "" + containingJar.getName());
		}
		File extractedFile = new File(dstDir, new File(zipFileEntry.getName())
				.getName());
		try {
			pipeStream(containingJar.getInputStream(zipFileEntry),
					new FileOutputStream(extractedFile));
		} catch (FileNotFoundException e) {
			throw new DeploymentException(""file "" + fileName + "" not found in ""
					+ containingJar.getName(), e);
		} catch (IOException e) {
			throw new DeploymentException(""erro extracting file "" + fileName
					+ "" from "" + containingJar.getName(), e);
		}
		logger.debug(""Extracted file "" + extractedFile.getName());
		return extractedFile;
	}"
1,"Takes a list an an array or sorts

@param list list to sorts
@param sorts what you want to sore the list by[SEP]public static void sort(List list, Sort... sorts) {
        Sort.sorts(sorts).sort(list);
    }"
1,"Returns the {@code String} representation of the given {@code Date}
according to the specified format pattern.

@param date the {@code Date} to format.
@param format the format pattern to use.

@return the {@code String} representation of {@code date}.

@throws NullPointerException if one of the arguments is {@code null}.[SEP]public static String format(Date date, String format)
	{
		Parameters.checkNotNull(date);
		return new SimpleDateFormat(format).format(date);
	}"
1,"Start the example application.

@param args command line arguments[SEP]@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                Is24CsvWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<Is24CsvRecord> records = new ArrayList<>();
        records.add(createHausKaufRecord());
        records.add(createHausKaufRecord());
        records.add(createWohnungMieteRecord());
        records.add(createWohnungMieteRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }"
1,"Start the example application.

@param args command line arguments[SEP]@SuppressWarnings(""Duplicates"")
    public static void main(String[] args) {
        // init logging
        PropertyConfigurator.configure(
                IdxWritingExample.class.getResource(PACKAGE + ""/log4j.properties""));

        // create some CSV records
        List<IdxRecord> records = new ArrayList<>();
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());
        records.add(createRecord());

        // write CSV records into a java.io.File
        try {
            write(records, File.createTempFile(""output-"", "".csv""));
        } catch (IOException ex) {
            LOGGER.error(""Can't create temporary file!"");
            LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            System.exit(1);
        }

        // write CSV records into a java.io.OutputStream
        write(records, new NullOutputStream());

        // write CSV records into a java.io.Writer
        write(records, new NullWriter());

        // write CSV records into a string and send it to the console
        writeToConsole(records);
    }"
1,"/* Arrays[SEP]public static <A> A[] arrayFilter(A[] arr, Predicate<A> accept) {
		if (arr == null || arr.length == 0)
			return arr;
		A[] accepted = newArray(arr, arr.length);
		int j = 0;
		for (int i = 0; i < arr.length; i++)
			if (accept.test(arr[i]))
				accepted[j++] = arr[i];
		return j == arr.length ? arr : copyOf(accepted, j);
	}"
1,"Multiply this matrix by a constant.

@param k
the constant
@return the product matrix[SEP]public Matrix multiply (final float k)
  {
    final float pv[][] = new float [m_nRows] [m_nCols]; // product values

    // Compute values of the product.
    for (int r = 0; r < m_nRows; ++r)
    {
      for (int c = 0; c < m_nCols; ++c)
      {
        pv[r][c] = k * m_aValues[r][c];
      }
    }

    return new Matrix (pv);
  }"
1,"Load the properties from the propertyFile and build the
resources from it.[SEP]private synchronized void readProperties() {
    try {
      propertyFileURI = CatalogManager.class.getResource(""/""+propertyFile);
      InputStream in =
	CatalogManager.class.getResourceAsStream(""/""+propertyFile);
      if (in==null) {
	if (!ignoreMissingProperties) {
	  System.err.println(""Cannot find ""+propertyFile);
	  // there's no reason to give this warning more than once
	  ignoreMissingProperties = true;
	}
	return;
      }
      resources = new PropertyResourceBundle(in);
    } catch (MissingResourceException mre) {
      if (!ignoreMissingProperties) {
	System.err.println(""Cannot read ""+propertyFile);
      }
    } catch (java.io.IOException e) {
      if (!ignoreMissingProperties) {
	System.err.println(""Failure trying to read ""+propertyFile);
      }
    }

    // This is a bit of a hack. After we've successfully read the properties,
    // use them to set the default debug level, if the user hasn't already set
    // the default debug level.
    if (verbosity == null) {
      try {
	String verbStr = resources.getString(""verbosity"");
	int verb = Integer.parseInt(verbStr.trim());
	debug.setDebug(verb);
	verbosity = new Integer(verb);
      } catch (Exception e) {
	// nop
      }
    }
  }"
0,"Returns an empty list by default, or the last value set by {@link #setFromLocation(List)}

`latitude` and `longitude` are ignored by this implementation, except to check that they are in
appropriate bounds. `maxResults` determines the
maximum number of addresses to return.[SEP]@Implementation
  protected List<Address> getFromLocation(double latitude, double longitude, int maxResults)
      throws IOException {
    Preconditions.checkArgument(
        -90 <= latitude && latitude <= 90, ""Latitude must be between -90 and 90, got %s"", latitude);
    Preconditions.checkArgument(
        -180 <= longitude && longitude <= 180,
        ""Longitude must be between -180 and 180, got %s"",
        longitude);
    return fromLocation.subList(0, Math.min(maxResults, fromLocation.size()));
  }"
1,"Adds a new type to the list of types on which a constructor is invoked in
the basic block.

@param var
a type on a which a constructor is invoked.[SEP]private void init(final int var) {
        // creates and/or resizes the initializations array if necessary
        if (initializations == null) {
            initializations = new int[2];
        }
        int n = initializations.length;
        if (initializationCount >= n) {
            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
            System.arraycopy(initializations, 0, t, 0, n);
            initializations = t;
        }
        // stores the type to be initialized
        initializations[initializationCount++] = var;
    }"
1,"See {@link #forHtmlUnquotedAttribute(String)} for description of encoding.  This
version writes directly to a Writer without an intervening string.

@param out where to write encoded output
@param input the input string to encode
@throws IOException if thrown by writer[SEP]public static void forHtmlUnquotedAttribute(Writer out, String input)
        throws IOException
    {
        encode(Encoders.HTML_UNQUOTED_ATTRIBUTE_ENCODER, out, input);
    }"
0,"Inspect a given binary file. That is a file for which we don't have a better
inspector.

@param bytes[SEP]private void inspectBinaryFile(byte[] bytes) {
		for (int i = 0; i < bytes.length; i += width) {
			out.print(String.format(""0x%04X "", i));
			// Print out databytes
			for (int j = 0; j < width; ++j) {
				if(j+i < bytes.length) {
					out.print(String.format(""%02X "", bytes[i+j]));
				} else {
					out.print(""   "");
				}
			}
			//
			for (int j = 0; j < width; ++j) {
				if(j+i < bytes.length) {
					char c = (char) bytes[i+j];
					if(c >= 32 && c < 128) {
						out.print(c);
					} else {
						out.print(""."");
					}
				}
			}
			//
			out.println();
		}
	}"
0,"Getter method for instance variable {@link #hidden}.

@return value of instance variable {@link #hidden}[SEP]public List<IHidden> getHidden()
    {
        for (final IHidden hidden : this.hidden) {
            hidden.setAdded(false);
        }
        return this.hidden;
    }"
1,"Converts the object into a boolean value.

@param o the object to convert
@return a <code>boolean</code>[SEP]public static boolean convertToBoolean(Object o)
  {
    if(o == null)
      return false;

    if(o instanceof Boolean)
    {
      return (Boolean) o;
    }

    return convertToBoolean(o.toString());
  }"
0,"Create a new path with a given file.

@param file the file for the path
@return the new path[SEP]public Path withFile(final String file) {
		final Path result = new Path(this);
		result.setFile(file);
		return result;
	}"
1,"Return the result of a random choose from a given distribution.

@param probs
@return[SEP]public int randomChooseFromDistribution(double... probs) {
		int result = -1;
		int[] range = new int[probs.length];
		double accuracy = 1000;
		int total = 0;

		for (int i = 0; i < probs.length; i++) {
			range[i] = (int) (probs[i] * accuracy);
			total += range[i];
		}

		int randNum = (int) (rng.nextDouble() * total);
		for (int i = 0; i < range.length; i++) {
			randNum -= range[i];
			if (randNum <= 0) {
				result = i;
				break;
			}
		}
		return result;
	}"
1,"Same as String.indexOf but (slightly) faster ;)

Hint: Performance optimized code - so some warnings are suppressed.[SEP]@SuppressWarnings({""MethodWithMultipleReturnPoints"", ""LabeledStatement"", ""ValueOfIncrementOrDecrementUsed"", ""ContinueStatement"", ""ContinueStatementWithLabel""})
    public static int indexOf(char[] src, char[] find, int startAt) {
        int startPos = startAt;
        final int max = src.length - find.length;
        if (startPos > max) {
            return -1;
        }
        final char find0 = find[0];
        final int len = find.length;
        int j;
        int k;

        // Find the first character
        startOver:
        while (startPos <= max) {
            if (src[startPos++] == find0) {
                // First character found - look for the rest
                j = startPos;
                k = 1;
                while (k < len) {
                    if (src[j++] != find[k++]) {
                        continue startOver;
                    }
                }
                return startPos - 1;
            }
        }
        return -1;
    }"
1,"Reads the file into the the provided list.
Skips empty lines and lines starting with #.

@param file	the file to read
@param lines 	the lines to add the content to
@return 		null if successful, otherwise error message[SEP]protected String readFile(File file, List<String> lines) {
    int		i;

    try {
      lines.addAll(Files.readAllLines(file.toPath()));
      i = 0;
      while (i < lines.size()) {
        if (lines.get(i).trim().isEmpty()) {
          lines.remove(i);
          continue;
	}
	if (lines.get(i).startsWith(""#"")) {
          lines.remove(i);
          continue;
	}
	i++;
      }
    }
    catch (Exception e) {
      return ""Failed to read file: "" + file + ""\n"" + e;
    }

    return null;
  }"