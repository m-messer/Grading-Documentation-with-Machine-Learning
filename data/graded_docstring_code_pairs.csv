,function,docstring,file_name,id,label
0,"public void act(List<Animal> newkingfishers)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {
             makeSick();
             age = MAX_AGE - MAX_AGE/10;
            }
            }
            if (!isHealthy())
            {
                spreadDisease();
            }
            giveBirth(newkingfishers);            
            // Move towards a source of food if found.
            Location newLocation = null;
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 1))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the kingfisher does most of the time: it hunts for
salmons. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newkingfisheres A list to return newly born kingfisheres.",Kingfisher.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby); // Checks through neighbouring elements to detect animal.
         if (animal instanceof Kingfisher) { // Only animals of the same species can infect each other.
             Kingfisher kingfisher = (Kingfisher) animal;
             if (kingfisher.isHealthy()) { // Spreads disease only if animal is currently healthy
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){ // Random chance that it spreads.
                    kingfisher.makeSick();
                    kingfisher.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease.,Kingfisher.java,28.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the kingfisher's death.,Kingfisher.java,28.0,2
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this kingfisher more hungry. This could result in the kingfisher's death.,Kingfisher.java,28.0,2
4,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Salmon) {
                Salmon salmon = (Salmon) animal;
                if(salmon.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    salmon.setDead();
                    foodLevel += SALMON_FOOD_VALUE;
                    return where;
                }
            }
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    foodLevel += plant.getFoodValue();
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for salmons adjacent to the current location.
Only the first live salmon is eaten.
@return Where food was found, or null if it wasn't.",Kingfisher.java,28.0,2
5,"private void giveBirth(List<Animal> newkingfishers)
    {
        // New kingfisheres are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Kingfisher)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Kingfisher young = new Kingfisher(field, l, randomGender, false);
                        newkingfishers.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this kingfisher is to give birth at this step.
New births will be made into free adjacent locations.
@param newkingfisheres A list to return newly born kingfisheres.",Kingfisher.java,28.0,2
6,"private int breed(Object obj)
    {
        int births = 0;
        if(((Kingfisher)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Kingfisher.java,28.0,2
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A kingfisher can breed if it has reached the breeding age.,Kingfisher.java,28.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,28.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,28.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,28.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,28.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,28.0,2
0,"protected List<Location> getSuitableLocations(Location location)
    {
        List<Location> free = field.getFreeAdjacentLocations(location);
        
        List<Location> suitable = new LinkedList<>();
        for(Location next : free) {
            if (field.getLand(next.getRow(), next.getCol()))
                suitable.add(next);
        }
        return suitable;
    }","Get a shuffled list of the suitable free adjacent locations.
@param location Location of animal.
@return A list of free adjacent locations.",LandAnimal.java,28.0,2
0,"public void move(){
        Random rand = new Random();
        
        int choice = rand.nextInt(4);
        
        eject(TYPE);
        if (choice == 0){ // Moves up.
            setPosition(row-1, col);
            center.move(-1,0);
        }else if (choice == 1){ // Moves right.
            setPosition(row, col+1);
            center.move(0,1);
        }else if (choice == 2){ // Moves down.
            setPosition(row+1, col);
            center.move(1,0);
        }else if (choice == 3){ // Moves left.
            setPosition(row, col-1);
            center.move(0,-1);
        }
        decreaseLife();
        inject(TYPE);
    }",Moves the cloud and also adds or deletes information to the field.,Snow.java,28.0,2
1,"public boolean exists()
    {
        if (lifespan <=0) 
        eject(TYPE);
        return lifespan > 0? true:false;
    }",Returns whether cloud still exists or not.,Snow.java,28.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,28.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,28.0,2
0,"public void act(List<Animal> neweagles)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            //if the eagle is healthy, randomly try to make it sick
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {//make the salmon sick
             makeSick();
             //make its age to 90% old
             age = MAX_AGE - MAX_AGE/10;
            }
            }
            //if it is unhealthy, try to spread the disease
            if (!isHealthy())
            {
                spreadDisease();
            }
            //give birth to new eagles
            giveBirth(neweagles);            
            // Move towards a source of food if found.
            Location newLocation = null;
            //the stronger the fog, the less chance for the animal to find food
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 0))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the eagle does most of the time: it hunts for
squirrels. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param neweaglees A list to return newly born eaglees.",Eagle.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
    // if(getLocation()==null) return;
    //get adjacent locations
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
      //parse all the adjacent locations to try to spread the disease
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby);
         //check if the animal fount in the current adjacent loc is an eagle
         if (animal instanceof Eagle) {
             Eagle eagle = (Eagle) animal;
             if (eagle.isHealthy()) {
                 //if the found eagle is healthy, try to spr
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){
                    eagle.makeSick();
                    eagle.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease betweeen two eagles,Eagle.java,28.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the eagle's death.,Eagle.java,28.0,2
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this eagle more hungry. This could result in the eagle's death.,Eagle.java,28.0,2
4,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Squirrel) {
                Squirrel squirrel = (Squirrel) animal;
                if(squirrel.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    squirrel.setDead();
                    foodLevel += SQUIRREL_FOOD_VALUE;
                    return where;
                }
            }
            if(animal instanceof Kingfisher) {
                Kingfisher kingfisher = (Kingfisher) animal;
                if(kingfisher.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    kingfisher.setDead();
                    foodLevel += KINGFISHER_FOOD_VALUE;
                    return where;
                }
            }
            if(animal instanceof Salmon) {
                Salmon salmon = (Salmon) animal;
                if(salmon.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    salmon.setDead();
                    foodLevel += SALMON_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for squirrels, kingfishers, or salmon adjacent to the current location.
Only the first live prey is eaten.
@return Where food was found, or null if it wasn't.",Eagle.java,28.0,2
5,"private void giveBirth(List<Animal> neweagles)
    {
        // New eaglees are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Eagle)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Eagle young = new Eagle(field, l, randomGender, false);
                        neweagles.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this eagle is to give birth at this step.
New births will be made into free adjacent locations.
@param neweaglees A list to return newly born eaglees.",Eagle.java,28.0,2
6,"private int breed(Object obj)
    {
        int births = 0;
        if(((Eagle)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Eagle.java,28.0,2
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A eagle can breed if it has reached the breeding age.,Eagle.java,28.0,2
0,"protected void eject(int index)
    {
        for (WeatherBlock block : blocks)
        {
            for(int i = block.getRow(); i < block.getRow()+3; i++)
                for (int j = block.getCol(); j < block.getCol()+3; j++)
                if (i>=0 && i<field.getDepth() && j>=0 && j<field.getWidth())
                    field.setWeather(i, j, 0, index);
        }
    }",Removes every weather tile of a certain type from ther field.,Weather.java,28.0,2
1,"protected void inject(int index)
    {
        for (WeatherBlock block : blocks)
        {
            for(int i = block.getRow(); i < block.getRow()+3; i++)
                for (int j = block.getCol(); j < block.getCol()+3; j++)
                if (i>=0 && i<field.getDepth() && j>=0 && j<field.getWidth())
                    field.setWeather(i, j, Math.max(block.getType(), field.getWeather(i, j, index)), index);
        }
    }",Inserts a weather tile on every surface covered by this cloud.,Weather.java,28.0,2
2,"protected void fillQuadrant(int x, int y)
    {
        // Creating 3x3 WeatherBlocks that make up the cloud...
        int i, j;
        WeatherBlock current, main = center;
        
        for (j = 1; j <= radius; j++){
            if (y == 1)
            {
                if (main.getRight() != null)
                    main = main.getRight();
                    else{
                        current = new WeatherBlock(main.getRow(), main.getCol() + 3);
                        main.setRight(current);
                        blocks.add(current);
                        main = current;
                        main.setType(3-((main.getCol() - center.getCol())/radius));
                    }
            }else{
                if (main.getLeft() != null)
                    main = main.getLeft();
                    else{
                        current = new WeatherBlock(main.getRow(), main.getCol() - 3);
                        main.setLeft(current);
                        blocks.add(current);
                        main = current;
                        main.setType(3-((center.getCol() - main.getCol())/radius));
                    }
            }
            current = main;
            for (i = 1; i<= radius; i++){
                WeatherBlock aux = new WeatherBlock(row + 3*x*i, col + 3*y*j);
                double distance = calculateDistance(aux.getRow()+1, aux.getCol()+1);
                if (distance <= 3*radius){
                    if (x == 1) current.setTop(aux);
                    else current.setBottom(aux);
                    current = aux;
                    
                    if (distance < radius){
                        current.setType(3);
                    }else if (distance <= 2*radius){
                        current.setType(2);
                    }else{
                        current.setType(1);
                    }
                }else break;
                blocks.add(current);
            }
        }
    }",Fills in quadrant with blocks.,Weather.java,28.0,2
3,"public List<WeatherBlock> getBlocks()
    {
        return blocks;
    }",Returns list of blocks that make up cloud.,Weather.java,28.0,2
8,"public WeatherBlock getCenter()
    {
        return center;
    }",Return center of cloud.,Weather.java,28.0,2
10,"public double calculateDistance(int x, int y)
    {
        // Setting up the true center of the cloud
        int rx = row + 1;
        int ry = col + 1;
        
        return Math.sqrt(Math.pow(rx - x, 2) + Math.pow(ry - y, 2));
    }",Returns the distance between the center of the cloud to some point.,Weather.java,28.0,2
0,"public static void setTime(int step) {
        currentTime = step % 400;
    }","Based on the current step value, the currentTime is calculated.",Time.java,28.0,2
1,"public static int getTime()
    {
        return currentTime;
    }",Returns the currentTime.,Time.java,28.0,2
2,"public static int sunlight() {
        if(currentTime < 100) {
            return 0;
        } else if (currentTime < 200) {
            return (currentTime - 100);
        } else if (currentTime < 300) {
            return 100;
        } else {
            return (400 - currentTime);
        }
    }","In between day and night, it calculates a value for each step, rising or falling by 1, appropriately, until the next night or day comes along.",Time.java,28.0,2
0,"public void act(List<Animal> newsheeps)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {
             makeSick();
             age = MAX_AGE - MAX_AGE/7;
            }
            }
            if (!isHealthy())
            {
                spreadDisease();
            }
            giveBirth(newsheeps);            
            // Move towards a source of food if found.
            Location newLocation = null;
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 1))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the sheep does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newsheeps A list to return newly born sheeps.",Sheep.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
    //get adjacent locations
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
     //parse the adjacent locations
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby);
         //test if the nearby aniumal is a sheep
         if (animal instanceof Sheep) {
             Sheep sheep = (Sheep) animal;
             //if the nearby sheep is healthy, try to make it sick
             if (sheep.isHealthy()) {
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){
                    sheep.makeSick();
                    sheep.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease between two sheeps,Sheep.java,28.0,2
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    foodLevel += plant.getFoodValue();
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for plants adjacent to the current location.
Only the first live plant is eaten.
@return Where food was found, or null if it wasn't.",Sheep.java,28.0,2
3,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the sheep's death.",Sheep.java,28.0,2
4,"private void giveBirth(List<Animal> newsheeps)
    {
        // New sheeps are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Sheep)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.6) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Sheep young = new Sheep(field, l, randomGender, false);
                        newsheeps.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this sheep is to give birth at this step.
New births will be made into free adjacent locations.
@param newsheeps A list to return newly born sheeps.",Sheep.java,28.0,2
5,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this sheep more hungry. This could result in the sheep's death.,Sheep.java,28.0,2
6,"private int breed(Object obj)
    {
        int births = 0;
        if(((Sheep)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Sheep.java,28.0,2
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A sheep can breed if it has reached the breeding age.
@return true if the sheep can breed, false otherwise.",Sheep.java,28.0,2
0,"public void grow()
    {
        if((foodValue + growthRate) > MAX_FOOD_VALUE){
            foodValue = MAX_FOOD_VALUE;
        } else {
            foodValue += growthRate;
        }
    }",Grows food value at a certain rate.,Plant.java,28.0,2
1,"public boolean isAlive() {
        return alive;
    }",Returns whether plant is alive or not.,Plant.java,28.0,2
2,"public int getFoodValue() {
        return MAX_FOOD_VALUE;
    }",Returns the max food value that the plant could offer.,Plant.java,28.0,2
3,"public void setDead()
    {
        if(location != null) {
            alive = false;
            field.clear(location);
            location = null;
            field = null;
        }
    }",Handles the death of a plant.,Plant.java,28.0,2
4,"public void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }",Sets a new location.,Plant.java,28.0,2
0,"protected List<Location> getSuitableLocations(Location location)
    {
        List<Location> free = field.getFreeAdjacentLocations(location);
        
        List<Location> suitable = new LinkedList<>();
        for(Location next : free) {
            if (!field.getLand(next.getRow(), next.getCol()))
                suitable.add(next);
        }
        return suitable;
    }","Get a shuffled list of the suitable free adjacent locations.
@param location Location of animal.
@return A list of free adjacent locations.",WaterAnimal.java,28.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,28.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,28.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,28.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,28.0,2
0,"public void setColor(Class aClass, Color color)
    {
        colors.put(aClass, color);
    }","Define a color to be used for a given class.
@param aClass The Class object.
@param color The color to be used for the given class.",SimulatorView.java,28.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,28.0,2
2,"private Color getColor(Class aClass)
    {
        Color col = colors.get(aClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class.,SimulatorView.java,28.0,2
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    if (animal.getClass() != Plant.class)
                    {
                        Animal a = (Animal) animal;
                        if (a.isHealthy()) fieldView.drawMark(col, row, getColor(animal.getClass())); // Healthy animals use their normal colour.
                        else fieldView.drawMark(col, row, Color.RED); // Sick animals are shown as RED.
                    }else fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else if(field.getLand(row, col)) {
                    fieldView.drawMark(col, row, LAND_COLOR); // Draw land tile
                }
                else if(!field.getLand(row, col)) {
                    fieldView.drawMark(col, row, WATER_COLOR); // Draw water tile.
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
                
                // Draws cloud tiles with a specific transparency already initialized in Simulator. Depeding on how far from center, ther eis a smaller chance to appear.
                Random rand = new Random();
                double chance = rand.nextDouble();
                if (chance <= field.getWeather(row, col, 0)*0.25) fieldView.drawMark(col, row, getColor(Fog.class));
                chance = rand.nextDouble();
                if (chance <= field.getWeather(row, col, 1)*0.25) fieldView.drawMark(col, row, getColor(Rain.class));
                chance = rand.nextDouble();
                if (chance <= field.getWeather(row, col, 2)*0.25) fieldView.drawMark(col, row, getColor(Snow.class));
                    
                fieldView.drawMark(col, row, new Color(0, 0, 0, Time.sunlight()));
            }
        }
        
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,28.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,28.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,28.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(100);   
            // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,28.0,2
2,"private void generatePlants() 
    {   
        Random rand = new Random();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(field.getObjectAt(row, col) == null && rand.nextDouble() <= PLANT_CREATION_PROBABILITY*0.05+0.005*field.getWeather(row, col, 1)) {
                    Location location = new Location(row, col);
                    Plant plant = new Plant(field, location);
                    plants.add(plant);
                }
            }
        }
    }","Method that generates plants throughout the field. Is affected by rain, making the birth chance slightly higher.",Simulator.java,28.0,2
3,"public void simulateOneStep()
    {
        step++;
        generatePlants();
        Time.setTime(step);
        // Random chance for clouds to form.
        Random rand = new Random();
        
        // Random chance to create a cloud.
        if (CLOUD_CREATION_PROBABILITY >= rand.nextDouble())
        {
            int chance = rand.nextInt(3);
            if (chance == 0)
            clouds.add(new Fog(rand.nextInt(field.getDepth()), rand.nextInt(field.getWidth()), rand.nextInt(8)+3, rand.nextInt(50)+25, field));
            if (chance == 1)
            clouds.add(new Rain(rand.nextInt(field.getDepth()), rand.nextInt(field.getWidth()), rand.nextInt(8)+3, rand.nextInt(50)+25, field));
            if (chance == 2)
            clouds.add(new Snow(rand.nextInt(field.getDepth()), rand.nextInt(field.getWidth()), rand.nextInt(8)+3, rand.nextInt(50)+50, field));
        }
        // Process the clouds.
        for(Iterator<Weather> it = clouds.iterator(); it.hasNext(); ) {
            Weather cloud = it.next();
            cloud.move();
            if (!cloud.exists())
                it.remove();
        }
        // Creates new plants.
        List<Plant> newPlants = new ArrayList<>();
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.grow();
            if(!plant.isAlive()) {
                it.remove();
            }
        }
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            // Toggles awake or sleep status.
            animal.setAsleep();
            if(animal.getAsleep()){
                continue;
            }
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born wolves and squirrels to the main lists.
        animals.addAll(newAnimals);
        
        // Draw elements.
        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal or other.",Simulator.java,28.0,2
4,"public void reset()
    {
        step = 0;
        animals.clear();
        clouds.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,28.0,2
5,"private void populate()
    {
        // Creating a river.
        Random rand = Randomizer.getRandom();
        field.clear();
        int width = field.getWidth();
        int rwidth = field.getWidth()/3; // Width of river;
        int river = width/2 - rwidth/2; // Start point of river.
        int direction = 0; // Stores information about the direction the last row of water 
                           // to create a smoother curvature in the river
        
        // Setting all tiles as land.
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                field.setLand(row, col, true);
            }
        }
        
        // Gow down row by row filling in tiles with water information
        for(int row = 0; row < field.getDepth(); row++) {
            int startriver = 0 > river? 0 : river; // Starting point of setting up the river on specific row
            int endriver = (river + rwidth) < width? river + rwidth : width; // Ending point...
            for(int col = startriver; col < endriver; col++) {
                field.setLand(row, col, false);
            }
            if (direction == 0) // Moved straight down.
            {
                direction = rand.nextInt(3) - 1;
            }else if (direction == 1) // Moved slightly right.
            {
                direction = rand.nextInt(3);
            }else if (direction == 2) // Moved hard right.
            {
                direction = rand.nextInt(2) + 1;
            }else if (direction == -1) // Moved slightly left.
            {
                direction = rand.nextInt(3) - 2;
            }else if (direction == -2)// Moved hard left.
            {
                direction = rand.nextInt(2) - 2;
            }
            river += direction;
        }
        
        // Adds plants and animals to field
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= PLANT_CREATION_PROBABILITY && field.getLand(row, col)) {
                    Location location = new Location(row, col);
                    Plant plant = new Plant(field, location);
                    plants.add(plant);
                }
                else if(rand.nextDouble() <= WOLF_CREATION_PROBABILITY && field.getLand(row, col)) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    Wolf wolf = new Wolf(field, location, randomGender, true);
                    animals.add(wolf);
                }
                else if(rand.nextDouble() <= SQUIRREL_CREATION_PROBABILITY && field.getLand(row, col)) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.7) ? true : false;
                    Squirrel squirrel = new Squirrel(field, location, randomGender, true);
                    animals.add(squirrel);
                }
                else if(rand.nextDouble() <= SHEEP_CREATION_PROBABILITY && field.getLand(row, col)) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.7) ? true : false;
                    Sheep sheep = new Sheep(field, location, randomGender, true);
                    animals.add(sheep);
                }
                else if(rand.nextDouble() <= EAGLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    Eagle eagle = new Eagle(field, location, randomGender, true);
                    animals.add(eagle);
                }
                else if(rand.nextDouble() <= KINGFISHER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    Kingfisher kingfisher = new Kingfisher(field, location, randomGender, true);
                    animals.add(kingfisher);
                }
                else if(rand.nextDouble() <= SALMON_CREATION_PROBABILITY && !field.getLand(row, col)) {
                    Location location = new Location(row, col);
                    boolean randomGender = (rand.nextDouble()>0.7) ? true : false;
                    Salmon salmon = new Salmon(field, location, randomGender, true);
                    animals.add(salmon);
                }
                // else leave the location empty.
            }
        }
    }","Randomly populate the field with wolves, squirrels, sheep, eagles, and water tiles.",Simulator.java,28.0,2
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,28.0,2
0,"public void act(List<Animal> newsalmons)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            //if the salmon is healthy, randomly try to make it sick
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {//make the salmon sick
             makeSick();
             //make its age to be 90% old
             age = MAX_AGE - MAX_AGE/10;
            }
            }
            //if it is unhealthy, try to spread the disease
            if (!isHealthy())
            {
                spreadDisease();
            }
            //give birth to new salmons
            giveBirth(newsalmons);            
            // Move towards a source of food if found.
            Location newLocation = null;
            //the stronger the fog, the less chance for the animal to find food
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 0))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the salmon does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newsalmons A list to return newly born salmons.",Salmon.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
    //get the adjacent locations
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
     //parse all the adjacent locations to try to spread the disease
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby);
         //check if the animal found in the current adjacent loc is a salmon
         if (animal instanceof Salmon) {
             Salmon salmon = (Salmon) animal;
             //check if the found salmon is healthy
             if (salmon.isHealthy()) {
                //if the found salmon is healthy, try to spread the disease
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){
                    salmon.makeSick();
                    salmon.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease between two salmons,Salmon.java,28.0,2
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    foodLevel += plant.getFoodValue();
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for salmons adjacent to the current location.
Only the first live salmon is eaten.
@return Where food was found, or null if it wasn't.",Salmon.java,28.0,2
3,"private void incrementAge()
    {
        age++;
        //when the animal reaches the maximum age, it dies instantly
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the salmon's death.",Salmon.java,28.0,2
4,"private void giveBirth(List<Animal> newsalmons)
    {
        // New salmons are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Salmon)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.7) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Salmon young = new Salmon(field, l, randomGender, false);
                        newsalmons.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this salmon is to give birth at this step.
New births will be made into free adjacent locations.
@param newsalmons A list to return newly born salmons.",Salmon.java,28.0,2
5,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this salmon more hungry. This could result in the salmon's death.,Salmon.java,28.0,2
6,"protected boolean getGender()
    {
        return isMale;
    }","/*
Return whether the animal is a male or not",Salmon.java,28.0,2
7,"private int breed(Object obj)
    {
        int births = 0;
        if(((Salmon)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Salmon.java,28.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A salmon can breed if it has reached the breeding age.
@return true if the salmon can breed, false otherwise.",Salmon.java,28.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,28.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,28.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,28.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,28.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,28.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,28.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,28.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,28.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,28.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,28.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,28.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,28.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,28.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,28.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,28.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,28.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,28.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,28.0,2
0,"public void act(List<Animal> newwolves)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {
             makeSick();
             age = MAX_AGE - MAX_AGE/10;
            }
            }
            if (!isHealthy())
            {
                spreadDisease();
            }
            giveBirth(newwolves);            
            // Move towards a source of food if found.
            Location newLocation = null;
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 1))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the wolf does most of the time: it hunts for
sheep. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newwolves A list to return newly born wolfes.",Wolf.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
    // get adjacent locations
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
     //parse the adjacents locations
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby);
         //test if the nearby animal is a wolf
         if (animal instanceof Wolf) {
             Wolf wolf = (Wolf) animal;
             //if the nearby wolf is healthy, try to make it sick
             if (wolf.isHealthy()) {
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){
                    wolf.makeSick();
                    wolf.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease between two wolves,Wolf.java,28.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the wolf's death.,Wolf.java,28.0,2
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this wolf more hungry. This could result in the wolf's death.,Wolf.java,28.0,2
4,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            
            if(animal instanceof Squirrel) {
                Squirrel squirrel = (Squirrel) animal;
                if(squirrel.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.95) { 
                    squirrel.setDead();
                    foodLevel += SQUIRREL_FOOD_VALUE;
                    return where;
                }
            }
            if(animal instanceof Sheep && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.85) {
                Sheep sheep = (Sheep) animal;
                if(sheep.isAlive()) { 
                    sheep.setDead();
                    foodLevel += SHEEP_FOOD_VALUE;
                    return where;
                }
            }
            
        }
        return null;
    }","Look for squirrels or sheep adjacent to the current location.
Only the first live sheep or squirrel is eaten.
@return Where food was found, or null if it wasn't.",Wolf.java,28.0,2
5,"private void giveBirth(List<Animal> newwolves)
    {
        // New wolfes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Wolf)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.5) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Wolf young = new Wolf(field, l, randomGender, false);
                        newwolves.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this wolf is to give birth at this step.
New births will be made into free adjacent locations.
@param newwolfes A list to return newly born wolfes.",Wolf.java,28.0,2
6,"private int breed(Object obj)
    {
        int births = 0;
        if(((Wolf)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Wolf.java,28.0,2
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A wolf can breed if it has reached the breeding age.,Wolf.java,28.0,2
0,"public void act(List<Animal> newsquirrels)
    {
        incrementAge();
        incrementHunger();
        // Snow affects animals' movements.
        if(isAlive() && rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 2)) {
            if (isHealthy())
            {
             Random rand = new Random();
             boolean randomSick = (rand.nextDouble() <= ANIMAL_GET_SICK_PROBABILITY ) ? true : false;
            if(randomSick)
            {
             makeSick();
             age = MAX_AGE - MAX_AGE/7;
            }
            }
            if (!isHealthy())
            {
                spreadDisease();
            }
            giveBirth(newsquirrels);            
            // Move towards a source of food if found.
            Location newLocation = null;
            if (rand.nextDouble() >= 0.25*field.getWeather(location.getRow(), location.getCol(), 1))
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(getSuitableLocations(getLocation()));
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the squirrel does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newsquirrels A list to return newly born squirrels.",Squirrel.java,28.0,2
1,"public void spreadDisease()
    {
     Field field = getField();
    // get the adjacent locations
     List<Location> adjacent = field.adjacentLocations(getLocation());
     Iterator<Location> iterator = adjacent.iterator();
     //parse the adjacent locations
     while (iterator.hasNext()) {
         Location nearby = iterator.next();
         Object animal = field.getObjectAt(nearby);
         //try to find a squirrel nearby
         if (animal instanceof Squirrel) {
             Squirrel squirrel = (Squirrel) animal;
             //if the found squirrel is healthy, try to make it sick
             if (squirrel.isHealthy()) {
                Random rand = new Random ();
                boolean randomSpread = (rand.nextDouble() <= DISEASE_SPREAD_PROBABILITY ) ? true : false;
                if (randomSpread){
                    squirrel.makeSick();
                    squirrel.age = MAX_AGE - MAX_AGE/10;
                }    
            }    
        }     
    }        
    }",Spread the disease between two squirrels,Squirrel.java,28.0,2
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive() && foodLevel < FOOD_LIMIT && rand.nextDouble() > 0.875) { 
                    foodLevel += plant.getFoodValue();
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for plants adjacent to the current location.
Only the first live plant is eaten.
@return Where food was found, or null if it wasn't.",Squirrel.java,28.0,2
3,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the squirrel's death.",Squirrel.java,28.0,2
4,"private void giveBirth(List<Animal> newsquirrels)
    {
        // New squirrels are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        
        List<Location> locations = field.adjacentLocations(location);
        for (Location loc : locations){
            Object obj = field.getObjectAt(loc.getRow(), loc.getCol());
            if (obj != null && obj.getClass() == this.getClass())
            {
                if (((Squirrel)obj).getGender() != isMale)
                {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    boolean randomGender = (rand.nextDouble()>0.7) ? true : false;
                    int births = breed(obj);
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location l = free.remove(0);
                        Squirrel young = new Squirrel(field, l, randomGender, false);
                        newsquirrels.add(young);
                    }
                    break;
                }
            }
        }
    }","Check whether or not this squirrel is to give birth at this step.
New births will be made into free adjacent locations.
@param newsquirrels A list to return newly born squirrels.",Squirrel.java,28.0,2
5,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this squirrel more hungry. This could result in the squirrel's death.,Squirrel.java,28.0,2
6,"protected boolean getGender()
    {
        return isMale;
    }","/*
Rreturn whether the animal is a male or not",Squirrel.java,28.0,2
7,"private int breed(Object obj)
    {
        int births = 0;
        if(((Squirrel)obj).canBreed() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Squirrel.java,28.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A squirrel can breed if it has reached the breeding age.
@return true if the squirrel can breed, false otherwise.",Squirrel.java,28.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,28.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,28.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,28.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,28.0,2
4,"public boolean getLand(int row, int col)
    {
        return isLand[row][col];
    }","Return the land status of a location on the grid.
@return Whether the statement ""Is the location at row and col land?"" is true or not.",Field.java,28.0,2
5,"public void setLand(int row, int col, boolean land)
    {
        isLand[row][col] = land;
    }",Sets the land status of a location on the grid.,Field.java,28.0,2
6,"public int getWeather(int row, int col, int cloud)
    {
        return weather[row][col][cloud];
    }","Return the land status of a location on the grid.
@return Whether the statement ""Is the location at row and col land?"" is true or not.",Field.java,28.0,2
7,"public void setWeather(int row, int col, int intensity, int cloud)
    {
        weather[row][col][cloud] = intensity;
    }",Sets the land status of a location on the grid.,Field.java,28.0,2
8,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,28.0,2
9,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,28.0,2
10,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,28.0,2
11,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,28.0,2
12,"public Location freeAdjacentLocation(List<Location> free)
    {
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,28.0,2
13,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,28.0,2
14,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,28.0,2
15,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,28.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,28.0,2
1,"protected boolean isHealthy()
    {
        return healthy;
    }","Check whether the animal is healthy or not.
@return true if the animal is still healthy.",Animal.java,28.0,2
2,"protected void makeSick()
    {
        healthy = false;
    }",Makes animal sick.,Animal.java,28.0,2
3,"protected List<Location> getSuitableLocations(Location location)
    {
        return field.getFreeAdjacentLocations(location);
    }","Get a shuffled list of the suitable free adjacent locations.
@param location Location of animal.
@return A list of free adjacent locations.",Animal.java,28.0,2
4,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,28.0,2
5,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,28.0,2
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,28.0,2
7,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,28.0,2
10,"protected boolean getGender()
    {
        return isMale;
    }","/*
Returns a boolean representing whether it is a male or not",Animal.java,28.0,2
0,"public void move(){
        Random rand = new Random();
        
        int choice = rand.nextInt(4);
        
        eject(TYPE);
        if (choice == 0){ // Moves up.
            setPosition(row-1, col);
            center.move(-1,0);
        }else if (choice == 1){ // Moves right.
            setPosition(row, col+1);
            center.move(0,1);
        }else if (choice == 2){ // Moves down.
            setPosition(row+1, col);
            center.move(1,0);
        }else if (choice == 3){ // Moves left.
            setPosition(row, col-1);
            center.move(0,-1);
        }
        decreaseLife();
        inject(TYPE);
    }",Moves the cloud and adds or deletes information from the field.,Rain.java,28.0,2
1,"public boolean exists()
    {
        if (lifespan <=0) 
        eject(TYPE);
        return lifespan > 0? true:false;
    }",Returns whether cloud still exists.,Rain.java,28.0,2
0,"public void move(int x, int y)
    {
        setPosition(row + x, col + y);
        
        if (top != null) top.move(x, y);
        if (right != null) right.move(x, y);
        if (bottom != null) bottom.move(x, y);
        if (left != null) left.move(x, y);
    }",Moves the block by a certain amount.,WeatherBlock.java,28.0,2
1,"public List<WeatherBlock> neighbours()
    {
        List<WeatherBlock> neighbours = new ArrayList<WeatherBlock>();
        
        if (top != null) neighbours.add(top);
        if (right != null) neighbours.add(right);
        if (bottom != null) neighbours.add(bottom);
        if (left != null) neighbours.add(left);
        
        return neighbours;
    }",Returns a list of this blocks neighbours.,WeatherBlock.java,28.0,2
0,"public void move(){
        Random rand = new Random();
        
        int choice = rand.nextInt(4);
        
        eject(TYPE);
        if (choice == 0){ // Moves up.
            setPosition(row-1, col);
            center.move(-1,0);
        }else if (choice == 1){ // Moves right.
            setPosition(row, col+1);
            center.move(0,1);
        }else if (choice == 2){ // Moves down.
            setPosition(row+1, col);
            center.move(1,0);
        }else if (choice == 3){ // Moves left.
            setPosition(row, col-1);
            center.move(0,-1);
        }
        decreaseLife();
        inject(TYPE);
    }",Moves cloud and inserts or deletes information from field.,Fog.java,28.0,2
1,"public boolean exists()
    {
        if (lifespan <=0) 
        eject(TYPE);
        return lifespan > 0? true:false;
    }",Returns whether cloud still exists.,Fog.java,28.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,17.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,17.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,17.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,17.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,17.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,17.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,17.0,3
0,"public void act(List<Animal> newBoars)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newBoars);  
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Boar does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newBoars A list to return newly born Boars.",Boar.java,17.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Boar's death.",Boar.java,17.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Boar's death.,Boar.java,17.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Boar more hungry. This could result in the Goat's death.,Boar.java,17.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Boar.java,17.0,3
5,"private void giveBirth(List<Animal> newBoars)
    {
        if(findPartner() == true && FOOD_VALUE > 3) {
           // New Boars are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Boar young = new Boar(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newBoars.add(young);
           }
        }
    }","Check whether or not this Boar is to give birth at this step.
New births will be made into free adjacent locations.
@param newBoars A list to return newly born Boars.",Boar.java,17.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Boar) {
                Boar BoarPartner = (Boar) animal;
                String partnerOneGender = getGender();
                String partnerGender = BoarPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(BoarPartner.isInfected() || isInfected()) {
                        BoarPartner.setInfected();
                        setInfected();
                }
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Boar.java,17.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Boar.java,17.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Boar can breed if it has reached the breeding age.
@return true if the Boar can breed, false otherwise.",Boar.java,17.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,17.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,17.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,17.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,17.0,3
0,"public void act(List<Animal> newDeers)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newDeers); 
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Deer does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newDeers A list to return newly born Deers.",Deer.java,17.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Deer's death.",Deer.java,17.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Deer's death.,Deer.java,17.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Deer more hungry. This could result in the Goat's death.,Deer.java,17.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Deer.java,17.0,3
5,"private void giveBirth(List<Animal> newDeers)
    {
         if(findPartner() == true && FOOD_VALUE > 5) {
           // New Deers are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Deer young = new Deer(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newDeers.add(young);
           }
       }
    }","Check whether or not this Deer is to give birth at this step.
New births will be made into free adjacent locations.
@param newDeers A list to return newly born Deers.",Deer.java,17.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Deer) {
                Deer DeerPartner = (Deer) animal;
                String partnerOneGender = getGender();
                String partnerGender = DeerPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(DeerPartner.isInfected() || isInfected()) {
                        DeerPartner.setInfected();
                        setInfected();
                }
                // it looks nicer
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Deer.java,17.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Deer.java,17.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Deer can breed if it has reached the breeding age.
@return true if the Deer can breed, false otherwise.",Deer.java,17.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,17.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,17.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,17.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,17.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,17.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,17.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,17.0,3
2,"public void simulateOneStep()
    {
        step++;
        // Keeping track of time (Day and Night) 
        hour++; 
        if(hour == 12) {
            if(changeTime%2 == 0) {
                isDay = true; 
            } else {
                isDay = false; 
            }
            changeTime += 1;
            hour = 0; 
        }
        // Random rain 
        Random randomNumberWeather = new Random();
        int randomWeather = randomNumberWeather.nextInt(5);
        if(randomWeather < 4) {
            isRain = true;
        } else {
            isRain = false; 
        }
        // Provide space for newborn animals and plants
        List<Animal> newAnimals = new ArrayList<>(); 
        List<Plants> newPlants = new ArrayList<>();
        // Let all animals act and plants
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            if(animal instanceof Dragon) {
                if(isDay == false) {
                    animal.act(newAnimals);
                } else {
                    Dragon Dragon = (Dragon) animal;
                    Dragon.incrementAge();
                }
            } else {
                if(animal instanceof Tiger) {
                   if(isDay == true) {
                      animal.act(newAnimals);
                   } else {
                      Tiger Tiger = (Tiger) animal;
                      Tiger.incrementAge();
                   }  
                } else {
                   animal.act(newAnimals);
                }
            }
            // removes if it is dead. 
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        
        for(Iterator<Plants> it = plants.iterator(); it.hasNext(); ) {
            Plants plants = it.next();
            if(plants instanceof Grass && isRain == true) {
                plants.act(newPlants);
            } 
            // removes if it is dead. 
            if(! plants.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born Dragones and Goats to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
Dragon and Goat.",Simulator.java,17.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,17.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= Dragon_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Dragon Dragon = new Dragon(true, field, location);
                    animals.add(Dragon);
                }
                else if(rand.nextDouble() <= Goat_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Goat Goat = new Goat(true, field, location);
                    animals.add(Goat);
                }
                else if(rand.nextDouble() <= Tiger_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tiger Tiger = new Tiger(true, field, location);
                    animals.add(Tiger);
                }
                else if(rand.nextDouble() <= Boar_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Boar Boar = new Boar(true, field, location);
                    animals.add(Boar);
                }
                else if(rand.nextDouble() <= Deer_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Deer Deer = new Deer(true, field, location);
                    animals.add(Deer);
                }
                else if(rand.nextDouble() <= Grass_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass Grass = new Grass(true, field, location);
                    plants.add(Grass);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with Dragones and Goats and other animals.,Simulator.java,17.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,17.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,17.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,17.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,17.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,17.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,17.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,17.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,17.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,17.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,17.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,17.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,17.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,17.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,17.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,17.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,17.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,17.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,17.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,17.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,17.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,17.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,17.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,17.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,17.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,17.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,17.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,17.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,17.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,17.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,17.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,17.0,3
0,"public void act(List<Plants> newGrass)
    {
        incrementAge();
        if(isAlive()) {
            // It just grows 
            giveBirth(newGrass); 
        }
    }","This is what the Grass does most of the time.
In the process, it might breed
or die of old age.
@param field The field currently occupied.
@param newDragones A list to return newly born Dragones.",Grass.java,17.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Grass's death.,Grass.java,17.0,3
2,"private void giveBirth(List<Plants> newGrass)
    {
         // New Grass are born into adjacent locations.
         // Get a list of adjacent free locations.
         Field field = getField();
         List<Location> free = field.getFreeAdjacentLocations(getLocation());
         int births = breed();
         for(int b = 0; b < births && free.size() > 0; b++) {
             Location loc = free.remove(0);
             Grass young = new Grass(false, field, loc);
             newGrass.add(young);
         }
    }","Check whether or not this Grass is to give birth at this step.
New births will be made into free adjacent locations.
@param newDragones A list to return newly born Dragones.",Grass.java,17.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Grass.java,17.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Grass can breed if it has reached the breeding age.,Grass.java,17.0,3
0,"public void act(List<Animal> newTigeres)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newTigeres);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Tiger does most of the time: it hunts for
Goats. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newTigeres A list to return newly born Tigeres.",Tiger.java,17.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Tiger's death.,Tiger.java,17.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Tiger's death.,Tiger.java,17.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Tiger more hungry. This could result in the Tiger's death.,Tiger.java,17.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat Goat = (Goat) animal;
                if(Goat.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Goat.isInfected()) {
                        setInfected();
                    }
                    Goat.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Boar) {
                Boar Boar = (Boar) animal;
                if(Boar.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Boar.isInfected()) {
                        setInfected();
                    }
                    Boar.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Deer) {
                Deer Deer = (Deer) animal;
                if(Deer.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Deer.isInfected()) {
                        setInfected();
                    }
                    Deer.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Goats adjacent to the current location.
Only the first live Goat is eaten.
@return Where food was found, or null if it wasn't.",Tiger.java,17.0,3
5,"public void giveBirth(List<Animal> newTigeres)
    {
        if(findPartner() == true && FOOD_VALUE > 4) {
           // New Tigeres are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Tiger young = new Tiger(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newTigeres.add(young);
           }
        }
    }","Check whether or not this Tiger is to give birth at this step.
New births will be made into free adjacent locations.
@param newTigeres A list to return newly born Tigeres.",Tiger.java,17.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Tiger) {
                Tiger TigerPartner = (Tiger) animal;
                String partnerOneGender = getGender();
                String partnerGender = TigerPartner.getGender();
                // these tigers met and if one of them is infected 
                // then they all are infected 
                if(TigerPartner.isInfected() || isInfected()) {
                        TigerPartner.setInfected();
                        setInfected();
                }
                // continue with everything else 
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Tiger.java,17.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Tiger.java,17.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Tiger can breed if it has reached the breeding age.,Tiger.java,17.0,3
0,"protected String getGender()
    {
        return gender;
    }","Check the gender of an animal.
@return gender",Animal.java,17.0,3
1,"protected boolean isInfected()
    {
        return infected;
    }","Check if infected
@return infected",Animal.java,17.0,3
2,"protected void setInfected()
    {
        if(!infected) {
            infected = true;
        }
    }",The animal gets infected if it is not,Animal.java,17.0,3
3,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,17.0,3
4,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,17.0,3
5,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,17.0,3
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,17.0,3
7,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,17.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the Plants is alive or not.
@return true if the Plants is still alive.",Plants.java,17.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the Plants is no longer alive.
It is removed from the field.",Plants.java,17.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the Plants's location.
@return The Plants's location.",Plants.java,17.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the Plants at the new location in the given field.
@param newLocation The Plants's new location.",Plants.java,17.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the Plants's field.
@return The Plants's field.",Plants.java,17.0,3
0,"public void act(List<Animal> newDragones)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newDragones);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Dragon does most of the time: it hunts for
Goats. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newDragones A list to return newly born Dragones.",Dragon.java,17.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Dragon's death.,Dragon.java,17.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Dragon's death.,Dragon.java,17.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Dragon more hungry. This could result in the Dragon's death.,Dragon.java,17.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat Goat = (Goat) animal;
                if(Goat.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Goat.isInfected()) {
                        setInfected();
                    }
                    Goat.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Boar) {
                Boar Boar = (Boar) animal;
                if(Boar.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Boar.isInfected()) {
                        setInfected();
                    }
                    Boar.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Deer) {
                Deer Deer = (Deer) animal;
                if(Deer.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Deer.isInfected()) {
                        setInfected();
                    }
                    Deer.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Goats adjacent to the current location.
Only the first live Goat is eaten.
@return Where food was found, or null if it wasn't.",Dragon.java,17.0,3
5,"private void giveBirth(List<Animal> newDragones)
    {
        if(findPartner() && FOOD_VALUE > 7) {
           // New Dragones are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Dragon young = new Dragon(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newDragones.add(young);
           }
        }
    }","Check whether or not this Dragon is to give birth at this step.
New births will be made into free adjacent locations.
@param newDragones A list to return newly born Dragones.",Dragon.java,17.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dragon) {
                Dragon DragonPartner = (Dragon) animal;
                String partnerOneGender = getGender();
                String partnerGender = DragonPartner.getGender();
                // these dragons met and if one of them is infected 
                // then they all are infected 
                if(DragonPartner.isInfected() || isInfected()) {
                        DragonPartner.setInfected();
                        setInfected();
                }
                // continue with everything else 
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Dragon.java,17.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Dragon.java,17.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Dragon can breed if it has reached the breeding age.,Dragon.java,17.0,3
0,"public void act(List<Animal> newGoats)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newGoats);  
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Goat does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newGoats A list to return newly born Goats.",Goat.java,17.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Goat's death.",Goat.java,17.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Goat's death.,Goat.java,17.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Goat more hungry. This could result in the Goat's death.,Goat.java,17.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Goat.java,17.0,3
5,"private void giveBirth(List<Animal> newGoats)
    {
        if(findPartner() == true && FOOD_VALUE > 5) {
           // New Goats are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Goat young = new Goat(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newGoats.add(young);
           }
       }
    }","Check whether or not this Goat is to give birth at this step.
New births will be made into free adjacent locations.
@param newGoats A list to return newly born Goats.",Goat.java,17.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat GoatPartner = (Goat) animal;
                String partnerOneGender = getGender();
                String partnerGender = GoatPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(GoatPartner.isInfected() || isInfected()) {
                        GoatPartner.setInfected();
                        setInfected();
                }
                // nicer
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Goat.java,17.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Goat.java,17.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Goat can breed if it has reached the breeding age.
@return true if the Goat can breed, false otherwise.",Goat.java,17.0,3
0,"protected Location eat(Location where, Field field) {
        Object animal = field.getObjectAt(where).getKey();
        if(animal != null && foodValue.containsKey(animal.getClass())) {
            Animal prey = (Animal) animal;
            if(prey.isAlive()) { 
                increaseFoodLevel(foodValue.get(prey.getClass()));
                prey.setDead();
                return where;
            }
        }
        return null;
    }","If there is suitable animal at the specified location,
it gets eaten by the capacity for food the animal has available
and its location is returned. In other case null is returned
@param where where the potential food is
@param field the field on which everything happens
@return location where food has been eaten",Bear.java,73.0,3
1,"public Animal getYoung(Field field, Location loc) {
        return new Bear(false, field, loc);
    }","Returns a new young bear
@param field
@param loc
@return new instance of young animal",Bear.java,73.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,73.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,73.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,73.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,73.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,73.0,3
0,"protected Location eat(Location where, Field field) {
        Object plant = field.getObjectAt(where).getValue();
        if(plant != null) {
            Plant prey = (Plant) plant;
            if(prey.getLength() >= 2) {
                int amount = Math.min(getFoodCapacity(), (int) prey.getLength());
                increaseFoodLevel(amount);
                prey.getEaten(amount);
                return where;
            }
        }
        return null;
    }","If there is a plant higher than 2 at the specified location,
it gets eaten by the capacity for food the animal has available
and its location is returned. In other case null is returned
@param where where the potential food is
@param field the field on which everything happens
@return location where food has been eaten",Hare.java,73.0,3
1,"public Animal getYoung(Field field, Location loc) {
        return new Hare(false, field, loc);
    }","Returns a new young hare
@param field
@param loc
@return new instance of young animal",Hare.java,73.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,73.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,73.0,3
0,"protected Location eat(Location where, Field field) {
        Object animal = field.getObjectAt(where).getKey();
        if(animal != null && foodValue.containsKey(animal.getClass())) {
            Animal prey = (Animal) animal;
            if(prey.isAlive()) { 
                increaseFoodLevel(foodValue.get(prey.getClass()));
                prey.setDead();
                return where;
            }
        }
        return null;
    }","If there is suitable animal at the specified location,
it gets eaten by the capacity for food the animal has available
and its location is returned. In other case null is returned
@param where where the potential food is
@param field the field on which everything happens
@return location where food has been eaten",Bobcat.java,73.0,3
1,"public Animal getYoung(Field field, Location loc) {
        return new Bobcat(false, field, loc);
    }","Returns a new young bobcat
@param field
@param loc
@return new instance of young animal",Bobcat.java,73.0,3
0,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clearPlant(location);
        }
        location = newLocation;
        field.placePlant(this, newLocation);
    }","Place the plant at the given location
@param newLocation the location on which plant should be placed",Plant.java,73.0,3
1,"public void grow()
    {
        // put your code here
        if (length < MAX_LENGTH)
            length += GROWTH_RATE;
    }","Increment the plant's length by the growth rate specified,
only if the plant hasn't reached max length.",Plant.java,73.0,3
2,"protected void getEaten(int amount)
    {
        length -= amount;
    }","Decrement the plants length by the specified amount
after getting eaten.
@param amount eaten amount",Plant.java,73.0,3
3,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,73.0,3
4,"protected double getLength(){
        return length;
    }","Return the plant's length.
@return the plant's length",Plant.java,73.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,73.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,73.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,73.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,73.0,3
0,"protected Location eat(Location where, Field field) {
        Object plant = field.getObjectAt(where).getValue();
        if(plant != null) {
            Plant prey = (Plant) plant;
            if(prey.getLength() >= 2) { 
                int amount = Math.min(getFoodCapacity(), (int) prey.getLength());
                increaseFoodLevel(amount);
                prey.getEaten(amount);
                return where;
            }
        }
        return null;
    }","If there is a plant higher than 2 at the specified location,
it gets eaten by the capacity for food the animal has available
and its location is returned. In other case null is returned
@param where where the potential food is
@param field the field on which everything happens
@return location where food has been eaten",Deer.java,73.0,3
1,"public Animal getYoung(Field field, Location loc) {
        return new Deer(false, field, loc);
    }","Returns a new young deer
@param field
@param loc
@return new instance of young animal",Deer.java,73.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,73.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,73.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,73.0,3
3,"public void showStatus(int step, Field field, boolean isRaining)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                // creates a pair of objects to the plants and animals can coexist.
                Pair<Object, Object> location = field.getObjectAt(row, col);

                Object animal = location.getKey();

                Object plant = location.getValue();
                
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                    // If the animal is infected, draw a smaller mark on its square.
                    if(((Animal) animal).hasDisease()) {
                        stats.incrementInfectedCount();
                        fieldView.drawSmallMark(col, row, DISEASE_COLOR);
                    }
                }
                else if(plant != null && ((Plant) plant).getLength() > 2) {
                    stats.incrementCount(plant.getClass());
                    fieldView.drawMark(col, row, getColor(plant.getClass()));
                }
                else if(isRaining) {
                    fieldView.drawMark(col, row, RAIN_COLOR);       // If its raining change the field colour to the rain color.
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field) + ""Rain: "" + isRaining);
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,73.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,73.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,73.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);    // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,73.0,3
2,"public void simulateOneStep()
    {
        step++;
        // Change the time of day every 10 steps.
        if (step % NIGHT_LENGTH == 0) {
            night = !night;             
        }

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            if ((night && animal.isNocturnal()) || (!night && !animal.isNocturnal())) {
                animal.act(newAnimals);
            }
            else {
                animal.sleep();
            }
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        // randomly generates if its raining or not.
        isRaining = rand.nextBoolean();
        // Allows plants to grow only when raining.
        if (isRaining) {
            for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
                Plant plant = it.next();
                plant.grow();
            }
        }

        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field, isRaining);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
plant and animal.",Simulator.java,73.0,3
3,"public void reset()
    {
        step = 0;
        night = false;
        animals.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field, isRaining);
    }",Reset the simulation to a starting position.,Simulator.java,73.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= creationProbabilities.get(Bobcat.class)) {
                    Location location = new Location(row, col);
                    Bobcat bobcat = new Bobcat(true, field, location);
                    animals.add(bobcat);
                }
                else if(rand.nextDouble() <= creationProbabilities.get(Hare.class)) {
                    Location location = new Location(row, col);
                    Hare hare = new Hare(true, field, location);
                    animals.add(hare);
                }
                else if(rand.nextDouble() <= creationProbabilities.get(Deer.class)) {
                    Location location = new Location(row, col);
                    Deer deer = new Deer(true, field, location);
                    animals.add(deer);
                }
                else if(rand.nextDouble() <= creationProbabilities.get(Bear.class)) {
                    Location location = new Location(row, col);
                    Bear bear = new Bear(true, field, location);
                    animals.add(bear);
                }
                else if(rand.nextDouble() <= creationProbabilities.get(Squirrel.class)) {
                    Location location = new Location(row, col);
                    Squirrel squirrel = new Squirrel(true, field, location);
                    animals.add(squirrel);
                }

                if(rand.nextDouble() <= creationProbabilities.get(Plant.class)) {
                    Location location = new Location(row, col);
                    Plant plant = new Plant(field, location);
                    plants.add(plant);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with animals.,Simulator.java,73.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,73.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }

        buffer.append(infected.getName() + "": "" + infected.getCount() + ' ');        // Describes the number of infected species.

        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,73.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }

        infected.reset();
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,73.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,73.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,73.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,73.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col).getKey();
                if(animal != null) {
                    incrementCount(animal.getClass());

                    if(((Animal) animal).hasDisease()) {
                        infected.increment();       // increment te infected counter.   
                    }
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of plants and animals.
These are not kept up to date as plants and animals
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,73.0,3
6,"public void incrementInfectedCount() {
        infected.increment();
    }",Increment the infected counter.,FieldStats.java,73.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,73.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,73.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,73.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,73.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,73.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,73.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,73.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,73.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,73.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,73.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,73.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,73.0,3
0,"protected Location eat(Location where, Field field) {
        Object plant = field.getObjectAt(where).getValue();
        if(plant != null) {
            Plant prey = (Plant) plant;
            if(prey.getLength() >= 2) { 
                int amount = Math.min(getFoodCapacity(), (int) prey.getLength());
                increaseFoodLevel(amount);
                prey.getEaten(amount);
                return where;

            }
        }
        return null;
    }","If there is a plant higher than 2 at the specified location,
it gets eaten by the capacity for food the animal has available
and its location is returned. In other case null is returned
@param where where the potential food is
@param field the field on which everything happens
@return location where food has been eaten",Squirrel.java,73.0,3
1,"public Animal getYoung(Field field, Location loc) {
        return new Squirrel(false, field, loc);
    }","Returns a new young squirrel
@param field
@param loc
@return new instance of young animal",Squirrel.java,73.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = new Pair<Object, Object>(null, null);
            }
        }
    }",Empty the field.,Field.java,73.0,3
1,"public void clearAnimal(Location location)
    {
        field[location.getRow()][location.getCol()] = new Pair(null, field[location.getRow()][location.getCol()].getValue());
    }","Clear the given location.
@param location The location to clear.",Field.java,73.0,3
2,"public void clearPlant(Location location)
    {
        field[location.getRow()][location.getCol()] = new Pair(field[location.getRow()][location.getCol()].getKey(), null);
    }","Clear the given location.
@param location The location to clear.",Field.java,73.0,3
3,"public void place(Object organism, int row, int col)
    {
        place(organism, new Location(row, col));
        	
    }","Place an organism at the given location.
@param organism The organism to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,73.0,3
4,"public void place(Object organism, Location location)
    {
        if(organism instanceof Plant)
        	field[location.getRow()][location.getCol()] = 
        				new Pair(field[location.getRow()][location.getCol()]
        				.getKey(), organism);
        else
        	field[location.getRow()][location.getCol()] = 
        				new Pair(organism, field[location.getRow()][location.getCol()]
        				.getValue());
    }","Place an organism at the given location.
If there is already an organism at the location it will
be lost.
@param organism The organism to be placed.
@param location Where to place the animal.",Field.java,73.0,3
5,"public void placePlant(Object plant, Location location)
    {
        field[location.getRow()][location.getCol()] = new Pair(field[location.getRow()][location.getCol()].getKey(), plant);
    }","Place a plant at the given location.
If there is already a plant at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,73.0,3
6,"public Pair<Object, Object> getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal and plant at the given location, if any.
@param location Where in the field.
@return Pair with animal (or null) as a key and plant (or null) as a value at the given location",Field.java,73.0,3
7,"public Pair<Object,Object> getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal and plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return Pair with animal (or null) as a key and plant (or null) as a value at the given location",Field.java,73.0,3
8,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,73.0,3
9,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next).getKey() == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,73.0,3
10,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,73.0,3
11,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,73.0,3
12,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,73.0,3
13,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,73.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the animal's death.",Animal.java,73.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(hasDisease) {
            foodLevel--;
        }
        if(foodLevel <= 0) {
            setDead();
        }
    }","Decrements the foodlevel of the animal.
If the animal has the disease, foodlevel
decrements by 2.
This could result in the animal's death.",Animal.java,73.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            where = eat(where, field);

            if(where != null)
                return where;
        }
        return null;
    }","Look for animals adjacent to the current location.
Only the first live animal is eaten.
@return Where food was found, or null if it wasn't.",Animal.java,73.0,3
3,"private void giveBirth(List<Animal> newAnimals)
    {
        // New animals are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Animal young = getYoung(field, loc);

            if (hasDisease) {
                young.getDisease();
            }

            newAnimals.add(young);
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newDeers A list to return newly born animals.",Animal.java,73.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A animal can breed if it has reached the breeding age.
@return true if the animal can breed, false otherwise.",Animal.java,73.0,3
5,"private Animal hasPartner() {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());

        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where).getKey();
            if(animal != null && this.getClass() == animal.getClass() && !((Animal) animal).isFemale()) {
                return (Animal) animal;
            }
        }

        return null;
    }","Checks whether an animal has a partner of the opposite gender in an nearby location.
@return the partner if the above is the case.",Animal.java,73.0,3
6,"private int breed()
    {
        int births = 0;
        Animal partner = hasPartner();
        if(canBreed() && partner != null && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;

            if(hasDisease && !partner.hasDisease()){
                partner.getDisease();
            }
            if(partner.hasDisease() && !hasDisease()) {
                getDisease();
            }
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,73.0,3
7,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,73.0,3
8,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clearAnimal(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,73.0,3
9,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,73.0,3
10,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clearAnimal(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,73.0,3
11,"public void act(List<Animal> newAnimals)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newAnimals);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

            // during every step there is some probability of getting infected, e.g. through a wound
            if(rand.nextInt(DISEASE_PROBABILITY) == 0 && !hasDisease)
                getDisease();
            else
                hasDisease = false;
        }
    }","This is what the animal does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newAnimals A list to return newly born animals.",Animal.java,73.0,3
12,"public void sleep() {
        incrementAge();
        incrementHunger();
    }","Imitates sleeping. Animal gets older and more
hungry but doesn't move or breed.",Animal.java,73.0,3
13,"protected void increaseFoodLevel(int foodValue)
    {   
        foodLevel += foodValue;

        if (foodLevel > MAX_FOOD_LEVEL) {
            foodLevel = MAX_FOOD_LEVEL;
        }
    }","Increase the animal's foodlevel by the amount specified.
If the food level is above the max, keep it at the maximum.
@param foodValue value of eaten food",Animal.java,73.0,3
14,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,73.0,3
15,"public boolean isFemale() {
        return isFemale;
    }","Return if the animal is female.
@return if the animal is female.",Animal.java,73.0,3
16,"protected boolean isNocturnal() {
        return isNocturnal;
    }","Return if the animal is nocturnal.
@return if the animal is nocturnal.",Animal.java,73.0,3
17,"private void getDisease(){
        hasDisease = true;

        MAX_AGE *= 0.8;
    }","Give the animal a disease,
and decrease lifespan by 20%.",Animal.java,73.0,3
18,"public boolean hasDisease(){
        return hasDisease;
    }","Return if the animal is infected.
@return if the animal is infected.",Animal.java,73.0,3
19,"public int getFoodCapacity() {
        return MAX_FOOD_LEVEL - foodLevel;
    }","Return the animal's capacity for food.
@return The animal's capacity for food.",Animal.java,73.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,622.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,622.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,622.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,622.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Gazelle(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Gazelle.java,622.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,622.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Hyena(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Hyena.java,622.0,3
0,"public String getCurrentWeather()
    {
        return(currentWeather);
    }","Accessor function for current weather
@return The current wether of the simulation",Weather.java,622.0,3
1,"public void act(List<Species> species) {
        switch(currentWeather) {
            case ""Clear"":
                actClear(species);
                return;
            case ""Sunny"":
                actSunny(species);
                return;
            case ""Rain"":
                actRain(species);
                return;
            case ""Storm"":
                actStorm(species);
                return;
            default:
                return;
        }
    }","Function to run effects of current weather
@param species - List type of all species that are alive",Weather.java,622.0,3
2,"public void actClear(List<Species> species) {
        if (weatherCooldown > 0) {
            return;
        } else {
            if (rand.nextDouble() <= SUNNY_PROBABILITY) {
                currentWeather = ""Sunny"";
            } else if (rand.nextDouble() <= RAIN_PROBABILITY) {
                currentWeather = ""Rain"";
            } else if (rand.nextDouble() <= STORM_PROBABILITY) {
                currentWeather = ""Storm"";
            } else {
                return;
            }
            weatherCooldown = rand.nextInt(20);
            weatherLength = rand.nextInt(200);
            weatherInstantiate = true;
            postWeatherEffectsLength = rand.nextInt(30);
        }
    }","Function to run effects of clear weather
Generates random int and chooses if new weather
@param species - List type of all species that are alive",Weather.java,622.0,3
3,"public void actSunny(List<Species> species) {
        if (weatherInstantiate) {
            postWeatherEffectsLength = 1;
            weatherCooldown = 0;
        } else if (weatherLength > 0) {
            weatherLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(2);
                }
            }
            return;
        } else if (postWeatherEffectsLength > 0) {
            postWeatherEffectsLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(1);
                }
            }
            return;
        } else {
            currentWeather = ""Clear"";
        }
    }","Function to run effects of sunny weather
doubles breed prob of plants
@param species - List type of all species that are alive",Weather.java,622.0,3
4,"public void actRain(List<Species> species) {
        if (weatherInstantiate) {
            postWeatherEffectsLength = 1;
            weatherCooldown = 0;
        } else if (weatherLength > 0) {
            weatherLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(2);
                }
            }
            return;
        } else if (postWeatherEffectsLength > 0) {
            postWeatherEffectsLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(1);
                }
            }
            return;
        } else {
            currentWeather = ""Clear"";
        }
    }","Function to run effects of raining weather
doubles breed prob of plants
@param species - List type of all species that are alive",Weather.java,622.0,3
5,"public void actStorm(List<Species> species) {
        if (weatherInstantiate) {
            postWeatherEffectsLength = 1;
            weatherCooldown = 0;
        } else if (weatherLength > 0) {
            weatherLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(0.5);
                }
                if (rand.nextInt(10000) <= 1) {
                    _species.setDead();
                }
            }
            return;
        } else if (postWeatherEffectsLength > 0) {
            postWeatherEffectsLength--;
            for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
                Species _species = it.next();
                if (_species instanceof Plant) {
                    Plant plant = (Plant) _species;
                    plant.setBreedingProbMult(1);
                }
            }
            return;
        } else {
            currentWeather = ""Clear"";
        }
    }","Function to run effects of stormy weather
halves breed prob of plants and has random chance of death
@param species - List type of all species that are alive",Weather.java,622.0,3
0,"public void act(List<Species> newPlants, Clock clock)
    {
        incrementAge();
        if(isAlive()) {
            if (!clock.isNight())
                giveBirth(newPlants);
        }
    }","Function of plants tasks / acts, plant carries out tasks set such as aging or breeding.
@param newPlants - List Type Species to return newly born plants.",Plant.java,622.0,3
1,"public String getKeyIdentifier() {
        return keyIdentifier;
    }","Accessor function for Key Identifier
REDUNDANT
@return keyIdentifier - Type String",Plant.java,622.0,3
2,"public int getFoodLevel() {
        return foodLevel;
    }","Accessor function for Food Level
@return foodLevel - Type Int",Plant.java,622.0,3
3,"public int getFoodValue() {
        return foodValue;
    }","Accessor function for Food Value
@return foodValue - Type Int",Plant.java,622.0,3
4,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase Age and Check For Death By Max Age.,Plant.java,622.0,3
5,"private void giveBirth(List<Species> newPlants)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            
            createChild(newPlants, false, field, loc);
        }
    }","Function to check and birth plants adjascent to this plant.
@param newPlants - List type of Species to append new plants to.",Plant.java,622.0,3
6,"public void createChild(List<Species> newPlants, boolean randomAge, Field field, Location location)
    {
        //newPlants.add();
        ;    
    }","Override function utilised to create child instances of subclass and append to Species.
@param newPlants - List type species for appending new plants to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field plant is on.
@param location - Location type depicting location on field of plant.",Plant.java,622.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY * BREEDING_PROBABILITY_MULT) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate random number clamped between zero and max litter.
@return births - Int type of number of births.",Plant.java,622.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","Boolean checking if animal can breed.
@return canBreed - boolean type.",Plant.java,622.0,3
9,"public void setBreedingProbMult(double breedProb) {
        BREEDING_PROBABILITY_MULT = breedProb;
    }","Mutator func for breed prob mult
@param - double breed prob mult",Plant.java,622.0,3
10,"public double getBreedingProb() {
        return BREEDING_PROBABILITY_MULT;
    }","Accessor func for breed prob mult
@return - double breed prob mult",Plant.java,622.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,622.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,622.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,622.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,622.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,622.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,622.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,622.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,622.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,622.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,622.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,622.0,3
2,"public void simulateOneStep()
    {
        clock.tick(step);
        step++;

        // Provide space for newborn species.
        List<Species> newSpecies = new ArrayList<>();        
        // Let all species act.
        for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
            Species species = it.next();
            species.act(newSpecies, clock);
            if(! species.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born species to the main lists.
        species.addAll(newSpecies);
        weather.act(species);
        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
instance of species",Simulator.java,622.0,3
3,"public void reset()
    {
        step = 0;
        species.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
        
        // Auto run simulation
        runLongSimulation();
    }",Reset the simulation to a starting position.,Simulator.java,622.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= Lion_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lion Lion = new Lion(true, field, location);
                    species.add(Lion);
                }
                else if(rand.nextDouble() <= GAZELLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Gazelle gazelle = new Gazelle(true, field, location);
                    species.add(gazelle);
                }
                else if(rand.nextDouble() <= HYENA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Hyena hyena = new Hyena(true, field, location);
                    species.add(hyena);
                }
                else if(rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Zebra zebra = new Zebra(true, field, location);
                    species.add(zebra);
                }
                else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    species.add(grass);
                }
                else if(rand.nextDouble() <= WILDEBEAST_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Wildebeast wildebeast = new Wildebeast(true, field, location);
                    species.add(wildebeast);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with animals,Simulator.java,622.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Zebra(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Zebra.java,622.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        buffer.append("" | Weather: "");
        buffer.append(weather.getCurrentWeather());
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,622.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,622.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,622.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,622.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,622.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and gazelles.
These are not kept up to date as foxes and gazelles
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,622.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,622.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,622.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,622.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,622.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,622.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,622.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,622.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,622.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,622.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,622.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,622.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,622.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,622.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,622.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,622.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,622.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,622.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,622.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,622.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,622.0,3
8,"public List<Location> getFreeAnimalAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            } else if (getObjectAt(next) instanceof Plant) {
                free.add(next);
                Plant plant = (Plant) getObjectAt(next);
                plant.setDead();
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,622.0,3
9,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,622.0,3
10,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,622.0,3
11,"public List<Location> fiveAdjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -5; roffset <= 5; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -5; coffset <= 5; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,622.0,3
12,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,622.0,3
13,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Lion(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Lion.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Grass(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newPlants - List type species for appending new plants to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field plant is on.
@param location - Location type depicting location on field of plant.",Grass.java,622.0,3
0,"public void act(List<Species> newAnimals, Clock clock)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (clock.isNight() != doesSleep)
                giveBirth(newAnimals);            
            // Move towards a source of food if found. if hungry
            Location newLocation = null;
            if (foodLevel < DEFAULT_FOOD_VALUE)
                newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                if (clock.isNight() != doesSleep)
                    setLocation(newLocation);
            } else {
                Field field = getField();
                newLocation = field.randomAdjacentLocation(getLocation());
                if (field.getObjectAt(newLocation) instanceof Plant) {
                    Plant inTheWay = (Plant) field.getObjectAt(newLocation);
                    inTheWay.setDead();
                    setLocation(newLocation);
                } else {
                    this.setDead();
                }
            }
        }
    }","Function of animals tasks / acts, animal carries out tasks set such as hunting or breeding.
@param newAnimals - List Type Species to return newly born animals.",Animal.java,622.0,3
1,"public String getKeyIdentifier() {
        return keyIdentifier;
    }","Accessor function for Key Identifier
REDUNDANT
@return keyIdentifier - Type String",Animal.java,622.0,3
2,"public int getFoodLevel() {
        return foodLevel;
    }","Accessor function for Food Level
@return foodLevel - Type Int",Animal.java,622.0,3
3,"public int getFoodValue() {
        return foodValue;
    }","Accessor function for Food Value
@return foodValue - Type Int",Animal.java,622.0,3
4,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase Age and Check For Death By Max Age.,Animal.java,622.0,3
5,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase Hunger by reducing food level, check for death by starvation.",Animal.java,622.0,3
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(isAnimalPrey(animal)) {
                Animal prey = (Animal) animal;
                if(prey.isAlive()) { 
                    prey.setDead();
                    foodLevel += prey.getFoodValue();
                    return where;
                }
            } else if(isPlantPrey(animal)) {
                Plant prey = (Plant) animal;
                if(prey.isAlive()) { 
                    prey.setDead();
                    foodLevel += prey.getFoodValue();
                    return where;
                }
            }
        }
        return null;
    }","Look for prey adjacent to the current location. Hunt and move to first prey found.
@return where - Location type of prey.",Animal.java,622.0,3
7,"private boolean isAnimalPrey(Object _species) 
    {
        if (_species instanceof Animal) {
            Animal animal = (Animal) _species;
            String animalID = animal.getKeyIdentifier();
            for (String preyID : preyKeyIdentifiers) {
                if (preyID.equals(animalID)) {
                    return true;
                }
            }
        }
        return false;
    }","Funtion dedicated to identifying if an an instance of species is prey to the page animal.
@return isprey - Boolean type",Animal.java,622.0,3
8,"private boolean isPlantPrey(Object _species) 
    {
        if (_species instanceof Plant) {
            Plant plant = (Plant) _species;
            String plantID = plant.getKeyIdentifier();
            for (String preyID : preyKeyIdentifiers) {
                if (preyID.equals(plantID)) {
                    return true;
                }
            }
        }
        return false;
    }","Funtion dedicated to identifying if an an instance of species is prey to the page animal.
@return isprey - Boolean type",Animal.java,622.0,3
9,"private boolean foundMatch(Object _species)
    {
        if(_species instanceof Animal)
        {
            Animal animal = (Animal) _species;
            if(animal.getKeyIdentifier().equals(keyIdentifier))
            {
                if(animal.getGenderIsMale() != genderIsMale)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            
            else
            {
                return false;
            }
        }
        return false;
    }","Method which returns true if the animal has found an animal of the same species
and the animal is opposite gender.",Animal.java,622.0,3
10,"private boolean foundMate()
    {
        Field field = getField();
        List<Location> adjacent = field.fiveAdjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(foundMatch(animal)) 
            {
                return (true);
            } 
        }
        return false;
    }","A method which checks all adjecent spaces for a mate,
returns true if one is found and false if one is not found",Animal.java,622.0,3
11,"private void giveBirth(List<Species> newAnimals)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        if(foundMate())
        {
            for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            
            createChild(newAnimals, false, field, loc);
            }
        }
    }","Function to check and birth animals adjascent to this animal.
@param newAnimals - List type of Species to append new animals to.",Animal.java,622.0,3
12,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        //newAnimals.add();
        ;    
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Animal.java,622.0,3
13,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate random number clamped between zero and max litter.
@return births - Int type of number of births.",Animal.java,622.0,3
14,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","Boolean checking if animal can breed.
@return canBreed - boolean type.",Animal.java,622.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Species.java,622.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Species.java,622.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Species.java,622.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Species.java,622.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Species.java,622.0,3
5,"protected boolean getGenderIsMale()
    {
        return(genderIsMale);
    }","Return the animal's gender, in boolean form.
True meaning that the animal is a male.",Species.java,622.0,3
0,"public void tick(int step) {
        tick = step;
        isNight = !isNight;
    }","Function which increments the tick based on main programs tick
@param int step",Clock.java,622.0,3
1,"public boolean isNight() {
        return isNight;
    }","Accessor func for isNight
@return boolean isnight",Clock.java,622.0,3
0,"public void createChild(List<Species> newAnimals, boolean randomAge, Field field, Location location)
    {
        newAnimals.add(new Wildebeast(randomAge, field, location));
    }","Override function utilised to create child instances of subclass and append to Species.
@param newAnimals - List type species for appending new animals to
@param randomage - Boolean type depicting random age preconfiguration
@param field - Field type depicting field animal is on.
@param location - Location type depicting location on field of animal.",Wildebeast.java,622.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,291.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,291.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,291.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,291.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,291.0,3
0,"public void act(List<Animal> newOwls)
     {
        incrementAge();
        incrementHunger();
        deathByAge();
        overComeDisease();
        setInfectedAge(25,40);
         if(isAlive() ) {

            giveBirth(newOwls);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the owl does most of the time: it hunts for
owls. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newowles A list to return newly born owles.",Owl.java,291.0,3
1,"private void giveBirth(List<Animal> newOwls)
        {
        // New owles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Owl young = new Owl(false, field, loc);
            newOwls.add(young);
         }
       }","Check whether or not this owl is to give birth at this step.
New births will be made into free adjacent locations.
@param newowles A list to return newly born owles.",Owl.java,291.0,3
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Worm) {
                Worm worm = (Worm) animal;
                if(worm.isAlive()) { 
                    if (worm.getAge()<7){
                        worm.setDead();
                        setFoodLevel( getFoodLevel() + WORM_FOOD_VALUE);
                        if(getFoodLevel() > 10)
                        {
                            setFoodLevel(10);
                        }
                        return where;
                }
                }
            }
        }
        return null;
    }","Look for worms adjacent to the current location.
Only the first live worm is eaten.
@return Where food was found, or null if it wasn't.",Owl.java,291.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,291.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,291.0,3
0,"public void act(List<Animal> newEagles)
    {
        incrementAge();
        incrementHunger();
        deathByAge();
        overComeDisease();
        setInfectedAge(30,50);
        if(isAlive()) {
            giveBirth(newEagles);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the eagle does most of the time: it hunts for
worms. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newEagles A list to return newly born eagles.",Eagle.java,291.0,3
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Squirrel) {
                Squirrel squirel = (Squirrel) animal;
                if(squirel.isAlive()) { 
                    if (squirel.getAge()<7){
                        squirel.setDead();
                        setFoodLevel( getFoodLevel() + SQUIREL_FOOD_VALUE);
                        if(getFoodLevel() > 10)
                        {
                            setFoodLevel(10);
                        }
                        return where;
                }
                }
            }
            else if(animal instanceof Worm)
            {
                Worm worm = (Worm) animal;
                if (worm.isAlive())
                {
                    worm.setDead();
                    setFoodLevel( getFoodLevel() + WORM_FOOD_VALUE);
                    if(getFoodLevel()> 10)
                    {
                        setFoodLevel(10);
                    }
                    return where;
                }
            }
             else if(animal instanceof Owl)
            {
                Owl owl = (Owl) animal;
                if (owl.isAlive())
                {
                    owl.setDead();
                    setFoodLevel( getFoodLevel() + OWL_FOOD_VALUE);
                    if(getFoodLevel()> 10)
                    {
                        setFoodLevel(10);
                    }
                    return where;
                }
            }
        }
        return null;
    }","Look for worms adjacent to the current location.
Only the first live animal found is eaten.
@return Where food was found, or null if it wasn't.",Eagle.java,291.0,3
2,"private void giveBirth(List<Animal> newEagles)
    {
        // New eagles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Eagle young = new Eagle(false, field, loc);
            newEagles.add(young);
        }
    }","Check whether or not this eagle is to give birth at this step.
New births will be made into free adjacent locations.
@param newEagles A list to return newly born eagles.",Eagle.java,291.0,3
0,"private void fill_weather_map()
    {
        weather_map.put(""Clear"",true);
        weather_map.put(""Rain"",false);
        weather_map.put(""Storm"",false);
        weather_map.put(""Cloudy"",false);
    }",initialises the map of weather states,Weather.java,291.0,3
1,"public void change_weather()
    {
        int new_weather_index = randomGenerator.nextInt(4);
        if (new_weather_index == 0)
        {
            weather_map.put(""Clear"",true);
            weather_map.put(""Rain"",false);
            weather_map.put(""Storm"",false);
            weather_map.put(""Cloudy"",false);
        }
        else if(new_weather_index == 1)
        {
            weather_map.put(""Clear"",false);
            weather_map.put(""Rain"",true);
            weather_map.put(""Storm"",false);
            weather_map.put(""Cloudy"",false);
        }
        else if (new_weather_index == 2)
        {
            weather_map.put(""Clear"",false);
            weather_map.put(""Rain"",false);
            weather_map.put(""Storm"",true);
            weather_map.put(""Cloudy"",false);
        }
        else if (new_weather_index == 3)
        {
            weather_map.put(""Clear"",false);
            weather_map.put(""Rain"",false);
            weather_map.put(""Storm"",false);
            weather_map.put(""Cloudy"",true);
        }
    }",A method to change the weather randomly,Weather.java,291.0,3
2,"public String get_weather()
    {
        String current_weather;
        for (String weather: weather_map.keySet())
        {
            if (weather_map.get(weather) == true)
            {
                return weather;
            }
        }
        return ""none"";
    }",A method to return the current weather in the simulator,Weather.java,291.0,3
0,"public static void setTime(int newTime)
    {
        time = newTime;
        daysPassed = 0;
        currentTime = time/10;
    }",A method to set a new time,Time.java,291.0,3
1,"public static void incrementTime()
    {
        time++;
        if (time>= 240)
        {
            time=0;
            daysPassed++;
        }
        currentTime = time/10;
       }","The method to increment time.
And set current time to a more suitable format",Time.java,291.0,3
2,"public static String getStringTime()
    {
        String timeString = (""Time: ""+ currentTime + "":00 and Days Passed: "" + daysPassed); 
        return timeString;
    }","A method to return the time and days elapsed to be displayed on the GUI
Stored as a string",Time.java,291.0,3
3,"public static void setTimeOfDay()
    {
        incrementTime();
        if (time>=0 && time < 70) // night
        {
            night = true;
            evening = false;
            afternoon = false;
            morning = false;
        }
        else if (time>=70 && time < 120) // morning
        {
            night = false;
            evening = false;
            afternoon = false;
            morning = true;
        }
        else if (time>=120 && time < 170) // afternoon
        {
            night = false;
            evening = false;
            afternoon = true;
            morning = false;
        }
        else // evening
        {
            night = false;
            evening = true;
            afternoon = false;
            morning = false;
        }
    }",A method to set the time of day.,Time.java,291.0,3
4,"public static boolean getMorning()
    {
        return morning;
    }",Returns whether it is the morning.,Time.java,291.0,3
5,"public static boolean getNight()
    {
        return night;
    }",Returns whether it is the night.,Time.java,291.0,3
6,"public static boolean getEvening()
    {
        return evening;
    }",Returns whether it is the evening.,Time.java,291.0,3
7,"public static boolean getAfternoon()
    {
        return afternoon;
    }",Returns whether it is the afternoon.,Time.java,291.0,3
8,"public static int getDays()
    {
        return daysPassed;
    }",Returns the no. of days elapsed.,Time.java,291.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,291.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,291.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,291.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,291.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,291.0,3
2,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,291.0,3
3,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,291.0,3
4,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,291.0,3
5,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,291.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,291.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,291.0,3
2,"public void simulateOneStep()
    {
        step++;
        if (step % 10 == 0) // every 40 steps
        {
            weather_machine.change_weather(); // change the weather
        }
       
        field.getFieldTime().setTimeOfDay();// This changes the time of day
        
        setBackgroundColor(); //This uses the time of day to set a background colour

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();    
        List<Plants> newPlants = new ArrayList<>();
        // Let all rabbits act.
        
        for(Iterator<Plants> it = plants.iterator(); it.hasNext(); ) {
            Plants plants = it.next();

            plants.act(newPlants);

            
            if(! plants.isAlive()) {
                it.remove();
            }
        }  
        
      
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
             Animal animal = it.next();
            if (field.getFieldTime().getMorning() == false && (animal.getNocturnal() == true) )//nocturnal animals sleep in the morning
            {
                animal.act(newAnimals);
            }
            else if (field.getFieldTime().getNight() == false && animal.getNocturnal() == false)//Animals should be asleep at night
            {
                animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
            }
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);
        plantsInRain();
        view.setInfoText(field.getFieldTime().getStringTime()+"" the weather is: ""+weather_machine.get_weather());
        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,291.0,3
3,"public void reset()
    {
        step = 0;
        field.getFieldTime().setTime(0);
        animals.clear();
        plants.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
        view.setInfoText(field.getFieldTime().getStringTime());
    }",Reset the simulation to a starting position.,Simulator.java,291.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SQUIREL_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Squirrel squirel = new Squirrel(true, field, location);
                    animals.add(squirel);
                }
                else if(rand.nextDouble() <= WORM_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Worm worm = new Worm(true, field, location);
                    animals.add(worm); 
                }
                else if(rand.nextDouble() <= EAGLE_CREATION_PROBABILITY)
                {
                  Location location = new Location(row, col);
                  Eagle eagle = new Eagle(true, field, location);
                  animals.add(eagle);  
                }

                else if(rand.nextDouble() <= OWL_CREATION_PROBABILITY)
                {
                  Location location = new Location(row, col);
                  Owl owl = new Owl(true, field, location);
                  animals.add(owl);   
                }
                  else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY)
                {
                  Location location = new Location(row, col);
                  Grass grass = new Grass(field, location);
                  plants.add(grass);  

                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with wildlife.,Simulator.java,291.0,3
5,"private void populatePlants()
    {
            Random rand = Randomizer.getRandom();
            for(int row = 0; row < field.getDepth(); row++) {
                for(int col = 0; col < field.getWidth(); col++) {
                     if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY)
                      {
                          Location location = new Location(row, col);
                          if (field.getObjectAt(location)==null)
                          {
                              Grass grass = new Grass(field, location);
                              plants.add(grass);
                            }
                }
            }
    }
    }",This will find free locations within the field and spawn in grass at a random probability,Simulator.java,291.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,291.0,3
7,"private void setBackgroundColor()
    {
        if (field.getFieldTime().getNight())
        {
            view.setEmptyColor(Color.black);
        }
        else if (field.getFieldTime().getMorning())
        {
            view.setEmptyColor(Color.white);
        }
        else
        {
            view.setEmptyColor(Color.gray);
        }
    }",This changes the background color based on the time of day e.g. Night time is black.,Simulator.java,291.0,3
8,"private void plantsInRain()
    { 
        if(weather_machine.get_weather() == ""Rain"")
        {
            populatePlants();
        }
    }",This checks to see if it is raining - if so plants will grow in any location that is free,Simulator.java,291.0,3
0,"protected boolean getNocturnal()
    {
        return isNocturnal;
    }",returns current weather in the simulation,Actor.java,291.0,3
2,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","An example of a method - replace this comment with your own

@param  y  a sample parameter for a method
@return    the sum of x and y",Actor.java,291.0,3
3,"protected Field getField()
    {
        return field;
    }","*
Returns the field",Actor.java,291.0,3
5,"protected Location getLocation()
    {
        return location;
    }","Return the actors's location.
@return The actors's location.",Actor.java,291.0,3
6,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Actor.java,291.0,3
7,"protected int getAge()
    {
        return age;
    }","*
Return age",Actor.java,291.0,3
8,"protected void setAge(int newAge)
    {
        age = newAge;
    }","*
set age",Actor.java,291.0,3
9,"protected int getMaxAge()
     {
        return maxAge;
    }","*
Return maxAge",Actor.java,291.0,3
10,"protected void setMaxAge(int newAge)
    {
        maxAge = newAge;
    }","*
set age",Actor.java,291.0,3
11,"protected void incrementAge()
    {
        age++;
    }","*
increment age",Actor.java,291.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append("": "");
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,291.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,291.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,291.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,291.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,291.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,291.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,291.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,291.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,291.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,291.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,291.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,291.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,291.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,291.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,291.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,291.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,291.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,291.0,3
0,"public void act(List<Animal> newSquirreles)
    {
        incrementAge();
        incrementHunger();
        deathByAge();
        overComeDisease();
        setInfectedAge(30,70);
        if(isAlive()) {
            giveBirth(newSquirreles);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the squirrel does most of the time: it hunts for
WORMs. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSquirrels A list to return newly born squirreles.",Squirrel.java,291.0,3
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Worm) {
                Worm worm = (Worm) animal;
                if(worm.isAlive()) { 
                    worm.setDead();
                    setFoodLevel(getFoodLevel()+WORM_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for WORMs adjacent to the current location.
Only the first live WORM is eaten.
@return Where food was found, or null if it wasn't.",Squirrel.java,291.0,3
2,"private void giveBirth(List<Animal> newSquirrels)
    {
        // New squireles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Squirrel young = new Squirrel(false, field, loc);
            newSquirrels.add(young);
        }
    }","Check whether or not this squirel is to give birth at this step.
New births will be made into free adjacent locations.
@param newsquireles A list to return newly born squireles.",Squirrel.java,291.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",A method to change the weather randomly.,Field.java,291.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,291.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,291.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,291.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,291.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,291.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,291.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,291.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,291.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,291.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,291.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,291.0,3
0,"public void act(List<Animal> newworms)
    {
        incrementAge();
        deathByAge();
        incrementHunger();
        overComeDisease();
        setInfectedAge(20,30);
        if(isAlive()){
            giveBirth(newworms);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if (newLocation == null)
            {
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the worm does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newworms A list to return newly born worms.",Worm.java,291.0,3
1,"private void giveBirth(List<Animal> newworms)
    {
        // New worms are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Worm young = new Worm(false, field, loc);
            newworms.add(young);
        }
    }","Check whether or not this worm is to give birth at this step.
New births will be made into free adjacent locations.
@param newworms A list to return newly born worms.",Worm.java,291.0,3
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Grass) {
                Grass grass = (Grass) plant;
                if(grass.isAlive()) { 
                    grass.setDead();
                    setFoodLevel(getFoodLevel()+GRASS_FOOD_VALUE);
                    if (getFoodLevel()>10)
                    {
                        setFoodLevel(10);
                    }
                    return where;
                }
            }
        }
        return null;
    }","Look for worms adjacent to the current location.
Only the first live grass found is eaten.
@return Where food was found, or null if it wasn't.",Worm.java,291.0,3
1,"public void grow(List<Plants> newGrass)
    {
        if(isAlive())
        {
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if (newLocation != null)
            {
                if(rand.nextDouble() <= getFertility())
                {    
                    Grass grownGrass = new Grass(getField(),newLocation); 
                    newGrass.add(grownGrass);
                }
            }
        }
    }","If the plant is still alive the grass will find a location adjacent to it that is free
and then there is a probability that it will create a new object at that free location
this is then added to the list of plants which is the parameter",Grass.java,291.0,3
0,"public boolean getNight()
     {
       if (getField().getFieldTime().getNight())
       {
           return true;
        }
       return false;
    }","*
This returns the boolean night that is stored within field",Animal.java,291.0,3
1,"protected void setGender()
     {
        isMale = random.nextBoolean();
    }",This generates a random boolean value which is then stored in isMale,Animal.java,291.0,3
2,"protected boolean getGender()
    {
        return isMale;
    }",Returns the boolean variable isMale,Animal.java,291.0,3
3,"protected void setFoodLevel(int newLevel)
    {
        foodLevel = newLevel;
    }",This allows the foodLevel to be set - it is set to the parameter that is passed,Animal.java,291.0,3
4,"protected int getFoodLevel()
    {
        return foodLevel;
    }",Returns the foodLevel as an integer,Animal.java,291.0,3
5,"protected void incrementHunger()
     {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
     }",Make this animal more hungry. This could result in the animals's death.,Animal.java,291.0,3
6,"protected void toggleInfected()
    {
       isInfected =! isInfected;
     }","This can either make isInfected true or false
This is because I want to add a way in which an animal can be cured of
disease",Animal.java,291.0,3
7,"protected Boolean getInfected()
    {
        return this.isInfected;
    }",This returns the boolean variable isInfected,Animal.java,291.0,3
8,"protected boolean meet()
     {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal != null && animal.getClass() == this.getClass()) {
                Animal adjacentAnimal = (Animal) animal;
                spreadDisease(adjacentAnimal);
                if(adjacentAnimal.isAlive() && (getGender() != adjacentAnimal.getGender()) && adjacentAnimal.getAge() >= BREEDING_AGE && getAge() >= BREEDING_AGE) { 
                        return true;
                }
            }
        }
        return false;
    }","This gets a list of locations adjacent to the animal and then iterates through the list
it will then validate the following condtions - there is an animal present and it is of the same class as this.getClass()
it will then make an animal in that ajacent location and run spreadDisease on it
and then validate whether the animal is alive and the genders are different and both ages are above breeding age
if so it will return true if not it will return",Animal.java,291.0,3
9,"protected int breed()
     {
        int births = 0;
        if(meet() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","This sets an integer to 0 and if a random double is less then the breeding probability then it will set that integer to a random
number from 1 to the max litter size
this will then be returned",Animal.java,291.0,3
10,"protected void setInfectedAge(int dyingAge,int healthyAge)
    {
        if (this.getInfected())
        {
            this.setMaxAge(dyingAge);
        }
        else
        {
            this.setMaxAge(healthyAge);
        }
    }",This checks if the animal is infected if so it's maxAge will be set to dyingAge parameter else it will be set to healthyAge parameter,Animal.java,291.0,3
11,"protected void spreadDisease(Animal adjacentAnimal)
    {
        if (this.getInfected())
         {
            if(rand.nextDouble() <= infection_chance) {
                if(adjacentAnimal.isAlive() && adjacentAnimal.getInfected()==false) { 
                        adjacentAnimal.toggleInfected();
               
                }
            }
           }
     }",This spreads the disease if the animal making contact already has the disease,Animal.java,291.0,3
12,"protected void overComeDisease()
    {
        if (this.getInfected())
        {
           if(rand.nextDouble() <= cure_rate) 
           {
               this.toggleInfected();
            }
    }
   }",This checks if the animal has the disease and if so has chance of being cured from said disease,Animal.java,291.0,3
0,"public void actDay(List<Actor> newActors)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
            if(!isInfected()){
                setDisease();
            }
            if(isInfected()){
                spreadDisease();
                worsenDisease();
            }
        }
        
        if(isAlive()){
            if(!getField().isRainy()){
                giveBirth(newActors);
                Location newLocation = findFood();            
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocationForAnimls(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    setDead();
                }
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,647.0,0
7,"public boolean canBreed()
    {
        return isFemale() && getAge() >= BREEDING_AGE && diffSex();
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,647.0,0
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,647.0,0
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,647.0,0
0,"public void actDay(List<Actor> newActors)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
            if(!isInfected()){
                setDisease();
            }
            if(isInfected()){
                spreadDisease();
                worsenDisease();
            }
        }
        
        if(isAlive()){
            if(!getField().isFoggy()){
                giveBirth(newActors);
                Location newLocation = findFood();            
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocationForAnimls(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    setDead();
                }
            }
        }
        
        if(isAlive()){
            if(getField().isSunny()){
                giveBirth(newActors);
                Location newLocation = findFood();            
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocationForAnimls(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    setDead();
                }
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Eagle.java,647.0,0
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Animal prey = (Rabbit) animal;
                if(prey.isInfected()){
                    this.setInfected();
                }
                if(prey.isAlive()) { 
                    prey.setDead();
                    setFoodLevel(Integer.min(getFoodLevel() + RABBIT_FOOD_VALUE, MAX_FOOD_VALUE));
                    return where;
                }
            }
            else if(animal instanceof Fox) {
                Animal prey = (Fox) animal;
                if(prey.isInfected()){
                    this.setInfected();
                }
                if(prey.isAlive()) { 
                    prey.setDead();
                    setFoodLevel(Integer.min(getFoodLevel() + FOX_FOOD_VALUE, MAX_FOOD_VALUE));
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Eagle.java,647.0,0
7,"public boolean canBreed()
    {
        return isFemale() && getAge() >= BREEDING_AGE && diffSex();
    }",A fox can breed if it has reached the breeding age.,Eagle.java,647.0,0
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,647.0,0
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,647.0,0
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,647.0,0
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,647.0,0
0,"@BeforeEach
    public void setUp()
    {
        simulato1 = new Simulator();
    }","Sets up the test fixture.

Called before every test case method.",SimulatorTest.java,647.0,0
1,"@AfterEach
    public void tearDown()
    {
    }","Tears down the test fixture.

Called after every test case method.",SimulatorTest.java,647.0,0
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,647.0,0
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,647.0,0
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,647.0,0
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,647.0,0
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,647.0,0
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,647.0,0
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(100);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,647.0,0
2,"public void simulateOneStep()
    {
        step++;
        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>(); 
        
        // Let all animals act.
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            if(step%2 == 0){
                actor.actNight(newActors);
            } else {
                actor.actDay(newActors);
            }

            if(! actor.isAlive()) {
                it.remove();
            }
        }

        // Add the newly born animals to the main lists.
        actors.addAll(newActors);
        view.showStatus(step, field);
        field.changeWeather();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each animals.
Use steps to count the number of days and nights.
Animals have different actions at different time.",Simulator.java,647.0,0
3,"public void reset()
    {
        step = 0;
        actors.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,647.0,0
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= HUNTER_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Hunter hunter = new Hunter(field, location);
                    actors.add(hunter);
                }
                else if(rand.nextDouble() <= EAGLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Eagle eagle = new Eagle(true, field, location);
                    actors.add(eagle);
                }
                else if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    actors.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    actors.add(rabbit);
                }
                else {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    actors.add(grass);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,647.0,0
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,647.0,0
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,647.0,0
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,647.0,0
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,647.0,0
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,647.0,0
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,647.0,0
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,647.0,0
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,647.0,0
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,647.0,0
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,647.0,0
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,647.0,0
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,647.0,0
0,"public void actDay(List<Actor> newActors)
    {
        incrementAge();
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,647.0,0
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isInfected()){
                    this.setInfected();
                }
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    setFoodLevel(Integer.min(getFoodLevel() + RABBIT_FOOD_VALUE, MAX_FOOD_VALUE));
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,647.0,0
7,"public boolean canBreed()
    {
        return isFemale() && getAge() >= BREEDING_AGE && diffSex();
    }",A fox can breed if it has reached the breeding age.,Fox.java,647.0,0
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,647.0,0
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,647.0,0
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,647.0,0
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,647.0,0
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,647.0,0
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,647.0,0
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,647.0,0
7,"public List<Location> getFreeAdjacentLocationsForAnimals(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            Object obj = getObjectAt(next);
            if(obj == null || obj instanceof Grass) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,647.0,0
9,"public Location freeAdjacentLocationForAnimls(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocationsForAnimals(location);
        if(free.size() > 0) {
            Object obj = getObjectAt(free.get(0));
            if (obj instanceof Grass){
                Grass grass = (Grass)obj;
                grass.setDead();
            }
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,647.0,0
11,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,647.0,0
12,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,647.0,0
13,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,647.0,0
10,"public boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,647.0,0
13,"public void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,647.0,0
15,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,647.0,0
16,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,647.0,0
17,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,647.0,0
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,488.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,488.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,488.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,488.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,488.0,3
0,"public void captureNewImage() {
        this.habitat.passHalfDay();
        this.repaint();
    }",Paints the image of the habitat.,CameraDrone.java,488.0,3
1,"public String stats() {
        StringBuffer buffer = new StringBuffer();

        HashMap<String, Integer> data = habitat.speciesData;
        for (String type : data.keySet()) {
            String[] speciesColor = type.split("","");
            buffer.append(String.format(""<font color='%s'>"", speciesColor[1]));
            buffer.append(speciesColor[0]);
            buffer.append(""</font>"");
            buffer.append("": "");
            buffer.append(data.get(type));
            buffer.append(' ');
        }

        return buffer.toString();
    }","Provide the statistics of the habitat.

@return a string of statistics;",CameraDrone.java,488.0,3
2,"public int day() {
        return this.habitat.time() / 24;
    }","Gets the current day.

@return simulated day of this habitat.",CameraDrone.java,488.0,3
3,"public String weather() {
        return habitat.isRaining() ? ""Raining"" : ""Drought"";
    }","Gets the current weather of this habitat.

@return simulated weather of this habitat.",CameraDrone.java,488.0,3
4,"public boolean isDetectingChange() {
        return habitat != null && habitat.isAlive();
    }","Provides whether the habitat is still active.

@return true if habitat is changing, false if not;",CameraDrone.java,488.0,3
5,"private void drawOutline(Graphics g, Point point) {
        g.setColor(Color.GRAY);
        g.drawRect(point.x * SCALE, point.y * SCALE, SCALE, SCALE);
    }","Draws a gray outline around each rectangle on the image.

@param g     The Graphics object;
@param point The Coordinate of the rectangle;",CameraDrone.java,488.0,3
6,"@Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (this.habitat 
                != null) {
            HashMap<Point, Color> view = habitat.topView;
            
            for (Point point : view.keySet()) {
                g.setColor(view.get(point));
                g.fillRect(point.x * SCALE, point.y * SCALE, SCALE, SCALE);
                drawOutline(g, point);
            }
        }
    }","Draw the image of the habitat.

* @param g The Graphics object;",CameraDrone.java,488.0,3
7,"public String time() {
        return habitat.nightTime() ? ""Mid-Night"" : ""NoonTime"";
    }","Gets the current time.

@return simulated time of this habitat.",CameraDrone.java,488.0,3
0,"@Override
    protected Animal makeOffspring(Point point) {
        return new Zombie(point, false);
    }","Gets an offspring from this Zombie.

@param point The location of the offspring.

@return A Zombie offspring.",Zombie.java,488.0,3
1,"@Override
    int maxOffspring() {
        return 2;
    }","Gets the maximum number of offsprings this Zombie could have at once.

@return 2.",Zombie.java,488.0,3
2,"@Override
    Class[] foodSource() {
        return new Class[] {Pigman.class, FriedChicken.class, Cow.class};
    }","Gets the preys of this Zombie.

@return Cow.class inside an array.",Zombie.java,488.0,3
3,"@Override
    boolean nocturnal() {
        return true;
    }","Gets whether this Zombie is active at night or day

@return true as it is only active at night.",Zombie.java,488.0,3
4,"@Override
    double reproductionProbability() {
        return 0.4;
    }","Gets the probability that this Zombie could reproduce.

@return 0.4.",Zombie.java,488.0,3
5,"@Override
    double stdProbability() {
        return 0.2;
    }","Gets the probability that this Zombie would catch a STD on instantiation.

@return 0.2.",Zombie.java,488.0,3
6,"@Override
    public Color color() {
        return Color.decode(""#ADD8E6"");
    }","Gets the color of this Zombie.

@return Blue.",Zombie.java,488.0,3
7,"@Override
    protected int maxAge() {
        return 150;
    }","Gets the maximum age of this Zombie.

@return 150.",Zombie.java,488.0,3
8,"@Override
    int pubertyAge() {
        return 20;
    }","The age that this Zombie must reach before it could reproduce.

@return 20.",Zombie.java,488.0,3
9,"@Override
    int foodValue() {
        return 4;
    }","The food value of each prey.

@return 4.",Zombie.java,488.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.

@return A random object.",Helper.java,488.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Helper.java,488.0,3
2,"public static String hexFrom(Color color) {
        return String.format(""#%02x%02x%02x"", color.getRed(), color.getGreen(), color.getBlue());
    }","Gets the hex value of a color as a string.

@param color The color to convert.

@return The hexcode as a string.",Helper.java,488.0,3
3,"public static <E> Object randomObjectFrom(Collection<E> collection) {
        int index = getRandom().nextInt(collection.size());
        return new ArrayList<E>(collection).get(index); 
    }","Gets a random object from a collection

@param color The collecton to choose from.

@return A random object.",Helper.java,488.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,488.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,488.0,3
0,"@Override
    public Color color() {
        return Color.pink;
    }","Gets the color of this Pigman.

@return Pink.",Pigman.java,488.0,3
1,"@Override
    protected int maxAge() {
        return 40;
    }","Gets the maximum age of this Pigman.

@return 40.",Pigman.java,488.0,3
2,"@Override
    int maxOffspring() {
        return 8;
    }","Gets the maximum number of offsprings this Pigman could have at once.

@return 8.",Pigman.java,488.0,3
3,"@Override
    Class[] foodSource() {
        return new Class[]{Grass.class};
    }","Gets the preys of this Pigman.

@return Grass.class inside an array.",Pigman.java,488.0,3
4,"@Override
    protected Animal makeOffspring(Point point) {
        return new Pigman(point, false);
    }","Gets an offspring from this Pigman.

@param point The location of the offspring.

@return A pigman offsring.",Pigman.java,488.0,3
5,"@Override
    boolean nocturnal() {
        return false;
    }","Gets whether this Pigman is active at night or day

@return false as it is only active at day.",Pigman.java,488.0,3
6,"@Override
    double reproductionProbability() {
        return 0.75;
    }","Gets the probability that this Pigman could reproduce.

@return 0.75.",Pigman.java,488.0,3
7,"@Override
    double stdProbability() {
        return 0.1;
    }","Gets the probability that this Pigman would catch a STD on instantiation.

@return 0.1.",Pigman.java,488.0,3
8,"@Override
    int pubertyAge() {
        return 5;
    }","The age that this Pigman must reach before it could reproduce.

@return 5.",Pigman.java,488.0,3
9,"@Override
    int foodValue() {
        return 2;
    }","The food value of each prey.

@return 2.",Pigman.java,488.0,3
0,"@Override
    protected Animal makeOffspring(Point point) {
        return new Witch(point, false);
    }","Gets an offspring from this Witch.

@param point The location of the offspring.

@return A Witch offspring.",Witch.java,488.0,3
1,"@Override
    int maxOffspring() {
        return 2;
    }","Gets the maximum number of offsprings this Witch could have at once.

@return 2.",Witch.java,488.0,3
2,"@Override
    Class[] foodSource() {
        return new Class[] {Cow.class, Pigman.class, FriedChicken.class};
    }","Gets the preys of this Witch.

@return Cow.class inside an array.",Witch.java,488.0,3
3,"@Override
    boolean nocturnal() {
        return false;
    }","Gets whether this Witch is active at night or day

@return false as it is not active at night.",Witch.java,488.0,3
4,"@Override
    double reproductionProbability() {
        return 0.5;
    }","Gets the probability that this Witch could reproduce.

@return 0.5.",Witch.java,488.0,3
5,"@Override
    double stdProbability() {
        return 0.3;
    }","Gets the probability that this Witch would catch a STD on instantiation.

@return 0.3.",Witch.java,488.0,3
6,"@Override
    public Color color() {
        return Color.decode(""#330066"");
    }","Gets the color of this Witch.

@return Purple.",Witch.java,488.0,3
7,"@Override
    protected int maxAge() {
        return 100;
    }","Gets the maximum age of this Witch.

@return 100.",Witch.java,488.0,3
8,"@Override
    int pubertyAge() {
        return 25;
    }","The age that this Witch must reach before it could reproduce.

@return 25.",Witch.java,488.0,3
9,"@Override
    int foodValue() {
        return 5;
    }","The food value of each prey.

@return 5.",Witch.java,488.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,488.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,488.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,488.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,488.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,488.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,488.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,488.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,488.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,488.0,3
0,"private void updateScreen() {
        cameraPanel.captureNewImage();
        infoLabel.setText(""Day: "" + cameraPanel.day() + ""     "" + cameraPanel.time() +""     "" + cameraPanel.weather());
        statsLabel.setText(""<html>Population: "" + cameraPanel.stats() + ""</html>"");
    }",Updates the screen.,Simulator.java,488.0,3
1,"public void simulateForThirtySeconds() {
        simulateFor(200);
    }",Run the simulator for thirty seconds in real time.,Simulator.java,488.0,3
2,"public void simulateFor(int turns) {
        for (int time = 0; time < turns; time ++) {
            updateScreen();

            if (!cameraPanel.isDetectingChange())
                return;

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                System.out.println(""Sleep exception."");
            }
        }
    }","Run the simulator from its current state for the given number of seconds.
Stop before the given number of seconds if the camera doesn't detect any
change.

@param turn The number of turns to simulate for.",Simulator.java,488.0,3
0,"@Override
    protected Animal makeOffspring(Point point) {
        return new Cow(point, false);
    }","Gets an offspring from this Cow.

@param point The location of the offspring.

@return A Cow offspring.",Cow.java,488.0,3
1,"@Override
    int maxOffspring() {
        return 7;
    }","Gets the maximum number of offsprings this Cow could have at once.

@return 7.",Cow.java,488.0,3
2,"@Override
    Class[] foodSource() {
        return new Class[] {Grass.class};
    }","Gets the preys of this Cow.

@return Pigman.class inside an array.",Cow.java,488.0,3
3,"@Override
    boolean nocturnal() {
        return false;
    }","Gets whether this Cow is active at night or day

@return false as it is not active at night.",Cow.java,488.0,3
4,"@Override
    double reproductionProbability() {
        return 1;
    }","Gets the probability that this Cow could reproduce.

@return 1.",Cow.java,488.0,3
5,"@Override
    double stdProbability() {
        return 0.3;
    }","Gets the probability that this Cow would catch a STD on instantiation.

@return 0.3.",Cow.java,488.0,3
6,"@Override
    public Color color() {
        return Color.decode(""#FFD580"");
    }","Gets the color of this Cow.

@return Orange.",Cow.java,488.0,3
7,"@Override
    protected int maxAge() {
        return 40;
    }","Gets the maximum age of this Cow.

@return 40.",Cow.java,488.0,3
8,"@Override
    int pubertyAge() {
        return 6;
    }","The age that this Cow must reach before it could reproduce.

@return 6.",Cow.java,488.0,3
9,"@Override
    int foodValue() {
        return 2;
    }","The food value of each prey.

@return 2.",Cow.java,488.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,488.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,488.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,488.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,488.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,488.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,488.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,488.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,488.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,488.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,488.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,488.0,3
0,"protected void setAge(int age) {
        this.age = age;
    }","Sets the age of this organism.

@param age The age;",Organism.java,488.0,3
1,"public void setDead() {
        this.alive = false;
    }",Set the organism to be dead.,Organism.java,488.0,3
2,"public Point point() {
        return point;
    }","Gets the location of this organism.

@return The point.",Organism.java,488.0,3
3,"public boolean isAlive() {
        return alive;
    }","Gets whether the organism is alive.

@return true if alive, false if dead.",Organism.java,488.0,3
4,"protected int age() {
        return age;
    }","Gets the age of this organism.

@return The age.",Organism.java,488.0,3
5,"protected void incrementAge() {
        this.age++;
    }",Increments the age of this organism.,Organism.java,488.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,488.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,488.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,488.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,488.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,488.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,488.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,488.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,488.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,488.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,488.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,488.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,488.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,488.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,488.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,488.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,488.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,488.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,488.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,488.0,3
0,"@Override
    public Color color() {
        return Color.decode(""#006400"");
    }","Gets the color of this grass.

@return Dark green.",Grass.java,488.0,3
1,"public void grow() {
        if(naturalDeath())
            setDead();
    }",Let the grass grow. It would die if it reaches its maximum age.,Grass.java,488.0,3
2,"@Override
    protected int maxAge() {
        return 20;
    }","Gets the maximum age of this grass.

@return 20.",Grass.java,488.0,3
3,"@Override
    protected boolean naturalDeath() {
        incrementAge();
        return age() >= maxAge();
    }","Calculates whether this grass would die due to aging.

@return true if the grass dies, false it not.",Grass.java,488.0,3
0,"public void actOn(Map<Point, Organism> neighbors) {
        offsprings.clear();
        Map<Point, Organism> mates = new HashMap<Point, Organism>();
        Map<Point, Organism> preys = new HashMap<Point, Organism>();
        Map<Point, Organism> emptyCell = new HashMap<Point, Organism>();

        for (Point point : neighbors.keySet()) {
            Organism neighbor = neighbors.get(point);

            if (neighbor == null) {
                emptyCell.put(point, neighbor);
                break;
            }

            if (neighbor instanceof Animal && canReproduceWith((Animal) neighbor))
                mates.put(point, neighbor);

            if (canEat(neighbor))
                preys.put(point, neighbor);

            if (neighbor instanceof Grass || !neighbor.isAlive())
                emptyCell.put(point, neighbor);
        }

        if (!mates.isEmpty() && !emptyCell.isEmpty()) {
            reproduce(emptyCell.keySet());
            if (hasSTD)
                for (Organism mate : mates.values()) {
                    ((Animal) mate).infected();
                }

        } else if (!preys.isEmpty() && this.foodLevel < foodValue())
            hunt((Organism) Helper.randomObjectFrom(preys.values()));

        else if (!emptyCell.isEmpty())
            point().setLocation((Point) Helper.randomObjectFrom((Collection<Point>) emptyCell.keySet()));

        else
            setDead();

        if (naturalDeath())
            setDead();
    }","Let the animal act on its neighbors.

@param neighbors The neighors of the organism.",Animal.java,488.0,3
1,"public void infected() {
        this.hasSTD = true;
    }",Infect the animal with the STD.,Animal.java,488.0,3
2,"private void hunt(Organism prey) {
        prey.setDead();
        point().setLocation(prey.point());
        foodLevel += this.foodValue();

        if (prey instanceof Animal && ((Animal) prey).hasSTD())
            this.infected();
    }","Eat an organism and move to its location.

@param prey The organism to be eaten.",Animal.java,488.0,3
3,"@Override
    protected boolean naturalDeath() {
        incrementAge();

        if (hasSTD())
            foodLevel = foodLevel / 5;
        else
            foodLevel--;

        return age() > maxAge() || foodLevel <= 0;
    }","Gets whether this animal would die naturally.

@return true if it dies, false if not.",Animal.java,488.0,3
4,"private boolean canReproduceWith(Animal animal) {
        return isFemale && animal.getClass().equals(this.getClass()) && !animal.isFemale()
                 && age() >= pubertyAge();
    }","Gets whether this animal could reproduce with another.

@param animal The animal to reproduce with.

@return true if it could, false if not.",Animal.java,488.0,3
5,"private void reproduce(Collection<Point> emptyPoints) {
        int counter = 0;
        
        for (Point point : emptyPoints) {
            if (counter > maxOffspring())
                break;

            if (Helper.getRandom().nextDouble() < this.reproductionProbability()) {
                this.offsprings.add(makeOffspring(point));
                counter++;
            }
        }
    }","Reproduce and give birth to offsprings at given locations.

@param emptyPoints The locations to place the offsprings.",Animal.java,488.0,3
6,"private boolean canEat(Organism organism) {
        return Arrays.stream(foodSource()).anyMatch(food -> food.equals(organism.getClass()));
    }","Gets whether this animal could eat an organism.

@param organism The organism to be eaten.

@return true if it could, false if not.",Animal.java,488.0,3
7,"public boolean isFemale() {
        return isFemale;
    }","Gets whether this animal is female or male.

@return true if it is female, false if male.",Animal.java,488.0,3
8,"public boolean hasSTD() {
        return hasSTD;
    }","Gets whether this animal is infected.

@return true if it has a STD, false if not.",Animal.java,488.0,3
0,"public void passHalfDay() {
        hour += 12;

        rain = Helper.getRandom().nextDouble() < 0.3 ? true : false;

        if (rain)
            generateGrass(0.75);

        ArrayList<Grass> plants = new ArrayList<Grass>(grassMap.values());

        for (Grass grass : plants) {
            if (grass.isAlive())
                grass.grow();
        }

        ArrayList<Animal> animals = new ArrayList<Animal>(animalMap.values());

        for (Animal animal : animals) {
            if (animal.isAlive() && animal.nocturnal() == nightTime()) {
                animalMap.remove(animal.point());
                animal.actOn(getNeighborsFor(animal));

                if (animal.isAlive())
                    animalMap.put(animal.point(), animal);

                for (Animal offspring : animal.offsprings) {
                    animalMap.put(offspring.point(), offspring);
                }
            }
        }

        update();
    }","Run the habitat from its current state for an virtual hour. Iterate over the
whole field to update the state of each organism.",Habitat.java,488.0,3
1,"private Map<Point, Organism> getNeighborsFor(Animal animal) {
        Map<Point, Organism> neighbors = new HashMap<Point, Organism>();

        for (int xOffset = -2; xOffset <= 2; xOffset++)
            for (int yOffset = -2; yOffset <= 2; yOffset++) {
                if (xOffset != 0 && yOffset != 0) {
                    int nX = animal.point().x + xOffset;
                    int nY = animal.point().y + yOffset;

                    if (nX >= 0 && nX < width & nY < height && nY >= 0) {

                        Point point = new Point(nX, nY);
                        Grass grassNeighbor = grassMap.get(point);
                        Animal animalNeighbor = animalMap.get(point);

                        neighbors.put(point, grassNeighbor);
                        if (animalNeighbor != null && animalNeighbor.isAlive())
                            neighbors.put(animalNeighbor.point(), animalNeighbor);
                    }
                }
            }

        return neighbors;
    }","Gets the neighboring organims surrounding an organism.

@param organism The organism to get neighbors from.

@return List of organisms.",Habitat.java,488.0,3
2,"private void generateGrass(double probability) {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                Point point = new Point(x, y);
                Organism grass = grassMap.get(point);

                if (grass == null || !grass.isAlive()) {
                    if (Helper.getRandom().nextDouble() < probability)
                        grassMap.put(point, new Grass(point));
                }
            }
        }
    }","Generates grasses across the habitat.

@param probability The chance of a grass spawning in one cell.",Habitat.java,488.0,3
3,"public boolean isAlive() {
        return alive;
    }","Checks if there are any animals alive.

@return true if there are animals alive, false if not.",Habitat.java,488.0,3
4,"public int time() {
        return hour;
    }","Gets the current hour of the habitat.

@return The current hour.",Habitat.java,488.0,3
5,"public boolean isRaining() {
        return rain;
    }","Gets the current weather.

@return True if raining, false if drought.",Habitat.java,488.0,3
6,"public void update() {
        alive = false;

        for (String key : speciesData.keySet()) {
            speciesData.put(key, 0);
        }

        for (int x = 0; x < width; x++)
            for (int y = 0; y < height; y++) {
                Point point = new Point(x, y);
                topView.put(point, Color.decode(""#F5F5F5""));
                updateOrganismStats(grassMap.get(point));
                updateOrganismStats(animalMap.get(point));
            }
    }","Gets the top view of the habitat.

@return A HashMap with each point mapped to a color.",Habitat.java,488.0,3
7,"private void updateOrganismStats(Organism organism) {
        if (organism != null && organism.isAlive()) {
            topView.put(organism.point(), organism.color());
            incrementData(organism.getClass().getSimpleName() + "","" + Helper.hexFrom(organism.color()));

            if (organism instanceof Animal) {
                this.alive = true;
                if (((Animal) organism).hasSTD()) {
                    topView.put(organism.point(), new Color(255, 0, 0, 200));
                    incrementData(""STD Infected"" + "","" + Helper.hexFrom(Color.red));
                }
            }
        }
    }","Updates the statistics of an organism.

@param The organism to be updated.",Habitat.java,488.0,3
8,"private void incrementData(String key) {
        if (speciesData.containsKey(key))
            speciesData.put(key, speciesData.get(key) + 1);
        else
            speciesData.put(key, 0);
    }","Increments the population of a species.

@param key the name of the species combined with its color.",Habitat.java,488.0,3
9,"public boolean nightTime() {
        return hour % 24 == 0 ? true : false;
    }","Gets the time of the day.

@return True if it's night time, false if day time.",Habitat.java,488.0,3
0,"@Override
    protected Animal makeOffspring(Point point) {
        return new FriedChicken(point, false);
    }","Gets an offspring from this FriedChicken.

@param point The location of the offspring.

@return A Fried Chicken offspring.",FriedChicken.java,488.0,3
1,"@Override
    int maxOffspring() {
        return 5;
    }","Gets the maximum number of offsprings this FriedChicken could have at once.

@return 5.",FriedChicken.java,488.0,3
2,"@Override
    Class[] foodSource() {
        return new Class[] { Grass.class };
    }","Gets the preys of this FriedChicken.

@return Pigman.class inside an array.",FriedChicken.java,488.0,3
3,"@Override
    boolean nocturnal() {
        return true;
    }","Gets whether this FriedChicken is active at night or day

@return true as it is only active at night.",FriedChicken.java,488.0,3
4,"@Override
    double reproductionProbability() {
        return 0.75;
    }","Gets the probability that this FriedChicken could reproduce.

@return 0.75.",FriedChicken.java,488.0,3
5,"@Override
    double stdProbability() {
        return 0.05;
    }","Gets the probability that this FriedChicken would catch a STD on instantiation.
s
@return 0.05.",FriedChicken.java,488.0,3
6,"@Override
    public Color color() {
        return Color.decode(""#C4A484"");
    }","Gets the color of this FriedChicken.

@return Brown.",FriedChicken.java,488.0,3
7,"@Override
    protected int maxAge() {
        return 50;
    }","Gets the maximum age of this FriedChicken.

@return 50.",FriedChicken.java,488.0,3
8,"@Override
    int pubertyAge() {
        return 3;
    }","The age that this Fried Chicken must reach before it could reproduce.

@return 3.",FriedChicken.java,488.0,3
9,"@Override
    int foodValue() {
        return 2;
    }","The food value of each prey.

@return 2.",FriedChicken.java,488.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,319.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,319.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,319.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,319.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,319.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,319.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,319.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,319.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,319.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,319.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,319.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,319.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,319.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,319.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,319.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,319.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,319.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,319.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,319.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,319.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    animals.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    animals.add(rabbit);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,319.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,319.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,319.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,319.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,319.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,319.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,319.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,319.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,319.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,319.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,319.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,319.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,319.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,319.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,319.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,319.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,319.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,319.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,319.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,319.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,319.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,319.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,319.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,319.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,319.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,319.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,319.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,319.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,319.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,319.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,319.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,319.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,319.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,319.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,319.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,319.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Wolf.class);
        set.add(Frog.class);
        return set;
    }","Initialize the Python food list and return it.
@return The food list.",Python.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc){
        return new Python(false, super.getField(), loc);
    }","Spawn a Python in a given location.
@param loc The location in which to spawn the animal.
@return The Python to be spawned.",Python.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Butterfly.class);
        set.add(FruitFly.class);
        return set;
    }","Initialize the DragonFly food list and return it.
@return The food list.",DragonFly.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc){
        return new DragonFly(false, super.getField(), loc);
    }","Spawn a DragonFly in a given location.
@param loc The location in which to spawn the animal.
@return The DragonFly to be spawned.",DragonFly.java,319.0,3
0,"public static void main(String[] Args) throws Exception {
        Simulator sim = new Simulator(120,180);
        sim.runLongSimulation();
    }","Main method - creates and runs the simulation
@param Args args
@throws Exception exception",Run.java,319.0,3
0,"public Integer getStat(StatTypes type){
        return statValues.get(type);
    }","Return the value of the specified stat type in this instance.
@param type A stat type to query.
@return An integer corresponding to the received stat type.",Stats.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Lavender.class);
        set.add(Flower.class);
        return set;
    }","Initialize the Butterfly food list and return it.
@return The food list.",Butterfly.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc){
        return new Butterfly(false, super.getField(), loc);
    }","Spawn a Butterfly in a given location.
@param loc The location in which to spawn the animal.
@return The Butterfly to be spawned.",Butterfly.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(FruitFly.class);
        set.add(DragonFly.class);
        return set;
    }","Initialize the Thrush food list and return it.
@return The food list.",Thrush.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc) {
        return new Thrush(false, super.getField(), loc);
    }","Spawn a Thrush in a given location.
@param loc The location in which to spawn the animal.
@return The Thrush to be spawned.",Thrush.java,319.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Wolf.class);
        set.add(Frog.class);
        set.add(Python.class);
        set.add(Thrush.class);
        return set;
    }","Initialize the Eagle food list and return it.
@return The food list.",Eagle.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc){
        return new Eagle(false, super.getField(), loc);
    }","Spawn a Eagle in a given location.
@param loc The location in which to spawn the animal.
@return The Eagle to be spawned.",Eagle.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Mango.class);
        return set;
    }","Initialize the FruitFly food list and return it.
@return The food list.",FruitFly.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc) {
        return new FruitFly(false, super.getField(), loc);
    }","Spawn a FruitFly in a given location.
@param loc The location in which to spawn the animal.
@return The FruitFly to be spawned.",FruitFly.java,319.0,3
0,"@Override
    public void act(List<Actor> newActors){
        if(waterQuantity>0 && sunQuantity>0) {
            grow();
            if (pollinate() && growth > stats.getStat(StatTypes.BREEDING_AGE) && sprouted < stats.getStat(StatTypes.MAX_LITTER_SIZE)) {
                sprout(newActors);
                sprouted++;
            }
            waterQuantity+=getLocation().getWeather().getWater();
            sunQuantity+=getLocation().getWeather().getSun();
            if(waterQuantity>MAX_QUANTITY)
                waterQuantity=MAX_QUANTITY;
            if(sunQuantity>MAX_QUANTITY)
                sunQuantity=MAX_QUANTITY;
            waterQuantity-=1;
            sunQuantity-=1;
        }
        else
            setDead();
    }","Override of the act method in Actor. Start the plant actions -> check if the plant dies, grow, pollinate, sprout
@param newActors - List of new plants (generated by the sprout of this plant)",Plant.java,319.0,3
1,"private void grow(){
        if(stats.getStat(StatTypes.MAX_AGE)>growth)
            growth+=3;
    }",Make the plant grow -> increment the grow field if the maxGrowth hasn't been reached,Plant.java,319.0,3
2,"private boolean pollinate(){
        if(rand.nextInt(100)<stats.getStat(StatTypes.BREEDING_PROBABILITY))
            return true;
        for(Location loc: super.getField().adjacentLocations(super.getLocation())){
            for(Actor act : getField().getActorsAt(loc))
                if(act.getClass().equals(this.getClass()))
                    if(rand.nextInt(100)<stats.getStat(StatTypes.BREEDING_PROBABILITY))
                        return true;
        }
        return false;
    }","Try to pollinate the plant -> the plant get pollinated by itself or by other adjacent plant
@return true if the plant was pollinated",Plant.java,319.0,3
3,"public int getGrowth(){
        return growth;
    }","Get the growth of this plant (size of the plant)
@return plant growth",Plant.java,319.0,3
4,"public int isEaten(int amount){
        growth -= amount;
        if(growth<=0){
            return (growth+amount)*stats.getStat(StatTypes.NUTRITIONAL_VALUE);
        }
        return amount*stats.getStat(StatTypes.NUTRITIONAL_VALUE);
    }","An animal eats this plant by an amount -> reduce the growth of this plant (the plant may die). Return the nutritional value multiplied by how much the animal ate out of this plant.
@param amount -> the amount an animal eats out of this plant
@return total nutritional value",Plant.java,319.0,3
5,"private void sprout(List<Actor> newActors){
        List<Location> aux = super.getField().getFreeAdjacentLocations(super.getLocation());
        if(aux.size() > 0)
            newActors.add(newPlant(aux.get(rand.nextInt(aux.size()))));
    }","This plant sprouts -> creating children of this plant
@param newActors - list of children of the plant",Plant.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Butterfly.class);
        set.add(DragonFly.class);
        set.add(FruitFly.class);
        return set;
    }","Initialize the Frog food list and return it.
@return The food list.",Frog.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc) {
        return new Frog(false, super.getField(), loc);
    }","Spawn a Frog in a given location.
@param loc The location in which to spawn the animal.
@return The Frog to be spawned.",Frog.java,319.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,319.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,319.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,319.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,319.0,3
0,"@Override
    public void actionPerformed(ActionEvent ae) {
        String acName = ae.getActionCommand();
        boolean show = false;
        switch(acName) {
            case ""Faster"":
                delayTime.modifyDelay(-1);
                speedLabel.setText(""x""+delayTime.getMult());
                break;
            case ""Slower"":
                delayTime.modifyDelay(1);
                speedLabel.setText(""x""+delayTime.getMult());
                break;
            case ""Stop"":
                delayTime.setPlay(false);
                break;
            case ""Start"":
                delayTime.setPlay(true);
                break;
            case ""Animals ON"":
                toggleActors(Animal.class, true);
                show = true;
                break;
            case ""Animals OFF"":
                toggleActors(Animal.class,false);
                show = true;
                break;
            case ""Plants ON"":
                toggleActors(Plant.class,true);
                show = true;
                break;
            case ""Plants OFF"":
                toggleActors(Plant.class,false);
                show = true;
                break;
            case ""Show Weather"":
                weatherStatus = !weatherStatus;
                show = true;
                break;
            default:
                try {
                    toggleAct(getClass(acName));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                show = true;
                break;
        }
        if(show)
            buttonShow(lastField);
    }","Override of the actionPerformed method -> sets the actions of the java.awt buttons
@param ae - the ActionEvent",SimulatorView.java,319.0,3
1,"private Class<?> getClass(String s) throws Exception {
        return Class.forName(s);
    }","get a Class from a name (String)
@param s - the name
@return Class associated with the name
@throws Exception Exception",SimulatorView.java,319.0,3
2,"private void toggleActors(Class<?> cl, boolean onOff){
        for(Class<?> cls : actorTypes){
            if(cl.isAssignableFrom(cls)){
                if(onOff)
                    showColor(cls);
                else removeColor(cls);
            }
        }
    }","toggle all the actors (and subclasses) of a specified class on or off in the SimulatorView (display/not display specified actors)
@param cl - Class of the actors
@param onOff boolean - true to turn on, false to turn off",SimulatorView.java,319.0,3
3,"private void toggleAct(Class<?> cl){
        if(colors.get(cl) == null)
            showColor(cl);
        else removeColor(cl);
    }","toggle a single actor on/off in the SimulatorView (display/not display)
@param cl - Class of the actor",SimulatorView.java,319.0,3
4,"public void setWeatherColor(WeatherTypes type, Color color) {
        weatherColors.put(type, color);
    }","set the display color of a weather type in the SimulatorView
@param type - weather type
@param color - the color",SimulatorView.java,319.0,3
5,"public void setColor(Class<?> cl, Color color) {
        this.colors.put(cl, color);
        this.defaultColors.put(cl, color);
        actorButtonMap.get(cl).setForeground(color);
    }","set the color of an actor in the SimulatorView
@param cl - class of the actor
@param color - the color",SimulatorView.java,319.0,3
6,"public void showColor(Class<?> cl){
        this.colors.put(cl,defaultColors.get(cl));
    }","toggle on an actor in the SimulatorView (display)
@param cl - class of the actor",SimulatorView.java,319.0,3
7,"public void removeColor(Class<?> cl) {
        this.colors.remove(cl);
    }","toggle off an actor in the SimulatorView (not display)
@param cl - class of the actor",SimulatorView.java,319.0,3
8,"private Color getColor(Class<?> cl) {
        Color col = this.colors.get(cl);
        return col == null ? UNKNOWN_COLOR : col;
    }","get the color associated with an actor
@param cl - class of the actor
@return The color corresponding to the given class, default if not available",SimulatorView.java,319.0,3
9,"public void showStatus(int step, Field field) {
        lastStep = step;
        lastField = field;
        if (!this.isVisible()) {
            this.setVisible(true);
        }

        this.stepLabel.setText(""Step: "" + step);
        this.stats.reset();
        this.fieldView.preparePaint();

        Actor act;
        for(int row = 0; row < field.getDepth(); ++row) {
            for(int col = 0; col < field.getWidth(); ++col) {
                this.fieldView.drawMark(col, row, EMPTY_COLOR);
                for (Iterator<Actor> var5 = field.getActorsAt(row, col).iterator(); var5.hasNext(); this.fieldView.drawMark(col, row, this.getColor(act.getClass()))) {
                    act = var5.next();
                    this.stats.incrementCount(act.getClass());
                }
                if(weatherStatus)
                    this.fieldView.drawMark(col, row, weatherColors.get(field.getLocation(row, col).getWeather()));
            }
        }

        this.stats.countFinished();
        String var10001 = this.stats.getPopulationDetails();
        this.population.setText(""Population: "" + var10001);
        this.fieldView.repaint();
    }","update the SimulatorView accordingly and show the updated version
@param step - step number
@param field - the field",SimulatorView.java,319.0,3
11,"public boolean isViable(Field field) {
        return this.stats.isViable(field);
    }","check if the fieldStats are viable
@param field - the field
@return boolean - true if viable",SimulatorView.java,319.0,3
12,"private void initializeAnimalTypes() {
        actorTypes.add(FruitFly.class);
        actorTypes.add(Butterfly.class);
        actorTypes.add(DragonFly.class);
        actorTypes.add(Frog.class);
        actorTypes.add(Thrush.class);
        actorTypes.add(Wolf.class);
        actorTypes.add(Python.class);
        actorTypes.add(Eagle.class);
        actorTypes.add(Flower.class);
        actorTypes.add(Lavender.class);
        actorTypes.add(Mango.class);
    }",initialize the actorTypes list -> used to generate buttons,SimulatorView.java,319.0,3
0,"private void setColors(){
        view.setColor(Thrush.class, getAwtColor(javafx.scene.paint.Color.BROWN));
        view.setColor(Wolf.class, getAwtColor(javafx.scene.paint.Color.LIGHTGRAY));
        view.setColor(FruitFly.class, getAwtColor(javafx.scene.paint.Color.GREENYELLOW));
        view.setColor(DragonFly.class, Color.RED);
        view.setColor(Butterfly.class, Color.PINK);
        view.setColor(Mango.class, Color.ORANGE);
        view.setColor(Lavender.class, getAwtColor(javafx.scene.paint.Color.PURPLE));
        view.setColor(Frog.class, getAwtColor(javafx.scene.paint.Color.DARKGREEN));
        view.setColor(Python.class, getAwtColor(javafx.scene.paint.Color.KHAKI));
        view.setColor(Flower.class, getAwtColor(javafx.scene.paint.Color.MEDIUMVIOLETRED));
        view.setColor(Eagle.class, getAwtColor(javafx.scene.paint.Color.SANDYBROWN));

        view.setWeatherColor(WeatherTypes.SUNNY, getAwtColor(javafx.scene.paint.Color.LIGHTGOLDENRODYELLOW));
        view.setWeatherColor(WeatherTypes.RAINY, getAwtColor(javafx.scene.paint.Color.DARKCYAN));
        view.setWeatherColor(WeatherTypes.TORRENTIAL_RAIN, getAwtColor(javafx.scene.paint.Color.DARKBLUE));
        view.setWeatherColor(WeatherTypes.FOGGY, getAwtColor(javafx.scene.paint.Color.LIGHTGRAY));
    }",Set the colors the entities should be displayed as in the simulatorView,Simulator.java,319.0,3
1,"private Color getAwtColor(javafx.scene.paint.Color col){
       return new java.awt.Color((float) col.getRed(),
                (float) col.getGreen(),
                (float) col.getBlue(),
                (float) col.getOpacity());
    }","Convert a javafx color to a java.awt color
@param col - color to be converted
@return converted color",Simulator.java,319.0,3
2,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,319.0,3
3,"public void simulate(int numSteps)
    {

        int step = 1;

        while(step <= numSteps && view.isViable(field)) {
            if(delayTime.getPlay()){
            simulateOneStep();
            delay(delayTime.getDelay());
            step++;
            }
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,319.0,3
4,"public void simulateOneStep()
    {
        step++;
        if(step%4==0)
            field.generateWeather();
        // Provide space for newborn actors.
        List<Actor> newActors = new ArrayList<>();
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            if(actor.isAlive())
                actor.act(newActors);
            if(! actor.isAlive()) {
                it.remove();
            }
        }
        field.advanceTimeOfDay();

        actors.addAll(newActors);

        infectRandom();

        view.showStatus(step, field);
        infView.update(field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,319.0,3
5,"private void infectRandom(){
        int n = actors.size()*INFECTION_PROBABILITY/100;
        Actor act;

        int i=0;

        while(i<n){
            act = actors.get(rand.nextInt(actors.size()));
            if(act instanceof Animal)
            {
                ((Animal) act).infect(); // infect animals
            }
            i++;
        }
    }",infect random animals,Simulator.java,319.0,3
6,"public void reset() throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {
        step = 0;
        actors.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,319.0,3
7,"private void populate() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        HashMap<Class<?>, Double> spawnProbabilities= new HashMap<>();
        initializeProbabilities(spawnProbabilities);
        field.clear();
        field.generateWeather();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                for(Class<?> classType : spawnProbabilities.keySet())
                    if(rand.nextDouble() <= spawnProbabilities.get(classType))
                        actors.add((Actor) classType.getConstructor(boolean.class, Field.class, Location.class).newInstance(true, field, field.getLocation(row, col)));
            }
        }
    }",Randomly populate the field with animals.,Simulator.java,319.0,3
8,"private void initializeProbabilities(HashMap<Class<?>, Double> spawnProbabilities){
        spawnProbabilities.put(Butterfly.class, 0.2);
        spawnProbabilities.put(DragonFly.class, 0.1);
        spawnProbabilities.put(FruitFly.class, 0.5);
        spawnProbabilities.put(Lavender.class, 0.2);
        spawnProbabilities.put(Flower.class, 0.2);
        spawnProbabilities.put(Mango.class, 0.1);
        spawnProbabilities.put(Thrush.class, 0.08);
        spawnProbabilities.put(Wolf.class, 0.012);
        spawnProbabilities.put(Frog.class, 0.08);
        spawnProbabilities.put(Python.class, 0.0125);
        spawnProbabilities.put(Eagle.class, 0.01);
    }","Set the probability of spawning for each animal (in the populate step)
@param spawnProbabilities - HashMap in which the probabilities are stored",Simulator.java,319.0,3
9,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,319.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the actor is alive or not.
@return true if the actor is still alive.",Actor.java,319.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.remove(location,this);
            location = null;
            field = null;
        }
    }","Indicate that the actor is no longer alive.
It is removed from the field.",Actor.java,319.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the actor's location.
@return The actor's location.",Actor.java,319.0,3
3,"protected void setLocation(Location newLocation)
    {
        location = newLocation;
        field.place(this, newLocation);
    }","Place the actor at the new location in the given field.
@param newLocation The actor's new location.",Actor.java,319.0,3
4,"protected void move(Location newLocation){
        field.remove(location,this);
        this.setLocation(newLocation);
    }","Move the actor to a new location (remove it from the old location)
@param newLocation the new location",Actor.java,319.0,3
5,"protected Field getField()
    {
        return field;
    }","Return the actor's field.
@return The actor's field.",Actor.java,319.0,3
0,"public String getPopulationDetails()
    {
        StringBuilder buffer = new StringBuilder();
        for(Class<?> key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,319.0,3
1,"public String[] getPopulationDetailsSeparate(){
        String[] str = new String[counters.keySet().size()];
        int i=0;
        StringBuilder sb = new StringBuilder();
        for(Class<?> key : counters.keySet()) {
            Counter info = counters.get(key);
            sb.setLength(0);
            sb.append(info.getName());
            sb.append("": "");
            sb.append(info.getCount());
            sb.append(' ');
            str[i] = sb.toString();
            i++;
        }
        return str;
    }","Get details of what is in the field. Information about each animal is given in separate strings - returning a String array.
@return An array of strings, each containing information about a different animal type",FieldStats.java,319.0,3
2,"public void reset()
    {
        countsValid = false;
        for(Class<?> key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,319.0,3
3,"public void incrementCount(Class<?> animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,319.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,319.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class<?> key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return true;
        //return nonZero == counters.size();
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,319.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                for(Actor act : field.getActorsAt(row, col))
                    if(act!=null)
                        incrementCount(act.getClass());
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,319.0,3
0,"public WeatherTypes getWeather() {
        return weather;
    }","Get the weather of this location
@return weather",Location.java,319.0,3
1,"public void setWeather(WeatherTypes weather) {
        this.weather = weather;
    }","Set the weather of this location
@param weather The weather type to set",Location.java,319.0,3
2,"public void remove(Actor act){
        if(cont.contains(act)) {
            cont.remove(act);
            n--;
        }
    }","remove a specific Actor from this location
@param act - the Actor",Location.java,319.0,3
3,"public boolean isEmpty(){
        return n==0;
    }","Check if this location is empty (no Actors)
@return boolean - true if empty",Location.java,319.0,3
4,"public HashSet<Actor> getActors(){
        return cont;
    }","returns an arrayList of all the actors at this location
@return arrayList with all of the actors",Location.java,319.0,3
5,"public void add(Actor act){
        if(n<maxSize) {
            cont.add(act);
            n++;
        }
    }","add an actor to this location
@param act the actor",Location.java,319.0,3
6,"public boolean isFull() {
        return n == maxSize;
    }","Check if the maximum numbers of Actors in this location has been reached
@return boolean - true if full",Location.java,319.0,3
7,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,319.0,3
8,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,319.0,3
9,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,319.0,3
10,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,319.0,3
11,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,319.0,3
0,"private HashSet<Class<?>> iniFood(){
        HashSet<Class<?>> set = new HashSet<>();
        set.add(Thrush.class);
        set.add(Frog.class);
        return set;
    }","Initialize the Wolf food list and return it.
@return The food list.",Wolf.java,319.0,3
1,"@Override
    protected Animal spawnAnimal(Location loc) {
        return new Wolf(false, super.getField(), loc);
    }","Spawn a Wolf in a given location.
@param loc The location in which to spawn the animal.
@return The Wolf to be spawned.",Wolf.java,319.0,3
0,"@Override
    protected Plant newPlant(Location location){
        return new Mango(false, getField(),location);
    }","Override the newPlant method - create a child of this plant
@param location - the location of the new plant
@return the new plant",Mango.java,319.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = new Location(row,col);
            }
        }
    }",Empty the field.,Field.java,319.0,3
1,"public boolean isEmpty(int row,int col){
        return field[row][col].isEmpty();
    }","@param row The row of the location.
@param col The column of the location.
@return True if the specified location contains no actor.",Field.java,319.0,3
2,"public void remove(Location location, Actor actor){
        location.remove(actor);
    }","Removes an actor from a location.
@param location The location to remove the actor from.
@param actor The actor to be removed.",Field.java,319.0,3
3,"public Location getLocation(int row,int col){
        return field[row][col];
    }","Return the location at a specified row and column
@param row the row
@param col the column
@return location at specified row and column",Field.java,319.0,3
4,"public void place(Actor actor, Location location)
    {
        location.add(actor);
    }","Place an actor at the given location.
@param actor The actor to be placed.
@param location Where to place the actor.",Field.java,319.0,3
5,"public HashSet<Actor> getActorsAt(Location location)
    {
        return location.getActors();
    }","Return the actors at the given location, if any.
@param location Where in the field.
@return The actor at the given location, or an empty arrayList if there is none.",Field.java,319.0,3
6,"public HashSet<Actor> getActorsAt(int row, int col)
    {
        return field[row][col].getActors();
    }","Return the actors at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The actors at the given location, or null if there is none.",Field.java,319.0,3
7,"private boolean isFree(Location location){
        return !location.isFull();
    }","Checks if a location is free
@param location the location
@return boolean - true if free",Field.java,319.0,3
8,"public void advanceTimeOfDay(){
        timeOfDay+=TIME_INCREMENT_PER_STEP_IN_HOURS;
        timeOfDay%=24;
    }",Advance the time of day by a set amount of hours.,Field.java,319.0,3
9,"public void generateWeather(){
        double randomNumber;
        WeatherTypes result=null;
        for(int i=0;i<depth;i+=10)
            for(int j=0;j<width;j+=10) {
                randomNumber = rand.nextDouble();
                for (WeatherTypes type : WeatherTypes.values())
                    if(randomNumber<=type.getProbability())
                        result = type;
                setWeather(i, j, result);
            }
    }","Randomly generate the weather across the field.
This is done in squares of size 10 by 10.",Field.java,319.0,3
10,"private void setWeather(int row, int col, WeatherTypes type){
        for(int i=row;i<row+10 && i<depth;i++)
            for(int j=col;j<col+10 && j<width;j++)
                getLocation(i, j).setWeather(type);
    }

    /**
     * @return The time of day in hours (from 0 to 23)
     */
    public int getTimeOfDay(){
        return timeOfDay;
    }

    /**
     * Get a shuffled list of the free adjacent locations.
     * @param location Get locations adjacent to this.
     * @return A list of free adjacent locations.
     */
    public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(isFree(next)) {
                free.add(next);
            }
        }
        return free;
    }

    /**
     * Try to find a free location that is adjacent to the
     * given location. If there is none, return null.
     * The returned location will be within the valid bounds
     * of the field.
     * @param location The location from which to generate an adjacency.
     * @return A valid location within the grid area.
     */
    public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }

    /**
     * Return a shuffled list of locations adjacent to the given one.
     * The list will not include the location itself.
     * All locations will lie within the grid.
     * @param location The location from which to generate adjacencies.
     * @return A list of locations adjacent to that given.
     */
    public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        int row = location.getRow();
        int col = location.getCol();
        for(int roffset = -1; roffset <= 1; roffset++) {
            int nextRow = row + roffset;
            if(nextRow >= 0 && nextRow < depth) {
                for(int coffset = -1; coffset <= 1; coffset++) {
                    int nextCol = col + coffset;
                    // Exclude invalid locations and the original location.
                    if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                        locations.add(field[nextRow][nextCol]);
                    }
                }
            }
        }

        // Shuffle the list. Several other methods rely on the list
        // being in a random order.
        Collections.shuffle(locations, rand);
        return locations;
    }

    /**
     * Return the depth of the field.
     * @return The depth of the field.
     */
    public int getDepth()
    {
        return depth;
    }

    /**
     * Return the width of the field.
     * @return The width of the field.
     */
    public int getWidth()
    {
        return width;
    }
}","Attributes a specified type of weather to a 10 by 10 square
(with the left-upper corner in the specified position)
@param row The row
@param col The col
@param type The type of weather",Field.java,319.0,3
0,"public void update(Field field){
        Actor act;

        this.infectedStats.reset();
        for(int row = 0; row < field.getDepth(); ++row) {
            for(int col = 0; col < field.getWidth(); ++col) {
                for (Actor actor : field.getActorsAt(row, col)) {
                    act = actor;
                    if (act instanceof Animal && ((Animal) act).isInfected()) {
                        this.infectedStats.incrementCount(act.getClass());
                    }
                }
            }
        }
        int i=0;
        for(String str : infectedStats.getPopulationDetailsSeparate()){
            labels[i].setText(str);
            i++;
        }
    }","Update the infection view.
@param field The field which the infection view analyzes.",InfectionView.java,319.0,3
0,"protected void setIsAwake(boolean[] isAwake){
        this.isAwake = isAwake;
    }","Sets the isAwake array of this instance.
@param isAwake The animal's sleeping schedule.",Animal.java,319.0,3
1,"public boolean getGender(){
        return gender;
    }",@return True if this animal is a male or false if it's female.,Animal.java,319.0,3
2,"protected void setFood(HashSet<Class<?>> food){
        this.food = food;
    }","Sets the species of animals this animal eats.
@param food The animal's food list (what it can and will eat).",Animal.java,319.0,3
3,"private Location moveRandomly(){
        return this.getField().freeAdjacentLocation(this.getLocation());
    }","Finds an available location to move to.
@return The location to which to move, chosen randomly",Animal.java,319.0,3
4,"@Override
    public void act(List<Actor> newAnimals){
        breedCooldown--;
        if(isAwake[getField().getTimeOfDay()/6]) {
            Location newLoc = null;
            //newLoc = super.getField().randomAdjacentLocation(super.getLocation());
            if (foodLevel * 2 < MAX_FOOD_LEVEL)
                newLoc = seekFood();
            else if (canBreed())
                newLoc = seekMate();
            if (newLoc == null) {
                newLoc = moveRandomly();
            }
            if (newLoc != null)
                super.move(newLoc);
            if (!eat())
                giveBirth(newAnimals);
        }
        incrementAge();
        incrementHunger();
        if(infected && isAlive())
            disease();
    }","Implements core actions for animals, such as hunting for food or for mates, as well as eating, breeding and aging.
@param newAnimals Newborn animals to be added into the world.",Animal.java,319.0,3
5,"private boolean eat(){
        boolean result = false;
        Animal an;
        Plant pl;
        ArrayList<Actor> toDie = new ArrayList<>();
        if(foodLevel * 2 < MAX_FOOD_LEVEL){{
                for(Actor act : getField().getActorsAt(getLocation())) {
                    //System.out.println(act.getClass());
                    if (act != null && foodLevel < MAX_FOOD_LEVEL && food.contains(act.getClass())) {
                        if (act instanceof Animal) {
                            an = (Animal) act;
                            foodLevel += an.getStats().getStat(StatTypes.NUTRITIONAL_VALUE);
                            toDie.add(act);
                        } else if (act instanceof Plant) {
                            pl = (Plant) act;
                            foodLevel += pl.isEaten(stats.getStat(StatTypes.BITE));
                            if(pl.getGrowth()<=0)
                                toDie.add(pl);
                        }
                        result = true;
                    }
                }
            }
            for(Actor dead : toDie){
                dead.setDead();
            }
            if(foodLevel>MAX_FOOD_LEVEL)
                foodLevel=MAX_FOOD_LEVEL;
        }

        return result;
    }","While the animal is hungry, it will eat whatever is in its diet and in the same location.
@return True if the animal ate.",Animal.java,319.0,3
6,"private Location seekFood(){
        return see(food);
    }","Points the animal to a food source if it is in its range of sight.
@return The location to which to move to in order to be closer to a food source.",Animal.java,319.0,3
7,"private Location seekMate(){
        HashSet<Class<?>> ownSpecies = new HashSet<>();
        ownSpecies.add(this.getClass());
        return see(ownSpecies);
    }","Points the animal to the closest member of the same species of the opposite gender in order to mate.
@return The location to which to move to in order to be closer to a mate.",Animal.java,319.0,3
8,"private Location see(HashSet<Class<?>> seeked){
        sLoc best = null;
        boolean genderDoesNotMatter=true;
        if(seeked.contains(this.getClass()))
            genderDoesNotMatter = false;

        Stack<sLoc> open = new Stack<>();
        HashSet <Location> closed = new HashSet<>();

        open.push(new sLoc(super.getLocation(),0,null));
        closed.add(super.getLocation());

        sLoc now;

        sLoc next;

        while(!open.isEmpty() && best==null){

            now = open.pop();
            if(now.l!=null && now.d!=0) {
                for (Actor act : now.l.getActors()) {
                    if (seeked.contains(act.getClass()) &&
                            (genderDoesNotMatter || ((Animal) act).getGender()!=this.getGender())) {
                        best = now;
                    }
                }
            }

            if(now.d < stats.getStat(StatTypes.SIGHT) + getLocation().getWeather().getSightAffection()){
                for(Location loc : super.getField().adjacentLocations(now.l)){
                    if(!closed.contains(loc)){
                        next = new sLoc(loc,now.d+1,now);
                        closed.add(loc);
                        open.push(next);
                    }
                }
            }
        }

        if(best != null) {
            while(best.d>1)
                best = best.bef;
            if(best.l!=null)
                return best.l;
        }
        return null;
    }","A searching algorithm based on Lee's algorithm which searches around the animal in it's vision field.
@param seeked The classes the animal should search for.
@return The location to which to move to in order to be closer to what the animal searched for.",Animal.java,319.0,3
9,"protected void incrementAge()
    {
        age++;
        if(age > stats.getStat(StatTypes.MAX_AGE)) {
            setDead();
        }
    }","Increase the age.
This could result in the animal's death.",Animal.java,319.0,3
10,"protected Stats getStats(){
        return stats;
    }",@return The animal's stats.,Animal.java,319.0,3
11,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this animal more hungry. This could result in the animal's death.,Animal.java,319.0,3
12,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextInt(100) <= stats.getStat(StatTypes.BREEDING_PROBABILITY)) {
            births = rand.nextInt(stats.getStat(StatTypes.MAX_LITTER_SIZE)) + 1;
        }
        if(births>0)
            breedCooldown=15;
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,319.0,3
13,"public int getAge(){
        return age;
    }",@return The age of the animal.,Animal.java,319.0,3
14,"private boolean canBreed()
    {
        return age >= stats.getStat(StatTypes.BREEDING_AGE) && breedCooldown<=0;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Animal.java,319.0,3
15,"private void giveBirth(List<Actor> newAnimals)
    {
        // New animals are born into adjacent locations.
        // Get a list of adjacent free locations.
        boolean foundMate=false;
        for(Actor act : getLocation().getActors())
            if(act.getClass()==this.getClass() && ((Animal) act).getGender()!=this.getGender())
                foundMate=true;
        if(foundMate) {
            int births = breed();
            for (int b = 0; b < births; b++)
                newAnimals.add(spawnAnimal(getLocation()));
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newAnimals A list to return newly born animals.",Animal.java,319.0,3
16,"private void disease(){
        if(infCounter==0) {
            infected = false;
            //treated
            //revert infection
        }
        else {
            infCounter--;
            foodLevel--;
            for(Location loc : getField().adjacentLocations(getLocation())){
                for(Actor act : loc.getActors()){
                    if(act.getClass().equals(this.getClass()) && ((Animal) act).canInfect()){
                        ((Animal) act).infect();
                    }
                }
            }
        }
    }","Shortens the amount of time left for the animal to be infected.
Also infects animals of the same species in the vicinity.",Animal.java,319.0,3
17,"public void infect(){
        infected = true;
        infCounter = DISEASE_DURATION;
        wasInfected = true;
    }",Infects this animal.,Animal.java,319.0,3
18,"public boolean canInfect(){
        return !wasInfected;
    }",@return True if the animal can be infected.,Animal.java,319.0,3
19,"public boolean isInfected(){
        return infected;
    }",@return True if the animal is infected.,Animal.java,319.0,3
0,"@Override
    protected Plant newPlant(Location location){
        return new Lavender(false, getField(),location);
    }","Spawn a Lavender in a given location.
@param location The location in which to spawn the plant.
@return The Lavender to be spawned.",Lavender.java,319.0,3
0,"@Override
    protected Plant newPlant(Location location){
        return new Flower(false, getField(),location);
    }","Spawn a Flower in a given location.
@param location The location in which to spawn the plant.
@return The Flower to be spawned.",Flower.java,319.0,3
0,"public static void modifyDelay(int k){
        if(k == -1 && delay>1){
            delay /= 2;
            mult*= 2;
        }
        else if(k == 1 && delay < 1<<10){
            delay *= 2;
            mult/= 2;
        }
    }","Modifies the delay based on input:
doubles for k=1
halves for k=-1
@param k The input",delayTime.java,319.0,3
1,"public static double getMult(){
        return mult;
    }",@return The current multiplier,delayTime.java,319.0,3
2,"public static boolean getPlay(){
        return play;
    }",@return False if the simulation is paused.,delayTime.java,319.0,3
3,"public static void setPlay(boolean val){
        play = val;
    }","Modifies the play field.
@param val The value to be assigned to play.",delayTime.java,319.0,3
4,"public static int getDelay(){
        return delay;
    }",@return The current delay.,delayTime.java,319.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,132.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,132.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,132.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,132.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,132.0,3
0,"public void actDay(boolean isRaining)
    {
        if(isAlive()){
            lifeProcesses();
        }
        if(isRaining)
        {
            growthLevel++;
        }
    }","This is what the Tree does most of the time - it grows
and ages
* @param isRaining if it is raining or not, if true, grass grows 2
levels",Tree.java,132.0,3
1,"public void actNight(boolean isRaining)
    {
        if(isAlive()){
            lifeProcesses();
        }
        if(isRaining)
        {
            growthLevel++;
        }
    }","This is what the Tree does most of the time - it grows
and ages
@param isRaining if it is raining or not, if true, grass grows 2
levels",Tree.java,132.0,3
2,"public int getFoodValue()
    {
            return FOOD_VALUE;
    }",@return Food value Tree provides,Tree.java,132.0,3
3,"public int getRegrowthPeriod()
    {
        return REGROWTH_PERIOD;
    }",@return Time before Tree regrows and is edible,Tree.java,132.0,3
4,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age of Tree,Tree.java,132.0,3
0,"public void diseaseFunctions(Location location, Field field)
    {
        spreadDisease(location,field);
        incrementTimeWithDisease();
    }","Spread disease through host and increment time
host has lived with disease
@param loacation Location of host in field
@param field Field in which the hos is situated",Disease.java,132.0,3
1,"private void spreadDisease(Location location, Field field)
    {
        //assert field != null;
        List<Location> adjacent = field.adjacentLocations(location);
        for(Location position : adjacent)
        {
            Object adjacentActor = field.getObjectAt(position);
            if(adjacentActor instanceof Actor)
            {
                Actor actor = (Actor) adjacentActor;
                if(rand.nextDouble() <= INFECTION_CHANCE)
                {
                    new Disease(actor);
                }
            }
        }
    }","Spread disease to actors neighbouirng the host
@param loacation Location of host in field
@param field Field in which the hos is situated",Disease.java,132.0,3
2,"private void incrementTimeWithDisease()
    {
        timeWithDisease++;
        if(timeWithDisease >= SURVIVAL_TIME)
        {
            host.setDead();  
        }
    }","Increment time host has lived with disease
If it is over the surivival time
make the host die",Disease.java,132.0,3
0,"public void actDay(boolean isRaining)
    {
        bodilyFunctions();
        roam();
    }","Giraffes perform bodily functions i.e
age, get hungry, give birth etc.
If it is not raining and is daytime it roams
and finds food etc
@param isRaining whether it is raining or not",Giraffe.java,132.0,3
1,"public void actNight(boolean isRaining)
    {
        bodilyFunctions();
    }","Giraffes only perform bodily functions during night
and sleep thus not roam and hunt",Giraffe.java,132.0,3
2,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return Time Giraffe can go without eating,Giraffe.java,132.0,3
3,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age until Giraffe lives,Giraffe.java,132.0,3
4,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return Breeding age of a Giraffe,Giraffe.java,132.0,3
5,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return Max litter size of a Giraffe,Giraffe.java,132.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return Probability Giraffe breeds succesfully,Giraffe.java,132.0,3
7,"protected Actor generateOffspring(Field field, Location loc)
    {
        Giraffe young = new Giraffe(false, field, loc);
        return young;
    }","Create a new Giraffe
@param field Field of parent Giraffe
@param location Location of parent Giraffe
@return The newly born Giraffe",Giraffe.java,132.0,3
8,"public int getBreedingCooldown()
    {
        return BREEDING_COOLDOWN;
    }",@return Time period before Giraffe can breed again after giving birth,Giraffe.java,132.0,3
0,"public static Random getRandom()

    {

        if(useShared) {

            return rand;

        }

        else {

            return new Random();

        }

    }","Provide a random generator.

@return A random object.",Randomizer.java,132.0,3
1,"public static void reset()

    {

        if(useShared) {

            rand.setSeed(SEED);

        }

    }","Reset the randomization.

This will have no effect if randomization is not through

a shared Random generator.",Randomizer.java,132.0,3
0,"public void actNight(boolean isRaining)
    {
        bodilyFunctions();
        if(!isRaining)
            roam();
    }","Hyenas perform bodily functions i.e
age, get hungry, give birth etc.
If it is not raining and is night it roams
and finds food etc
@param isRaining whether it is raining or not",Hyena.java,132.0,3
1,"public void actDay(boolean isRaining)
    {
        bodilyFunctions();
    }","Hyenas only perform bodily functions during day
and sleep thus not roam and hunt",Hyena.java,132.0,3
2,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return Time Hyena can go without eating,Hyena.java,132.0,3
3,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age until Hyena lives,Hyena.java,132.0,3
4,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return Breeding age of Hyena,Hyena.java,132.0,3
5,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return Max litter size of Hyena,Hyena.java,132.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return Probability Hyena breeds succesfully,Hyena.java,132.0,3
7,"protected Actor generateOffspring(Field field, Location loc)
    {
        Hyena young = new Hyena(false, field, loc);
        return young;
    }","Create a new Hyena
@param field Field of parent Hyena
@param location Location of parent Hyena
@return The newly born Hyena",Hyena.java,132.0,3
8,"public int getBreedingCooldown()
    {
        return BREEDING_COOLDOWN;
    }",@return Time before Hyena is fertile after giving birth,Hyena.java,132.0,3
0,"public void lifeProcesses()
    {
        grow();
        incrementAge();
    }","Plant grows and its age increments
as the simulation progresses",Plant.java,132.0,3
1,"public void grow()
    {
        if(!edible)
        {
            growthLevel++;
        }
        if(growthLevel >= this.getRegrowthPeriod())
        {
            edible = true;
            growthLevel = 0;
        }
    }","If Plant is inedible it's growth level increases
and it becomes edible once it is past regrowth period",Plant.java,132.0,3
2,"protected void eaten()
    {
        setInedible();
    }",Plant once consumed becomes inedible for a set period,Plant.java,132.0,3
3,"private void setInedible()
    {
        edible = false;
        growthLevel = 0;
    }",Make Plant inedible and groth level 0,Plant.java,132.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,132.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,132.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,132.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,132.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,132.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,132.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null)
        {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else 
        {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,132.0,3
3,"public void showStatus(int step, int time, int day, Field field, boolean isNight, boolean rain)
    {
        if(!isVisible()) 
        {
            setVisible(true);
        }
        //int diseaseCount = stats.getDiseaseCounter();
        
        stepLabel.setText(STEP_PREFIX + step + ""    "" + TIME_PREFIX + time + ""hr    "" + DAY_PREFIX + day + ""    "" + RAIN_PREFIX + rain );
          //+ ""    "" + DISEASE_COUNTER_PREFIX);  //diseaseCount );
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) 
        {
            for(int col = 0; col < field.getWidth(); col++) 
            {
                Object actor = field.getObjectAt(row, col);
                if(actor != null)
                {
                    stats.incrementCount(actor.getClass());
                    fieldView.drawMark(col, row, getColor(actor.getClass()));
                }
                else 
                {
                    // colour empty space according to if it day or night
                    if(isNight)
                    {
                        fieldView.drawMark(col, row, EMPTY_COLOR_NIGHT);
                    }
                    else
                    {
                        fieldView.drawMark(col, row, EMPTY_COLOR_DAY);
                    }
                }
            }
        }
        stats.countFinished();
        //get population details from FieldStats class
        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param time The time (hour) of day
@param day The number of day
@param isNight If it is nigth or not
@param rain If it is raining or not",SimulatorView.java,132.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,132.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,132.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++)
        {
            simulateOneStep();
            //delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,132.0,3
2,"public void simulateOneStep()
    {
        step++;
        boolean isNight = enviromentalFactors.getIsNight();
        boolean isRaining = enviromentalFactors.getIsRaining();
        // Provide space for newborn Actors.
        List<Actor> newActors = new ArrayList<>();  
        // Let all rabbits act.
        for(Iterator<Actor> it = Actors.iterator(); it.hasNext(); )
        {
            Actor Actor = it.next();
            if(! Actor.isAlive()) 
            {
                it.remove();
            }
            //check if it is day or nigth for different behaviour      
            if(!isNight)
            {
                Actor.actDay(isRaining);
            }
            else
            {
                Actor.actNight(isRaining);
            }
            newActors.addAll(Actor.getNewActors());
        }
               
        // Add the newly born actors to the main lists.
        Actors.addAll(newActors);
        //increment the hour 
        enviromentalFactors.nextHour();
        //to show information on status bar 
        view.showStatus(step,enviromentalFactors.getTime(), enviromentalFactors.getDay(), field, isNight, isRaining);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
Lion and rabbit.",Simulator.java,132.0,3
3,"public void reset()
    {
        step = 0;
        Actors.clear();
        populate();
        boolean isNight = enviromentalFactors.getIsNight();
        boolean isRaining = enviromentalFactors.getIsRaining();
        // Show the starting state in the view.
        view.showStatus(step,enviromentalFactors.getTime(), enviromentalFactors.getDay(), field, isNight, isRaining);
    }",Reset the simulation to a starting position.,Simulator.java,132.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) 
        {
            for(int col = 0; col < field.getWidth(); col++) 
            {
                if(rand.nextDouble() <= LION_CREATION_PROBABILITY)
                {
                    Location location = new Location(row, col);
                    Lion lion = new Lion(true, field, location);
                    Actors.add(lion);
                }
                else if(rand.nextDouble() <= HYENA_CREATION_PROBABILITY)
                {
                    Location location = new Location(row, col);
                    Hyena hyena = new Hyena(true, field, location);
                    Actors.add(hyena);
                }
                else if(rand.nextDouble() <= GIRAFFE_CREATION_PROBABILITY) 
                {
                    Location location = new Location(row, col);
                    Giraffe giraffe = new Giraffe(true, field, location);
                    Actors.add(giraffe);
                }
                else if(rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) 
                {
                    Location location = new Location(row, col);
                    Zebra zebra = new Zebra(true, field, location);
                    Actors.add(zebra);
                }
                else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY) 
                {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    Actors.add(grass);
                }
                else if(rand.nextDouble() <= TREE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tree tree = new Tree(true, field, location);
                    Actors.add(tree);
                }
                else{} //leave the location empty.
            }
        }
    }",Randomly populate the field with actors.,Simulator.java,132.0,3
5,"private void delay(int millisec)
    {
        try 
        {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) 
        {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,132.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > this.getMaxAge())
            setDead();
    
    }","Increment age of the Actor
if age is greater than max age
then make the Actor die",Actor.java,132.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the Actor is no longer alive.
It is removed from the field.",Actor.java,132.0,3
2,"public void giveDisease()
    {
        diseased = true;
    }",Give Actor disease by setting boolean true,Actor.java,132.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the Actor at the new location in the given field.
@param newLocation The Actor's new location.",Actor.java,132.0,3
4,"protected boolean isAlive()
    {
        return alive;
    }",@return true if the Actor is still alive.,Actor.java,132.0,3
5,"protected boolean isEdible()
    {
        return edible;
    }",@return true if the Actor is still edible,Actor.java,132.0,3
6,"public boolean isDiseased()
    {
        return diseased;
    }",@return true if the Actor has disease.,Actor.java,132.0,3
7,"protected Location getLocation()
    {
        return location;
    }","Return the Actor's location.
@return The Actor's location.",Actor.java,132.0,3
8,"protected Field getField()
    {
        return field;
    }","Return the Actor's field.
@return The Actor's field.",Actor.java,132.0,3
9,"public ArrayList<Actor> getNewActors()
    {
        return newActors;
    }",@return List of new Actors added,Actor.java,132.0,3
0,"public void actDay(boolean isRaining)
    {
        bodilyFunctions();
        roam();
    }","Zebras perform bodily functions i.e
age, get hungry, give birth etc.
If it is not raining and is daytime it roams
and finds food etc
@param isRaining whether it is raining or not",Zebra.java,132.0,3
1,"public void actNight(boolean isRaining)
    {
        bodilyFunctions();
    }","Zebras only perform bodily functions during night
and sleep thus not roam and hunt",Zebra.java,132.0,3
2,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return Time Zebra can go without eating,Zebra.java,132.0,3
3,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age until Zebra lives,Zebra.java,132.0,3
4,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return Breeding age of a Zebra,Zebra.java,132.0,3
5,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return Max litter size of a Zebra,Zebra.java,132.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return Probability Zebra breeds succesfully,Zebra.java,132.0,3
7,"protected Actor generateOffspring(Field field, Location loc)
    {
        Zebra young = new Zebra(false, field, loc);
        return young;
    }","Create a new Zebra
@param field Field of parent Zebra
@param location Location of parent Zebra
@return The newly born Zebra",Zebra.java,132.0,3
8,"public int getBreedingCooldown()
    {
        return BREEDING_COOLDOWN;
    }",@return Time period before Zebra can breed again after giving birth,Zebra.java,132.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet())
        {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append("" "");
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,132.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) 
        {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,132.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null)
        {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,132.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,132.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) 
        {
            generateCounts(field);
        }
        for(Class key : counters.keySet())
        {
            Counter info = counters.get(key);
            if(info.getCount() > 0) 
            {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,132.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++)
        {
            for(int col = 0; col < field.getWidth(); col++) 
            {
                Object object = field.getObjectAt(row, col);
                if(object != null)
                {
                    incrementCount(object.getClass());
                    Actor actor = (Actor) object;
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of actors.
These are not kept up to date as actors
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,132.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location)
        {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else 
        {
            return false;
        }
    }",Implement content equality.,Location.java,132.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,132.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,132.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,132.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,132.0,3
0,"public boolean canEat(Actor consumer, Actor provider)
    {
       //Check if provider is edible (valid for plant)
       if(provider.isEdible())
       {
           //Check is provider is in consumer's food ArrayList
           ArrayList<String> possibleFood = foodChain.get(consumer.getClass().getSimpleName());
           if (possibleFood.contains(provider.getClass().getSimpleName()))
           {
               return true;
           }        
       }
       return false;
    }","@param consumer Actor that is the predator
@param provider Actor that is the prospective prey
@return true If Animal can consume the prey/plant",FoodChain.java,132.0,3
1,"public int getStartValue(Actor actor)
    {
        return getFood(actor,0);
    }","@param actor Actor f
@return Start food value in Actor",FoodChain.java,132.0,3
2,"public int getFood(Actor actor,int index)
    {
        return 300;
    }",@return 200 as initial food value in Actor,FoodChain.java,132.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,132.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,132.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,132.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,132.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,132.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,132.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,132.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) 
        {
            for(int col = 0; col < width; col++) 
            {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,132.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,132.0,3
2,"public void place(Object actor, int row, int col)
    {
        place(actor, new Location(row, col));
    }","Place an actor at the given location.
If there is already an actor at the location it will
be lost.
@param actor The actor to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,132.0,3
3,"public void place(Object actor, Location location)
    {
        field[location.getRow()][location.getCol()] = actor;
    }","Place an actor at the given location.
If there is already an actor at the location it will
be lost.
@param actor The actor to be placed.
@param location Where to place the actor.",Field.java,132.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the actor at the given location, if any.
@param location Where in the field.
@return The actor at the given location, or null if there is none.",Field.java,132.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the actor at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The actor at the given location, or null if there is none.",Field.java,132.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,132.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) 
        {
            if(getObjectAt(next) == null) 
            {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,132.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,132.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) 
            {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) 
                {
                    for(int coffset = -1; coffset <= 1; coffset++)
                    {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0))
                        {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,132.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,132.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,132.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age until Lion lives,Lion.java,132.0,3
1,"public void actDay(boolean isRaining)
    {
        bodilyFunctions();
        if (!isRaining)
            roam();
    }","Lions perform bodily functions i.e
age, get hungry, give birth etc.
If it is not raining and is daytime it roams
and finds food etc
@param isRaining whether it is raining or not",Lion.java,132.0,3
2,"public void actNight(boolean isRaining)
    {
        bodilyFunctions();
    }","Lions only perform bodily functions during night
and sleep thus not roam and hunt",Lion.java,132.0,3
3,"public int getFoodValue()
    {
        return LION_FOOD_VALUE;
    }",@return Time Lion can go without eating,Lion.java,132.0,3
4,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return Breeding age of a Lion,Lion.java,132.0,3
5,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return Max litter size of a Lion,Lion.java,132.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return Probability Lion breeds succesfully,Lion.java,132.0,3
7,"protected Actor generateOffspring(Field field, Location loc)
    {
        Lion young = new Lion(false, field, loc);
        return young;
    }","Create a new Lion
@param field Field of parent Lion
@param location Location of parent Lion
@return The newly born Lion",Lion.java,132.0,3
8,"public int getBreedingCooldown()
    {
        return BREEDING_COOLDOWN;
    }",@return Time period before Lion can breed again after giving birth,Lion.java,132.0,3
0,"public void actDay(boolean isRaining)
    {
        if(isAlive()){
            lifeProcesses();
        }
        if(isRaining)
        {
            growthLevel++;
        }
    }","This is what the Grass does most of the time - it grows
and ages
@param isRaining if it is raining or not, if true, grass grows 2
levels",Grass.java,132.0,3
1,"public void actNight(boolean isRaining)
    {
        if(isAlive()){
            lifeProcesses();
        }
        if(isRaining)
        {
            growthLevel++;
        }
    }","This is what the Grass does most of the time - it grows
and ages
@param isRaining if it is raining or not, if true, grass grows 2
levels",Grass.java,132.0,3
2,"public int getFoodValue()
    {
            return FOOD_VALUE;
    }",@return Food value Grass provides,Grass.java,132.0,3
3,"public int getRegrowthPeriod()
    {
        return REGROWTH_PERIOD;
    }",@return Time before Grass regrows and is edible,Grass.java,132.0,3
4,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return Max age of Grass,Grass.java,132.0,3
0,"public boolean canBreed()
    { 
        if (age >= this.getBreedingAge() && isFertile && checkForMate(getLocation())) 
            return true;
        else
            return false;
    }","@return true If Animal can breed if certain conditions
i.e breeding age, fertility and availability of
mate are satisfied",Animal.java,132.0,3
1,"protected void eaten()
    {
        setDead();
    }",If Animal is eaten they die,Animal.java,132.0,3
2,"protected boolean checkForMate(Location location)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        for(Location position : adjacent)
        {
            Object adjacentAnimal = field.getObjectAt(position);
            if(adjacentAnimal != null && adjacentAnimal instanceof Animal)
            {
                Animal animal = (Animal) adjacentAnimal;
                //Check both animals are of same species and opposite genders
                if (isCompatibleMate(this,animal))
                {
                    return true;
                }
            }
        }  
        return false;
    }","@return true If Animal next to another is of same species
and opposite gender for them to mate",Animal.java,132.0,3
3,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Hunger increase when food level in Animal
decreses. Animal dies if it is below 0.",Animal.java,132.0,3
4,"protected void giveBirth()
    {
        // New Animals are born into adjacent locations.
        // Get a list of adjacent free locations.
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        //Get number of Animals that will be born
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Actor young = this.generateOffspring(field,loc);
            newActors.add(young);
        }
        isFertile = false;
        breedingCooldownCounter = 0;
    }",Animal gives birth,Animal.java,132.0,3
5,"protected void roam()
    {
        if(isAlive()) 
        {
            //If Animal can breed is true then it gives birth
            if(canBreed())
            {
                giveBirth();
            }

            if(foodLevel < 200){
            // Move towards a source of food if found.
            
            Location newLocation = findFood();
            if(newLocation == null)
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();
            }
            }
        }
    }","Make the Animal roam and perform tasks
i.e giving birth, finding food when step
is incremented.",Animal.java,132.0,3
6,"protected void incrementBreedingCooldown()
    {
        if(isFertile == false)
        {    
            breedingCooldownCounter ++;
            if(breedingCooldownCounter >= this.getBreedingCooldown())
            {
                isFertile = true;
            }
        }
    }","Increment time Animal is not fertile
once it reaches cooldown value for Animal
it again becomes fertile",Animal.java,132.0,3
7,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Actor)
            {
                Actor actor = (Actor) object;
                if(foodChain.canEat(this,actor))
                {
                    actor.eaten();
                    foodLevel += actor.getFoodValue();
                    //if prey is an Animal the predator takes its place
                    if(object instanceof Animal)
                    {
                        return where;
                    }
                    else if(object instanceof Plant)
                    {
                        return null;
                    }
                }
            }
        }
        return null;
    }","Check if there is food next to Animal
and if Animal can eat it or not",Animal.java,132.0,3
8,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= this.getBreedingProbability()) 
        {
            births = rand.nextInt(this.getMaxLitterSize()) + 1;
        }
        return births;
    }","If Animal can breed and it's within breeding probability
randomly choose litter size from max litter size of Animal",Animal.java,132.0,3
9,"public boolean isMale()
    {
        return male;
    }",@return true If Animal is male,Animal.java,132.0,3
10,"public boolean isOppositeGender(Animal animal1,Animal animal2)
    {
        if(animal1.isMale() != animal2.isMale())
        {
            return true;
        }
        return false;
    }","@param animal1 Animal we're at
@param animal2 Animal next to it
@return true If both Animals are of opposite gender",Animal.java,132.0,3
11,"public boolean isSameSpecies(Animal animal1, Animal animal2)
    {
        if(animal1.getClass().equals(animal2.getClass()))
        {
            return true;
        }
        return false;
    }","@param animal1 Animal we're at
@param animal2 Animal next to it
@return true If both Animals are of same species",Animal.java,132.0,3
12,"public boolean isCompatibleMate(Animal animal1, Animal animal2){
        if(isOppositeGender(animal1,animal2) && isSameSpecies(animal1,animal2))
        {
            return true;
        }
        return false;
    }","@param animal1 Animal we're at
@param animal2 Animal next to it
@return true If both Animals are of same species and opposite genders",Animal.java,132.0,3
13,"public void bodilyFunctions()
    {
        if(alive)
        {
            Field field = getField();
            //assert field != null;
            //spread disease if Animal has disease
            if(diseased && disease != null)
            {
                disease.diseaseFunctions(getLocation(), getField());
            }
            incrementAge();
            incrementHunger();
            incrementBreedingCooldown();
        }
    }","Bodily function like increasing age, hunger etc.
taking place in Animal when it moves a step",Animal.java,132.0,3
14,"public Animal getSpecies()
    {
        return this;
    }",@return type of species,Animal.java,132.0,3
0,"public void nextHour()
    {
        currentTime++;
        checkNewDay();
        checkNight();
    }","Increment time of day and call methods to check if it is new day
and if it is night",EnviromentalFactors.java,132.0,3
1,"public void checkNewDay()
    {
        if(currentTime >= 24)
        {
            currentTime = 0;
            day ++;
            isRaining = rand.nextBoolean();
        }
    }","If hour of day is equal to 24 reset
it to 0(midnight) and increment number of day
and set randomly if it is raning or not",EnviromentalFactors.java,132.0,3
2,"private void checkNight()
    {
        if((currentTime >= 6) && (currentTime <= 19))
        {
            isNight = false;
        }
        else
        {
            isNight = true;
        }
    }","set boolean value for isNight according to
what time period (hours) of day it is
between 6am and 7pm it is daytime",EnviromentalFactors.java,132.0,3
3,"public int getTime()
    {
        return currentTime;
    }",@return Current time (hours) of the day,EnviromentalFactors.java,132.0,3
4,"public boolean getIsNight()
    {
        return isNight;
    }",@return true If it is night time,EnviromentalFactors.java,132.0,3
5,"public int getDay()
    {
        return day;    
    }",@return Number of day in simulation,EnviromentalFactors.java,132.0,3
6,"public boolean getIsRaining()
    {
        return isRaining;
    }",@returb true If it is raining,EnviromentalFactors.java,132.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,151.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,151.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,151.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,151.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,151.0,3
0,"public void act(List<Animal> newSharkes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSharkes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the shark does most of the time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSharkes A list to return newly born sharkes.",Shark.java,151.0,3
1,"private void incrementAge()
    {
        age++;//increment the age 
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead();//the shark will be dead
        }
    }",Increase the age. This could result in the shark's death.,Shark.java,151.0,3
2,"private void incrementHunger()
    {
        foodLevel--; //decreasing food level of fish by one
        //if the food level of shark is less than or equal to 0
        if(foodLevel <= 0) {
            setDead();//the shark will be dead
        }
    }",Make this shark more hungry. This could result in the shark's death.,Shark.java,151.0,3
3,"private Location findFood()
    {
        //check the animals and plants around the shark
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean whaleEx = animal instanceof Whale;

            //if the adjacent shrimp was alive and there isnt any whale around the shark let the shark to eat it 
            if(animal instanceof Shrimp && !whaleEx) {            
                Shrimp shrimp = (Shrimp) animal;
                if(shrimp.isAlive()) { 
                    shrimp.setDead();
                    foodLevel = SHRIMP_FOOD_VALUE;
                    return where;
                }
            }

            //if the adjacent plankton was alive and there isnt any whale around the shark let the shark to eat it 
            if(animal instanceof Plankton && !whaleEx) {           
                Plankton plankton = (Plankton) animal;
                if(plankton.isAlive()) { 
                    plankton.setDead();
                    foodLevel = PLANKTON_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
shark can eat plankton and shrimp only if there is
no whale around it
@return Where food was found, or null if it wasn't.",Shark.java,151.0,3
4,"private void giveBirth(List<Animal> newSharkes)
    {
        // New sharkes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Shark young = new Shark(false, field, loc);
            newSharkes.add(young);
        }
    }","Check whether or not this shark is to give birth at this step.
New births will be made into free adjacent locations.
@param newSharkes A list to return newly born sharkes.",Shark.java,151.0,3
5,"private int breed()
    {
        int births = 0;
        if(dayNight.isDay() && canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {   //breeds only in day.
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Shark.java,151.0,3
6,"private boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            for (int i =0; i>= field.adjacentLocations(getLocation()).size(); i++)
            {
                //if the adjacent animal is a male shark 
                if(animal instanceof Shark && isMale)
                {
                    //if the shark is female and is old enough to breed and the food level is grater than 2
                    if (!isMale && age >= BREEDING_AGE && foodLevel>2)
                    {
                        return true; //the shark can breed
                    }
                }

                //if the adjacent animal is a female shark
                if(animal instanceof Shark && !isMale )
                {
                    //if the shark is male and is old enough to breed and the food level is grater than 2
                    if (isMale && age >= BREEDING_AGE && foodLevel>2)
                    {
                        return true; //the shark can breed
                    }
                }
            }
        }
        return age >= BREEDING_AGE;
    }","A shark can breed if it has reached the breeding age.
@return true if the shark can breed, false otherwise.
a shark can only breed if it is next to its opposite gender",Shark.java,151.0,3
7,"public int returnHunger()
    {
        return foodLevel;
    }",returns the food level of sahrk,Shark.java,151.0,3
0,"public boolean hasDisease()
    {
        System.out.println(""Animals have been infected with unknown disease!!!"");
        hasDisease =true;
        return hasDisease;
        
    }","a method which infects the animals by disease
and prints that they have been infected",Disease.java,151.0,3
1,"public boolean hasNotDisease()
    {
        System.out.println(""Animals have been cured!!!"");
        hasDisease =false;
        return hasDisease;
    }","a method which cures the animals from disease
and prints that they have been cured",Disease.java,151.0,3
0,"public void computeStep(int step)
    {
        a= ((step - (step % 100))/100) % 2;  //calculating the time 
        
        //old calculation:
        //a = step % 100;
        //b = step - a;
        //c = b / 100;
        //d = c % 2;
        
        //if the button chosen is on automatic mode
        if (!button){
            //if the calculation shows that is day
            if(a == 0)
            {
                isDay = true;  //the current time changes to day
            }
            else
            {
                isDay = false;  //the current time changes to night
            }
        }
    }","this method gets the steps from SimulatorView Class
and then computes the the time of the day by
having the count of steps
each 100 step the day and night changes
this method will only be running if the button
is in automatic mode",DayNight.java,151.0,3
1,"public boolean isDay()
    {
        return isDay;
    }","returns a boolean of the current time
true if its day
false if its night",DayNight.java,151.0,3
2,"public String showTime()
    {
        //if its day
        if(isDay())
        {
            return ""ITS DAY!!!"";

        }
        else
        {
            return ""ITS NIGHT!!!"";
        }
    }",returns a string of current time,DayNight.java,151.0,3
3,"public void day()
    {

        button = true;
        isDay = true;
    }","this method will change the current time to day
and also the current mode to manual",DayNight.java,151.0,3
4,"public void night()
    {
        button = true;
        isDay = false;
    }","this method will change the current time to night
and also the current mode to manual",DayNight.java,151.0,3
5,"public void auto()
    {
        button = false;
    }",this method changes the current time mode to auto,DayNight.java,151.0,3
6,"public void changeTime()
    {
        if (button)
        {
            if (isDay)
            {
                isDay = false;
            }
            else if(!isDay)
            {
                isDay = true;
            }
        }
    }","this method changes the time depending on what it is
if the current time is day, it changes to night
vice versa",DayNight.java,151.0,3
7,"public String showMode()
    {
        if (!button)
        {
            return ""(Auto mode)"";
        }
        else if (button)
        {
            return ""(Manual mode)"";
        }
        return ""MODE"";
    }",this method returns string of current time mode,DayNight.java,151.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,151.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,151.0,3
0,"public void act(List<Animal> newWhales)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newWhales);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null ) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the whale does most of the time: it hunts for
fish and plankton. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newWhales A list to return newly born whales.",Whale.java,151.0,3
1,"private void incrementAge()
    {
        age++;  //increment the age 
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead(); //the whale will be dead
        }
    }",Increase the age. This could result in the whale's death.,Whale.java,151.0,3
2,"private void incrementHunger()
    {
        foodLevel--;   //decreasing food level of fish by one
        //if the food level of whale is less than or equal to 0
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this whale more hungry. This could result in the whale's death.,Whale.java,151.0,3
3,"private Location findFood()
    {
        //check the animals and plants around the whale
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            //only hunts if its day.
            if(dayNight.isDay()) 
            {
                //if the adjacent plankton was alive it lets the whale to eat it 
                if(animal instanceof Plankton) {           
                    Plankton plankton = (Plankton) animal;
                    if(plankton.isAlive()) { 
                        plankton.setDead();
                        foodLevel = PLANKTON_FOOD_VALUE;
                        return where;
                    }
                }
                //if the adjacent fish was alive it lets the whale to eat it 
                if(animal instanceof Fish) {
                    Fish fish = (Fish) animal;
                    if(fish.isAlive()) { 
                        fish.setDead();
                        foodLevel = FISH_FOOD_VALUE;
                        return where;
                    }
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Whale.java,151.0,3
4,"private void giveBirth(List<Animal> newWhales)
    {
        // New whales are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Whale young = new Whale(false, field, loc);
            newWhales.add(young);
        }
    }","Check whether or not this whale is to give birth at this step.
New births will be made into free adjacent locations.
@param newWhales A list to return newly born whales.",Whale.java,151.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Whale.java,151.0,3
6,"private boolean canBreed()
    {

        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            for (int i =0; i>= field.adjacentLocations(getLocation()).size(); i++)
            {
                //if the adjacent animal is a male shark and the food level is greater than 3
                if(animal instanceof Whale && isMale && foodLevel>3)
                {
                    //if the whale is female and is old enough to breed 
                    if (!isMale && age >= BREEDING_AGE)
                    {
                        return true;  //the whale can breed
                    }
                }
                
                //if the adjacent animal is a female whale and the food level is greater than 3
                if(animal instanceof Whale && !isMale && foodLevel >3)
                {
                    //if the whale is male and is old enough to breed
                    if (isMale && age >= BREEDING_AGE)
                    {
                        return true;  //the whale can breed
                    }
                }
            }
        }
        return age >= BREEDING_AGE;
    }","A whale can breed if it has reached the breeding age.
@return true if the whale can breed, false otherwise.
a whale can only breed if it is next to its opposite gender",Whale.java,151.0,3
7,"public int returnHunger()
    {
        return foodLevel;
    }",returns the food level of sahrk,Whale.java,151.0,3
0,"public void computeStep(int step, boolean isDay)
    {
        this.isDay = isDay;
        steps = step;

        //if the steps are divisible by 30
        a = step % 30;
        if(!button)
        {
            if(a == 0)
            {
                changeWeather();
            }
        }
    }","this method gets the steps and current time
from SimulatorView Class and then computes the
current weather by having the count of steps

if the weather is on automatic mode
each 30 steps the changeWeather() method weil be called",Weather.java,151.0,3
1,"public void changeWeather()
    {
        Random rd = new Random(); // creating Random object

        //every 30 steps the weather randomly changes
        isCloudy = rd.nextBoolean();
        if (!isDay && isCloudy)
        {
            isCloudy = false;
        }
    }","if the weather is on automatic mode
evary 30 steps this method weil be called

this method changes the weather depending on current condition
if the current weather is cloudy, then it generates a new
random boolean and then changes the weather",Weather.java,151.0,3
2,"public String showWeather()
    {   

        if(isCloudy )
        {
            return ""The weather is cloudy"";

        }
        else
        {
            return ""The sky is clear"";
        }
    }",returns a string of current weather,Weather.java,151.0,3
3,"public boolean isCloudy()
    {
        return isCloudy;
    }","returns a boolean of the current weather
true if its cloudy
false if its clear",Weather.java,151.0,3
4,"public void cloudy()
    {
        isCloudy = true; 
        button = true;
    }","this method will change the current weather to cloudy
and also the current mode to manual",Weather.java,151.0,3
5,"public void clear()
    {
        button = true;
        isCloudy = false;
    }","this method will change the current weather to clear
and also the current mode to manual",Weather.java,151.0,3
6,"public void auto()
    {
        button = false;
    }",this method will change the current weather to auto,Weather.java,151.0,3
7,"public String showMode()
    {
        if (!button)
        {
            return ""(Auto mode)"";
        }
        else if (button)
        {
            return ""(Manual mode)"";
        }
        return ""MODE"";
    }",this method returns string of current weather mode,Weather.java,151.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,151.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,151.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,151.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,151.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,151.0,3
0,"public void act(List<Animal> newShrimps)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newShrimps);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the shrimp does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newShrimps A list to return newly born shrimps.",Shrimp.java,151.0,3
1,"private void incrementAge()
    {
        age++; //increment the age 
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead(); //the shrimp will be dead
        }
    }","Increase the age.
This could result in the shrimp's death.",Shrimp.java,151.0,3
2,"private void giveBirth(List<Animal> newShrimps)
    {
        // New shrimps are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Shrimp young = new Shrimp(false, field, loc);
            newShrimps.add(young);
        }
    }","Check whether or not this shrimp is to give birth at this step.
New births will be made into free adjacent locations.
@param newShrimps A list to return newly born shrimps.",Shrimp.java,151.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Shrimp.java,151.0,3
4,"private boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            // checks for opposite gender
            for (int i =0; i>= field.adjacentLocations(getLocation()).size(); i++)
            {
                //if the adjacent animal is a male shrimp 
                if(animal instanceof Shrimp && isMale)
                {
                    //if the shrimp is female and is old enough to breed
                    if (!isMale && age >= BREEDING_AGE)
                    {
                        return true; //it can breed
                    }
                }
                
                //if the adjacent animal is a female shrimp 
                if(animal instanceof Shrimp && !isMale)
                {
                    //if the shrimp is male and is old enough to breed
                    if (isMale && age >= BREEDING_AGE)
                    {
                        return true; //it can breed
                    }
                }
            }
        }
        return age >= BREEDING_AGE;
    }","A shrimp can breed if it has reached the breeding age.
@return true if the shrimp can breed, false otherwise.
a shrimp can only breed if it is next to its opposite gender",Shrimp.java,151.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,151.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,151.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,151.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,151.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,151.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,151.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // returns the defined unknown colour
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,151.0,3
3,"public void showStatus(int step, Field field)
    {
        //changes the visibility to true if its not true
        if(!isVisible()) {
            setVisible(true);
        }
        
        //returning the step variable to the DayNight Class
        dayNight.computeStep(step);
        
        //returning the step variable and current time to the Weather Class
        weather.computeStep(step, dayNight.isDay());
        
        //displays the current step on the top left corner of the frame 
        stepLabel.setText(STEP_PREFIX + step);
        
        //display the current weather and current weather mode in the top center of the frame
        weatherLoc.setText(CURRENT_WEATHER_PREFIX + weather.showWeather() + "",  "" + weather.showMode());
        
        //display the current time of the day and the current time mode in the top right corner of the frame 
        time.setText(CURRENT_TIME_PREFIX + dayNight.showTime() + "",  "" + dayNight.showMode());
        
        
        stats.reset();

        
        //checkes the day and weather at the same time
        //then decides which colour should the fields be
        
        fieldView.preparePaint();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                //if its day and the weather is cloudy:
                else if(dayNight.isDay() && weather.isCloudy()){
                    //seting the colour to day
                    fieldView.drawMark(col, row, DAY_COLOR);
                    //seting the colour of the cells to cloudy weather
                    setCloudyWeather();

                }
                //if its day and the weather is not cloudy
                else if(dayNight.isDay() && !weather.isCloudy()){
                    //seting the colour to day
                    fieldView.drawMark(col, row, DAY_COLOR);
                    //seting the colour of the cells to not cloudy weather
                    setNotCloudyWeather();
                }
                //if its night and the weather is cloudy
                else if(!dayNight.isDay() && weather.isCloudy()){
                    //seting the colour to night
                    fieldView.drawMark(col, row, NIGHT_COLOR);
                    //seting the coulour of the cells to cloudy weather
                    setCloudyWeather();

                }
                //if its night and the weather is not cloudy
                else if(!dayNight.isDay() && !weather.isCloudy()){
                    //seting the colour to night
                    fieldView.drawMark(col, row, NIGHT_COLOR);
                    //seting the colour of the cells to not cloudy weather
                    setNotCloudyWeather();
                }
            }
        }
        stats.countFinished();
        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,151.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,151.0,3
5,"public void displayKey()
    {
        System.out.println("" Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Welcome to the 'INTO THE DEEP OCEAN' simulator          Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t This is the Key:                                        Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Shark is Blue                                           Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Whale is Pink                                           Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Fish is Orange                                          Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Shrimp is Red                                           Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Plankton is Yellow                                      Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂ\t Seaweed is Green                                        Ã¢ÂÂ"");
        System.out.println("" Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ"");
    }","Print out the opening message for the player.
Prints the key when the user calls the method
this method is called when the user presses the 'Key' button",SimulatorView.java,151.0,3
6,"private void setCloudyWeather()
    {
        
        setColor(Fish.class, new Color(255,165,0,100)); //set the colour of fish to orange
        setColor(Shark.class, new Color(0,0,255,100));  //set the colour of shark to blue
        setColor(Shrimp.class, new Color(255,0,0,100));  //set the colour of shrimp to red
        setColor(Whale.class, new Color(255,192,203,100)); //set the colour of whale to pink
        setColor(Plankton.class, new Color(255,255,0,100)); //set the colour of plankton to yellow
        setColor(SeaWeed.class, new Color(0,255,0,100)); //set the colour of seaweed to green
    }","this method sets the colour of the cells to the cloudy colour
by decreasing its opacity",SimulatorView.java,151.0,3
7,"private void setNotCloudyWeather()
    {
        setColor(Fish.class, new Color(255,165,0,255)); //set the colour of fish to orange
        setColor(Shark.class, new Color(0,0,255,255));  //set the colour of shark to blue
        setColor(Shrimp.class, new Color(255,0,0,255));  //set the colour of shrimp to red
        setColor(Whale.class, new Color(255,192,203,255)); //set the colour of whale to pink
        setColor(Plankton.class, new Color(255,255,0,255)); //set the colour of plankton to yellow
        setColor(SeaWeed.class, new Color(0,255,0,255)); //set the colour of seaweed to green
    }","this method sets the colour of the cells to the not cloudy colour
by increasing its opacity",SimulatorView.java,151.0,3
8,"private void setAutoCloudyWeather()
    {
        //if the weather is cloudy         
        if (weather.isCloudy())
        {
            //seting the coulour of the cells to cloudy weather
            setCloudyWeather();         
        }
        
        //if the weather is not cloudy   
        if (!weather.isCloudy())
        {
            //seting the coulour of the cells to not cloudy weather
            setNotCloudyWeather();
        }
    }","this method sets the colour of the cells to cloudy/not cloudy colour
by checking the weather condition",SimulatorView.java,151.0,3
0,"public void runLongSimulation()
    {
        simulate(2000);     // max step is 2000
    }","Run the simulation from its current state for a reasonably long period,
(2000 steps).",Simulator.java,151.0,3
1,"public void simulate(int numSteps)
    {

        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,151.0,3
2,"public void simulateOneStep()
    {
        // its a if statment which stops the game 
        if(!stop){   
            step++;
            // Provide space for newborn animals.
            List<Animal> newAnimals = new ArrayList<>(); 

            // Provide space for newborn plants.
            List<Plant> newPlants = new ArrayList<>();

            // Let all animals act.
            for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.act(newAnimals);
                if(! animal.isAlive()) {
                    animal.setDead();

                }
            }
            // Let all plants act.
            for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
                Plant plant = it.next();
                plant.act(newPlants);
                if(! plant.isAlive()) {
                    it.remove();
                }
            }

            // Add the newly born animals and plants to the main lists.
            animals.addAll(newAnimals);
            plants.addAll(newPlants);

            //returns the step and field to the SimulatorView Class
            view.showStatus(step, field);
        }
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
shark and fish.",Simulator.java,151.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();

        // Show the starting state in the view.
        //returns the step and field to the SimulatorView Class
        view.showStatus(step, field);

    }",Reset the simulation to a starting position.,Simulator.java,151.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                //populates the field with sharks
                if(rand.nextDouble() <= SHARK_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shark shark = new Shark(true, field, location);
                    animals.add(shark);
                }
                //populates the field with fish
                else if(rand.nextDouble() <= FISH_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fish fish = new Fish(true, field, location);
                    animals.add(fish);
                }
                //populates the field with palnktons
                else if(rand.nextDouble() <= PLANKTON_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Plankton plankton = new Plankton(true, field, location);
                    animals.add(plankton);
                }
                //populates the field with whales
                else if(rand.nextDouble() <= WHALE_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Whale whale = new Whale(true, field, location);
                    animals.add(whale);
                }
                //populates the field with shrimps
                else if(rand.nextDouble() <= SHRIMP_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Shrimp shrimp = new Shrimp(true, field, location);
                    animals.add(shrimp);
                }
                //populates the field with seaweed
                else if(rand.nextDouble() <= SEAWEED_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    SeaWeed seaWeed = new SeaWeed(true, field, location);
                    plants.add(seaWeed);
                }

                // else leave the location empty.
            }
        }
    }",Randomly populate the field with all animals and plants.,Simulator.java,151.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,151.0,3
6,"public void stop()
    {
        stop = true;
    }","By calling this method, the simulation stops",Simulator.java,151.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,151.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,151.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,151.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,151.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,151.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of sharkes and fishs.
These are not kept up to date as sharkes and fishs
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,151.0,3
0,"public void act(List<Animal> newFish)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newFish);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fish does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born fish.",Fish.java,151.0,3
1,"private void incrementHunger()
    {
        foodLevel--; //decreasing food level of fish by one
        //if the food level of fish is less than or equal to 0
        if(foodLevel <= 0) { 
            setDead(); //the fish will be dead
        }
    }",Make this fish more hungry. This could result in the fish's death.,Fish.java,151.0,3
2,"private void incrementAge()
    {
        age++; //increment the age 
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead(); //the fish will be dead
        }
    }","Increase the age.
This could result in the fish's death.",Fish.java,151.0,3
3,"private void diseaseCounter()
    {
        age += 5;
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead(); //the fish will be dead
        }
    }",Increase the age by 5,Fish.java,151.0,3
4,"private void giveBirth(List<Animal> newFish)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fish young = new Fish(false, field, loc);
            newFish.add(young);
        }
    }","Check whether or not this fish is to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born fish.",Fish.java,151.0,3
5,"private Location findFood()
    {
        //check the animals and plants around the fish
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);            
            SeaWeed seaWeed = (SeaWeed) plant;
            
            //if the adjacent seaweed was alive let the fish to eat it
            if(seaWeed.isAlive()) { 
                seaWeed.setDead();
                foodLevel = SEAWEED_FOOD_VALUE;
                return where;
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
fish can only eat seaweed
@return Where food was found, or null if it wasn't.",Fish.java,151.0,3
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fish.java,151.0,3
7,"private boolean canBreed()
    {

        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            for (int i =0; i>= field.adjacentLocations(getLocation()).size(); i++)
            {
                //if the adjacent animal is a male fish 
                if(animal instanceof Fish && isMale)
                {
                    //if the fish is female and is old enough to breed
                    if (!isMale && age >= BREEDING_AGE && foodLevel>1)
                    {
                        return true;//the fish can breed
                    }
                }
                
                //if the adjacent animal is a female fish
                if(animal instanceof Fish && !isMale)
                {
                    //if the fish is male and is old enough to breed
                    if (isMale && age >= BREEDING_AGE && foodLevel>1)
                    {
                        return true; //the fish can breed
                    }
                }
            }
        }
        return age >= BREEDING_AGE;
    }","A fish can breed if it has reached the breeding age.
@return true if the fish can breed, false otherwise.
a fish can only breed if it is next to its opposite gender",Fish.java,151.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,151.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,151.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,151.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,151.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,151.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,151.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,151.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,151.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,151.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,151.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,151.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,151.0,3
0,"public void act(List<Plant> newSeaWeeds)
    {
        incrementAge();
        //incrementHunger();
        if(isAlive()) {
            giveBirth(newSeaWeeds);            
            if(staticLocation == null) {
                setLocation(staticLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the seaWeed does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newSeaWeeds A list to return newly born seaWeeds.",SeaWeed.java,151.0,3
1,"private void incrementHunger()
    {
        foodLevel--; //decreasing food level of fish by one
        //if the food level of fish is less than or equal to 0
        if(foodLevel <= 0) { 
            setDead(); //the fish will be dead
        }
    }",Make this seaweed more hungry. This could result in the seaweed's death.,SeaWeed.java,151.0,3
2,"private void incrementAge()
    {
        age++; //increment the age 
        //if the current age was grater than max age 
        if(age > MAX_AGE) {
            setDead(); //the fish will be dead
        }
    }","Increase the age.
This could result in the seaWeed's death.",SeaWeed.java,151.0,3
3,"private void giveBirth(List<Plant> newSeaWeeds)
    {
        // New seaWeeds are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            SeaWeed young = new SeaWeed(false, field, loc);
            newSeaWeeds.add(young);
        }
    }","Check whether or not this seaWeed is to give birth at this step.
New births will be made into free adjacent locations.
@param newSeaWeeds A list to return newly born seaWeeds.",SeaWeed.java,151.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
        }
        return null;
    }","Look for seaWeeds adjacent to the current location.
Only the first live seaWeed is eaten.
@return Where food was found, or null if it wasn't.",SeaWeed.java,151.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed()) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",SeaWeed.java,151.0,3
6,"private boolean canBreed()
    {
        return dayNight.isDay() && weather.isCloudy() && age >= BREEDING_AGE;
    }","A seaWeed can breed if it has reached the breeding age.
and it can only breed at day and when the weather is cloudy
@return true if the seaWeed can breed, false otherwise.",SeaWeed.java,151.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,151.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,151.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,151.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,151.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,151.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,151.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,151.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,151.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,151.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,151.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,151.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,151.0,3
0,"public void act(List<Animal> newPlanktons)
    {
        incrementAge();
        //incrementHunger();
        if(isAlive()) {
            giveBirth(newPlanktons);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the plankton does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newPlanktons A list to return newly born planktons.",Plankton.java,151.0,3
1,"private void incrementAge()
    {
        age++;  //increment the age 
        //if the current age was grater than max age
        if(age > MAX_AGE) {
            setDead();//the plankton will be dead
        }
    }","Increase the age.
This could result in the plankton's death.",Plankton.java,151.0,3
2,"private void incrementHunger()
    {
        foodLevel--; //decreasing food level of plankton by one
        //if the food level of plankton is less than or equal to 0
        if(foodLevel <= 0) {
            setDead();//the plankton will be dead
        }
    }",Make this plankton more hungry. This could result in the plankton's death.,Plankton.java,151.0,3
3,"private void giveBirth(List<Animal> newPlanktons)
    {
        // New planktons are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Plankton young = new Plankton(false, field, loc);
            newPlanktons.add(young);
        }
    }","Check whether or not this plankton is to give birth at this step.
New births will be made into free adjacent locations.
@param newPlanktons A list to return newly born planktons.",Plankton.java,151.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);            
            SeaWeed seaWeed = (SeaWeed) plant;
            //if the adjacent seaweed was alive let the fish to eat it
            if(seaWeed.isAlive()) { 
                seaWeed.setDead();
                foodLevel = SEAWEED_FOOD_VALUE;
                return where;
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
plankton can only eat seaweed
@return Where food was found, or null if it wasn't.",Plankton.java,151.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Plankton.java,151.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A plankton can breed if it has reached the breeding age.
@return true if the plankton can breed, false otherwise.",Plankton.java,151.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,151.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,151.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,151.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,151.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,151.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,702.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,702.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,702.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,702.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,702.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,702.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,702.0,3
0,"public void act(List<Animal> newBoars)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newBoars);  
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Boar does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newBoars A list to return newly born Boars.",Boar.java,702.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Boar's death.",Boar.java,702.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Boar's death.,Boar.java,702.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Boar more hungry. This could result in the Goat's death.,Boar.java,702.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Boar.java,702.0,3
5,"private void giveBirth(List<Animal> newBoars)
    {
        if(findPartner() == true && FOOD_VALUE > 3) {
           // New Boars are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Boar young = new Boar(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newBoars.add(young);
           }
        }
    }","Check whether or not this Boar is to give birth at this step.
New births will be made into free adjacent locations.
@param newBoars A list to return newly born Boars.",Boar.java,702.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Boar) {
                Boar BoarPartner = (Boar) animal;
                String partnerOneGender = getGender();
                String partnerGender = BoarPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(BoarPartner.isInfected() || isInfected()) {
                        BoarPartner.setInfected();
                        setInfected();
                }
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Boar.java,702.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Boar.java,702.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Boar can breed if it has reached the breeding age.
@return true if the Boar can breed, false otherwise.",Boar.java,702.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,702.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,702.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,702.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,702.0,3
0,"public void act(List<Animal> newDeers)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newDeers); 
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Deer does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newDeers A list to return newly born Deers.",Deer.java,702.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Deer's death.",Deer.java,702.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Deer's death.,Deer.java,702.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Deer more hungry. This could result in the Goat's death.,Deer.java,702.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Deer.java,702.0,3
5,"private void giveBirth(List<Animal> newDeers)
    {
         if(findPartner() == true && FOOD_VALUE > 5) {
           // New Deers are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Deer young = new Deer(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newDeers.add(young);
           }
       }
    }","Check whether or not this Deer is to give birth at this step.
New births will be made into free adjacent locations.
@param newDeers A list to return newly born Deers.",Deer.java,702.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Deer) {
                Deer DeerPartner = (Deer) animal;
                String partnerOneGender = getGender();
                String partnerGender = DeerPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(DeerPartner.isInfected() || isInfected()) {
                        DeerPartner.setInfected();
                        setInfected();
                }
                // it looks nicer
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Deer.java,702.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Deer.java,702.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Deer can breed if it has reached the breeding age.
@return true if the Deer can breed, false otherwise.",Deer.java,702.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,702.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,702.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,702.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,702.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,702.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,702.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,702.0,3
2,"public void simulateOneStep()
    {
        step++;
        // Keeping track of time (Day and Night) 
        hour++; 
        if(hour == 12) {
            if(changeTime%2 == 0) {
                isDay = true; 
            } else {
                isDay = false; 
            }
            changeTime += 1;
            hour = 0; 
        }
        // Random rain 
        Random randomNumberWeather = new Random();
        int randomWeather = randomNumberWeather.nextInt(5);
        if(randomWeather < 4) {
            isRain = true;
        } else {
            isRain = false; 
        }
        // Provide space for newborn animals and plants
        List<Animal> newAnimals = new ArrayList<>(); 
        List<Plants> newPlants = new ArrayList<>();
        // Let all animals act and plants
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            if(animal instanceof Dragon) {
                if(isDay == false) {
                    animal.act(newAnimals);
                } else {
                    Dragon Dragon = (Dragon) animal;
                    Dragon.incrementAge();
                }
            } else {
                if(animal instanceof Tiger) {
                   if(isDay == true) {
                      animal.act(newAnimals);
                   } else {
                      Tiger Tiger = (Tiger) animal;
                      Tiger.incrementAge();
                   }  
                } else {
                   animal.act(newAnimals);
                }
            }
            // removes if it is dead. 
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        
        for(Iterator<Plants> it = plants.iterator(); it.hasNext(); ) {
            Plants plants = it.next();
            if(plants instanceof Grass && isRain == true) {
                plants.act(newPlants);
            } 
            // removes if it is dead. 
            if(! plants.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born Dragones and Goats to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
Dragon and Goat.",Simulator.java,702.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,702.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= Dragon_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Dragon Dragon = new Dragon(true, field, location);
                    animals.add(Dragon);
                }
                else if(rand.nextDouble() <= Goat_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Goat Goat = new Goat(true, field, location);
                    animals.add(Goat);
                }
                else if(rand.nextDouble() <= Tiger_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tiger Tiger = new Tiger(true, field, location);
                    animals.add(Tiger);
                }
                else if(rand.nextDouble() <= Boar_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Boar Boar = new Boar(true, field, location);
                    animals.add(Boar);
                }
                else if(rand.nextDouble() <= Deer_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Deer Deer = new Deer(true, field, location);
                    animals.add(Deer);
                }
                else if(rand.nextDouble() <= Grass_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass Grass = new Grass(true, field, location);
                    plants.add(Grass);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with Dragones and Goats and other animals.,Simulator.java,702.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,702.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,702.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,702.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,702.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,702.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,702.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,702.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,702.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,702.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,702.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,702.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,702.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,702.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,702.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,702.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,702.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,702.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,702.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,702.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,702.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,702.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,702.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,702.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,702.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,702.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,702.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,702.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,702.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,702.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,702.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,702.0,3
0,"public void act(List<Plants> newGrass)
    {
        incrementAge();
        if(isAlive()) {
            // It just grows 
            giveBirth(newGrass); 
        }
    }","This is what the Grass does most of the time.
In the process, it might breed
or die of old age.
@param field The field currently occupied.
@param newDragones A list to return newly born Dragones.",Grass.java,702.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Grass's death.,Grass.java,702.0,3
2,"private void giveBirth(List<Plants> newGrass)
    {
         // New Grass are born into adjacent locations.
         // Get a list of adjacent free locations.
         Field field = getField();
         List<Location> free = field.getFreeAdjacentLocations(getLocation());
         int births = breed();
         for(int b = 0; b < births && free.size() > 0; b++) {
             Location loc = free.remove(0);
             Grass young = new Grass(false, field, loc);
             newGrass.add(young);
         }
    }","Check whether or not this Grass is to give birth at this step.
New births will be made into free adjacent locations.
@param newDragones A list to return newly born Dragones.",Grass.java,702.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Grass.java,702.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Grass can breed if it has reached the breeding age.,Grass.java,702.0,3
0,"public void act(List<Animal> newTigeres)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newTigeres);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Tiger does most of the time: it hunts for
Goats. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newTigeres A list to return newly born Tigeres.",Tiger.java,702.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Tiger's death.,Tiger.java,702.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Tiger's death.,Tiger.java,702.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Tiger more hungry. This could result in the Tiger's death.,Tiger.java,702.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat Goat = (Goat) animal;
                if(Goat.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Goat.isInfected()) {
                        setInfected();
                    }
                    Goat.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Boar) {
                Boar Boar = (Boar) animal;
                if(Boar.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Boar.isInfected()) {
                        setInfected();
                    }
                    Boar.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Deer) {
                Deer Deer = (Deer) animal;
                if(Deer.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Deer.isInfected()) {
                        setInfected();
                    }
                    Deer.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Goats adjacent to the current location.
Only the first live Goat is eaten.
@return Where food was found, or null if it wasn't.",Tiger.java,702.0,3
5,"public void giveBirth(List<Animal> newTigeres)
    {
        if(findPartner() == true && FOOD_VALUE > 4) {
           // New Tigeres are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Tiger young = new Tiger(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newTigeres.add(young);
           }
        }
    }","Check whether or not this Tiger is to give birth at this step.
New births will be made into free adjacent locations.
@param newTigeres A list to return newly born Tigeres.",Tiger.java,702.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Tiger) {
                Tiger TigerPartner = (Tiger) animal;
                String partnerOneGender = getGender();
                String partnerGender = TigerPartner.getGender();
                // these tigers met and if one of them is infected 
                // then they all are infected 
                if(TigerPartner.isInfected() || isInfected()) {
                        TigerPartner.setInfected();
                        setInfected();
                }
                // continue with everything else 
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Tiger.java,702.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Tiger.java,702.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Tiger can breed if it has reached the breeding age.,Tiger.java,702.0,3
0,"protected String getGender()
    {
        return gender;
    }","Check the gender of an animal.
@return gender",Animal.java,702.0,3
1,"protected boolean isInfected()
    {
        return infected;
    }","Check if infected
@return infected",Animal.java,702.0,3
2,"protected void setInfected()
    {
        if(!infected) {
            infected = true;
        }
    }",The animal gets infected if it is not,Animal.java,702.0,3
3,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,702.0,3
4,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,702.0,3
5,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,702.0,3
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,702.0,3
7,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,702.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the Plants is alive or not.
@return true if the Plants is still alive.",Plants.java,702.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the Plants is no longer alive.
It is removed from the field.",Plants.java,702.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the Plants's location.
@return The Plants's location.",Plants.java,702.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the Plants at the new location in the given field.
@param newLocation The Plants's new location.",Plants.java,702.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the Plants's field.
@return The Plants's field.",Plants.java,702.0,3
0,"public void act(List<Animal> newDragones)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newDragones);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Dragon does most of the time: it hunts for
Goats. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newDragones A list to return newly born Dragones.",Dragon.java,702.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the Dragon's death.,Dragon.java,702.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Dragon's death.,Dragon.java,702.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Dragon more hungry. This could result in the Dragon's death.,Dragon.java,702.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat Goat = (Goat) animal;
                if(Goat.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Goat.isInfected()) {
                        setInfected();
                    }
                    Goat.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Boar) {
                Boar Boar = (Boar) animal;
                if(Boar.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Boar.isInfected()) {
                        setInfected();
                    }
                    Boar.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Deer) {
                Deer Deer = (Deer) animal;
                if(Deer.isAlive()) { 
                    // if the prey was infected than the Dragon gets the infection 
                    if(Deer.isInfected()) {
                        setInfected();
                    }
                    Deer.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Goats adjacent to the current location.
Only the first live Goat is eaten.
@return Where food was found, or null if it wasn't.",Dragon.java,702.0,3
5,"private void giveBirth(List<Animal> newDragones)
    {
        if(findPartner() && FOOD_VALUE > 7) {
           // New Dragones are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Dragon young = new Dragon(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newDragones.add(young);
           }
        }
    }","Check whether or not this Dragon is to give birth at this step.
New births will be made into free adjacent locations.
@param newDragones A list to return newly born Dragones.",Dragon.java,702.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dragon) {
                Dragon DragonPartner = (Dragon) animal;
                String partnerOneGender = getGender();
                String partnerGender = DragonPartner.getGender();
                // these dragons met and if one of them is infected 
                // then they all are infected 
                if(DragonPartner.isInfected() || isInfected()) {
                        DragonPartner.setInfected();
                        setInfected();
                }
                // continue with everything else 
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Dragon.java,702.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Dragon.java,702.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A Dragon can breed if it has reached the breeding age.,Dragon.java,702.0,3
0,"public void act(List<Animal> newGoats)
    {
        incrementAge();
        if(isInfected()) {
            incrementInfectionAge();
        }
        incrementHunger();
        if(isAlive()) {
            giveBirth(newGoats);  
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Goat does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newGoats A list to return newly born Goats.",Goat.java,702.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Goat's death.",Goat.java,702.0,3
2,"public void incrementInfectionAge()
    {
        infectionAge++;
        if(infectionAge >= MAX_INFECTION_AGE) {
            setDead();
        }
    }",Increase the infection age. This could result in the Goat's death.,Goat.java,702.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this Goat more hungry. This could result in the Goat's death.,Goat.java,702.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plants = field.getObjectAt(where);
            if(plants instanceof Grass) {
                Grass Grass = (Grass) plants;
                if(Grass.isAlive()) { 
                    Grass.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Grass adjacent to the current location.
Only the first live Grass is eaten.
@return Where food was found, or null if it wasn't.",Goat.java,702.0,3
5,"private void giveBirth(List<Animal> newGoats)
    {
        if(findPartner() == true && FOOD_VALUE > 5) {
           // New Goats are born into adjacent locations.
           // Get a list of adjacent free locations.
           Field field = getField();
           List<Location> free = field.getFreeAdjacentLocations(getLocation());
           int births = breed();
           for(int b = 0; b < births && free.size() > 0; b++) {
               Location loc = free.remove(0);
               Goat young = new Goat(false, field, loc);
               if(isInfected()) {
                   young.setInfected();
               }
               newGoats.add(young);
           }
       }
    }","Check whether or not this Goat is to give birth at this step.
New births will be made into free adjacent locations.
@param newGoats A list to return newly born Goats.",Goat.java,702.0,3
6,"private boolean findPartner()
    {
        boolean breedableGenders = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Goat) {
                Goat GoatPartner = (Goat) animal;
                String partnerOneGender = getGender();
                String partnerGender = GoatPartner.getGender();
                // these boars met and if one of them is infected 
                // then they all are infected 
                if(GoatPartner.isInfected() || isInfected()) {
                        GoatPartner.setInfected();
                        setInfected();
                }
                // nicer
                if(!partnerGender.equals(partnerOneGender)) { 
                    breedableGenders = true;
                } else {
                    breedableGenders = false;
                }
            }
        }
        return breedableGenders;
    }","Method to find a partner at the adjacent fields
@return boolean true if there is a partner.",Goat.java,702.0,3
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Goat.java,702.0,3
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Goat can breed if it has reached the breeding age.
@return true if the Goat can breed, false otherwise.",Goat.java,702.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,380.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,380.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,380.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,380.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,380.0,2
0,"public void act(List <Animal> newGazelles)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newGazelles);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the gazelle does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newGazelles A list to return newly born gazelles.",Gazelle.java,380.0,2
1,"public void nightAct(List <Animal> newGazelles)
    {
       
    }",Gazelles sleep during the night.,Gazelle.java,380.0,2
2,"public void rainAct(List <Animal> newGazelles)
    {
        act(newGazelles);
    }",Gazelles behave normally when it rains.,Gazelle.java,380.0,2
3,"public void fogAct(List <Animal> newGazelles)
    {
        incrementAge();
        if(isAlive() && !isMale && !hasDisease) {
            giveBirth(newGazelles);                 
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }",Gazelles can't move when there is fog.,Gazelle.java,380.0,2
4,"public void stormAct(List <Animal> newGazelles)
    {
        
        if(isAlive() && !hasDisease) {
                        
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }",Gazelles can't breed when there is a storm,Gazelle.java,380.0,2
7,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the gazelle's death.",Gazelle.java,380.0,2
8,"private void giveBirth(List<Animal> newGazelles)
    {
        // New gazelles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Gazelle young = new Gazelle(false, field, loc);
            newGazelles.add(young);
        }
    }","Check whether or not this gazelle is to give birth at this step.
New births will be made into free adjacent locations.
@param newGazelles A list to return newly born gazelles.",Gazelle.java,380.0,2
9,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Gazelle.java,380.0,2
10,"private boolean canBreed()
    {
        if(age >= BREEDING_AGE)
        {
            Field field = getField();
            List<Location> matingPartners = field.getAnimalLocation(getLocation());
            for(Location where : matingPartners) {
                Object animal = field.getObjectAt(where);
               
                if(animal instanceof Gazelle){
                    Gazelle gazelle = (Gazelle) animal;
                    if(gazelle.isMale() && gazelle.getAge() >= BREEDING_AGE)
                    return true;
                }
                    else return false;                                          
            }
        }
        return false;
    }",A gazelle can breed if it has reached the breeding age.,Gazelle.java,380.0,2
2,"public void act(List <Animal> newGiraffes)
    {
        incrementAge();
        if(isAlive() && !hasDisease) {
            giveBirth(newGiraffes);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }","This is what the giraffe does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newGiraffes A list to return newly born giraffes.",Giraffe.java,380.0,2
3,"public void nightAct(List <Animal> newGiraffes)
    {
     
    }",Giraffes sleep during the night.,Giraffe.java,380.0,2
4,"public void rainAct(List <Animal> newGiraffes)
    {
        incrementAge();
        if(isAlive() && !hasDisease) {
            giveBirth(newGiraffes);            
            
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }",Giraffes can't move when it rains.,Giraffe.java,380.0,2
5,"public void fogAct(List <Animal> newGiraffes)
    {
        if(isAlive() && !isMale && !hasDisease) {
            giveBirth(newGiraffes); 
            
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }",Giraffes can't die when it's foggy.,Giraffe.java,380.0,2
6,"public void stormAct(List <Animal> newGiraffes)
    {
        
        if(isAlive() && !hasDisease) {
            
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }",Giraffes can't give birth when there is a storm.,Giraffe.java,380.0,2
7,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the giraffe's death.",Giraffe.java,380.0,2
8,"private void giveBirth(List<Animal> newGiraffes)
    {
        // New giraffes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Giraffe young = new Giraffe(false, field, loc);
            newGiraffes.add(young);
        }
    }","Check whether or not this giraffe is to give birth at this step.
New births will be made into free adjacent locations.
@param newGiraffes A list to return newly born giraffes.",Giraffe.java,380.0,2
10,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Giraffe.java,380.0,2
11,"private boolean canBreed()
    {
        if(age >= BREEDING_AGE)
        {
            Field field = getField();
            List<Location> matingPartners = field.getAnimalLocation(getLocation());
            for(Location where : matingPartners) {
                Object animal = field.getObjectAt(where);
               
                if(animal instanceof Giraffe){
                    Giraffe giraffe = (Giraffe) animal;
                    if(giraffe.isMale() && giraffe.getAge() >= BREEDING_AGE)
                    return true;
                }
                    else return false;                                          
            }
        }
        return false;
    }",A giraffe can breed if it has reached the breeding age.,Giraffe.java,380.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,380.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,380.0,2
0,"public void act(List<Animal> newPlants)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newPlants);            
            }
            else {
                // Overcrowding.
                setDead();
            }
        }","This is what the plant does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newPlants A list to return newly born plants.",Plant.java,380.0,2
1,"public void nightAct(List<Animal> newPlants)
    {
       
    }",Plants don't reproduce if there is no sunlight.,Plant.java,380.0,2
2,"public void rainAct(List <Animal> newPlants)
    {
        breeding_probability = 0.2;
        act(newPlants);
        breeding_probability = 0.1;
    }",Plants grow faster when it rains.,Plant.java,380.0,2
3,"public void fogAct(List <Animal> newPlants)
    {
        
    }",Plants don't reproduce if there is no sunlight.,Plant.java,380.0,2
4,"public void stormAct(List <Animal> newPlants)
    {
        act(newPlants);     
    }",Plants behave normally during a storm.,Plant.java,380.0,2
5,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the plant's death.",Plant.java,380.0,2
6,"private void giveBirth(List<Animal> newPlants)
    {
        // New plants are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Plant young = new Plant(false, field, loc);
            newPlants.add(young);
        }
    }","Check whether or not this plant is to give birth at this step.
New births will be made into free adjacent locations.
@param newPlants A list to return newly born plants.",Plant.java,380.0,2
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= breeding_probability) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Plant.java,380.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A plant can breed if it has reached the breeding age.
@return true if the plant can breed, false otherwise.",Plant.java,380.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,380.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,380.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,380.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,380.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,380.0,2
1,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,380.0,2
2,"public void showStatus(int step, Field field)
    {
        this.step=step;
        if(!isVisible()) {
            setVisible(true);
        }
        if(step%50==0 && step!=0)
        {
            changeTime();
        }
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        timeLabel.setText(TIME_OF_DAY + getTime());
        stats.reset();
        weatherLabel.setText(WEATHER + showWeather());
        stats.reset();
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,380.0,2
3,"public void getWeather()
    {
      if(weatherInfo==""Stormy"")
      {
        isSunny=false;
        itRains=false;
        isStorm=true;
        isFoggy=false;   
      }
      if(weatherInfo==""Foggy"")
      {
        isSunny=false;
        itRains=false;
        isStorm=false;
        isFoggy=true;   
      }
      if(weatherInfo==""Rainy"")
      {
        isSunny=false;
        itRains=true;
        isStorm=false;
        isFoggy=false;   
      }
      if(weatherInfo==""Sunny"")
      {
        isSunny=true;
        itRains=false;
        isStorm=false;
        isFoggy=false;   
      }
    }",Assigns boolean values to the weather conditons.,SimulatorView.java,380.0,2
4,"public String showWeather()
    {
        if( day && step%25 == 0 ) 
        {
            Random rand = new Random();
            weatherProbability = rand.nextDouble();
            if(weatherProbability<=STORM_PROBABILITY)
            {
                weatherInfo= ""Stormy"";
                EMPTY_COLOR= Color.white;
            }
            if(weatherProbability>STORM_PROBABILITY && weatherProbability<=FOG_PROBABILITY)
            {
                weatherInfo=""Foggy"";
                EMPTY_COLOR= Color.gray;
            }
            if(weatherProbability>FOG_PROBABILITY && weatherProbability<=RAIN_PROBABILITY)
            {
                weatherInfo=""Rainy"";
                EMPTY_COLOR= Color.white;
            }
            if(weatherProbability>RAIN_PROBABILITY)
            {
                weatherInfo=""Sunny"";
                EMPTY_COLOR= Color.white;
            }
        }
        if(!day)
        {
            weatherInfo=""Dark"";
            EMPTY_COLOR= Color.black;
        }
        return weatherInfo;
     }",A weather has a certain probability and every 25 steps a new weather is called.,SimulatorView.java,380.0,2
5,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,380.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,380.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,380.0,2
2,"public void simulateOneStep()
    {
        step++;
        //
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) 
        {
            Animal animal = it.next();
            
                if(view.showWeather()==""Sunny"")
                {
                    animal.act(newAnimals);
                }
                else if(view.showWeather()==""Rainy"")
                {
                    animal.rainAct(newAnimals);
                }
                else if(view.showWeather()==""Foggy"")
                {
                    animal.fogAct(newAnimals);
                }
                else if(view.showWeather()==""Stormy"")
                {
                    animal.stormAct(newAnimals);
                }
                else if(view.showWeather()==""Dark"")
                {
                    animal.nightAct(newAnimals);
                }
        
                if( !animal.isAlive() )
                it.remove();
        }
        
    

        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
        
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,380.0,2
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,380.0,2
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= TIGER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tiger tiger = new Tiger(true, field, location);
                    animals.add(tiger);
                }
                else if(rand.nextDouble() <= LION_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lion lion= new Lion(true, field, location);
                    animals.add(lion);
                }
                else if(rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Zebra zebra = new Zebra(true, field, location);
                    animals.add(zebra);
                }
                else if(rand.nextDouble() <= GIRAFFE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Giraffe giraffe = new Giraffe(true, field, location);
                    animals.add(giraffe);
                }
                else if(rand.nextDouble() <= GAZELLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Gazelle gazelle= new Gazelle(true, field, location);
                    animals.add(gazelle);
                }
                else if(rand.nextDouble() <= PLANT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Plant plant= new Plant(true, field, location);
                    animals.add(plant);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,380.0,2
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,380.0,2
0,"public void act(List<Animal> newZebras)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newZebras);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the zebra does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newzebras A list to return newly born zebras.",Zebra.java,380.0,2
1,"public void nightAct(List<Animal> newZebras)
    {
       
    }",Zebras sleep during the night.,Zebra.java,380.0,2
2,"public void rainAct(List <Animal> newZebras)
    {
        act(newZebras);
    }",Zebras behave normally when it rains,Zebra.java,380.0,2
3,"public void fogAct(List <Animal> newZebras)
    {
        incrementAge();
        if(isAlive() && !isMale && !hasDisease) {
            giveBirth(newZebras);                 
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }",Zebras can only give birth whe there is fog.,Zebra.java,380.0,2
4,"public void stormAct(List <Animal> newZebras)
    {
        incrementAge();
        if(isAlive() && !hasDisease) {
            giveBirth(newZebras);            
            // Try to move into a free location.
            
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }",Zebras can't move during a storm.,Zebra.java,380.0,2
7,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the zebra's death.",Zebra.java,380.0,2
8,"private void giveBirth(List<Animal> newZebras)
    {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Zebra young = new Zebra(false, field, loc);
            newZebras.add(young);
        }
    }","Check whether or not this zebra is to give birth at this step.
New births will be made into free adjacent locations.
@param newzebras A list to return newly born zebras.",Zebra.java,380.0,2
10,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Zebra.java,380.0,2
11,"private boolean canBreed()
    {
        if(age >= BREEDING_AGE)
        {
            Field field = getField();
            List<Location> matingPartners = field.getAnimalLocation(getLocation());
            for(Location where : matingPartners) {
                Object animal = field.getObjectAt(where);
               
                if(animal instanceof Zebra){
                    Zebra zebra = (Zebra) animal;
                    if(zebra.isMale() && zebra.getAge() >= BREEDING_AGE)
                    return true;
                }
                    else return false;                                          
            }
        }
        return false;
    }",A zebra can breed if it has reached the breeding age.,Zebra.java,380.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,380.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,380.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,380.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,380.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,380.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,380.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,380.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,380.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,380.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,380.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,380.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,380.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,380.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,380.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,380.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,380.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,380.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,380.0,2
1,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,380.0,2
2,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,380.0,2
3,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,380.0,2
4,"public void place(Object livingBeing, Location location)
    {
        field[location.getRow()][location.getCol()] = livingBeing;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,380.0,2
5,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,380.0,2
6,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,380.0,2
7,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,380.0,2
8,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,380.0,2
9,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,380.0,2
10,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,380.0,2
11,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,380.0,2
12,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,380.0,2
0,"public void act(List <Animal> newLions)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newLions);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the lion does most of the time: it hunts for
preys. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born lions.",Lion.java,380.0,2
1,"public void nightAct(List <Animal> newLions)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newLions);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }",Lions can't die during the night.,Lion.java,380.0,2
2,"public void rainAct(List <Animal> newLions)
    {
        act(newLions);
    }",Lions behave normally when its rainy.,Lion.java,380.0,2
3,"public void fogAct(List <Animal> newLions)
    {
        
        if(isAlive() && !isMale && !hasDisease) {
            giveBirth(newLions);                 
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }",Lions don't move when its foggy.,Lion.java,380.0,2
4,"public void stormAct(List <Animal> newLions)
    {
        incrementHunger();
        incrementAge();
        if(isAlive() && !hasDisease) 
        {
            giveBirth(newLions);
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }","Lions can't move when its stormy, but they can still breed.",Lion.java,380.0,2
5,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> animalsNearby = field.getAnimalLocation(getLocation());
        for(Location where : animalsNearby) {
            Object animal = field.getObjectAt(where);
            if(animal instanceof Lion){
                Lion lion = (Lion) animal;
                if(lion.isAlive())
                    lion.setDisease();
            }
        }
    }","If a lion is sick, it can spread the disease.",Lion.java,380.0,2
6,"public void setDisease()
    {
        hasDisease = true;
        if(age <= MAX_AGE - 10)
            age = MAX_AGE -10;
        else setDead();
    }",Lions have 10 steps to live when sick.,Lion.java,380.0,2
7,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the lion's death.,Lion.java,380.0,2
8,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this lion more hungry. This could result in the lion's death.,Lion.java,380.0,2
9,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Giraffe) {
                 Giraffe giraffe = (Giraffe) animal;
                if(giraffe.isAlive()) { 
                    giraffe.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Gazelle) {
                 Gazelle gazelle = (Gazelle) animal;
                if(gazelle.isAlive()) { 
                    gazelle.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Zebra) {
                 Zebra zebra = (Zebra) animal;
                if(zebra.isAlive()) { 
                    zebra.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
             else if(animal instanceof Plant) {
                Plant plant = (Plant) animal;
                if(plant.isAlive()) { 
                     plant.setDead();
                    foodLevel = 0;
                    return where;
                
                }
            }
          }
        return null;
       
    }","Look for preys adjacent to the current location.
Only the first live prey is eaten.
@return Where food was found, or null if it wasn't.",Lion.java,380.0,2
10,"private void giveBirth(List<Animal> newLions)
    {
        // New lions are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Lion young = new Lion(false, field, loc);
            newLions.add(young);
        }
    }","Check whether or not this lion is to give birth at this step.
New births will be made into free adjacent locations.
@param newLions A list to return newly born lions.",Lion.java,380.0,2
11,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Lion.java,380.0,2
12,"private boolean canBreed()
    {
        if(age >= BREEDING_AGE)
        {
            Field field = getField();
            List<Location> matingPartners = field.getAnimalLocation(getLocation());
            for(Location where : matingPartners) {
                Object animal = field.getObjectAt(where);
               
                if(animal instanceof Lion){
                    Lion lion = (Lion) animal;
                    if(lion.isMale() && lion.getAge() >= BREEDING_AGE)
                    return true;
                }
                    else return false;                                          
            }
        }
        return false;
    }",A lion can breed if it has reached the breeding age.,Lion.java,380.0,2
0,"public void act(List<Animal> newTigers)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newTigers);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }       
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }","This is what the tiger does most of the time: it hunts for
preys. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newTigers A list to return newly born tigers.",Tiger.java,380.0,2
1,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> animalsNearby = field.getAnimalLocation(getLocation());
        for(Location where : animalsNearby) {
            Object animal = field.getObjectAt(where);
            if(animal instanceof Tiger){
                Tiger tiger = (Tiger) animal;
                if(tiger.isAlive())
                    tiger.setDisease();
            }
        }
    }",If the tiger gets sick. It can spred the disease.,Tiger.java,380.0,2
2,"public void setDisease()
    {
        hasDisease = true;
        if(age <= MAX_AGE - 10)
            age = MAX_AGE -10;
        else setDead();
    }",Tigers with a disease only have 10 more steps of life.,Tiger.java,380.0,2
3,"public void nightAct(List <Animal> newTigers)
    {
       incrementAge();
        incrementHunger();
        if(isAlive() && !isMale) {
            giveBirth(newTigers);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","Tigers strive during the night, being capable of hunting.",Tiger.java,380.0,2
4,"public void rainAct(List <Animal> newTigers)
    {
        act(newTigers);
    }",Tigers behave normally when it rains.,Tiger.java,380.0,2
5,"public void fogAct(List <Animal> newTigers)
    {
        if(isAlive() && !isMale && !hasDisease) {
            giveBirth(newTigers);                 
        }
        else if(isAlive() & hasDisease)
        {
           spreadDisease();
        }
    }",Tigers can't move when its foggy.,Tiger.java,380.0,2
6,"public void stormAct(List <Animal> newTigers)
    {
        
        if(isAlive() && !hasDisease) {
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        else if(isAlive() && hasDisease)
            spreadDisease();
    }",Tigers can't breed when its stormy.,Tiger.java,380.0,2
7,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the tiger's death.,Tiger.java,380.0,2
8,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this tiger more hungry. This could result in the tiger's death.,Tiger.java,380.0,2
9,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Giraffe) {
                Giraffe giraffe = (Giraffe) animal;
                if(giraffe.isAlive()) { 
                    giraffe.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Gazelle) {
                Gazelle gazelle = (Gazelle) animal;
                if(gazelle.isAlive()) { 
                    gazelle.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            if(animal instanceof Zebra) {
                Zebra zebra = (Zebra) animal;
                if(zebra.isAlive()) { 
                    zebra.setDead();
                    foodLevel = FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Plant) {
                Plant plant = (Plant) animal;
                if(plant.isAlive()) { 
                    plant.setDead();
                    foodLevel = 0;
                    return where;

                }
            }
        }
        return null;
    }","Look for preys adjacent to the current location.
Only the first live prey is eaten.
@return Where food was found, or null if it wasn't.",Tiger.java,380.0,2
10,"private void giveBirth(List<Animal> newTigers)
    {
        // New tigers are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Tiger young = new Tiger(false, field, loc);
            newTigers.add(young);
        }
    }","Check whether or not this tiger is to give birth at this step.
New births will be made into free adjacent locations.
@param newTigers A list to return newly born tigers.",Tiger.java,380.0,2
11,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Tiger.java,380.0,2
12,"private boolean canBreed()
    {
        if(age >= BREEDING_AGE)
        {
            Field field = getField();
            List<Location> matingPartners = field.getAnimalLocation(getLocation());
            for(Location where : matingPartners) {
                Object animal = field.getObjectAt(where);
                if(animal instanceof Tiger){
                    Tiger tiger = (Tiger) animal;
                    if(tiger.isMale() && tiger.getAge() >= BREEDING_AGE)
                        return true;
                }
                else return false;                                          
            }
        }
        return false;
    }",A tiger can breed if it has reached the breeding age.,Tiger.java,380.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,380.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,380.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,380.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,380.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,380.0,2
0,"public void act(List<Organism> newOrganisms) 
    {
        if(getShouldAct()){
            incrementAge();
            incrementHunger();
                if(isAlive()){
                giveBirth(newOrganisms);
                //Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null){
                    //No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                //See if it was possible to move.
                if(newLocation != null){
                    setLocation(newLocation);
                }else {
                    //Overcrowding.
                    setDead();
                }
            }
            changeShouldAct();
        }
        else{
            changeShouldAct();
        }
    }","A method which increments the age and hunger of the dinosaur as well as
hunting prey. If its age increases past the threshold, it will die.
The method also enables the dinosaur to breed. After each rotation of the organism acting/not acting, the next rotation will be vice versa due o the changeShouldAct method
@param newOrganisms A list to receive newly born organisms.",Dinosaur.java,597.0,3
1,"protected boolean canBreed()
    {
        return (this.getAge() >= breedingAge && this.sex);
    }",A dinosaur can breed if it has reached the breeding age and is a female.,Dinosaur.java,597.0,3
2,"private void incrementHunger()
    {
        foodConsumed--;
        if(foodConsumed <= 0) {
            setDead();
        }
    }",Make this dinosaur more hungry. This could result in the dinosaur's death.,Dinosaur.java,597.0,3
3,"protected int getFoodConsumed(){
        return foodConsumed;
    }","Returns the food already consumed by the dinosaur.
@return int The food already consumed by the dinosaur.",Dinosaur.java,597.0,3
4,"protected void setFoodConsumed(int foodValue)
    {
        this.foodConsumed = foodValue;
    }","Sets the value of the food consumed to that stated in the parameter.
@param foodValue The value the foodConsumed variable should be updated to.",Dinosaur.java,597.0,3
5,"public boolean getDinoSex()
    {
        return sex;
    }","Returns the boolean value corresponding to the dinosaurs sex.
@return boolean true if female, 0 if male.",Dinosaur.java,597.0,3
6,"protected int getMaxFoodConsumed()
    {
        return maxFoodConsumed;
    }","Returns the maximum amount of food that the dinosaur is able to have consumed at one given time.
@return int the maximum amount of food that the dinosaur is able to have consumed at one time.",Dinosaur.java,597.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,597.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,597.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,597.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,597.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,597.0,3
0,"protected void giveBirth(List<Organism> newCycad) 
    {
        // New cycads are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Cycad young = new Cycad(false, field, loc);
            newCycad.add(young);
        }
    }",A method that allows the plant cycad to spread on the grid depending on chance.,Cycad.java,597.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,597.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,597.0,3
0,"public void act(List<Organism> newOrganisms) 
    {
        if(getShouldAct()){
            incrementAge();
            if(this.getAge() % this.growthRate == 0){
                increaseFoodValue(1);
            }
    
            if(isAlive()) {
                giveBirth(newOrganisms);
                // Try to move into a free location.
                Location newLocation = getField().freeAdjacentLocation(getLocation());
                   //See if it was possible to move.
                if(newLocation != null){
                    setLocation(this.getLocation());
                }
                else {
                 //Overcrowding.
                 setDead();
                }
            }
            changeShouldAct();
        }
        else{
            changeShouldAct();
        }
    }","A method which causes the foodValue field to increase. Everytime it increases,
the growthRate field decreases by 1. After each rotation of the plant acting/not acting, the next rotation will be vice versa
@param newOrganisms A list to receive newly born organisms.",Plant.java,597.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,597.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,597.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,597.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,597.0,3
0,"protected Location findFood() 
    {
        if (this.getFoodConsumed() <= 0.76 * this.getMaxFoodConsumed()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object organism = field.getObjectAt(where);
                if (organism instanceof Triceratops) {
                    Triceratops triceratops = (Triceratops) organism;
                    if (triceratops.isAlive()) {
                        triceratops.setDead();
                        if((this.getFoodConsumed() + triceratops.getFoodValue()) > this.getMaxFoodConsumed()){
                            this.setFoodConsumed(this.getMaxFoodConsumed());
                        }else {
                            this.setFoodConsumed(this.getFoodConsumed() + triceratops.getFoodValue());
                        }
                        return where;
                    }
                } 
                else if (organism instanceof Albertadromeus) {
                    Albertadromeus albertadromeus = (Albertadromeus) organism;
                    if (albertadromeus.isAlive()) {
                        albertadromeus.setDead();
                        if((this.getFoodConsumed() + albertadromeus.getFoodValue()) > this.getMaxFoodConsumed()){
                            this.setFoodConsumed(this.getMaxFoodConsumed());
                        }else {
                            this.setFoodConsumed(this.getFoodConsumed() + albertadromeus.getFoodValue());
                        }
                        return where;
                    }
                }
            }
        }
        return null;
    }","A method which enables the dinosaur to find its prey.
@return Location the location at which the prey is located.",TRex.java,597.0,3
1,"protected void giveBirth(List<Organism> newDinos) 
    {
        // New t.rexes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if((organism instanceof TRex) && ((TRex) organism).getDinoSex() != this.getDinoSex()) {
                int births = breed();
                for (int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    TRex young = new TRex(false, field, loc);
                    newDinos.add(young);
                }
            }
        }
    }","A method which gives birth to other dinosaurs under the correct conditions.
@param newDinos A list to return newly born dinosaurs.",TRex.java,597.0,3
2,"protected int breed() 
    {
        int births = 0;
        if(this.canBreed() && this.getRand().nextDouble() <= this.getBreedingChance()) {
            births = this.getRand().nextInt(this.getMaxLitterSize()) + 1;
        }
        return births;
    }","A method to determine the size of the litter that the dinosaur will produce.
@return int the number of children the dinosaur will have.",TRex.java,597.0,3
0,"protected Location findFood() 
    {
        if (this.getFoodConsumed() <= 0.3 * this.getMaxFoodConsumed()) {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object organism = field.getObjectAt(where);
                if (organism instanceof Cycad) {
                    Cycad cycad = (Cycad) organism;
                    if (cycad.isAlive()) {
                        cycad.setDead();
                        if((this.getFoodConsumed() + cycad.getFoodValue()) > this.getMaxFoodConsumed()){
                            this.setFoodConsumed(this.getMaxFoodConsumed());
                        }else {
                            this.setFoodConsumed(this.getFoodConsumed() + cycad.getFoodValue());
                        }
                        return where;
                    }
                }

            }
        }
        return null;
    }","A method which enables the dinosaur to find its prey.
@return Location the location at which the prey is located.",Triceratops.java,597.0,3
1,"protected void giveBirth(List<Organism> newDinos) 
    {
        // New triceratops are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if((organism instanceof Triceratops) && ((Triceratops) organism).getDinoSex() != this.getDinoSex()) {
                int births = breed();
                for (int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    Triceratops young = new Triceratops(false, field, loc);
                    newDinos.add(young);
                }
            }
        }
    }","A method which gives birth to other dinosaurs under the correct conditions.
@param newDinos A list to return newly born dinosaurs.",Triceratops.java,597.0,3
2,"protected int breed() 
    {
        int births = 0;
        if(this.canBreed() && this.getRand().nextDouble() <= this.getBreedingChance()) {
            births = this.getRand().nextInt(this.getMaxLitterSize()) + 1;
        }
        return births;
    }","A method to determine the size of the litter that the dinosaur will produce.
@return int the number of children the dinosaur will have.",Triceratops.java,597.0,3
0,"public void setColor(Class organismClass, Color color)
    {
        colors.put(organismClass, color);
    }","Define a color to be used for a given class of organism.
@param organismClass The organism's Class object.
@param color The color to be used for the given class.",SimulatorView.java,597.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,597.0,3
2,"private Color getColor(Class organism)
    {
        Color col = colors.get(organism);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of organism.,SimulatorView.java,597.0,3
3,"public void showStatus(int day, String stateDay, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        //below is setting the label on the top of the GUI to give the user the time and day that is currently in the simulation     
        dayLabel.setText(DAY_PREFIX + day + stateDay);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object organism = field.getObjectAt(row, col);
                if(organism != null) {
                    stats.incrementCount(organism.getClass());
                    fieldView.drawMark(col, row, getColor(organism.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration day it is.
@param field The field whose status is to be displayed.",SimulatorView.java,597.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,597.0,3
0,"public void runOneYear()
    {
        simulate(365);
    }","Run the simulation from its current state for a year,
(365 days).",Simulator.java,597.0,3
1,"public void simulate(int numDays)
    {
        for(int day = 1; day <= numDays*2 && view.isViable(field); day++) {
            simulate12Hours();
            delay(30);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numDays The number of steps to run for.",Simulator.java,597.0,3
2,"public void simulate12Hours()
    {
        //below is if statements for the afternoon and night cycle in the day
        if (stateDay){
            stateDay = false;
            day++;
        }
        else{
            stateDay = true;
        }     
        // Provide space for newborn organisms.
        List<Organism> newOrganisms = new ArrayList<>();
        // Let all organisms act.
        for(Iterator<Organism> it = organisms.iterator(); it.hasNext(); ) {
            Organism organism = it.next();
            organism.act(newOrganisms);
            if(! organism.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born dinosaurs and plants to the main lists.
        organisms.addAll(newOrganisms);

        view.showStatus(day, time(), field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
dinosaur and plant.",Simulator.java,597.0,3
3,"public void reset()
    {
        day = -1;
        organisms.clear();
        populate();
        simulate12Hours();
        simulate12Hours();
        // Show the starting state in the view.
        view.showStatus(day, time(), field);
    }",Reset the simulation to a starting position.,Simulator.java,597.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= CYCAD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Cycad cycad = new Cycad(true, field, location);
                    organisms.add(cycad);
                }
                else if(rand.nextDouble() <= TRICERATOPS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Triceratops triceratops = new Triceratops(true, field, location);
                    organisms.add(triceratops);
                }
                else if(rand.nextDouble() <= ALBERTADROMEUS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Albertadromeus albertadromeus = new Albertadromeus(true, field, location);
                    organisms.add(albertadromeus);
                }
                else if(rand.nextDouble() <= TREX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    TRex trex = new TRex(true, field, location);
                    organisms.add(trex);
                }
                
                else if(rand.nextDouble() <= RAPTOR_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Raptor raptor = new Raptor(true, field, location);
                    organisms.add(raptor);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with dinosaurs and plants.,Simulator.java,597.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,597.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,597.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,597.0,3
2,"public void incrementCount(Class organismClass)
    {
        Counter count = counters.get(organismClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(organismClass.getName());
            counters.put(organismClass, count);
        }
        count.increment();
    }","Increment the count for one class of organism.
@param organismClass The class of organism to increment.",FieldStats.java,597.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an organism count has been completed.,FieldStats.java,597.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,597.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object organism = field.getObjectAt(row, col);
                if(organism != null) {
                    incrementCount(organism.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,597.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,597.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,597.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,597.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,597.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,597.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,597.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,597.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,597.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the organism at the new location in the given field.
@param newLocation The organism's new location.",Organism.java,597.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,597.0,3
5,"protected void incrementAge()
    {
        age++;
        if(age > maxAge) {
            setDead();
        }
    }",Increase the age. This could result in the organism's death.,Organism.java,597.0,3
6,"protected int getFoodValue()
    { 
        return foodValue;
    }","Returns the food value of the organism.
@return int the number of additional steps the predator can take if this organism
is consumed.",Organism.java,597.0,3
7,"protected void increaseFoodValue(int increaseInFV)
    {
        foodValue += increaseInFV;
    }","Increases the food value of the organism by the specified value.
@param increaseInFV value foodValue is increased by.",Organism.java,597.0,3
8,"protected int getAge()
    {
        return age;
    }","Returns the age of the organism.
@return int the age of the organism.",Organism.java,597.0,3
9,"protected void setAge(int newAge)
    {
        this.age = newAge;
    }","Sets the age of the organism to that specified.
@param newAge the new value that the age should be set to.",Organism.java,597.0,3
10,"protected int getMaxAge()
    {
        return maxAge;
    }","Returns the maximum age of the organism.
@return int the maximum age the organism can survive to.",Organism.java,597.0,3
11,"protected void setMaxAge(int newMaxAge)
    {
        this.maxAge = newMaxAge;
    }","Sets the maximum age to the number specified.
@param newMaxAge the new value the maximum age is set to.",Organism.java,597.0,3
12,"protected double getBreedingChance()
    {
        return breedingChance;
    }","Returns the breeding chance for the particular organism.
@return double the chance that the organism breeds.",Organism.java,597.0,3
13,"protected void setBreedingChance(double newBreedingChance)
    {
        this.breedingChance = newBreedingChance;
    }","Sets the breeding chance to the value specified.
@param newBreedingChance the value the breeding chance should be set to.",Organism.java,597.0,3
14,"protected int getMaxLitterSize()
    {
        return maxLitterSize;
    }","Returns the maximum litter size of the organism.
@return int the maximum number of organisms that can be birthed in one litter.",Organism.java,597.0,3
15,"protected void setMaxLitterSize(int newMaxLitterSize)
    {
        this.maxLitterSize = newMaxLitterSize;
    }","Sets the maximum litter size to the stated value.
@param newMaxLitterSize the value to set the maximum litter size to.",Organism.java,597.0,3
16,"protected Random getRand()
    {
        return rand;
    }","Returns a random number.
@return Random a random number.",Organism.java,597.0,3
17,"protected boolean getShouldAct()
    {
        return shouldAct;
    }",This returns the variable shouldAct of the organism,Organism.java,597.0,3
18,"protected void changeShouldAct()
    {
        shouldAct = !shouldAct;
    }",This method changes the state of the variable shouldAct after a 12h period to indicate the organism can act in sync with the time of day,Organism.java,597.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,597.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,597.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,597.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,597.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,597.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,597.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,597.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,597.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,597.0,3
2,"public void place(Object organism, int row, int col)
    {
        place(organism, new Location(row, col));
    }","Place an organism at the given location.
If there is already an organism at the location it will
be lost.
@param organism The organism to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,597.0,3
3,"public void place(Object organism, Location location)
    {
        field[location.getRow()][location.getCol()] = organism;
    }","Place an organism at the given location.
If there is already an organism at the location it will
be lost.
@param organism The organism to be placed.
@param location Where to place the organism.",Field.java,597.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the organism at the given location, if any.
@param location Where in the field.
@return The organism at the given location, or null if there is none.",Field.java,597.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the organism at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The organism at the given location, or null if there is none.",Field.java,597.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,597.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,597.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,597.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,597.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,597.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,597.0,3
0,"protected Location findFood() 
    {
        if (this.getFoodConsumed() <= 0.40 * this.getMaxFoodConsumed()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object organism = field.getObjectAt(where);
                if (organism instanceof Albertadromeus) {
                    Albertadromeus albertadromeus = (Albertadromeus) organism;
                    if (albertadromeus.isAlive()) {
                        int otherRaptorsClose = 0;
                        List<Location> otherRaptors = field.adjacentLocations(albertadromeus.getLocation());
                        Iterator<Location> itRaptors = otherRaptors.iterator();
                        while (itRaptors.hasNext() && otherRaptorsClose == 0) {
                            Object possibleRaptor = field.getObjectAt(itRaptors.next());
                            if (possibleRaptor instanceof Raptor && possibleRaptor != this) {
                                Raptor newRaptor = (Raptor) possibleRaptor;
                                albertadromeus.setDead();
                                if((this.getFoodConsumed() + (albertadromeus.getFoodValue() / 2)) > this.getMaxFoodConsumed()){
                                    this.setFoodConsumed(this.getMaxFoodConsumed());
                                }else {
                                    this.setFoodConsumed(this.getFoodConsumed() + (albertadromeus.getFoodValue() / 2));
                                }
                                if((this.getFoodConsumed() + (albertadromeus.getFoodValue() / 2)) > this.getMaxFoodConsumed()){
                                    newRaptor.setFoodConsumed(this.getMaxFoodConsumed());
                                }else {
                                    newRaptor.setFoodConsumed(this.getFoodConsumed() + (albertadromeus.getFoodValue() / 2));
                                }

                                otherRaptorsClose++;
                                return where;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }","A method which enables the dinosaur to find its prey.
@return Location the location at which the prey is located.",Raptor.java,597.0,3
1,"protected void giveBirth(List<Organism> newDinos) 
    {
        // New raptors are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if((organism instanceof Raptor) && ((Raptor) organism).getDinoSex() != this.getDinoSex()) {
                int births = breed();
                for (int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    Raptor young = new Raptor(false, field, loc);
                    newDinos.add(young);
                }
            }
        }
    }","A method which gives birth to other dinosaurs under the correct conditions.
@param newDinos A list to return newly born dinosaurs.",Raptor.java,597.0,3
2,"protected int breed() 
    {
        int births = 0;
        if(this.canBreed() && this.getRand().nextDouble() <= this.getBreedingChance()) {
            births = this.getRand().nextInt(this.getMaxLitterSize()) + 1;
        }
        return births;
    }","A method to determine the size of the litter that the dinosaur will produce.
@return int the number of children the dinosaur will have.",Raptor.java,597.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,597.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,597.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,597.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,597.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,597.0,3
0,"protected Location findFood() {
        if (this.getFoodConsumed() <= 0.3 * this.getMaxFoodConsumed()) 
        {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object organism = field.getObjectAt(where);
                if (organism instanceof Cycad) {
                    Cycad cycad = (Cycad) organism;
                    if (cycad.isAlive()) {
                        cycad.setDead();
                        if((this.getFoodConsumed() + cycad.getFoodValue()) > this.getMaxFoodConsumed()){
                            this.setFoodConsumed(this.getMaxFoodConsumed());
                        }else {
                            this.setFoodConsumed(this.getFoodConsumed() + cycad.getFoodValue());
                        }
                        return where;
                    }
                }

            }
        }
        return null;
    }","A method which enables the dinosaur to find its prey.
@return Location the location at which the prey is located.",Albertadromeus.java,597.0,3
1,"protected void giveBirth(List<Organism> newDinos) 
    {
        // New albertadromeus are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if((organism instanceof Albertadromeus) && ((Albertadromeus) organism).getDinoSex() != this.getDinoSex()) {
                int births = breed();
                for (int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    Albertadromeus young = new Albertadromeus(false, field, loc);
                    newDinos.add(young);
                }
            }
        }
    }","A method which gives birth to other dinosaurs under the correct conditions.
@param newDinos A list to return newly born dinosaurs.",Albertadromeus.java,597.0,3
2,"protected int breed() 
    {
        int births = 0;
        if(this.canBreed() && this.getRand().nextDouble() <= this.getBreedingChance()) {
            births = this.getRand().nextInt(this.getMaxLitterSize()) + 1;
        }
        return births;
    }","A method to determine the size of the litter that the dinosaur will produce.
@return int the number of children the dinosaur will have.",Albertadromeus.java,597.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,570.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,570.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,570.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,570.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,570.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,570.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,570.0,3
0,"public void act(List<Organism> newHyenas)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (isInfected()) {
                infectOthers();
                heal();
            }
            else {
                reproduce(newHyenas);            
            }            

            if(dayTime()) {
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the hyena does most of the time: it hunts for zebra
in the day time. In the process, it might breed, die of hunger,
or die of old age. Also, it is possible for a hyena to catch an infection.
@param newHyenas A list to return newly born hyenas.",Hyena.java,570.0,3
1,"protected int getAge() 
    {
        return age;
    }","Return the age for this hyena.
@return The grass's hyena.",Hyena.java,570.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the hyena's death.,Hyena.java,570.0,3
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the breeding age for a hyena
@return The hyena's breeding age",Hyena.java,570.0,3
4,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if (object instanceof Zebra) {
                Zebra zebra = (Zebra) object;
                if(zebra.isAlive()) { 
                    zebra.setDead();
                    foodLevel += ZEBRA_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }

            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive()) { 
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for zebra adjacent to the current location.
Only the first live zebra is eaten.
@return Where food was found, or null if it wasn't.",Hyena.java,570.0,3
5,"private void reachMaxFoodLevel()
    {
        if(foodLevel > MAX_FOOD_LEVEL) {
            foodLevel = MAX_FOOD_LEVEL; 
        }
    }","Check whether food level is beyond maximum food level. If yes, cap it.",Hyena.java,570.0,3
6,"protected void reproduce(List<Organism> newHyenas)
    {
        // New hyenas are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Hyena young = new Hyena(false, field, loc);
            newHyenas.add(young);
        }
    }","Check whether or not this hyena is to give birth at this step.
New births will be made into free adjacent locations.
@param newHyenas A list to return newly born hyenas.",Hyena.java,570.0,3
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && healthy() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Hyena.java,570.0,3
8,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this hyena more hungry. This could result in the hyena's death.,Hyena.java,570.0,3
9,"private boolean healthy() {
        return foodLevel >= BREEDING_FOOD_LEVEL;
    }","Check whether the hyena is healthy enough to breed.
@return true if food level is above breeding food value, false if not.",Hyena.java,570.0,3
0,"public void act(List<Organism> newBuffalos) 
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (isInfected()) {
                infectOthers();
                heal();
            }
            else {
                reproduce(newBuffalos);            
            }

            if(dayTime()){
                // Try to move into a free location.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the buffalo does most of the time - it runs and eat grass
around in day time. Sometimes it will breed or die of old age or catch an infection.
@param newBuffalos A list to return newly born buffalos.",Buffalo.java,570.0,3
1,"protected int getAge() 
    {
        return age;
    }","Return the age for this buffalo.
@return The buffalo's age.",Buffalo.java,570.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the buffalo's death.",Buffalo.java,570.0,3
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the breeding age for a buffalo.
@return The buffalo's breeding age",Buffalo.java,570.0,3
4,"protected Location findFood()  
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Grass) {
                Grass grass = (Grass) plant;
                if(grass.isAlive()) { 
                    grass.setDead();
                    foodLevel += GRASS_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }
        }
        return null;
    }","Look for grass adjacent to the current location.
Only the first live grass is eaten.
@return Where food was found, or null if it wasn't.",Buffalo.java,570.0,3
5,"private void reachMaxFoodLevel()
    {
        if(foodLevel > MAX_FOOD_LEVEL) {
            foodLevel = MAX_FOOD_LEVEL; 
        }
    }","Check whether food level is beyond maximum food level. If yes, cap it.",Buffalo.java,570.0,3
6,"private void incrementHunger() 
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this buffalo more hungry. This could result in the buffalo's death.,Buffalo.java,570.0,3
7,"protected void reproduce(List<Organism> newBuffalos)
    {
        // New buffalos are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Buffalo young = new Buffalo (false, field, loc);
            newBuffalos.add(young);
        }
    }","Check whether or not this buffalo is to reproduce at this step.
New births will be made into free adjacent locations.
@param newBuffalos A list to return newly born buffalos.",Buffalo.java,570.0,3
8,"protected int breed()
    {
        int births = 0;
        if(canBreed() && healthy() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Buffalo.java,570.0,3
9,"private boolean healthy() {
        return foodLevel >= BREEDING_FOOD_LEVEL;
    }","Check whether the buffalo is healthy enough to breed.
@return true if food level is above breeding food value, false if not.",Buffalo.java,570.0,3
0,"protected Field getField() 
    {
        return field;
    }","Return the weather's field.
@return The weather's field.",Weather.java,570.0,3
0,"public void populate(Field field, List<Organism> actors)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if (rand.nextDouble() <= GRASS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Organism grass = new Grass(true, field, location);
                    actors.add(grass);
                }
                else if (rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Organism zebra = new Zebra(true, field, location);
                    actors.add(zebra);
                } 
                else if (rand.nextDouble() <= BUFFALO_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Organism buffalo = new Buffalo(true, field, location);
                    actors.add(buffalo);
                } else if (rand.nextDouble() <= HYENA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Organism hyena = new Hyena(true,field, location);
                    actors.add(hyena);
                } else if (rand.nextDouble() <= LION_CREATION_PROBABILITY) {
                    Location location = new Location(row,col);
                    Organism lion = new Lion(true, field, location);
                    actors.add(lion);
                }
                // else leave the location empty.
            }
        }
    }","Randomly populate the field with grass, zebras, buffalos, hyenas and lions.",PopulationGenerator.java,570.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,570.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,570.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,570.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,570.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,570.0,3
1,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,570.0,3
2,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        
        stepLabel.setText(STEP_PREFIX + step);
        String time = field.getCurrentTime().toString(); 
        timeLabel.setText(TIME_PREFIX + time);
        String weather = field.getCurrentWeather().toString();
        weatherLabel.setText(WEATHER_PREFIX + weather);
        String numberInfected = Integer.toString(field.getNumberInfected()); 
        infectedLabel.setText(INFECTED_PREFIX + numberInfected);
        
        stats.reset();
        fieldView.preparePaint();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object organism = field.getObjectAt(row, col);
                if(organism == null) {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }

                else {
                    stats.incrementCount(organism.getClass());
                    fieldView.drawMark(col, row, getColor(organism.getClass()));
                    if (organism instanceof Animal) {
                        Animal animal = (Animal) organism;  
                        if (animal.isInfected()) {
                            fieldView.drawMark(col,row,Color.BLACK);
                        }
                    }
                }
            }
            stats.countFinished();

            population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
            fieldView.repaint();
        }
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,570.0,3
3,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,570.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,570.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,570.0,3
2,"public void simulateOneStep()
    {
        step++;
        field.playWeather();
        if (step % 2 == 0) {
            field.setCurrentTime(Time.NIGHT);
        }
        else {
            field.setCurrentTime(Time.DAY);
        }
        
        // Provide space for newborn organisms.
        List<Organism> newOrganisms = new ArrayList<>();     
        //
        Random rand = new Random(); 
        // Let all organisms act.
        for(Iterator<Organism> it = organisms.iterator(); it.hasNext(); ) {
            Organism organism = it.next();
            if (organism instanceof Animal && rand.nextDouble() <= DISEASE_CREATION_PROBABILITY ) {
                Animal animal = (Animal) organism;
                animal.infect(); 
            }
            organism.act(newOrganisms);
            if(! organism.isAlive()) {
                it.remove(); 
            }
        }
               
        // Add the newly born organisms to the main lists.
        organisms.addAll(newOrganisms);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each plant and animal.",Simulator.java,570.0,3
3,"public void reset()
    {
        step = 0;
        organisms.clear();
        populate();
       
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,570.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        populator.populate(field, organisms);
    }",Randomly populate the field with plants and animals.,Simulator.java,570.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,570.0,3
0,"public void act(List<Organism> newZebras)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (isInfected()) {
                infectOthers();
                heal();
            }
            else {
                reproduce(newZebras);            
            }          

            if(dayTime()){
                // Try to move into a free location.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the zebra does most of the time - it runs
around and eat grass in the day time. Sometimes it will breed or die of old age or catch an infection.
@param newZebras A list to return newly born zebras.",Zebra.java,570.0,3
1,"protected int getAge() 
    {
        return age;
    }","Return the age for this zebra.
@return The zebra's age.",Zebra.java,570.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the zebra's death.",Zebra.java,570.0,3
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the breeding age for a zebra
@return The zebra's breeding age",Zebra.java,570.0,3
4,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Grass) {
                Grass grass = (Grass) plant;
                if(grass.isAlive()) { 
                    grass.setDead();
                    foodLevel += GRASS_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }
        }
        return null;
    }","Look for grass adjacent to the current location.
Only the first live grass is eaten.
@return Where food was found, or null if it wasn't.",Zebra.java,570.0,3
5,"private void reachMaxFoodLevel()
    {
        if(foodLevel > MAX_FOOD_LEVEL) {
            foodLevel = MAX_FOOD_LEVEL; 
        }
    }","Check whether food level is beyond maximum food level. If yes, cap it.",Zebra.java,570.0,3
6,"protected void reproduce(List<Organism> newZebras)
    {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Zebra young = new Zebra (false, field, loc);
            newZebras.add(young);
        }
    }","Check whether or not this zebra is to give birth at this step.
New births will be made into free adjacent locations.
@param newZebras A list to return newly born zebras.",Zebra.java,570.0,3
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && healthy() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Zebra.java,570.0,3
8,"private boolean healthy() {
        return foodLevel >= BREEDING_FOOD_LEVEL;
    }","Check whether the zebra is healthy enough to breed.
@return true if food level is above breeding food value, false if not.",Zebra.java,570.0,3
9,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this zebra more hungry. This could result in the fox's death.,Zebra.java,570.0,3
0,"public void act()
    {
        for(int row = 0; row < getField().getDepth(); row++) {
            for(int col = 0; col < getField().getWidth(); col++) {
                Location where = new Location(row, col);
                Object object = getField().getObjectAt(where);
                if(object instanceof Plant) {
                    Plant plant = (Plant) object;
                    if (plant.isAlive()) {
                        plant.incrementThirst();
                    }
                }
            }
        }            
    }",This is what  does.,Sunny.java,570.0,3
1,"public String toString() 
    {
        return displayString; 
    }","Return display string for rain.
@return The sunny word as a string",Sunny.java,570.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,570.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,570.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,570.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,570.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,570.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,570.0,3
0,"public boolean equals(Object obj)
    {
        if (this == obj) {
            return true;
        }

        if (obj == null) {
            return false;
        }

        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,570.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,570.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,570.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,570.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,570.0,3
0,"public boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,570.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,570.0,3
2,"protected Field getField() {
        return this.field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,570.0,3
3,"protected Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,570.0,3
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Organism.java,570.0,3
5,"protected boolean dayTime() 
    {
        return field.getCurrentTime().equals(Time.DAY); 
    }","Check whether it is day time in the given field
@return True if day time, false if not.",Organism.java,570.0,3
6,"protected boolean nightTime() 
    {
        return field.getCurrentTime().equals(Time.NIGHT); 
    }","Check whether it is night time in the given field.
@return True if night time, false if not.",Organism.java,570.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,570.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,570.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,570.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,570.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,570.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,570.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,570.0,3
0,"public Time getCurrentTime() {
        return currentTime; 
    }","Return the current time of the day.
@return Either day or night",Field.java,570.0,3
1,"public void setCurrentTime(Time newTime) 
    {
        currentTime = newTime; 
    }",Modify the time of the day at given field.,Field.java,570.0,3
2,"public void playWeather() 
    {
        setCurrentWeather(); 
        currentWeather.act();
    }",Play weather in given field.,Field.java,570.0,3
3,"public Weather getCurrentWeather() {
        return currentWeather; 
    }","Return the current weather of the field.
@return The field's current weather.",Field.java,570.0,3
4,"private void setCurrentWeather() 
    {
        currentWeather = randomWeather(); 
    }",Randomly modify current weather.,Field.java,570.0,3
5,"private Weather randomWeather() 
    {  
        List <Weather> weatherList = new ArrayList<>(possibleWeather) ; 
        int randomNumber = rand.nextInt(weatherList.size());
        return weatherList.get(randomNumber);
    }","Generate a random weather for this animal.
@return Any possible weather.",Field.java,570.0,3
6,"public void incrementNumberInfected() 
    {
        numberInfected ++; 
    }",Increment the number of infected animals on field by one.,Field.java,570.0,3
7,"public int getNumberInfected() 
    {
        numberInfected = 0;
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                Object organism = getObjectAt(row, col);
                if(organism != null) {
                     if (organism instanceof Animal) {
                        Animal animal = (Animal) organism;  
                        if (animal.isInfected()) {
                            numberInfected++; 
                        }
                    }
                }; 
            }
        }
        return numberInfected; 
    }","Return the number of infected animals on field.
@return how many infected animals.",Field.java,570.0,3
8,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,570.0,3
9,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,570.0,3
10,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,570.0,3
11,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,570.0,3
12,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,570.0,3
13,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,570.0,3
14,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,570.0,3
15,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,570.0,3
16,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,570.0,3
17,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,570.0,3
18,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,570.0,3
19,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,570.0,3
0,"public void act(List<Organism> newLions)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (isInfected()) {
                infectOthers();
                heal();
            }
            else {
                reproduce(newLions);            
            }         

            if (nightTime()) {
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            } 
        }
    }","This is what the lion does most of the time: it hunts for
buffalo, zebra or hyena in the night time. In the process, it might breed, die of hunger,
or die of old age. Also, it is possible for a lion to catch an infection.
@param newLions A list to return newly born lions.",Lion.java,570.0,3
1,"protected int getAge() 
    {
        return age;
    }","Return the age for this lion.
@return The lion's age.",Lion.java,570.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the lion's death.,Lion.java,570.0,3
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the breeding age for a lion.
@return The lion's breeding age",Lion.java,570.0,3
4,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this lion more hungry. This could result in the lion's death.,Lion.java,570.0,3
5,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Zebra){
                Zebra zebra = (Zebra) object;
                if(zebra.isAlive()) { 
                    zebra.setDead();
                    foodLevel += ZEBRA_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }
            
            if(object instanceof Buffalo) {
                Buffalo buffalo = (Buffalo) object;
                if(buffalo.isAlive()) { 
                    buffalo.setDead();
                    foodLevel += BUFFALO_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }

            if (object instanceof Hyena) {
                Hyena hyena = (Hyena) object;
                if(hyena.isAlive()) { 
                    hyena.setDead();
                    foodLevel += HYENA_FOOD_VALUE;
                    reachMaxFoodLevel();
                    return where;
                }
            }        

            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive()) { 
                    plant.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Look for buffalo/zebra/hyena adjacent to the current location.
Only the first live prey is eaten.
@return Where food was found, or null if it wasn't.",Lion.java,570.0,3
6,"private void reachMaxFoodLevel()
    {
        if(foodLevel > MAX_FOOD_LEVEL) {
            foodLevel = MAX_FOOD_LEVEL; 
        }
    }","Check whether food level is beyond maximum food level. If yes, cap it.",Lion.java,570.0,3
7,"protected void reproduce(List<Organism> newLions)
    {
        // New lions are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();

        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Lion young = new Lion(false, field, loc);
            newLions.add(young);
        }
    }","Check whether or not this lion is to give birth at this step.
New births will be made into free adjacent locations.
@param newLions A list to return newly born lions.",Lion.java,570.0,3
8,"protected int breed()
    {
        int births = 0;
        if(canBreed() && healthy() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Lion.java,570.0,3
9,"private boolean healthy() {
        return foodLevel >= BREEDING_FOOD_LEVEL;
    }","Check whether the lion is healthy enough to breed.
@return true if food level is above breeding food value, false if not.",Lion.java,570.0,3
0,"public void act(List<Organism> newGrasses)
    {
        incrementAge();
        if(isAlive()) {
            if (dayTime()){
                reproduce(newGrasses);
            }
            Location newLocation = getField().freeAdjacentLocation(getLocation()); 
            if (newLocation == null) {
                //Overcrowding
                setDead();
            }
        }      
    }","This is what the grass does most of the time: it absorbs water.
In the process, it might reproduce (only in the day time) or
die of wilting, old age or overcrowding.
@param newGrass A list to return newly born grass patches.",Grass.java,570.0,3
1,"protected int getAge() 
    {
        return age;
    }","Return the age for this grass.
@return The grass's age.",Grass.java,570.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the grass's death.",Grass.java,570.0,3
3,"public void incrementThirst()
    {
        waterLevel--;
        if(waterLevel < 0) {
            setDead();
        }
    }","Make this grass more thirsty. This could result in the grass's death
due to wilting.",Grass.java,570.0,3
4,"public void incrementWaterLevel()
    {
        waterLevel ++;
    }",Increment the water level of grass.,Grass.java,570.0,3
5,"protected void reproduce(List<Organism> newGrasses)
    {
        // New grasses are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed(); 
        for(int b = 0; free.size() > 0 && b < births; b++) {
            Location loc = free.remove(0);
            Grass young = new Grass(false, field, loc);
            newGrasses.add(young);
        }
    }","Check whether or not this grass is to reproduce at this step.
New grass will be made in free adjacent locations.
@param newGrass A list to return newly born grass.",Grass.java,570.0,3
6,"private int breed() 
    {
        int births = 0; 
        if (canBreed()) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1; 
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Grass.java,570.0,3
7,"private boolean canBreed()
    {
        return age >= REPRODUCE_AGE && rand.nextDouble() <= REPRODUCING_PROBABILITY;
    }","A grass can breed if it has reached the breeding age.
@return true if the grass can breed, false otherwise.",Grass.java,570.0,3
0,"protected Gender getGender() 
    {
        return gender;
    }","Return the gender for this animal .
@return The animal's gender.",Animal.java,570.0,3
1,"private void setGender(Gender newGender) 
    {
        this.gender = newGender;  
    }","Give this animal a new gender.
@param newGender The animal's new gender.",Animal.java,570.0,3
2,"private Gender randomGender() 
    {      
        Gender [] choice = Gender.values();
        int randomNumber = rand.nextInt(choice.length);
        return choice[randomNumber];
    }","Generate a random gender (either male or female) for this animal.
@return Either female or male",Animal.java,570.0,3
3,"protected boolean canBreed() 
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            //object at adjacent location needs to be an animal
            if (organism instanceof Animal) {
                Animal animal = (Animal) organism;
                //adjacent animal needs to be alive
                if (animal.isAlive()){
                    //same species for both animals 
                    if (sameSpecies(animal)) {
                        //different genders for both animals 
                        if (diffGender(animal)) {
                            //both animals need to be breeding age 
                            if (animal.ofBreedingAge() && ofBreedingAge()){
                                return true;                     
                            }
                        }
                    }
                }
            }
        }
        return false; 
    }","An animal can breed if the object at its adjacent location is an animal
of the same species but different gender. Also, both animals need to be of
breeding age.
@return True if all conditions satisfied",Animal.java,570.0,3
4,"private boolean diffGender(Animal other) 
    {
        return !other.getGender().equals(gender);
    }","Check whether both animals are of different gender.
@return true if different gender, false if not.",Animal.java,570.0,3
5,"private boolean sameSpecies(Animal other) 
    {
        return other.getClass().equals(getClass());
    }","Check whether both animals are of different species.
@return true if same species, false if not.",Animal.java,570.0,3
6,"private boolean ofBreedingAge()
    {
        return getAge() <= getBreedingAge();
    }","Check whether animals have reached breeding age.
@return true if animal of breeding age, false if not.",Animal.java,570.0,3
7,"public void infect()
    {
        if(isAlive() && !isImmune) {
            infection = rand.nextInt(MAX_INFECTION_TIME); 
            if (infection == MAX_INFECTION_TIME) {
                setDead();
            }
            isImmune = true;
        }
    }",Infect animal if it is not immune.,Animal.java,570.0,3
8,"public boolean isInfected() {
        return infection > 0;
    }","Check whether animals are infected.
@return true if infected, false if not",Animal.java,570.0,3
9,"protected void infectOthers()
    {
        Field field = getField();
        Location location = getLocation();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Animal) {
                Animal other = (Animal) object;
                if(other.isAlive()){
                    other.infect();
                }
            }
        }
    }","Look for uninfected animals adjacent to the current location.
If found, infect them.",Animal.java,570.0,3
10,"protected void heal() 
    {
        if (isInfected()) {
            infection --; 
        }      
    }","If animal is infected, execute the healing process. If infection reaches
zero, animal is healed.",Animal.java,570.0,3
0,"public void act()
    {
        for(int row = 0; row < getField().getDepth(); row++) {
            for(int col = 0; col < getField().getWidth(); col++) {
                Location where = new Location(row, col);
                Object object = getField().getObjectAt(where);
                if(object instanceof Plant) {
                    Plant plant = (Plant) object;
                    if (plant.isAlive()) {
                        plant.incrementWaterLevel();
                    }
                }
            }
        }            
    }",This is what rain does.,Rain.java,570.0,3
1,"public String toString() 
    {
        return displayString; 
    }","Return display string for rain.
@return The rainy word as a string",Rain.java,570.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,579.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,579.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,579.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,579.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,579.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,579.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,579.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,579.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,579.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,579.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,579.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,579.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,579.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,579.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,579.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,579.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,579.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,579.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,579.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,579.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    animals.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    animals.add(rabbit);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,579.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,579.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,579.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,579.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,579.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,579.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,579.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,579.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,579.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,579.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,579.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,579.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,579.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,579.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,579.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,579.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,579.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,579.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,579.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,579.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,579.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,579.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,579.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,579.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,579.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,579.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,579.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,579.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,579.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,579.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,579.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,579.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,579.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,579.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,579.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,579.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,579.0,3
0,"public double eval(double x, double y, double z) {
    
        //Place input coordinates on simplectic lattice.
        double stretchOffset = (x + y + z) * STRETCH_CONSTANT_3D;
        double xs = x + stretchOffset;
        double ys = y + stretchOffset;
        double zs = z + stretchOffset;
        
        //Floor to get simplectic lattice coordinates of rhombohedron (stretched cube) super-cell origin.
        int xsb = fastFloor(xs);
        int ysb = fastFloor(ys);
        int zsb = fastFloor(zs);
        
        //Skew out to get actual coordinates of rhombohedron origin. We'll need these later.
        double squishOffset = (xsb + ysb + zsb) * SQUISH_CONSTANT_3D;
        double xb = xsb + squishOffset;
        double yb = ysb + squishOffset;
        double zb = zsb + squishOffset;
        
        //Compute simplectic lattice coordinates relative to rhombohedral origin.
        double xins = xs - xsb;
        double yins = ys - ysb;
        double zins = zs - zsb;
        
        //Sum those together to get a value that determines which cell we're in.
        double inSum = xins + yins + zins;

        //Positions relative to origin point.
        double dx0 = x - xb;
        double dy0 = y - yb;
        double dz0 = z - zb;
        
        //We'll be defining these inside the next block and using them afterwards.
        double dx_ext0, dy_ext0, dz_ext0;
        double dx_ext1, dy_ext1, dz_ext1;
        int xsv_ext0, ysv_ext0, zsv_ext0;
        int xsv_ext1, ysv_ext1, zsv_ext1;
        
        double value = 0;
        if (inSum <= 1) { //We're inside the Tetrahedron (3-Simplex) at (0,0,0)
            
            //Determine which two of (0,0,1), (0,1,0), (1,0,0) are closest.
            byte aPoint = 0x01;
            double aScore = xins;
            byte bPoint = 0x02;
            double bScore = yins;
            if (aScore >= bScore && zins > bScore) {
                bScore = zins;
                bPoint = 0x04;
            } else if (aScore < bScore && zins > aScore) {
                aScore = zins;
                aPoint = 0x04;
            }
            
            //Now we determine the two lattice points not part of the tetrahedron that may contribute.
            //This depends on the closest two tetrahedral vertices, including (0,0,0)
            double wins = 1 - inSum;
            if (wins > aScore || wins > bScore) { //(0,0,0) is one of the closest two tetrahedral vertices.
                byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsb - 1;
                    xsv_ext1 = xsb;
                    dx_ext0 = dx0 + 1;
                    dx_ext1 = dx0;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb + 1;
                    dx_ext0 = dx_ext1 = dx0 - 1;
                }

                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0;
                    if ((c & 0x01) == 0) {
                        ysv_ext1 -= 1;
                        dy_ext1 += 1;
                    } else {
                        ysv_ext0 -= 1;
                        dy_ext0 += 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1;
                }

                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsb;
                    zsv_ext1 = zsb - 1;
                    dz_ext0 = dz0;
                    dz_ext1 = dz0 + 1;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz0 - 1;
                }
            } else { //(0,0,0) is not one of the closest two tetrahedral vertices.
                        byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.
                
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsb;
                    xsv_ext1 = xsb - 1;
                    dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb + 1;
                    dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysb;
                    ysv_ext1 = ysb - 1;
                    dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsb;
                    zsv_ext1 = zsb - 1;
                    dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                }
            }

            //Contribution (0,0,0)
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value = attn0 * attn0 * extrapolate(xsb + 0, ysb + 0, zsb + 0, dx0, dy0, dz0);
            }

            //Contribution (0,0,1)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1);
            }

            //Contribution (0,1,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;
            double dz2 = dz1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2);
            }

            //Contribution (1,0,0)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3);
            }
        } else if (inSum >= 2) { //We're inside the Tetrahedron (3-Simplex) at (1,1,1)
        
            //Determine which two tetrahedral vertices are the closest, out of (1,1,0), (1,0,1), (0,1,1) but not (1,1,1).
            byte aPoint = 0x06;
            double aScore = xins;
            byte bPoint = 0x05;
            double bScore = yins;
            if (aScore <= bScore && zins < bScore) {
                bScore = zins;
                bPoint = 0x03;
            } else if (aScore > bScore && zins < aScore) {
                aScore = zins;
                aPoint = 0x03;
            }
            
            //Now we determine the two lattice points not part of the tetrahedron that may contribute.
            //This depends on the closest two tetrahedral vertices, including (1,1,1)
            double wins = 3 - inSum;
            if (wins < aScore || wins < bScore) { //(1,1,1) is one of the closest two tetrahedral vertices.
                byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsb + 2;
                    xsv_ext1 = xsb + 1;
                    dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb;
                    dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    if ((c & 0x01) != 0) {
                        ysv_ext1 += 1;
                        dy_ext1 -= 1;
                    } else {
                        ysv_ext0 += 1;
                        dy_ext0 -= 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsb + 1;
                    zsv_ext1 = zsb + 2;
                    dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;
                }
            } else { //(1,1,1) is not one of the closest two tetrahedral vertices.
                        byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsb + 1;
                    xsv_ext1 = xsb + 2;
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb;
                    dx_ext0 = dx0 - SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysb + 1;
                    ysv_ext1 = ysb + 2;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy0 - SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsb + 1;
                    zsv_ext1 = zsb + 2;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz0 - SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                }
            }
            
            //Contribution (1,1,0)
            double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value = attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx3, dy3, dz3);
            }

            //Contribution (1,0,1)
            double dx2 = dx3;
            double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx2, dy2, dz2);
            }

            //Contribution (0,1,1)
            double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dy1 = dy3;
            double dz1 = dz2;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx1, dy1, dz1);
            }

            //Contribution (1,1,1)
            dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
            dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
            dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value += attn0 * attn0 * extrapolate(xsb + 1, ysb + 1, zsb + 1, dx0, dy0, dz0);
            }
        } else { //We're inside the Octahedron (Rectified 3-Simplex) in between.
            double aScore;
            byte aPoint;
            boolean aIsFurtherSide;
            double bScore;
            byte bPoint;
            boolean bIsFurtherSide;

            //Decide between point (1,0,0) and (0,1,1) as closest
            double p1 = xins + yins;
            if (p1 > 1) {
                aScore = p1 - 1;
                aPoint = 0x03;
                aIsFurtherSide = true;
            } else {
                aScore = 1 - p1;
                aPoint = 0x04;
                aIsFurtherSide = false;
            }

            //Decide between point (0,1,0) and (1,0,1) as closest
            double p2 = xins + zins;
            if (p2 > 1) {
                bScore = p2 - 1;
                bPoint = 0x05;
                bIsFurtherSide = true;
            } else {
                bScore = 1 - p2;
                bPoint = 0x02;
                bIsFurtherSide = false;
            }
            
            //The closest out of the two (0,0,1) and (1,1,0) will replace the furthest out of the two decided above, if closer.
            double p3 = yins + zins;
            if (p3 > 1) {
                double score = p3 - 1;
                if (aScore <= bScore && aScore < score) {
                    aScore = score;
                    aPoint = 0x06;
                    aIsFurtherSide = true;
                } else if (aScore > bScore && bScore < score) {
                    bScore = score;
                    bPoint = 0x06;
                    bIsFurtherSide = true;
                }
            } else {
                double score = 1 - p3;
                if (aScore <= bScore && aScore < score) {
                    aScore = score;
                    aPoint = 0x01;
                    aIsFurtherSide = false;
                } else if (aScore > bScore && bScore < score) {
                    bScore = score;
                    bPoint = 0x01;
                    bIsFurtherSide = false;
                }
            }
            
            //Where each of the two closest points are determines how the extra two vertices are calculated.
            if (aIsFurtherSide == bIsFurtherSide) {
                if (aIsFurtherSide) { //Both closest points on (1,1,1) side

                    //One of the two extra points is (1,1,1)
                    dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb + 1;

                    //Other extra point is based on the shared axis.
                    byte c = (byte)(aPoint & bPoint);
                    if ((c & 0x01) != 0) {
                        dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 2;
                        ysv_ext1 = ysb;
                        zsv_ext1 = zsb;
                    } else if ((c & 0x02) != 0) {
                        dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb;
                        ysv_ext1 = ysb + 2;
                        zsv_ext1 = zsb;
                    } else {
                        dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb;
                        ysv_ext1 = ysb;
                        zsv_ext1 = zsb + 2;
                    }
                } else {//Both closest points on (0,0,0) side

                    //One of the two extra points is (0,0,0)
                    dx_ext0 = dx0;
                    dy_ext0 = dy0;
                    dz_ext0 = dz0;
                    xsv_ext0 = xsb;
                    ysv_ext0 = ysb;
                    zsv_ext0 = zsb;

                    //Other extra point is based on the omitted axis.
                    byte c = (byte)(aPoint | bPoint);
                    if ((c & 0x01) == 0) {
                        dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb - 1;
                        ysv_ext1 = ysb + 1;
                        zsv_ext1 = zsb + 1;
                    } else if ((c & 0x02) == 0) {
                        dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 1;
                        ysv_ext1 = ysb - 1;
                        zsv_ext1 = zsb + 1;
                    } else {
                        dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 1;
                        ysv_ext1 = ysb + 1;
                        zsv_ext1 = zsb - 1;
                    }
                }
            } else { //One point on (0,0,0) side, one point on (1,1,1) side
                byte c1, c2;
                if (aIsFurtherSide) {
                    c1 = aPoint;
                    c2 = bPoint;
                } else {
                    c1 = bPoint;
                    c2 = aPoint;
                }

                //One contribution is a permutation of (1,1,-1)
                if ((c1 & 0x01) == 0) {
                    dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb - 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb + 1;
                } else if ((c1 & 0x02) == 0) {
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb - 1;
                    zsv_ext0 = zsb + 1;
                } else {
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb - 1;
                }

                //One contribution is a permutation of (0,0,2)
                if ((c2 & 0x01) != 0) {
                    dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                    xsv_ext1 = xsb + 2;
                    ysv_ext1 = ysb;
                    zsv_ext1 = zsb;
                } else if ((c2 & 0x02) != 0) {
                    dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                    xsv_ext1 = xsb;
                    ysv_ext1 = ysb + 2;
                    zsv_ext1 = zsb;
                } else {
                    dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;
                    xsv_ext1 = xsb;
                    ysv_ext1 = ysb;
                    zsv_ext1 = zsb + 2;
                }
            }

            //Contribution (0,0,1)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value = attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1);
            }

            //Contribution (0,1,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;
            double dz2 = dz1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2);
            }

            //Contribution (1,0,0)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3);
            }

            //Contribution (1,1,0)
            double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx4, dy4, dz4);
            }

            //Contribution (1,0,1)
            double dx5 = dx4;
            double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;
            if (attn5 > 0) {
                attn5 *= attn5;
                value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx5, dy5, dz5);
            }

            //Contribution (0,1,1)
            double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dy6 = dy4;
            double dz6 = dz5;
            double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;
            if (attn6 > 0) {
                attn6 *= attn6;
                value += attn6 * attn6 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx6, dy6, dz6);
            }
        }
 
        //First extra vertex
        double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0;
        if (attn_ext0 > 0)
        {
            attn_ext0 *= attn_ext0;
            value += attn_ext0 * attn_ext0 * extrapolate(xsv_ext0, ysv_ext0, zsv_ext0, dx_ext0, dy_ext0, dz_ext0);
        }

        //Second extra vertex
        double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1;
        if (attn_ext1 > 0)
        {
            attn_ext1 *= attn_ext1;
            value += attn_ext1 * attn_ext1 * extrapolate(xsv_ext1, ysv_ext1, zsv_ext1, dx_ext1, dy_ext1, dz_ext1);
        }

        //Normalization constant tested using over 4 billion evaluations to bound range within [-1,1].
        //This is a safe upper bound. Actual min/max values found over the course of the 4 billion
        //evaluations were -28.12974224468639 (min) and 28.134269887817773 (max).
        return value / 28.25;
    }",3D OpenSimplex (Simplectic) Noise.,OpenSimplexNoise.java,579.0,3
0,"public double eval(double x, double y, double z) {
        double val = 0;
        for(int i = 0; i < noises.length; i++) {
            double layerPersist = Math.pow(persistence,i+1);
            double layerLacunar = Math.pow(lacunarity,i);
            val += noises[i].eval(x*xFreq*layerLacunar, y*yFreq*layerLacunar, z*zFreq*layerLacunar)*layerPersist;
        }
        return val/normalisationFactor;
    }","Evaluate this noise3D at a given point
@param x The x coordinate to evaluate at
@param y The y coordinate to evaluate at
@param z The z coordinate to evaluate at",Noise3D.java,579.0,3
0,"public double eval(double x) {
        return noise.eval(x, 0, 0);
    }","Evaluate the noise at a given x and y coordinate
@param x The x coordinate to evaluate at",Noise1D.java,579.0,3
0,"public double eval(double x, double y) {
        return noise.eval(x, y, 0);
    }","Evaluate the noise at a given x and y coordinate
@param x The x coordinate to evaluate at
@param y The y coordinate to evaluate at",Noise2D.java,579.0,3
0,"public void preparePaint()
        {
            if(! size.equals(getSize())) {  // if the size has changed...
                size = getSize();
                habitatImage = createImage(size.width, size.height);
                g = habitatImage.getGraphics();

                xScale = size.width / gridWidth;
                if(xScale < 1) {
                    xScale = GRID_VIEW_SCALING_FACTOR;
                }
                yScale = size.height / gridHeight;
                if(yScale < 1) {
                    yScale = GRID_VIEW_SCALING_FACTOR;
                }
            }
        }","Prepare for a new round of painting. Since the component
may be resized, compute the scaling factor again.",HabitatPanel.java,579.0,3
1,"public void drawMark(int x, int y, Color colour)
        {
            g.setColor(colour);
            g.fillRect((x * xScale)/GRID_SCALE, (y * yScale)/GRID_SCALE, (xScale/GRID_SCALE), (yScale/GRID_SCALE));
        }",Paint on grid location on this habitat in a given colour.,HabitatPanel.java,579.0,3
2,"public void paintComponent(Graphics g)
        {
            if(habitatImage != null) {
                Dimension currentSize = getSize();
                if(size.equals(currentSize)) {
                    g.drawImage(habitatImage, 0, 0, null);
                }
                else {
                    // Rescale the previous image.
                    g.drawImage(habitatImage, 0, 0, currentSize.width, currentSize.height, null);
                }
            }
        }","The habitat view component needs to be redisplayed. Copy the
internal image to screen.",HabitatPanel.java,579.0,3
3,"public Dimension getPreferredSize()
        {
            return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR,
                                 gridHeight * GRID_VIEW_SCALING_FACTOR);
        }",Tell the GUI manager how big we would like to be.,HabitatPanel.java,579.0,3
0,"public void update(Habitat habitat, String stageName, long step)
    {
        makeVisible();
        
        habitatRenderer.render(habitat);
        
        String extra = """";
        if(stageName == Simulator.stageNames.get(SimulationStage.SIMULATION)) {
            long time = step * habitat.getSecondsPerStep();
            long minute = (time / (60)) % 60;
            long hour = (time / (60*60)) % 24;
            long day = time / (60*60*24);
            extra = ("" Day "" + day + "" at "" + hour + "":"" + (minute < 10 ? ""0"" + minute : minute));
        }
        controlPanel.setStageAndStepLabel(stageName, step, extra);
        
        populationLabel.setText(POPULATION_PREFIX + HabitatStats.getPopulationDetails(habitat));
        
        pack();
    }","Update the status of the window.
@param habitat The habitat being viewed.
@param stage The stage that the simulation is in.
@param step The step that the simulation is on",SimulatorWindow.java,579.0,3
1,"private void makeVisible() {
        if(!isVisible()) {
            setVisible(true);
        }
    }",Sets the simulator window visible.,SimulatorWindow.java,579.0,3
2,"public SimulatorControlPanel getControlPanel() {
        return controlPanel;
    }",@return controlPanel     the control panel for the simulation,SimulatorWindow.java,579.0,3
3,"public HabitatRenderer getHabitatRenderer() {
        return habitatRenderer;
    }",@return habitatRenderer      the habitat renderer for the simulation,SimulatorWindow.java,579.0,3
4,"public void addEventCode(EventCode code) {
        eventCodes.add(code);
    }","Add an event code to the window, indicating that action should be taken.
No visibility modifier indicates only usable from within GUI package.",SimulatorWindow.java,579.0,3
5,"public EventCode[] pollEventCodes() {
        EventCode[] codes = eventCodes.toArray(new EventCode[eventCodes.size()]);
        eventCodes.clear();
        return codes;
    }",Get all the event codes that were added since pollEventCodes was last pressed.,SimulatorWindow.java,579.0,3
0,"private JButton createButton(String buttonText, EventCode code) {
        JButton button = new JButton(buttonText);
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if(e.getSource() == button) {
                    parentWindow.addEventCode(code);
                }
            }
        });
        return button;
    }","Create a button wuth a particular name and code to execute upon press.
@param buttonText        name of the button
@param code          code to attempt to execute
@return button       the button with the above attributes",SimulatorControlPanel.java,579.0,3
1,"public void setStageAndStepLabel(String stageName, long step, String extra) {
        String stepText = (pauseButton.isVisible() ? "" (step "" + step + "")"" : """") + extra;
        stageAndStepLabel.setText("""" + stageName + stepText);
    }","Sets the stage, number of steps passed and additional information on the Stage and Step label.
@param stageName     the name of the current simulation stage
@param step      number of steps passed since start of simulation phase
@param extra     any additional text to be displayed",SimulatorControlPanel.java,579.0,3
2,"public void setViewButtonText(String text) {
        changeViewButton.setText(text);
    }","Sets the text on the view button.
@param text      the text to be displayed",SimulatorControlPanel.java,579.0,3
3,"public void setPausable(boolean pausable) {
        pauseButton.setVisible(pausable);
    }","Sets the pause button to be visible or invisible.
@param pausable      true if we want to see pause button, otherwise false",SimulatorControlPanel.java,579.0,3
4,"public void setPaused(boolean paused) {
        pauseButton.setText(paused ? "" Paused "" : ""Unpaused"");
    }","Sets the text on the screen to ""Paused"" or ""Unpaused""
@param paused        true if we want to display ""Paused"", false if ""Unpaused""",SimulatorControlPanel.java,579.0,3
5,"public void setCloudVisibility(boolean visible) {
        toggleCloudsButton.setText(visible ? ""Clouds: ON "" : ""Clouds: OFF"");
    }","Sets the text on the screen to ""Clouds: ON"" or ""Clouds: OFF""
@param paused        true if we want to display ""Clouds: ON"", false if ""Clouds: OFF""",SimulatorControlPanel.java,579.0,3
0,"public void render(Habitat habitat) {
        habitatPanel.preparePaint();
        switch(renderMode) {
            case NORMAL:
                renderNormal(habitat);
                break;
            case ELEVATION:
                renderElevation(habitat);
                break;
            case SATURATION:
                renderSaturation(habitat);
                break;
        }
        habitatPanel.repaint();
    }","Controls the rendering of the image on the display.
For each different case in the switch statement, render a different view of the habitat
@param habitat        the habitat that will be displayed",HabitatRenderer.java,579.0,3
1,"private void renderNormal(Habitat habitat) {
        for(Tile tile : habitat.getTiles()) {
            int col = tile.getCol(); int row = tile.getRow();
            Color colour = getTileColour(tile);
            habitatPanel.drawMark(col, row, colour);
        }
    }","Renders the normal view of the simulation.
@param habitat        the habitat that will be displayed",HabitatRenderer.java,579.0,3
2,"private Color getTileColour(Tile tile) {
        Habitat habitat = tile.getHabitat();
        
        Color tileColour = COLOURS.get(TileState.FERTILE_LAND);
        
        float waterCover = (tile.getWaterLevel() > WATER_DISPLAY_THRESHOLD ? 1 : 0);
        tileColour = mixColours(tileColour, COLOURS.get(TileState.WATER), waterCover);
        
        Algae algae = (Algae) tile.searchForEntity(EntityType.ALGAE);
        if(algae != null) {
            tileColour = mixColours(tileColour, COLOURS.get(TileState.ALGAE), (float) (algae.getBodyEnergy()/algae.getMaxBodyEnergy()));
        }
        
        if(tile.searchForEntity(EntityType.THICKET) != null) {
            tileColour = COLOURS.get(TileState.BUSH);
        }
        
        if(tile.searchForEntity(EntityType.WOODS) != null) {
            tileColour = COLOURS.get(TileState.TREE);
        }
        
        if(tile.searchForEntity(EntityType.FISH) != null) {
            tileColour = COLOURS.get(TileState.FISH);
        }
        
        if(tile.searchForEntity(EntityType.BIRD) != null) {
            tileColour = COLOURS.get(TileState.BIRD);
        }
        
        if(tile.searchForEntity(EntityType.DEER) != null) {
            tileColour = COLOURS.get(TileState.DEER);
        }
        
        if(tile.searchForEntity(EntityType.WOLF) != null) {
            tileColour = COLOURS.get(TileState.WOLF);
        }
        
        if(tile.searchForEntity(EntityType.BEAR) != null) {
            tileColour = COLOURS.get(TileState.BEAR);
        }
        
        CloudMap cloudMap = habitat.getCloudMap();
        if(cloudMap != null && cloudsVisible) {
            float cloudCover = (float) cloudMap.eval(tile.getCol(), tile.getRow());
            tileColour = mixColours(tileColour, COLOURS.get(TileState.CLOUD), cloudCover);
        }
        
        return tileColour;
    }","Returns the colour of any tile based on the flora and fauna, and any clouds, above it.
@param tile          the tile we want the colour of
@return tileColour       the colour of the tile",HabitatRenderer.java,579.0,3
3,"private void renderElevation(Habitat habitat) {
        double minElevation = habitat.getMinElevation();
        double maxElevation = habitat.getMaxElevation();
        double elevationRange = maxElevation - minElevation;
        for(Tile tile : habitat.getTiles()) {
            double differenceFromMin = tile.getElevation() - minElevation;
            float elevationPercentage = (float) (differenceFromMin/elevationRange);
            Color colour = elevationPercentageToColour(elevationPercentage);
            habitatPanel.drawMark(tile.getCol(),tile.getRow(), colour);
        }
    }","Renders the elevation view of the simulation.
@param habitat        the habitat that will be displayed",HabitatRenderer.java,579.0,3
4,"private Color elevationPercentageToColour(float elevationPercentage) {
        float hue = HIGHEST_ELEVATION_HUE - elevationPercentage*(HIGHEST_ELEVATION_HUE-LOWEST_ELEVATION_HUE);
        Color colour =  Color.getHSBColor(hue, ELEVATION_SAT, ELEVATION_BRIGHTNESS);
        return colour;
    }","Converts the floating point value elevationPercentage to an RGB Color.
@param elevationPercentage       float value to be converted to Color
@return colour       the colour based on elevationPercentage",HabitatRenderer.java,579.0,3
5,"private void renderSaturation(Habitat habitat) {
        float minSaturation = habitat.getMinSaturation();
        float maxSaturation = habitat.getMaxSaturation();
        float saturationRange = maxSaturation - minSaturation;
        for(Tile tile : habitat.getTiles()) {
            float differenceFromMin = tile.getSaturation() - minSaturation;
            float saturationPercentage = differenceFromMin/saturationRange;
            Color colour = saturationPercentageToColour(saturationPercentage); // convert saturation percentage of tiles to colour
            habitatPanel.drawMark(tile.getCol(),tile.getRow(), colour);
        }
    }","For all tiles in the habitat, render their colour on the display.
@param habitat       the Habitat to be displayed",HabitatRenderer.java,579.0,3
6,"private Color saturationPercentageToColour(float saturationPercentage) {
        float hue = HIGHEST_SATURATION_HUE - saturationPercentage*(HIGHEST_SATURATION_HUE-LOWEST_SATURATION_HUE);
        Color colour = Color.getHSBColor(hue, SATURATION_SAT, SATURATION_BRIGHTNESS);
        return colour;
    }","Converts the floating point value saturationPercentage to an RGB Color.
@param saturationPercentage       float value to be converted to Color
@return colour           colour based on saturation percentage",HabitatRenderer.java,579.0,3
7,"private Color mixColours(Color firstColour, Color secondColour, float ratio) {
        int r = (int) ((1-ratio)*(firstColour.getRed()) + (ratio)*(secondColour.getRed()));
        int g = (int) ((1-ratio)*(firstColour.getGreen()) + (ratio)*(secondColour.getGreen()));
        int b = (int) ((1-ratio)*(firstColour.getBlue()) + (ratio)*(secondColour.getBlue()));
        return new Color(r,g,b);
    }","Mixes and blends 2 different colours based on a ratio floating point value
@param firstColour       the first colour to be mixed
@param secondColour      the second colour to be mixed
@param ratio         a constant value that affects how much blending occurs
@return      a new colour based on the above 3 values",HabitatRenderer.java,579.0,3
8,"public boolean getCloudVisibility() {
        return cloudsVisible;
    }","@return true if clouds are visible, else false",HabitatRenderer.java,579.0,3
9,"public void setCloudVisibility(boolean visible) {
        cloudsVisible = visible;
    }","Sets cloud visibility to be true or not
@param visible       true if clouds visible, else false",HabitatRenderer.java,579.0,3
10,"public RenderMode getRenderMode() {
        return renderMode;
    }",@return the current mode of the simulation,HabitatRenderer.java,579.0,3
11,"public void setRenderMode(RenderMode renderMode) {
        this.renderMode = renderMode;
    }","Sets the mode the simulation is rendering to another mode.
@param renderMode        the mode we want the simulation to display",HabitatRenderer.java,579.0,3
0,"public static String getPopulationDetails(Habitat habitat)
    {
        ArrayList<String> infoBuffer = new ArrayList<String>();
        
        HashMap<Class, Counter> counters = generateCounts(habitat);
        
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            String name = info.getName().replace(""Entities."","""");
            String count = """" + info.getCount();
            infoBuffer.add(name + "": "" + count + "", "");
        }
        Collections.sort(infoBuffer);
        String detailsString = """";
        for(String info : infoBuffer) {
            detailsString += info;
        }
        return detailsString;
    }","Get details of what is in the habitat.
@return A string describing what is in the habitat.",HabitatStats.java,579.0,3
1,"private static void incrementCount(HashMap<Class,Counter> counters, Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",HabitatStats.java,579.0,3
2,"private static HashMap<Class,Counter> generateCounts(Habitat habitat)
    {
        HashMap<Class, Counter> counters = new HashMap<>();
        
        for(Tile tile : habitat.getTiles()) {
            for(Entity entity : tile.getEntities()) {
                if(entity instanceof Creature) {
                    if(((Creature) entity).getState() == CreatureState.ALIVE) {
                        incrementCount(counters, entity.getClass());
                    }
                } else {
                    incrementCount(counters, entity.getClass());
                }
            }
        }
        return counters;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the habitat, but only when a request
is made for the information.
@param habitat The habitat to generate the stats for.",HabitatStats.java,579.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,579.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,579.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,579.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,579.0,3
0,"public Tile[] getTilesWithinDistance(int radius) {
        return habitat.getTilesWithinDistance(this, radius);
    }","Gets all of the tiles of a habitat within a square of a given side length whose
center is this tile. This effectively gets all the tiles within a given
distance of this tile. The ordering is a spiral-like pattern from the origin.
@param distance the side length of the square
@return An array containing all tiles within that square.",Tile.java,579.0,3
1,"public Tile[] getTilesAtDistance(int radius) {
        return habitat.getTilesAtDistance(this, radius);
    }","Gets all of the tiles on the perimeter of a square of a given side length whose
center is a given tile within this habitat. This effectively gets all the tiles at
a given distance from the origin. The ordering is a spiral-like pattern from the
origin.

@param distance the side length of the square
@return An array containing all tiles that are on the perimeter of that square",Tile.java,579.0,3
2,"public Entity searchForEntity(EntityType type) {
        for(Entity entity : entities) {
            if(entity.getType() == type) {
                return entity;
            }
        }
        return null;
    }","Search for, and return, an entity of a certain type on a tile.
If the entity does not exist, return null.
@param type      the type of the entity.",Tile.java,579.0,3
3,"public void addEntity(Entity entity) {
        entities.add(entity);
    }","Add a creature to the tile
@param creature The creature to be added",Tile.java,579.0,3
4,"public boolean removeEntity(Entity entity) {
        return entities.remove(entity);
    }","Attempt to remove a creature from the tile
@param creature the creature to be removed
@return true if the operation was successful, otherwise false",Tile.java,579.0,3
5,"public ArrayList<Entity> getEntities()
    {
        return entities;
    }",@return the creatures within this tile,Tile.java,579.0,3
6,"public void spreadWater() {
        // Find the tile with the lowest overall level
        Tile lowestTile = this;
        double lowestLevel = this.getElevationPlusWater();
        for(Tile tile : habitat.getTilesAtDistance(this, 1)) {
            double level = tile.getElevationPlusWater();
            if(level < lowestLevel) {
                lowestTile = tile;
                lowestLevel = level;
            }
        }
        
        double average = (this.getElevationPlusWater() + lowestLevel)/2;
        double desiredAmountToGive = average - lowestLevel;
        double amountToGive = Math.min(waterLevel,desiredAmountToGive);
        
        addWaterLevel(-amountToGive);
        lowestTile.addWaterLevel(amountToGive);
    }","Attempt to ""spread"" water on one tile into its 4 surrounding tiles in each cardinal direction.
If a surrounding tile has lower elevation than the original, water can spread into it.",Tile.java,579.0,3
7,"public double getElevation() {
        return elevation;
    }",@return the elevation value of the tile,Tile.java,579.0,3
8,"public void setElevation(double elevation) {
        this.elevation = elevation;
    }","Assign an elevation value to the tile
@param elevation     elevation of tile",Tile.java,579.0,3
9,"public double getWaterLevel() {
        return waterLevel;
    }",@return the waterLevel value of tile,Tile.java,579.0,3
10,"public void addWaterLevel(double waterLevel) {
        this.waterLevel = Math.max(0,this.waterLevel + waterLevel);
    }","Add to the waterLevel value, then set waterLevel to be either 0 or the total water level of tile (whichever is larger)
@param waterLevel        the value to be added (double)",Tile.java,579.0,3
11,"public float getSaturation() {
        return saturation;
    }",@return the saturation value of the tile,Tile.java,579.0,3
12,"public void setSaturation(float saturation) {
        this.saturation = saturation;
    }","Assign a saturation floating point value to the tile.
@param saturation        saturation value of tile",Tile.java,579.0,3
13,"public double getElevationPlusWater() {
        return elevation + waterLevel;
    }",@return elevation of tile + water level of tile,Tile.java,579.0,3
14,"public Habitat getHabitat()
    {
        return habitat;
    }",@return The habitat containing this tile,Tile.java,579.0,3
15,"public int getRow()
    {
        return row;
    }",@return The row that this tile is in.,Tile.java,579.0,3
16,"public int getCol()
    {
        return col;
    }",@return The column that this tile is in.,Tile.java,579.0,3
17,"public boolean equals(Object obj)
    {
        if(obj instanceof Tile) {
            Tile other = (Tile) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Tile.java,579.0,3
18,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Tile.java,579.0,3
19,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Tile.java,579.0,3
0,"public double eval(double x, double y) {
        // Calculate the offset
        double xAfterOffset = x + OFFSET_AMPLITUDE * xOffsetNoise.eval(x,y);
        double yAfterOffset = y + OFFSET_AMPLITUDE * yOffsetNoise.eval(x,y);
        
        // Calculate the elevation at the offset position
        return calculateElevation(xAfterOffset, yAfterOffset);
    }","Evaluate the elevation of the terrain at a given coordinate (after offsetting)
@param x The x coordinate to get the elevation at
@param y The y coordinate to get the elevation at
@return The elevation of the terrain at the given coordinate (after offsetting)",ElevationMap.java,579.0,3
1,"private double calculateElevation(double x, double y) {
        // The hill value corresponds simply to the hill noise
        double hillVal = hillNoise.eval(x, y);
        
        // The valley value is mapped by a series of steps which produce valley-like structures
        double valleyVal = valleyNoise.eval(x,y);
        valleyVal = Math.abs(valleyVal);
        valleyVal = Math.pow(valleyVal, VALLEY_WIDTH);
        valleyVal = 2*valleyVal-1;
        
        // Return the hills and valleys, distributed according to the hill-valley ratio
        return ((1-HILL_VALLEY_RATIO)*hillVal + HILL_VALLEY_RATIO*valleyVal);
    }","Evaluate the elevation of the terrain at a given coordinate (before offsetting)
@param x The x coordinate to get the elevation at
@param y The y coordinate to get the elevation at
@return The elevation of the terrain at the given coordinate (before offsetting)",ElevationMap.java,579.0,3
0,"public void update(double timePassed) {
        time += timePassed;
        xDisplacement += timePassed * HORIZONTAL_WIND_AMPLITUDE * horizontalWindNoise.eval(time);
        yDisplacement += timePassed * VERTICAL_WIND_AMPLITUDE * verticalWindNoise.eval(time);
    }","Updates the displacement values of the clouds as time increases.
The more time passed, the further the clouds should be from start location.
@param timePassed        The amount of time passed since simulation stage start.",CloudMap.java,579.0,3
1,"public double eval(int x, int y) {
        double xAfterDisplacement = x - xDisplacement;
        double yAfterDisplacement = y - yDisplacement;
        
        double xAfterOffset = xAfterDisplacement + (OFFSET_AMPLITUDE * xOffsetNoise.eval(xAfterDisplacement,yAfterDisplacement,time));
        double yAfterOffset = yAfterDisplacement + (OFFSET_AMPLITUDE * yOffsetNoise.eval(xAfterDisplacement,yAfterDisplacement,time));
        
        double noiseVal = cloudNoise.eval(xAfterOffset,yAfterOffset,time);
        return noiseToCloudCover(noiseVal);
    }","Evaluate the clouds at a given coordinate and step
@param x The x coordinate to evaluate at
@param y The y coordinate to evaluate at",CloudMap.java,579.0,3
2,"private double noiseToCloudCover(double noiseVal) {
        double cloudVal = (noiseVal+1)/2;
        return (cloudVal > CLOUD_THRESHOLD ? Math.pow(cloudVal,1/SUPER_CLOUD_EXPONENT) : cloudVal*SUB_CLOUD_AMPLITUDE);
    }","Converts a noise value into a value used for cloud cover patterns.
@param noiseVal      double value of the noise value.",CloudMap.java,579.0,3
0,"public static Habitat generateHabitat(Long seed, Integer width, Integer height) {
        // Set all the data to the defaults if no values are provided.
        if(seed == null) seed = DEFAULT_SEED;
        if(width == null) width = DEFAULT_WIDTH;
        if(height == null) height = DEFAULT_HEIGHT;
        
        // Create the habitat, providing it the randomiser for later usage
        Habitat habitat = new Habitat(seed, width, height, SECONDS_PER_STEP, METERS_PER_TILE);
        // Clear the habitat
        habitat.reset();
        
        // Return the habitat
        return habitat;
    }","Generate a habitat from a width, height, and seed. This does not include the
contents of the habitat: those are provided in other methods of this class.
If null values are given, the default values are used.
@param seed The seed to generate the world from, or null
@param width The width of the habitat to generate, or null
@param height The height of the habitat to generate, or null
@return A habitat generated from the parameters",HabitatGenerator.java,579.0,3
1,"public static void generateElevation(Habitat habitat) {
        // Generate an elevation map to set elevations from
        ElevationMap elevationMap = new ElevationMap(habitat.getRandomiser());
        // Get the habitat's tiles, so that their elevations can be set
        Tile[] tiles = habitat.getTiles();
        // Set the elevation of the tiles
        setTileElevations(tiles, elevationMap);
        // Let the habitat know that its max and min heights need updating
        habitat.recalculateMinAndMaxElevations();
        // Normalise the minimum and maximum elevations for the habitat
        normaliseTileElevations(tiles);
        // Let the habitat know that its max and min heights need updating
        habitat.recalculateMinAndMaxElevations();
    }","Generate elevation for a given habitat. Elevation is normalised between the constants
MIN_ELEVATION and MAX_ELEVATION (both in meters). The elevations are generated by
the ElevationMap class, which automatically includes grooves to represent river lines.
@param habitat The habitat to generate elevation for",HabitatGenerator.java,579.0,3
2,"private static void setTileElevations(Tile[] tiles, ElevationMap elevationMap)
    {
        for(Tile tile : tiles) {
            int row = tile.getRow();
            int col = tile.getCol();
            tile.setElevation(elevationMap.eval(col,row));
        }
    }","Set the elevation of an array of tiles according to a given ElevationMap.
@param tiles An array containing all tiles to set the elevation of.
@param elevationMap The elevation map to get elevation values from",HabitatGenerator.java,579.0,3
3,"private static void normaliseTileElevations(Tile[] tiles) {
        double minElevation; 
        double maxElevation;
        minElevation = maxElevation = tiles[0].getElevation();
        for(Tile tile : tiles) {
            minElevation = Math.min(minElevation, tile.getElevation());
            maxElevation = Math.max(maxElevation, tile.getElevation());
        }
        double multiplier = (MAX_ELEVATION - MIN_ELEVATION) / (maxElevation - minElevation);
        double increment = MIN_ELEVATION - minElevation*multiplier;
        
        for(Tile tile : tiles) {
            double elevation = tile.getElevation();
            tile.setElevation(elevation * multiplier + increment);
        }
    }","Takes the tile elevations of a series of tiles and upscales the values for all tiles.
The new elevations represent real-world values of 1700-2500 metres.
@param tiles     The tiles which will have their elevations normalised",HabitatGenerator.java,579.0,3
4,"public static void generateWeather(Habitat habitat) {
        CloudMap cloudMap = new CloudMap(habitat.getRandomiser());
        habitat.setCloudMap(cloudMap);
    }","Generate weather for a given habitat. Weather is currently represented by a CloudMap,
which handles its own windspeed. The presence or absence of a cloud at any point
in time is determined by the CloudMap.
@param habitat The habitat to generate weather for.",HabitatGenerator.java,579.0,3
5,"public static void generateWater(Habitat habitat) {
        for(Tile tile : habitat.getTiles()) {
            tile.addWaterLevel(WATER_LEVEL_PER_TILE);
        }
        for(int i = 0; i < WATER_GENERATION_STEPS; i++) {
            for(Tile tile : habitat.getTiles()) {
                tile.spreadWater();
            }
        }
        habitat.recalculateMinAndMaxWaterLevels();
    }","Generate the water for a given habitat. This is done by spreading water evenly
across all tiles, and then using a fluid simulation to drain water from areas of
high elevation to areas of low elevation. This does not mean that all water will
end up at the lowest points, as it may collect in local minima as well. Due to
the nature of elevation generation, this is also likely to create rivers.
@param habitat The habitat to generate water for",HabitatGenerator.java,579.0,3
6,"public static void generateSaturations(Habitat habitat) {
        for(Tile tile : habitat.getTiles()) {
            float saturation = 0;
            for(int distance = 0; distance <= SATURATION_SEARCH_RADIUS; distance++) {
                Tile[] tilesAtCurrentDistance = habitat.getTilesAtDistance(tile, distance);
                for(Tile currentTile : tilesAtCurrentDistance) {
                    if(currentTile.getWaterLevel() > 0) {
                        saturation += 1.0/(SATURATION_SEARCH_RADIUS*(tilesAtCurrentDistance.length));
                    }
                }
            }
            tile.setSaturation(saturation);
        }
        habitat.recalculateMinAndMaxSaturations();
    }","Sets the saturation floating point value for every tile in the habitat.
This is done by taking a tile and getting all the tiles at a particular Manhattan
distance from it. We then check the water level values of all these tiles.
If it is above 0, saturation is increased based on distance from the original tile.
This is then repeated for all tiles in the habitat.
@param habitat   The habitat we want to set tile saturations for.",HabitatGenerator.java,579.0,3
7,"public static void generateFlora(Habitat habitat) {
        WoodsGenerator woodsGenerator = new WoodsGenerator(habitat.getRandomiser());
        woodsGenerator.populate(habitat.getTiles());
        ThicketGenerator thicketGenerator = new ThicketGenerator(habitat.getRandomiser());
        thicketGenerator.populate(habitat.getTiles());
        AlgaeGenerator algaeGenerator = new AlgaeGenerator(habitat.getRandomiser());
        algaeGenerator.populate(habitat.getTiles());
    }","Generates all plant life (algae, woods and thickets) in the habitat. This is done
using an EntityGenerator that corresponds to each type of plant.
@param habitat   The habitat we wish to generate all the plant life in.",HabitatGenerator.java,579.0,3
8,"public static void generateFauna(Habitat habitat) {
        FishGenerator fishGenerator = new FishGenerator(habitat.getRandomiser());
        fishGenerator.populate(habitat.getTiles());
        
        BirdGenerator birdGenerator = new BirdGenerator(habitat.getRandomiser());
        birdGenerator.populate(habitat.getTiles());
        
        DeerGenerator deerGenerator = new DeerGenerator(habitat.getRandomiser());
        deerGenerator.populate(habitat.getTiles());
        
        WolfGenerator wolfGenerator = new WolfGenerator(habitat.getRandomiser());
        wolfGenerator.populate(habitat.getTiles());
        
        BearGenerator bearGenerator = new BearGenerator(habitat.getRandomiser());
        bearGenerator.populate(habitat.getTiles());
    }","Generates all animal life (fish, birds, deer, bears, wolves) in the habitat. This
is done by using an EntityGenerator that corresponds to each type of animal.
@param habitat   The habitat we wish to generate all the animal life in.",HabitatGenerator.java,579.0,3
0,"public void reset()
    {
        // Reset the randomiser
        randomiser = new Random(seed);
        
        // Initialise the tile array
        tileGrid = new Tile[height][width];
        for(int row = 0; row < height; row++) {
            for(int col = 0; col < width; col++) {
                Tile tile = new Tile(this,row,col);
                tileGrid[row][col] = tile;
            }
        }
        
        cloudMap = null;
        
        // Initialise the elevations
        maxElevation = 0;
        minElevation = 0;
    }",Reset the habitat to its initial conditions,Habitat.java,579.0,3
1,"public void step() {
        secondsSinceStart += secondsPerStep;
        for(Entity entity : getEntities()) {
            entity.update(secondsPerStep);
        }
        // Useful for debugging
        //printActivities(); 
        
        cloudMap.update(secondsPerStep);
    }","Perform one step of the simulation. This means incrementing the time, and calling
the update method for all entities in the simulation.",Habitat.java,579.0,3
3,"public Tile getTile(int col, int row)
    {
        if(row < 0 || col < 0 || col >= width || row >= height) {
            return null;
        } else return tileGrid[row][col];
    }","Return the tile at the given location, if any.
@param col The column to check in
@param row The row to checkin
@return The tile at the given location, or null if there is none.",Habitat.java,579.0,3
4,"public Tile[] getTiles() {
        // Flatten the tileGrid to a one-dimensional array, and return it
        return Stream.of(tileGrid).flatMap(Stream::of).toArray(Tile[]::new);
    }","Get all of the tiles in the habitat. These are not provided in any particular order.
@return An array containing all tiles within the habitat.",Habitat.java,579.0,3
5,"public Tile[][] getTileGrid() {
        return tileGrid;
    }",@return The tile grid containing all tiles within the habitat,Habitat.java,579.0,3
6,"public Tile[] getTilesWithinDistance(Tile origin, int distance) {
        // Create a list of tiles to add to
        ArrayList<Tile> spiral = new ArrayList<Tile>();
        
        // Iterate until reaching the desired radius
        for(int currentDistance = 0; currentDistance <= distance; currentDistance++) {
            Tile[] tiles = getTilesAtDistance(origin, currentDistance);
            spiral.addAll(Arrays.asList(tiles));
        }
        
        // Return the tiles in the spiral as an array
        return spiral.toArray(new Tile[spiral.size()]);
    }","Gets all of the tiles within a square of a given side length whose center is a
given tile within this habitat. This effectively gets all the tiles within a given
distance of the origin tile. The ordering is a spiral-like pattern from the origin.

@param origin the tile at the center of the square
@param distance the side length of the square
@return An array containing all tiles within that square",Habitat.java,579.0,3
7,"public Tile[] getTilesAtDistance(Tile origin, int distance) {
        // The ArrayList of tiles to add to
        ArrayList<Tile> tiles = new ArrayList<Tile>();
        
        if(distance == 0) tiles.add(origin);
        else {
            // Start at the top-left of the spiral
            int col = origin.getCol() - distance;
            int row = origin.getRow() - distance;
        
            // A description of the clockwise motion that the spiral will take.
            int[][] spiralArms = new int[][] {{1,0},{0,1},{-1,0},{0,-1}};
            // Add the tiles on each arm of the spiral of this radius
            for(int[] spiralArm : spiralArms) {
                // Add each tile on the current spiral arm
                for(int i = 0; i < 2*distance; i++)
                {
                    Tile tile = getTile(col,row);
                    if(tile != null) tiles.add(tile);
                    // Move to the next tile
                    col += spiralArm[0];
                    row += spiralArm[1];
                }
            }
        }
        return tiles.toArray(new Tile[tiles.size()]);
    }","Gets all of the tiles on the perimeter of a square of a given side length whose
center is a given tile within this habitat. This effectively gets all the tiles at
a given distance from the origin. The ordering is a spiral-like pattern from the
origin.

@param origin the tile at the center of the square
@param distance the side length of the square
@return An array containing all tiles that are on the perimeter of that square",Habitat.java,579.0,3
8,"public void recalculateMinAndMaxElevations() {
        Tile[] tiles = getTiles();
        minElevation = maxElevation = tiles[0].getElevation();
        for(Tile tile : tiles) {
            minElevation = Math.min(minElevation, tile.getElevation());
            maxElevation = Math.max(maxElevation, tile.getElevation());
        }
    }","Recalculate the minimum and maximum elevations.
Use this whenever the elevation of a tile is changed",Habitat.java,579.0,3
9,"public double getMaxElevation() {
        return maxElevation;
    }",@return The max elevation of all tiles within this habitat,Habitat.java,579.0,3
10,"public double getMinElevation() {
        return minElevation;
    }",@return The min elevation of all tiles within this habitat,Habitat.java,579.0,3
11,"public void recalculateMinAndMaxWaterLevels() {
        Tile[] tiles = getTiles();
        minWaterLevel = maxWaterLevel = tiles[0].getWaterLevel();
        for(Tile tile : tiles) {
            minWaterLevel = Math.min(minWaterLevel, tile.getWaterLevel());
            maxWaterLevel = Math.max(maxWaterLevel, tile.getWaterLevel());
        }
    }","Recalculate the minimum and maximum water levels.
Use this whenever the elevation of a tile is changed",Habitat.java,579.0,3
12,"public double getMaxWaterLevel() {
        return maxWaterLevel;
    }",@return The max saturation of all tiles within this habitat,Habitat.java,579.0,3
13,"public double getMinWaterLevel() {
        return minWaterLevel;
    }",@return The min saturation of all tiles within this habitat,Habitat.java,579.0,3
14,"public void recalculateMinAndMaxSaturations() {
        Tile[] tiles = getTiles();
        minSaturation = maxSaturation = tiles[0].getSaturation();
        for(Tile tile : tiles) {
            minSaturation = Math.min(minSaturation, tile.getSaturation());
            maxSaturation = Math.max(maxSaturation, tile.getSaturation());
        }
    }","Recalculate the minimum and maximum saturations.
Use this whenever the elevation of a tile is changed",Habitat.java,579.0,3
15,"public float getMaxSaturation() {
        return maxSaturation;
    }",@return The max saturation of all tiles within this habitat,Habitat.java,579.0,3
16,"public float getMinSaturation() {
        return minSaturation;
    }",@return The min saturation of all tiles within this habitat,Habitat.java,579.0,3
17,"public int getWidth()
    {
        return width;
    }",@return The width of the habiat.,Habitat.java,579.0,3
18,"public int getHeight()
    {
        return height;
    }",@return The height of the habiat.,Habitat.java,579.0,3
19,"public int getMetersPerTile() {
        return metersPerTile;
    }",@return the value of metersPerTile.,Habitat.java,579.0,3
21,"public CloudMap getCloudMap() {
        return cloudMap;
    }",@return the CloudMap used by this habitat to generate weather,Habitat.java,579.0,3
22,"public void setCloudMap(CloudMap cloudMap) {
        this.cloudMap = cloudMap;
    }","Sets the cloudmap
@param cloudMap the cloudMap to set",Habitat.java,579.0,3
23,"public int getTimeOfDay() {
        return (int) (secondsSinceStart%(60*60*24));
    }","@return the number of seconds since the start of the current day that this
simulation is on",Habitat.java,579.0,3
24,"public Random getRandomiser() {
        return randomiser;
    }",@return the Random object used by this habitat to generate random values,Habitat.java,579.0,3
25,"private void printActivities() {
        Map<Pair<EntityType,CreatureActivity>,Integer> activities = new HashMap<>();
        for(Entity entity : getEntities()) {
            if(entity instanceof Creature) {
                Creature creature = (Creature) entity;
                Pair<EntityType,CreatureActivity> pair = new Pair(creature.getType(), creature.getActivity());
                Integer value = activities.get(pair);
                if(value == null) activities.put(pair, 1);
                else activities.put(pair,value+1);
            }
        }
        
        System.out.println("""");
        for(EntityType type : EntityType.values()) {
            System.out.print(type + ""{"");
            for(CreatureActivity activity : CreatureActivity.values()) {
                Integer value = activities.get(new Pair(type, activity));
                if(value != null) System.out.print(activity + "":"" + value  + "", "");
            }
            System.out.println(""}"");
        }
    }","Print the number of creatures of each type performing each activity A very useful
procedure for debugging.",Habitat.java,579.0,3
0,"public void run() {
        while(true) {
            // Process events
            // Get all window events (such as buttons pressed)
            EventCode[] codes = window.pollEventCodes();
            // Process each event code
            for(EventCode code : codes) {
                processEventCode(code);
            }
            
            // Run the simulation if it is not paused
            if(!paused) {
                step();
            }
            
            // Update the GUI with any changes
            window.update(habitat, stageNames.get(stage), stageStep);
        }
    }","Infinite loop to keep the window checking for new events and
running the simulation. Closing the window will exit the entire program,
including this loop.",Simulator.java,579.0,3
1,"private void processEventCode(EventCode code) {
        switch(code) {
        // Pause or unpause the simulation if the pause/unpause button is pressed
        case PAUSE_UNPAUSE_PRESSED:
            togglePaused();
            break;
        case NEXT_STEP_PRESSED:
            step();
            break;
        case RESET_SIMULATION_PRESSED:
            reset();
            break;
        case CHANGE_VIEWING_MODE_PRESSED:
            cycleRenderMode();
            break;
        case TOGGLE_CLOUDS_PRESSED:
            toggleCloudVisibility();
            break;
        }
    }","Process an EventCode
@param code The EventCode to process",Simulator.java,579.0,3
2,"private void step() {
        // Make sure the step for this stage is being counted
        stageStep++;
        
        switch(stage) {
            // Simulate the habitat if the simulation is in the simulation stage
            case SIMULATION:
                habitat.step();
                break;
            // Generate the flora if the simulation is in the flora generation stage
            case FAUNA_GENERATION:
                HabitatGenerator.generateFauna(habitat);
                setStage(SimulationStage.SIMULATION);
                break;
            // Generate the flora if the simulation is in the flora generation stage
            case FLORA_GENERATION:
                HabitatGenerator.generateFlora(habitat);
                setStage(SimulationStage.FAUNA_GENERATION);
                break;
            // Generate the saturation if the simulation is in the saturation generation stage
            case SATURATION_GENERATION:
                HabitatGenerator.generateSaturations(habitat);
                setStage(SimulationStage.FLORA_GENERATION);
                break;
            // Generate the water if the simulation is in the water generation stage
            case WATER_GENERATION:
                HabitatGenerator.generateWater(habitat);
                setStage(SimulationStage.SATURATION_GENERATION);
                break;
            // Generate the weather if the simulation is in the weather generation stage
            case WEATHER_GENERATION:
                HabitatGenerator.generateWeather(habitat);
                setStage(SimulationStage.WATER_GENERATION);
                break;
            // Generate the elevation if the simulation is in the elevation generation stage
            case ELEVATION_GENERATION:
                HabitatGenerator.generateElevation(habitat);
                setStage(SimulationStage.WEATHER_GENERATION);
                break;
        }
    }","Step the simulation through one step, whatever stage it is in.
If the simulation is ready to move to the next stage, it will",Simulator.java,579.0,3
3,"private void reset() {
        // Reset the habitat
        habitat.reset();
        // Set the stage of the simulation back to terrain generation
        setStage(SimulationStage.ELEVATION_GENERATION);
    }",Reset the habitat.,Simulator.java,579.0,3
4,"private void setStage(SimulationStage stage) {
        this.stage = stage;
        stageStep = 0;
        setPaused(true);
        switch(stage) {
            case ELEVATION_GENERATION:
            case WEATHER_GENERATION:
            case WATER_GENERATION:
            case SATURATION_GENERATION:
            case FLORA_GENERATION:
            case FAUNA_GENERATION:
                window.getControlPanel().setPausable(false);
                break;
            case SIMULATION:
                window.getControlPanel().setPausable(true);
                break;
        }
    }","Set the stage of the simulation
@param stage The SimulationStage to set the simulation to",Simulator.java,579.0,3
5,"private void togglePaused() {
        setPaused(!paused);
    }",Toggle whether the simulation is paused,Simulator.java,579.0,3
6,"private void setPaused(boolean paused) {
        this.paused = paused;
        window.getControlPanel().setPaused(paused);
    }","Set whether or not the simulation is paused
@param paused Whether or not the simulation should be paused",Simulator.java,579.0,3
7,"private void toggleCloudVisibility() {
        HabitatRenderer renderer = window.getHabitatRenderer();
        boolean cloudsVisible = renderer.getCloudVisibility();
        setCloudVisibility(!cloudsVisible);
    }",Toggles whether the clouds in the simulation are visible or not.,Simulator.java,579.0,3
8,"private void setCloudVisibility(boolean visible) {
        window.getHabitatRenderer().setCloudVisibility(visible);
        window.getControlPanel().setCloudVisibility(visible);
    }","Set the visibility of the clouds to be either true (visible) or false (hidden).
@param visible   either true or false",Simulator.java,579.0,3
9,"private void cycleRenderMode() {
        HabitatRenderer renderer = window.getHabitatRenderer();
        RenderMode[] modes = RenderMode.values();
        RenderMode previousMode = renderer.getRenderMode();
        RenderMode nextMode = modes[(previousMode.ordinal()+1)%(modes.length)];
        setRenderMode(nextMode);
    }","Changes the render mode of the simulation to show different views and representations of the habitat.
Cycles from normal to elevation to saturation view, then back to normal.",Simulator.java,579.0,3
10,"private void setRenderMode(RenderMode mode) {
        window.getHabitatRenderer().setRenderMode(mode);
        window.getControlPanel().setViewButtonText(viewNames.get(mode));
    }","Sets the type of mode we wish to represent the habitat with (normal, elevation, saturation).
@param mode      the type of mode we wish to display",Simulator.java,579.0,3
0,"protected void initialiseSpecifics() {
        // Set the creature's current state
        pregnancyCountdown = null;
        wanderDirection = null;
        state = CreatureState.ALIVE;
        activity = CreatureActivity.WANDERING;
        hydration = maxHydration;
        nourishment = maxNourishment;
        bodyEnergy = maxBodyEnergy;
        matingCooldownTimer = matingCooldownPeriod;
        decomposition = 0;
        tiredness = 1;
    }","Initialise the animal. This is the same for all entities, but must be called at the
end of the constructor for the subclass.",Creature.java,579.0,3
1,"public void update(int secondsPassed) {
        // Determine the creature's activities for this tick
        if(state == CreatureState.ALIVE) { // As long as the creature is alive
            incrementNeeds(secondsPassed);
            updatePregnancy(secondsPassed);
            chooseActivity();
            performActivity(secondsPassed);
        } else { // Decompose if the creature is a corpse
            decompose(secondsPassed);
        }
    }","Have this creature perform one step. This means incrementing its needs, and performing
an activity for the step
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
2,"private void incrementNeeds(int secondsPassed) {
        // Reduce the hydration and nourishment for the creature
        hydration -= hydrationLossRate * secondsPassed;
        nourishment -= nourishmentLossRate * secondsPassed;
        
        // Die if food or water runs out.
        if(hydration < 0 || nourishment < 0) setDead();
        
        // Make creature less tired if it is sleeping, otherwise make it more tired
        if(activity == CreatureActivity.SLEEPING) tiredness = Math.max(0, tiredness - secondsPassed/maxSleepTime);
        else {
            tiredness = tiredness = Math.min(1, tiredness + secondsPassed/timeBetweenSleeps);
            matingCooldownTimer = Math.max(0, matingCooldownTimer - secondsPassed);
        }
    }","Increment the needs of this entity- such as nourishment, hydration, and tiredness",Creature.java,579.0,3
3,"private void updatePregnancy(int secondsPassed) {
        // Decrement pregnant countdown and give birth, even if sleeping
        if(pregnancyCountdown != null) {
            pregnancyCountdown -= secondsPassed;
            if(pregnancyCountdown <= 0) {
                activity = CreatureActivity.WANDERING;
                giveBirth();
                pregnancyCountdown = null;
            }
        }
    }","Count down towardspregnancy if this creature is pregnant - giving birth if the
counter reaches 0
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
4,"private void decompose(int secondsPassed) {
        bodyEnergy -= maxBodyEnergy*decompositionRate*secondsPassed;
        decomposition += decompositionRate * secondsPassed;
        if(decomposition > 0.1) state = CreatureState.DECOMPOSED;
        if(bodyEnergy <= 0) selfDestruct();
    }","Decompose this entity - destroying it once fully decomposed
@param secondsPassed The number of seconds since the last step.",Creature.java,579.0,3
5,"private void chooseActivity() {
        // Flee predators if there are any (this overrides all other activities except sleeping)
        Creature predator = lookForPredators();
        if(predator != null && (sleepsWithEyesOpen || activity != CreatureActivity.SLEEPING)) {
            activity = CreatureActivity.FLEEING_PREDATOR;
        // Wake up if sleeping and no longer tired
        } else if(activity == CreatureActivity.SLEEPING) {
            if(tiredness == 0) activity = CreatureActivity.WANDERING;
        // If no important activity is in progress, choose one
        } else if (activity == CreatureActivity.WANDERING || activity == CreatureActivity.LOOKING_FOR_MATE);
            // Fall asleep if tired and it is time to sleep
            if (isSleepTime() && tiredness == 1) {
                activity = CreatureActivity.LOOKING_FOR_SLEEPING_PLACE;
            // Eat if hungry
            } else if (isHungry()) {
                activity = CreatureActivity.LOOKING_FOR_FOOD;
            // Drink if thirsty
            } else if (isThirsty()) {
                activity = CreatureActivity.LOOKING_FOR_WATER;
            // Mate if all needs are met and ready to mate
            } else if (matingCooldownTimer <= 0) {
                activity = CreatureActivity.LOOKING_FOR_MATE;
            }
        }","Choose an activity for this step, based on the current needs of the creature",Creature.java,579.0,3
6,"private void performActivity(int secondsPassed) {
        // Act on the current activity
        switch(activity) {
            case FLEEING_PREDATOR:
                Creature predator = lookForPredators();
                if(predator != null) flee(predator, secondsPassed);
                break;
            
            case LOOKING_FOR_SLEEPING_PLACE:
                Tile sleepingPlace = lookForSleepingPlace();
                if(sleepingPlace != null) {
                    sleepIn(sleepingPlace, secondsPassed);
                } else wander(secondsPassed);
                break;
            
            case LOOKING_FOR_WATER: 
                Tile water = lookForWater();
                if(water != null) {
                    drink(water, secondsPassed);
                } else wander(secondsPassed);
                break;
                
            case LOOKING_FOR_FOOD:
                Entity prey = lookForPrey();
                if(prey != null) {
                    hunt(prey, secondsPassed);
                } else wander(secondsPassed);
                break;
            
            case LOOKING_FOR_MATE:
                Creature potentialMate = lookForMate();
                if(potentialMate != null) {
                    mateWith(potentialMate, secondsPassed);
                } else wander(secondsPassed);
                break;
                
            case WANDERING:
                wander(secondsPassed);
                break;
        }
    }","Perform whatever the current activity this entity is pursuing is
@param secondsPassed The number of seconds since the last step.",Creature.java,579.0,3
7,"private void wander(int secondsPassed) {
        // Pick a new direction if no direction is currently available
        boolean needsNewDirection = (wanderDirection == null);
        // Also pick a new direction if moving in the current direction is unsuccessful
        if(!needsNewDirection) needsNewDirection = !move(wanderDirection, speed*secondsPassed);
        // Also pick a new direction on random chance
        if(!needsNewDirection) needsNewDirection = tile.getHabitat().getRandomiser().nextFloat() < wanderRandomlyChance;
        
        // Pick a new direction if a new direction is needed
        if(needsNewDirection) {
            Tile[] tiles = getEnterableTilesInRange(1);
            if (tiles.length >= 1) {
                int index = tile.getHabitat().getRandomiser().nextInt(tiles.length);
                moveToward(tiles[index], secondsPassed);
            }
        }
    }","Wander. This means walking in a straight line and changing directions occasionally
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
8,"private Creature lookForPredators() {
        Tile[] tiles = getEnterableTilesInRange(sightRange);
        for(Tile tile : tiles) {
            for(Entity entity : tile.getEntities()) {
                if(entity instanceof Creature) {
                    Creature creature = (Creature) entity;
                    if(fleeFromTypes.contains(creature.getType()) && creature.getState() == CreatureState.ALIVE && creature.getActivity() != CreatureActivity.SLEEPING) {
                        return creature;
                    }
                }
            }
        }
        return null;
    }","Look for predators within sight range
@return The nearest predator within sight range",Creature.java,579.0,3
9,"private void flee(Creature predator, int secondsPassed) {
        Tile target = pathFrom(predator);
        moveToward(target, secondsPassed);
    }","Flee a creature
@param predator The creature to flee
@param secondsPassed the number of seconds since the last step",Creature.java,579.0,3
10,"private Tile lookForSleepingPlace() {
        Tile[] tiles = getEnterableTilesInRange(sightRange);
        for(Tile tile : tiles) {
            if(canSleepIn(tile)) return tile;
        }
        return null;
    }","Look for a suitable sleeping place
@return The nearest suitable sleeping place",Creature.java,579.0,3
11,"private void sleepIn(Tile sleepingPlace, int secondsPassed) {
        Tile target = pathTo(sleepingPlace);
        moveToward(target, secondsPassed);
        if(tile == sleepingPlace) {
            activity = CreatureActivity.SLEEPING;
        }
    }","Move to and sleep in a given sleeping place
@param sleepingPlace The tile to sleep in
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
12,"private Tile lookForWater() {
        Tile[] tiles = getEnterableTilesInRange(sightRange);
        for(Tile tile : tiles) {
            if(tile.getWaterLevel() > 0) {
                return tile;
            }
        }
        return null;
    }","Look for water
@return The closest water tile within the sight range of this creature",Creature.java,579.0,3
13,"private void drink(Tile waterLocation, int secondsPassed) {
        Tile target = pathTo(waterLocation);
        moveToward(target, secondsPassed);
        for(Tile tile : tile.getTilesWithinDistance(1)) {
            if(tile == waterLocation) {
                hydration = maxHydration;
                if(!isThirsty()) activity = CreatureActivity.WANDERING;
            }
        }
    }","Move to and drink from a given water tile
@param waterLocation A tile containing water
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
14,"private Entity lookForPrey() {
        Tile[] tiles = getEnterableTilesInRange(sightRange);
        
        double maxEnergy = 0;
        Entity maxEnergyPrey = null;
        
        for(Tile tile : tiles) {
            for(Entity entity : tile.getEntities()) {
                if(preyTypes.contains(entity.getType()) && entity.getBodyEnergy() > maxEnergy) {
                    if(!(entity instanceof Creature && ((Creature) entity).getState() == CreatureState.DECOMPOSED)) {
                        maxEnergy = entity.getBodyEnergy();
                        maxEnergyPrey = entity;
                    }
                }
            }
        }
        return maxEnergyPrey;
    }","Look for prey
@return The entity that this creature can see which has the highest body energy",Creature.java,579.0,3
15,"private void hunt(Entity prey, int secondsPassed) {
        Tile target = pathTo(prey);
        moveToward(target, secondsPassed);
        for(Tile searchTile : tile.getTilesWithinDistance(1)) {
            if(searchTile == prey.getTile()) {
                nourishment += prey.beEaten(maxNourishment - nourishment);
                if(!isHungry()) activity = CreatureActivity.WANDERING;
            }
        }
    }","Move to and eat a given entity
@param prey The animal to hunt
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
16,"private Creature lookForMate() {
        Tile[] tiles = getEnterableTilesInRange(sightRange);
        for(Tile tile : tiles) {
            for(Entity entity : tile.getEntities()) {
                if(entity instanceof Creature) {
                    Creature creature = (Creature) entity;
                    if(getType() == creature.getType() && creature.sex != sex) {
                        return creature;
                    }
                }
            }
        }
        return null;
    }","Look for a mate
@return The closest creature of the same type but a different sex",Creature.java,579.0,3
17,"private void mateWith(Creature potentialMate, int secondsPassed) {
        Tile target = pathTo(potentialMate);
        moveToward(target, secondsPassed);
        if(tile == potentialMate.getTile()) {
            sex(potentialMate);
            potentialMate.sex(this);
            matingCooldownTimer = matingCooldownPeriod;
            activity = CreatureActivity.WANDERING;
        }
    }","Move to and mate with a given creature
@param potentialMate A creature to mate with
@param secondsPassed The number of seconds since the last step",Creature.java,579.0,3
18,"private void sex(Creature mate) {
        if(sex == Sex.FEMALE && mate.sex == Sex.MALE && getType() == mate.getType()) { 
            if(pregnancyCountdown == null) { pregnancyCountdown = pregnancyTime; }
        }
    }",Make self pregnant if mating pair is compatible,Creature.java,579.0,3
19,"private Tile[] getEnterableTilesInRange(int range) {
        List<Tile> tiles = Arrays.asList(tile.getTilesWithinDistance(range));
        return tiles.stream()
            .filter(nextTile -> canEnter(nextTile))
            .toArray(Tile[]::new);
    }","Get all the tiles which can be entered within a given range
@param range The distance (in tiles) to check
@return All tiles which are within the provided distance that this creature can enter",Creature.java,579.0,3
20,"private void moveToward(Tile target, int secondsPassed) {
        int xDif = target.getCol() - tile.getCol();
        int yDif = target.getRow() - tile.getRow();
        if(!(xDif == 0 && yDif == 0)) {
            double direction = Math.atan2(yDif,xDif);
            boolean success = move(direction, speed*secondsPassed);
            if(success) wanderDirection = direction;
            else wanderDirection = null;
        }
    }","Move towards a given tile
@param target The tile to move towards
@param secondsPassed The number of seconds that have passed since the last step",Creature.java,579.0,3
21,"private boolean move(double direction, double distance) {
        int metersPerTile = tile.getHabitat().getMetersPerTile();
        
        double nextX = x + distance*Math.cos(direction);
        double nextY = y + distance*Math.sin(direction);
        
        Tile nextTile = tile.getHabitat().getTile((int)(nextX/metersPerTile),(int)(nextY/metersPerTile));
        if(nextTile != null && canEnter(nextTile)) {
            setTile(nextTile);
            x = nextX; y = nextY;
            return true;
        }
        return false;
    }","Move this creature
@param direction The direction (radians) to move in
@param distance The amount of distance to move by
@return Whether or not the movement was successful",Creature.java,579.0,3
22,"private Tile pathFrom(Entity entityToRunFrom) {
        return pathFrom(entityToRunFrom.getTile());
    }","Get the next tile to move to on the path from a particular entity
@param entityToRunFrom The entity to path away from
@return The next tile on the journey away from that creature",Creature.java,579.0,3
23,"private Tile pathTo(Entity entityToRunTo) {
        return pathTo(entityToRunTo.getTile());
    }","Get the next tile to move to on the path to a particular entity
@param entityToRunFrom The entity to path away from
@return The next tile on the journey away from that creature",Creature.java,579.0,3
24,"private Tile pathFrom(Tile tileToRunFrom) {
        int runFromCol = tileToRunFrom.getCol();
        int runFromRow = tileToRunFrom.getRow();
        
        Tile furthestTile = null;
        float furthestDistance = 0;
        for(Tile searchTile : tile.getTilesWithinDistance(1)) {
            if(canEnter(searchTile)) {
                int xDistance = searchTile.getCol() - runFromCol;
                int yDistance = searchTile.getRow() - runFromRow;
                float distance = (float) Math.pow(Math.pow(xDistance, 2) + Math.pow(yDistance, 2), 0.5);
                if(furthestTile == null || distance > furthestDistance) {
                    furthestTile = searchTile;
                    furthestDistance = distance;
                }
            }
        }
        return furthestTile;
    }","Get the next tile to move to on the path from a particular tile
@param tileToRunFrom The tile to path away from
@return The next tile on the journey away from that tile",Creature.java,579.0,3
25,"private Tile pathTo(Tile tileToRunTo) {
        int runToCol = tileToRunTo.getCol();
        int runToRow = tileToRunTo.getRow();
        
        Tile closestTile = null;
        double closestDistance = 0;
        for(Tile searchTile : tile.getTilesWithinDistance(1)) {
            if(canEnter(searchTile)) {
                int xDistance = searchTile.getCol() - runToCol;
                int yDistance = searchTile.getRow() - runToRow;
                double distance = Math.pow(Math.pow(xDistance, 2) + Math.pow(yDistance, 2), 0.5);
                if(closestTile == null || distance < closestDistance) {
                    closestTile = searchTile;
                    closestDistance = distance;
                }
            }
        }
        return closestTile;
    }","Get the next tile to move to on the path to a particular tile
@param tileToRunFrom The tile to path towards
@return The next tile on the journey away from that tile",Creature.java,579.0,3
26,"private boolean isHungry() {
        return nourishment/maxNourishment < 0.7;
    }",@return Whether this creature is hungry,Creature.java,579.0,3
27,"private boolean isThirsty() {
        return hydration/maxHydration < 0.7;
    }",@return Whether this creature is thirsty,Creature.java,579.0,3
28,"private boolean canEnter(Tile checkTile) {
        return ((minWaterLevel == null || checkTile.getWaterLevel() > minWaterLevel) && (maxWaterLevel == null || checkTile.getWaterLevel() <= maxWaterLevel));
    }","Check if this creature can enter a given tile
@param checkTile The tile to check
@return Whether this creature can enter that tile",Creature.java,579.0,3
29,"protected void setDead() {
        state = CreatureState.DEAD;
        activity = null;
        bodyEnergy += nourishment;
        nourishment = 0;
    }",Set the creature as dead. It will begin to decompose.,Creature.java,579.0,3
0,"protected void selfDestruct() {
        tile.removeEntity(this);
    }",Destroy this entity - removing it from the habitat,Entity.java,579.0,3
1,"public double beEaten(double max) {
        if(this instanceof Creature) { ((Creature)this).setDead(); }
        double caloriesEaten = Math.min(bodyEnergy,max);
        bodyEnergy -= caloriesEaten;
        return caloriesEaten;
    }","Reduce the energy of this entity, and return the amount of energy that was reduced.
Also kill this entity if it is a creature.
@param max The maximum amount of energy to take
@return The amount of energy that the creature lost.",Entity.java,579.0,3
2,"public Tile getTile() {
        return tile;
    }",@return the tile that this entity is in,Entity.java,579.0,3
3,"protected void setTile(Tile nextTile)
    {
        if(tile != null) tile.removeEntity(this);
        nextTile.addEntity(this);
        tile = nextTile;
    }","Move from one tile to another.
@param tile The next tile to move to.",Entity.java,579.0,3
4,"public EntityType getType() {
        return type;
    }",@return The type of this entity,Entity.java,579.0,3
5,"public double getBodyEnergy() {
        return bodyEnergy;
    }","Get the amount of body energy for this entity. For plants, this may mean the amount
of energy in their fruit. For creatures, this may mean the amount of energy in their
flesh (that is, the amount that they cannot access themselves).
@return The amount of body energy for this entity",Entity.java,579.0,3
6,"public double getMaxBodyEnergy() {
        return maxBodyEnergy;
    }",@return the maximum body energy for this entity,Entity.java,579.0,3
0,"public void act(List<Animal> newBears, boolean isDayTime, String weather)
    {
        if(isDayTime && !weather.equals(""cold"")) {

            incrementAge();
            incrementHunger();
            if(isAlive()) {
                giveBirth(newBears);     

                // Move towards a source of food if found.
                Location newLocation = findFood();

                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());

                    // If adjacent locations are not free
                    if(newLocation == null){    
                        // Check if the bear can step on a plant.
                        newLocation = getField().freePlantAdjacentLocation(getLocation());

                        if(newLocation != null){

                            ((Plant)getField().getObjectAt(newLocation)).setDead();

                        }
                    }
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                    checkHealth();      // then check the health condition, dead or not
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the bear does most of the time: it hunts for
deer and chicken. In the process, it might breed, die of hunger,
or die of old age.
Bears only move during day time.
Bear does not move when it is cold.

@param newBears A list to return newly born bears.
@param isDayTime A boolean which tells whether the current time is day or night.
@param weather A String to denote the weather.",Bear.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the bear's death.,Bear.java,145.0,3
2,"public int getAge()
    {
        return age;
    }","Returns the age of the bear.

@return The age of the bear.",Bear.java,145.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Make this bear more hungry.
This could result in the bear's death.",Bear.java,145.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        while(it.hasNext() && foodLevel <= 10) {
            Location where = it.next();
            Object object = field.getObjectAt(where);

            if(object instanceof Chicken && foodLevel < 7 && rand.nextDouble() < 0.9) { // chicken has 10% of chance to escape
                Chicken chicken = (Chicken) object;
                if(chicken.isAlive()) { 
                    if(chicken.isInfected()) {
                        decreaseHealth();
                    }
                    chicken.setDead();
                    foodLevel += CHICKEN_FOOD_VALUE;
                    return where;
                }
            }

            else if(object instanceof Deer && rand.nextDouble() < 0.4) {    // deer has 60% of chance to escape
                Deer deer = (Deer) object;
                if(deer.isAlive()){
                    if(deer.isInfected()) {
                        decreaseHealth();
                    }
                    deer.setDead();
                    foodLevel += DEER_FOOD_VALUE;
                    return where;
                }
            }

            else if(object instanceof Berry && foodLevel <= 3){ // bear's healthLevel will not directly infected by berries
                Berry berry = (Berry) object;
                if(berry.isAlive()){ 
                    berry.setDead();
                    foodLevel += BERRY_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for deer and chicken adjacent to the current location.
Only the first live animal is eaten.

@return Where food was found, or null if it wasn't.",Bear.java,145.0,3
5,"private void giveBirth(List<Animal> newBears)
    {
        // New beares are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = super.breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Bear young = new Bear(false, field, loc);
            newBears.add(young);
        }
    }","Check whether or not this bear is to give birth at this step.
New births will be made into free adjacent locations.

@param newBears A list to return newly born bears.",Bear.java,145.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Returns the probability of a bear to breed.

@return the probability of a bear to breed.",Bear.java,145.0,3
7,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the max litter size of a bear.

@return the max litter size of a bear.",Bear.java,145.0,3
8,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Returns the age at which a bear starts to breed.

@return the age at which a bear starts to breed.",Bear.java,145.0,3
9,"protected void checkHealth()
    {
        if(getHealth() < 8){
            setInfected();
            if(getHealth() <= 0){
                setDead();
            }
        }
    }","To check whether the animal is in good health.
If the health level is less than 8, means it
will get infected.
If the health level is less than or equal to 0
then the animal is in no condition to survive.
Therefore it is set dead.",Bear.java,145.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,145.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,145.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,145.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,145.0,3
0,"public void act(List<Animal> newWeasels, boolean isDayTime, String weather)
    {
        if(!isDayTime) {
            incrementAge();
            incrementHunger();

            if(isAlive()) {
                giveBirth(newWeasels); 
                // If the weather is sunny the weasels reproduce twice.
                if(weather.equals(""sunny"")) {
                    giveBirth(newWeasels); 
                }

                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());

                    // if adjacent locations are not free
                    if(newLocation == null){    
                        // Check if the weasel can step on a plant.
                        newLocation = getField().freePlantAdjacentLocation(getLocation());
                        if(newLocation != null){

                            ((Plant)getField().getObjectAt(newLocation)).setDead();
                        }
                    }
                }

                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                    checkHealth();      // then check the health condition, dead or not
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the weasel does most of the time: it hunts for
prey. In the process, it might breed, die of hunger,
or die of old age.
Weasel are only moving at night time

@param newWeasels A list to return newly born weasels.
@param isDayTime A boolean which tells whether the current time is day or night.
@param weather A String to denote the weather.",Weasel.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the weasel's death.",Weasel.java,145.0,3
2,"public int getAge()
    {
        return age;
    }","Returns the age of the weasel.

@return int  The age of the weasel.",Weasel.java,145.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Make this weasel more hungry.
This could result in the weasel's death.",Weasel.java,145.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        
        while(it.hasNext() && foodLevel <= 10) {
            Location where = it.next();
            Object food = field.getObjectAt(where);
            
            if(food instanceof Chicken && Math.random() < 0.75) {
                Chicken chicken = (Chicken) food;
                if(chicken.isAlive()){
                    if(chicken.isInfected()){
                        decreaseHealth();
                    }
                    chicken.setDead();
                    foodLevel += CHICKEN_FOOD_VALUE;
                    return where;
                }
            }
            
            // Eating infected berry is not going to affect the weasel's health.
            else if(food instanceof Berry && foodLevel <= 3) {
                Berry berry = (Berry) food;
                if(berry.isAlive()){
                    berry.setDead();
                    foodLevel += BERRY_FOOD_VALUE;
                    return where;
                }

            }
        }
        return null;
    }","Look for food adjacent to the current location.
Only the first live animal is eaten.

@return Location     Where food was found, or null if it wasn't.",Weasel.java,145.0,3
5,"private void giveBirth(List<Animal> newWeasels)
    {
        // New weaseles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = super.breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Weasel young = new Weasel(false, field, loc);
            newWeasels.add(young);
        }
    }","Check whether or not this weasel is to give birth at this step.
New births will be made into free adjacent locations.

@param newWeasels A list to return newly born weaseles.",Weasel.java,145.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Returns the probability of a weasel to breed.

@return double   the probability of a weasel to breed.",Weasel.java,145.0,3
7,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the max litter weasel of a deer.

@return int  the max litter weasel of a deer.",Weasel.java,145.0,3
8,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Returns the age at which a weasel starts to breed.

@return int  the age at which a weasel starts to breed.",Weasel.java,145.0,3
9,"protected void checkHealth()
    {
        if(getHealth() < 2){
            setInfected();
            if(getHealth() <= 0){
                setDead();
            }
        }
    }","To check whether the animal is in good health.
If the health level is less than 8, means it
will get infected.
If the health level is less than or equal to 0
then the animal is in no condition to survive.
Therefore it is set dead.",Weasel.java,145.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.

@return A random object.",Randomizer.java,145.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,145.0,3
0,"public void populate(Field field, List<Animal> animals, List<Plant> plants, List<Hunter> hunters)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        int hunterCount = 0;
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= DEER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Deer deer = new Deer(true, field, location);
                    animals.add(deer);
                }
                else if(rand.nextDouble() <= CHICKEN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Chicken chicken = new Chicken(true, field, location);
                    animals.add(chicken);
                }
                else if(rand.nextDouble() <= WEASEL_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Weasel weasel = new Weasel(true, field, location);
                    animals.add(weasel);
                }
                else if(rand.nextDouble() <= TIGER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tiger tiger = new Tiger(true, field, location);
                    animals.add(tiger);
                }
                else if(rand.nextDouble() <= BEAR_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Bear bear = new Bear(true, field, location);
                    animals.add(bear);
                }
                else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    plants.add(grass);
                }
                else if(rand.nextDouble() <= BERRY_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Berry berry = new Berry(true, field, location);
                    plants.add(berry);
                }else if(rand.nextDouble() <= HUNTER_CREATION_PROBABILITY && hunterCount < 4) {
                    Location location = new Location(row, col);
                    Hunter hunter = new Hunter(field, location);
                    hunters.add(hunter);
                    hunterCount ++;
                }
                // else leave the location empty.
            }
        }
        
        // to make sure there is at least one hunter in the simulation.
        // manually insert a hunter if no hunter created yet.
        if(hunterCount == 0) {
            Hunter hunter = new Hunter(field, new Location(0,0));
            hunters.add(hunter);
        }  
    }","Randomly populates the field with actors.
Actors: Chicken, deer, weasel, tiger, bear, grass, berry, hunter.

@param field     The simulation's field.
@param animals   The animals generated in the simulation.
@param plants    The plants generated in the simulation.
@param hunters   The hunters generated in the simulation.",PopulationGenerator.java,145.0,3
0,"protected void setIsInfected(boolean infected)
    {
        isInfected = infected;
    }","Set the plant as infected or not infected.

@param infected  A boolean that shows if plant is infected.",Plant.java,145.0,3
1,"public boolean isInfected()
    { 
        return isInfected;        
    }","Returns whether the plant is infected or not.

@return boolean  The infection state of the plant.",Plant.java,145.0,3
2,"public boolean checkSuitableWeather(String currentWeather)
    {
        if( currentWeather.equals(getSuitableWeather())) {
            return true;
        }             
        return false;
    }","Checks if the weather is suitable for a plant
to carry out weather specific beahaviour.

@param currentWeather    A string for the current weather in the simulation.
@return boolean          Whether the weather is suitable or not.",Plant.java,145.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,145.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,145.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,145.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,145.0,3
0,"public void act(List<Animal> newDeers, boolean isDayTime, String weather)
    {
        if(isDayTime){
            incrementAge();
            incrementHunger();
            if(isAlive()) {
                if(!weather.equals(""rainy"") || !weather.equals(""foggy"")){
                    giveBirth(newDeers);
                }
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.                 
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // If adjacent locations are not free
                if(newLocation == null){    
                    // Check if can step on a plant near by
                    newLocation = getField().freePlantAdjacentLocation(getLocation());
                    if(newLocation != null){
                        ((Plant)getField().getObjectAt(newLocation)).setDead();
                    }
                }
                
                // check what will the animal do, if have a new location, move. 
                // if not, setDead() because of overcrowd
                if(newLocation != null) {
                    setLocation(newLocation);
                    checkHealth();      // Check the state of health.
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the deer does most of the time - it runs
around. Sometimes it will breed or die of old age.
Deers only move during day time.

@param newDeers A list to return newly born deers.
@param isDayTime A boolean which tells whether the current time is day or night.
@param weather A String to denote the weather.",Deer.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the deer's death.",Deer.java,145.0,3
2,"public int getAge()
    {
        return age;
    }","Returns the age of the deer.

@return The age of the deer.",Deer.java,145.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Make this deer more hungry.
This could result in the deer's death.",Deer.java,145.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        while(it.hasNext() && foodLevel <= 11) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);

            if(plant instanceof Grass) {
                Grass grass = (Grass) plant;
                if(grass.isAlive()) { 
                    if(grass.isInfected()){
                        this.decreaseHealth();
                    }
                    grass.setDead();
                    foodLevel += GRASS_FOOD_VALUE;
                    return where;
                }
            }
            else if(plant instanceof Berry) {
                Berry berry = (Berry) plant;
                if(berry.isAlive()){
                    if(berry.isInfected()){
                        decreaseHealth();
                    }
                    berry.setDead();
                    foodLevel += BERRY_FOOD_VALUE;
                    return where;
                }                
            }
        }
        return null;
    }","Look for grass and berries adjacent to the current location.
Only the first live plant is eaten

@return Where food was found, or null if it wasn't.",Deer.java,145.0,3
5,"private boolean checkGender()
    {
        Field field = getField();
        List<Location> occupied = field.getOccupiedAdjacentLocations(getLocation(), this);
        for(Location next : occupied){
            if(this.getGender() != ((Animal)field.getObjectAt(next)).getGender()){
                return true;
            }
        }
        return false;
    }","Check if the animal is of opposite gender.

@return True if have different gender, so it's able to breed
false if not",Deer.java,145.0,3
6,"private void giveBirth(List<Animal> newDeers)
    {
        // New deers are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        if(checkGender()){
            int births = super.breed();
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Deer young = new Deer(false, field, loc);
                newDeers.add(young);
            }
        }
    }","Check whether or not this deer is to give birth at this step.
New births will be made into free adjacent locations.

@param newDeers A list to return newly born deers.",Deer.java,145.0,3
7,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Returns the probability of a deer to breed.

@return double   The probability of a deer to breed.",Deer.java,145.0,3
8,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the max litter size of a deer.

@return int  The max litter size of a deer.",Deer.java,145.0,3
9,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Returns the age at which a deer starts to breed.

@return int  The age at which a deer starts to breed.",Deer.java,145.0,3
10,"protected void checkHealth()
    {
        if(getHealth() < 6){
            setInfected();
            if(getHealth() <= 0){
                setDead();
            }
        }
    }","To check whether the animal is in good health.
If the health level is less than 6, means it
will get infected.
If the health level is less than or equal to 0
then the animal is in no condition to survive.
Therefore it is set dead.",Deer.java,145.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.

@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,145.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,145.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,145.0,3
3,"public void showStatus(int step, Field field, String weather)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        // the current step, and the daytime
        stepLabel.setText(STEP_PREFIX + step + "" / "" + dayOrNight(step) + "" / "" + weather);   
        stats.reset();

        fieldView.preparePaint();

        //decide if the empty color is white or black according to the daytime
        Color EMPTY_COLOR;
        if(dayOrNight(step).equals("" DAY"")){    // if is day, backgroud color is white
            EMPTY_COLOR = EMPTY_COLOR_DAY;
        }
        else {  // if night, background color is black
            EMPTY_COLOR = EMPTY_COLOR_NIGHT;
        }
        
        // set the color accordingly
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));

        fieldView.repaint();
    }","Show the current status of the field.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,145.0,3
4,"public String dayOrNight(int steps)
    {
        if((steps / 25) % 2 == 1){
            return "" DAY"";
        }
        return ""NIGHT"";
    }","Determine whether the time is day or night.

@return String ""DAY"" or ""NIGHT"" accordingly.",SimulatorView.java,145.0,3
5,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.

@return true If there is more than one species alive.",SimulatorView.java,145.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,145.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.

@param numSteps The number of steps to run for.",Simulator.java,145.0,3
2,"public void simulateOneStep()
    {
        step++;
        updateDayTime();
        updateCurrentWeather();

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>(); 

        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals, isDayTime, currentWeather);
            if(! animal.isAlive()) {
                it.remove();
            }
        }

        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);

        // Provide space for newly produced plants.
        List<Plant> newPlants = new ArrayList<>();
        // Let all plants act.
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.act(newPlants, isDayTime, currentWeather);
            if(! plant.isAlive()) {
                it.remove();
            }
        }

        // Add the newly produced plants to the main lists.
        plants.addAll(newPlants);

        // Let all hunters act.
        for(Iterator<Hunter> it = hunters.iterator(); it.hasNext(); ) {
            Hunter hunter = it.next();
            hunter.act(currentWeather, step);            
        }

        view.showStatus(step, field, currentWeather);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal, plant, hunter, daytime and weather.",Simulator.java,145.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();    // reset the animals on the field.
        plants.clear();     // reset the plants on the field.
        hunters.clear();    // reset the hunters on the field.
        updateDayTime();    // reset the daytime.
        updateCurrentWeather();    // reset the weather.

        populationGenerator.populate(field, animals, plants, hunters);

        // Show the starting state in the view.
        view.showStatus(step, field, currentWeather);
    }",Reset the simulation to a starting position.,Simulator.java,145.0,3
4,"private void updateDayTime()
    {
        isDayTime = ((step / 25) % 2 == 1);
    }","Update the time of the day.
Updates according to the number of steps encountered.
Day and night is updated every 25 steps.",Simulator.java,145.0,3
5,"private void updateCurrentWeather()
    {
        if(step % 25 == 0) {
            // Weather changes randomly during the day and night.
            currentWeather = WEATHER_ARRAY[(int)(Math.random()*WEATHER_ARRAY.length)];
        }
    }","Updates the current weather to a random weather.
It's being updated every 25 days.",Simulator.java,145.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.

@param millisec  The time to pause for, in milliseconds",Simulator.java,145.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the actor is alive or not.

@return Returns true if the actor is alive.",Actor.java,145.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicates that the actor is no longer alive.
It is removed from the field.",Actor.java,145.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the actor's location.

@return The actor's location.",Actor.java,145.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the actor at the new location in the given field.

@param newLocation   The actor's new location.",Actor.java,145.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the actor's field.

@return The actor's field.",Actor.java,145.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,145.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,145.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,145.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,145.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,145.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,145.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,145.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column

@return A string representation of the location.",Location.java,145.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.

@return A hashcode for the location.",Location.java,145.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,145.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,145.0,3
0,"public void act(List<Plant> newBerries, boolean isDayTime, String currentWeather)
    {
        if(isDayTime){  // berries are only moving at day time
            incrementAge();
            if(isAlive()) {
                produceSeeds(newBerries, currentWeather);   
            }
        }
    }","This is what the berries do most of the time - it spreads
around. Sometimes it will spread or die of old age.
Berries spread around during day time.

@param newBerries  A list to return newly born berries.
@param isDayTime A boolean which tells whether the current time is day or night.
@param currentWeather A String to denote the current weather.",Berry.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the berry's death.",Berry.java,145.0,3
2,"private void produceSeeds(List<Plant> newBerries, String currentWeather)
    {
        // New berries are produced into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        if(Math.random() < 0.5){    // the berry have 50% of chance to produce seeds
            int seeds = spread();
            if(super.checkSuitableWeather(currentWeather)) {    // if is suitableWeather, double the seed num
                seeds *= 2;
            }

            for(int b = 0; b < seeds && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Berry young = new Berry(false, field, loc);
                newBerries.add(young);
            }
        }
    }","Check whether or not this berry is to produce seeds at this step.
New productions will be made into free adjacent locations.

@param newBerries    A list to return newly born berries.
@param currentWeather A String to denote the current weather.",Berry.java,145.0,3
3,"private int spread()
    {
        int seeds = 0;
        if(canSpread() && rand.nextDouble() <= SPREADING_PROBABILITY) {
            seeds = rand.nextInt(MAX_SEED_NUM) + 1;
        }
        return seeds;
    }","Generate a number representing the number of seeds,
if it can spread.

@return int  The number of rhizomes(may be zero).",Berry.java,145.0,3
4,"private boolean canSpread()
    {
        return age >= SPREADING_AGE;
    }","A berry can spread if it has reached its spreading age.

@return boolean  True if the berry can spread, false otherwise.",Berry.java,145.0,3
5,"public String getSuitableWeather()
    {
        return SUITABLE_WEATHER;
    }","Returns the suitable weather for the growth.

@return String   The suitable weather for growth.",Berry.java,145.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,145.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,145.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,145.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,145.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,145.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,145.0,3
0,"public void act(List<Animal> newChickens, boolean isDayTime, String weather)
    {
        if(!isDayTime) {
            incrementAge();
            incrementHunger();
            if(isAlive()) {
                giveBirth(newChickens);
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // If adjacent locations are not free
                if(newLocation == null) {    
                    // Check if can step on a plant.
                    newLocation = getField().freePlantAdjacentLocation(getLocation());
                    if(newLocation != null) {
                        
                        ((Plant)getField().getObjectAt(newLocation)).setDead();
                        
                    }
                }
                
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                    checkHealth();      // then check the health condition, dead or not
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }

    }","This is what the chicken does most of the time - it runs
around and hunts for prey. Sometimes it will breed or die of old age or die of hunger.
Chickens move at night time

@param newChickens A list to return newly born chickens.
@param isDayTime A boolean which tells whether the current time is day or night.
@param weather A String to denote the weather.",Chicken.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the chicken's death.",Chicken.java,145.0,3
2,"public int getAge()
    {
        return age;
    }","Returns the age of the chicken.

@return int  The age of the chicken.",Chicken.java,145.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Make this chicken more hungry.
This could result in the chicken's death.",Chicken.java,145.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        
        while(it.hasNext() && foodLevel <= 10) {    
            Location where = it.next();
            Object plant = field.getObjectAt(where);

            // check if the plant is the food supply for chicken
            if(plant instanceof Grass){
                Grass grass = (Grass) plant;
                if(grass.isAlive()){
                    if(grass.isInfected()){
                        decreaseHealth();
                    }
                    grass.setDead();
                    foodLevel += GRASS_FOOD_VALUE;
                    return where;
                }
            }
            else if(plant instanceof Berry && foodLevel < 4){
                Berry berry = (Berry) plant;
                if(berry.isAlive()){
                    if(berry.isInfected()){
                        decreaseHealth();
                    }
                    berry.setDead();
                    foodLevel += BERRY_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for grass or berries adjacent to the current location.
Only the first live food source for chicken is eaten.

@return Location     Where food was found, or null if it wasn't.",Chicken.java,145.0,3
5,"private void giveBirth(List<Animal> newChickens)
    {
        // New chickens are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());

        // check if the animal meets the condition for breeding
        if(checkGender()){
            int births = super.breed();
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Chicken young = new Chicken(false, field, loc);
                newChickens.add(young);
            }
        }
    }","Check whether or not this chicken is to give birth at this step.
New births will be made into free adjacent locations.

@param newChickens A list to return newly born chickens.",Chicken.java,145.0,3
6,"private boolean checkGender()
    {
        Field field = getField();
        List<Location> occupied = field.getOccupiedAdjacentLocations(getLocation(), this);
        for(Location next : occupied){
            if(this.getGender() != ((Animal)field.getObjectAt(next)).getGender()){
                return true;
            }
        }
        return false;
    }","Check if the animal is of opposite gender

@return boolean   True if have different gender, so it's able to breed
false if not",Chicken.java,145.0,3
7,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Returns the probability of a chicken to breed.

@return double   The probability of a chicken to breed.",Chicken.java,145.0,3
8,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the max litter size of a chicken.

@return int  The max litter size of a chicken.",Chicken.java,145.0,3
9,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Returns the age at which a chicken starts to breed.

@return int  The age at which a chicken starts to breed.",Chicken.java,145.0,3
10,"protected void checkHealth()
    {
        if(getHealth() < 3){
            setInfected();
            if(getHealth() <= 0){
                setDead();
            }
        }
    }","To check whether the animal is in good health.
If the health level is less than 5, means it
will get infected.
If the health level is less than or equal to 0
then the animal is in no condition to survive.
Therefore it is set dead.",Chicken.java,145.0,3
0,"public void act(String currentWeather, int steps)
    {
        if(canHunt()){  //which means if they reach the limit, hunters are not moving untill the next reset
            //The hunter does not hunt if the weather is rainy or foggy.
            if(!currentWeather.equals(""rainy"") || !currentWeather.equals(""foggy"")) {
                // Move towards an animal if found.
                Location newLocation = hunt(steps);

                if(newLocation == null) { 
                    // No animal found - try to move to a free location.                 
                    newLocation = getField().freeAdjacentLocation(getLocation());

                    // hunters are mean, so if adjacent location are not free, he will try to step on the plants
                    if(newLocation == null){    
                        // Check if the bear can step on a plant.
                        newLocation = getField().freePlantAdjacentLocation(getLocation());

                        if(newLocation != null){
                            ((Plant)getField().getObjectAt(newLocation)).setDead();
                        }
                    }
                }

                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else{
                    // do nothing, and stay where they are
                }
            }
        }
        checkIfResetCurrentHunt(steps);
    }","The hunter spends most of his time hunting down animals.
If the hunter cannot hunt an animal directly it moves around
until it finds its prey.
The hunter is unable to hunt if the weather is rainy or foggy.

@param currentWeather    The current weather in the simulation.
@param steps             The current step in the simulator",Hunter.java,145.0,3
1,"private void checkIfResetCurrentHunt(int steps)
    {
        if(currentHunts == HUNTING_LIMIT && steps % 100 == 0)
        {
            currentHunts = 0;
            System.out.println(""Hunt level reset."");
        }
    }","Checks if the hunter has exceeded the hunting limit when the current step is multiple of 100
(which means check each 2 days and 2 nights, if reaches the max, reset)
Resets the current hunts if meets the condition.",Hunter.java,145.0,3
2,"private Location hunt(int steps)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object actor = field.getObjectAt(where);
            if(actor instanceof Animal) {
                Animal animal = (Animal) actor;
                if(animal.isAlive()){
                    animal.setDead();
                    currentHunts ++;
                    System.out.println(""Hunter killed "" + animal.getClass().getName() + "". Now the hunt level is "" + currentHunts + ""/15."");
                    return where;
                }
            }
        }
        return null;
    }","Looks for animals to hunt.
Only the first live animal is hunted.

@param steps The current steps on the simulator
@return Where prey was found, or null if it wasn't.",Hunter.java,145.0,3
3,"private boolean canHunt()
    {
        return currentHunts < HUNTING_LIMIT;
    }","Returns whether the hunter can still hunt animals.
True if the hunter has not exceeded the hunting limit,
else false.

@return Returns whether the hunter can hunt.",Hunter.java,145.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,145.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.

@param location The location to clear.",Field.java,145.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.

@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,145.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.

@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,145.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.

@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,145.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.

@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,145.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.

@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,145.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.

@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,145.0,3
8,"public List<Location> getOccupiedAdjacentLocations(Location location, Object animalType)
    {
        List<Location> occupied = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) != null) {
                //check if the two animals are from the same class
                if( getObjectAt(next).getClass().equals(animalType.getClass())) {
                    occupied.add(next);
                }
            }
        }
        return occupied;
    }","Get a shuffled list of the occupied adjacent locations.

@param location Get locations adjacent to this.
@param the aninal type
@return A list of occupied adjacent locations.",Field.java,145.0,3
9,"public List<Location> getPlantAdjacentLocations(Location location)
    {
        List<Location> plants = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) != null) {
                //check if the two animals are from the same class
                if( getObjectAt(next) instanceof Plant) {
                    plants.add(next);
                }
            }
        }
        return plants;
    }","Get a shuffled list of the plants adjacent locations.

@param location  Get locations adjacent to this.
@return A list of plant adjacent locations.",Field.java,145.0,3
10,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.

@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,145.0,3
11,"public Location freePlantAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> plant = getPlantAdjacentLocations(location);
        if(plant.size() > 0) {
            return plant.get(0);
        }
        else {
            return null;
        }
    }","Try to find a location is occupid by a plant and adjacent to
the given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.

@param location  The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,145.0,3
12,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.

@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,145.0,3
13,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field
.
@return The depth of the field.",Field.java,145.0,3
14,"public int getWidth()
    {
        return width;
    }","Return the width of the field.

@return The width of the field.",Field.java,145.0,3
0,"public void act(List<Plant> newGrass, boolean isDayTime, String currentWeather)
    {
        if(!isDayTime){     // only going to do things during night
            incrementAge();
            if(isAlive()) {
                produceRhizomes(newGrass, currentWeather);  
            }
        }
    }","This is what the grass does most of the time - it spreads
around. Sometimes it will spread or die of old age.
Grass is only going to spread during night time.

@param newGrass  A list to return newly born grass.
@param isDayTime A boolean which tells whether the current time is day or night.
@param currentWeather A String to denote the current weather.",Grass.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the grass' death.",Grass.java,145.0,3
2,"private void produceRhizomes(List<Plant> newGrass, String currentWeather)
    {
        // New grass is produced into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        if(Math.random() < 0.5){    // the grass has 50% of chance to produce Rhizomes
            int rhizomes = spread();
            if(super.checkSuitableWeather(currentWeather)) {    // if is suitableWeather, double the rhizomes num
                rhizomes *= 2;
            }
            for(int b = 0; b < rhizomes && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Grass young = new Grass(false, field, loc);
                newGrass.add(young);
            }
        }
    }","Check whether or not this grass is to produce rhizomes at this step.
New productions will be made into free adjacent locations.

@param newGrass A list to return newly born grass.",Grass.java,145.0,3
3,"private int spread()
    {
        int births = 0;
        if(canSpread() && rand.nextDouble() <= SPREADING_PROBABILITY) {
            births = rand.nextInt(MAX_RHIZOME_NUM) + 1;
        }
        return births;
    }","Generate a number representing the number of rhizomes,
if the grass can spread.

@return int  The number of rhizomes(may be zero).",Grass.java,145.0,3
4,"private boolean canSpread()
    {
        return age >= SPREADING_AGE;
    }","Grass can spread if it has reached its spreading age.

@return boolean  true if the grass can spread, false otherwise.",Grass.java,145.0,3
5,"public String getSuitableWeather()
    {
        return SUITABLE_WEATHER;
    }","Returns the suitable weather for growth.

@return String   the suitable weather for growth.",Grass.java,145.0,3
0,"public void act(List<Animal> newTigers, boolean isDayTime, String weather)
    {
        if(isDayTime) {
            incrementAge();
            // foggy days tiger don't want to eat, so the hunger won't decrease
            if(!weather.equals(""foggy"")) {
                incrementHunger();
            }   

            if(isAlive()) {
                giveBirth(newTigers);            
                // Move towards a source of food if found.
                Location newLocation = findFood();

                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                     // if adjacent locations are not free
                    if(newLocation == null){    
                        // Check if the weasel can step on a plant.
                        newLocation = getField().freePlantAdjacentLocation(getLocation());
                        if(newLocation != null){
                            ((Plant)getField().getObjectAt(newLocation)).setDead();
                        }
                    }
                }

                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);   // Move to the new location.
                    checkHealth();      // Check state of health.
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the tiger does most of the time: it hunts for
prey. In the process, it might breed, die of hunger,
or die of old age.
Tigers only move during day time

@param newTigers A list to return newly born tigeres.
@param isDayTime A boolean which tells whether the current time is day or night
@param weather A String to keep track of the weather.",Tiger.java,145.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the tiger's death.",Tiger.java,145.0,3
2,"public int getAge()
    {
        return age;
    }","Returns the age of the tiger.

@return The age of the tiger.",Tiger.java,145.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Make this tiger more hungry.
This could result in the tiger's death.",Tiger.java,145.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        while(it.hasNext() && foodLevel <= 12) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);

            // Check if the animal is the food supply for tiger.
            if(animal instanceof Deer && rand.nextDouble() < 0.8){     // deer has 20% of chance to escape
                Deer deer = (Deer) animal;
                if(deer.isAlive()){
                    if(deer.isInfected()){
                        decreaseHealth();
                    }
                    deer.setDead();
                    foodLevel += DEER_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Bear && rand.nextDouble() < 0.7){     // bear has 30% of chance to escape
                Bear bear = (Bear) animal;
                if(bear.isAlive()){
                    if(bear.isInfected()){
                        decreaseHealth();
                    }
                    bear.setDead();
                    foodLevel += BEAR_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Weasel && foodLevel <= 4) {   // tigers are only going to eat weasel when foodLevel is under 4
                Weasel weasel = (Weasel) animal;
                if(weasel.isAlive()) { 
                    if(weasel.isInfected()){
                        decreaseHealth();
                    }
                    weasel.setDead();
                    foodLevel += WEASEL_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for deer, bears or chicken adjacent to the current location.
Only the first live food source for tiger is eaten.

@return Where food was found, or null if it wasn't.",Tiger.java,145.0,3
5,"private void giveBirth(List<Animal> newTigers)
    {
        // New tigers are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = super.breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Tiger young = new Tiger(false, field, loc);
            newTigers.add(young);
        }
    }","Check whether or not this tiger is to give birth at this step.
New births will be made into free adjacent locations.

@param newTigers A list to return newly born tigeres.",Tiger.java,145.0,3
6,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Returns the probability of a tiger to breed.

@return the probability of a tiger to breed.",Tiger.java,145.0,3
7,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the max litter size of a tiger.

@return the max litter size of a tiger.",Tiger.java,145.0,3
8,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Returns the age at which a tiger starts to breed.

@return the age at which a tiger starts to breed.",Tiger.java,145.0,3
9,"protected void checkHealth()
    {
        if(getHealth() < 8){
            setInfected();
            if(getHealth() <= 0){
                setDead();
            }
        }
    }","To check whether the animal is in good health.
If the health level is less than 8, means it
will get infected.
If the health level is less than or equal to 0
then the animal is in no condition to survive.
Therefore it is set dead.",Tiger.java,145.0,3
0,"public int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if the animal can breed.

@return int  the number of births (may be zero).",Animal.java,145.0,3
1,"public boolean canBreed()
    {
        return getAge() >= getBreedingAge();
    }","An animal can breed if it has reached its breeding age.

@return boolean  true if the animal can breed.",Animal.java,145.0,3
2,"protected void setRandomGender()
    {
        gender = rand.nextBoolean();
    }",Generate and set a random gender for the animal.,Animal.java,145.0,3
3,"public boolean getGender()
    {
        return gender;
    }","Return the animal's gender.

@return boolean  The animal's gender, true if male and false if female.",Animal.java,145.0,3
4,"protected void setInfected()
    {
        isInfected = true;
    }",Set the animal as having infection.,Animal.java,145.0,3
5,"protected boolean isInfected()
    {
        return isInfected;
    }","Returns whether the animal is infected or not.

@return The infection state of the animal.",Animal.java,145.0,3
6,"protected void setHealth(int healthLevel)
    {
        health = healthLevel;
    }","Set the health of the animal.

@param healthLevel   int for the health level of the animal.",Animal.java,145.0,3
7,"protected void decreaseHealth()
    {
        setHealth(getHealth()-1);
    }","Update the health level of the animal.
If an infected animal or plant is eaten then the
health level of the animal is decreased by 1.",Animal.java,145.0,3
8,"protected int getHealth()
    {
        return health;
    }","Return the health level of the animal.

@return health Returns the health level of the animal.",Animal.java,145.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,392.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,392.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,392.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,392.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,392.0,3
1,"protected Field getField() {
        return field;
    }","Returns the field of a creature.

@return field of the creature",Creature.java,392.0,3
2,"protected void setField(Field field) {
        this.field = field;
    }","Sets the fieldof a creature to the given field.

@param field new field",Creature.java,392.0,3
3,"protected Location getLocation() {
        return location;
    }","Returns the location of a creature.

@return location of the creature",Creature.java,392.0,3
4,"protected void setLocation(Location newLocation) {
        if (location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the creature at the new location in the given field.

@param newLocation of the animal",Creature.java,392.0,3
5,"protected boolean isAlive() {
        return alive;
    }","Returns whether a creature is alive or not.

@return true if is alive, false otherwise",Creature.java,392.0,3
6,"protected void setAlive(boolean alive) {
        this.alive = alive;
    }","Makes the creature alive or dead.

@param alive if true it makes the creature alive, dead othwerise",Creature.java,392.0,3
7,"protected int breed() {
        int births = 0;
        if (canBreed() && rand.nextDouble() <= breedingProbability) {
            births = rand.nextInt(maxLitterSize) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Creature.java,392.0,3
8,"public double getCreationProbability() {
        return creationProbability;
    }","Returns the creation probability of a creature.

@return creationProbability",Creature.java,392.0,3
9,"protected int getMaxAge() {
        return maxAge;
    }","Returns the maximum age of a creature.

@return maxAge maximum age of a creature",Creature.java,392.0,3
10,"protected int getAge() {
        return age;
    }","Returns the age of a creature.

@return age of creature",Creature.java,392.0,3
11,"protected void incrementAge() {
        age++;
        if (age > this.maxAge) {
            setDead();
        }
    }",Increments the age of a creature.,Creature.java,392.0,3
12,"protected void setAge(int age) {
        this.age = age;
    }","Sets the age of a creature to the given age.

@param age new age of the creature",Creature.java,392.0,3
13,"protected void setInfected(boolean isInfected) {
        this.isInfected = isInfected;
    }","Sets the infected status of a creature to the given one

@param isInfected new infected status of the creature, if true it is now infected, false othwerise.",Creature.java,392.0,3
14,"protected boolean getInfected() {
        return isInfected;
    }","Returns whether a creature is infected or not.

@return isInfected true if creature is infected, false otherwise",Creature.java,392.0,3
15,"protected void incrementTimeUntilDeath() {
        timeUntilDeath--;
        if (timeUntilDeath == 0) {
            setDead();
        }
    }",Increment the time until death of the creature.,Creature.java,392.0,3
0,"public Sloth getCreature(Boolean randomAge, Field newField, Location location) {
        return new Sloth(randomAge, newField, location);
    }","Returns a sloth with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the animal
@param location  location of the animal
@return sloth",Sloth.java,392.0,3
1,"protected boolean isTheSame(Object animal) {
        return this.getClass().isInstance(animal);
    }","Checks whether a given animal is of the same type as this animal - a sloth

@param animal given animal
@return true if same type, false otherwise",Sloth.java,392.0,3
0,"public boolean isInfected(){
        return (rand.nextDouble()<chance);
    }","Randomly decide with a given probability if the creature should get infected.
@return true if the creature gets infected.",Disease.java,392.0,3
1,"public int getTimeUntilDeath(){
        return timeUntilDeath;
    }","Return how much time (in steps) after infection does the creature die.
@return days until death.",Disease.java,392.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,392.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,392.0,3
0,"public void addWeather(String weatherName, int weight) {
        weatherTypes.put(weatherName, weight);
    }","Add a new type of weather

@param weatherName name of the new weather type
@param weight      weight of it happening",Weather.java,392.0,3
1,"public String randomiseWeather() {
        Object[] options = weatherTypes.keySet().toArray();
        int totalWeight = 0;
        for (Object weather : options) {
            totalWeight += weatherTypes.get(weather);
        }

        // Now choose a random weather.
        int idx = 0;
        for (double r = Math.random() * totalWeight; idx < options.length - 1; ++idx) {
            r -= weatherTypes.get(options[idx]);
            if (r <= 0.0) break;
        }
        return (String) options[idx];
    }","Return a randomised weather type.

@return String random weather",Weather.java,392.0,3
0,"public double whatIsTheTime() {
        return ((24 / unitPerDay) * time);
    }","Give the current time.
@return the current time",Time.java,392.0,3
1,"public void incrementTime() {
        time++;
        if (time % unitPerDay == 0) {
            time = 0;
        }
    }","Increments time by one unit. If it's midnight, set to 0.",Time.java,392.0,3
2,"public String stringTime() {
        String string = """";
        int minutes = (int) ((whatIsTheTime() % 1) * 60);
        int hours = (int) (whatIsTheTime() - (whatIsTheTime() % 1));
        if (hours < 10) {
            string += ""0"" + hours + "":"";
        } else string += hours + "":"";
        if (minutes < 10) {
            string += ""0"" + minutes;
        } else string += minutes;
        return string;
    }","Return the current time in String
@return  the current time in String.",Time.java,392.0,3
0,"@Override
    public void act(List<Creature> newCreatures, boolean dayTime) {
        incrementAge();
        if (isAlive()) {
            giveBirth(newCreatures);
            if (getInfected()) {
                Field field = getField();
                List<Location> adjacent = field.adjacentLocations(getLocation());
                Iterator<Location> it = adjacent.iterator();
                while (it.hasNext()) {
                    Location where = it.next();
                    Object creature = field.getObjectAt(where);
                    if (creature instanceof Plant) {
                        if (rand.nextInt(5) <= 3) ((Plant) creature).setInfected(true);
                    }
                    incrementTimeUntilDeath();
                }
            }
        }
    }","Make this plant act - that is: make it do
whatever it wants/needs to do.

@param newCreatures A list to receive newly born animals.",Plant.java,392.0,3
1,"@Override
    public boolean canBreed() {
        return true;
    }",Returns whether or not a plant can breed.,Plant.java,392.0,3
2,"public Plant getCreature(Boolean randomAge, Field newField, Location location) {
        return new Plant(true, newField, location);
    }","Returns a creature with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the creature
@param location  location of the creature
@return creature",Plant.java,392.0,3
3,"@Override
    protected void giveBirth(List<Creature> newCreatures) {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Creature young = this.getCreature(false, field, loc);
            newCreatures.add(young);
        }
    }",@param newCreatures a place for new creatures,Plant.java,392.0,3
4,"public int getNutritionalValue() {
        return nutritionalValue;
    }","Returns the nutritional value of a plant.

@return nutritionalValue",Plant.java,392.0,3
0,"public Monkey getCreature(Boolean randomAge, Field newField, Location location) {
        return new Monkey(randomAge, newField, location);
    }","Returns a monkey with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the animal
@param location  location of the animal
@return monkey",Monkey.java,392.0,3
1,"@Override
    public void act(List<Creature> newAnimals, boolean dayTime) {
        if (dayTime) {
            super.act(newAnimals, dayTime);
         }
        else {
            incrementHunger();
            incrementTimeUntilDeath();
        }
    }","Monkeys only move during the day. During the night, they still get hungrier and if infected, they get closer to death.
@param newAnimals A list to receive newly born animals.
@param dayTime True if it is during the day, false if it is the night",Monkey.java,392.0,3
2,"protected boolean isTheSame(Object animal) {
        return this.getClass().isInstance(animal);
    }","Checks whether a given animal is of the same type as this animal - a monkey

@param animal given animal
@return true if same type, false otherwise",Monkey.java,392.0,3
0,"@Override
    public Location findFood() {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object creature = field.getObjectAt(where);
            if(creature instanceof Plant) {
                Plant plant = (Plant) creature ;
                if(plant.isAlive()) {
                    plant.setDead();
                    if((this.getHungerLevel() + plant.getNutritionalValue())>this.getMaxHungerLevel()){
                        this.setHungerLevel(this.getMaxHungerLevel());
                    }
                    else this.setHungerLevel(this.getHungerLevel() + plant.getNutritionalValue());
                    return where;
                }
            }
        }
        return null;
    }","Search for neighbouring plants to eat. If no found return null.
@return The location where food is available. If no food is found, return null.",Prey.java,392.0,3
0,"public String getName() {
        return name;
    }",@return The short description of this type.,Counter.java,392.0,3
1,"public int getCount() {
        return count;
    }",@return The current count for this type.,Counter.java,392.0,3
2,"public void increment() {
        count++;
    }",Increment the current count by one.,Counter.java,392.0,3
3,"public void reset() {
        count = 0;
    }",Reset the current count to zero.,Counter.java,392.0,3
0,"public Location findFood() {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while (it.hasNext()) {
            Location where = it.next();
            Object creature = field.getObjectAt(where);
            if (creature instanceof Prey) {
                Prey prey = (Prey) creature;
                if (prey.isAlive()) {
                    prey.setDead();
                    if((this.getHungerLevel() + prey.getNutritionalValue())>this.getMaxHungerLevel()){
                        this.setHungerLevel(this.getMaxHungerLevel());
                    }
                    else this.setHungerLevel(this.getHungerLevel() + prey.getNutritionalValue());
                    return where;
                }
            }

        }

        Iterator<Location> it2 = adjacent.iterator();

        while (it2.hasNext()) {
            Location where2 = it2.next();
            Object creature2 = field.getObjectAt(where2);
            if (creature2 instanceof Plant) {
                Plant plant = (Plant) creature2;
                if (plant.isAlive()) {
                    plant.setDead();
                    return where2;
                }
            }
        }
        return null;
    }","Search for neighbouring preys to eat. If no found, search for plants. If no found return null.
@return The location where food is available. If no food is found, a location of a plant is returned. If still nothing is found, return null.",Predator.java,392.0,3
0,"public Capybara getCreature(Boolean randomAge, Field newField, Location location) {
        return new Capybara(randomAge, newField, location);
    }","Returns a capybara with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the animal
@param location  location of the animal
@return capybara",Capybara.java,392.0,3
1,"protected boolean isTheSame(Object animal) {
        return this.getClass().isInstance(animal);
    }","Checks whether a given animal is of the same type as this animal - a capybara

@param animal given animal
@return true if same type, false otherwise",Capybara.java,392.0,3
0,"public Leopard getCreature(Boolean randomAge, Field newField, Location location) {
        return new Leopard(randomAge, newField, location);
    }","Returns a leopard with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the animal
@param location  location of the animal
@return leopard",Leopard.java,392.0,3
1,"protected boolean isTheSame(Object animal) {
        return this.getClass().isInstance(animal);
    }","Checks whether a given animal is of the same type as this animal - a leopard

@param animal given animal
@return true if same type, false otherwise",Leopard.java,392.0,3
0,"public void setColor(Class creatureClass, Color color) {
        colors.put(creatureClass, color);
    }","Define a color to be used for a given class of creature.

@param creatureClass The creature's Class object.
@param color       The color to be used for the given class.",SimulatorView.java,392.0,3
1,"private Color getColor(Class creatureClass) {
        Color col = colors.get(creatureClass);
        if (col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        } else {
            return col;
        }
    }",@return The color to be used for a given class of creature.,SimulatorView.java,392.0,3
4,"public void showStatus(int step, Field field) {
        if (!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();

        fieldView.preparePaint();

        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                Object creature = field.getObjectAt(row, col);
                if (creature != null) {
                    stats.incrementCount(creature.getClass());
                    fieldView.drawMark(col, row, getColor(creature.getClass()));
                } else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();
        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.

@param step  Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,392.0,3
5,"public boolean isViable(Field field) {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.

@return true If there is more than one species alive.",SimulatorView.java,392.0,3
0,"public void runLongSimulation() {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,392.0,3
1,"public void simulate(int numSteps) {
        for (int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.

@param numSteps The number of steps to run for.",Simulator.java,392.0,3
2,"public void simulateOneStep() {
        step++;
        clock.incrementTime();
        if (step % clock.getUnitPerDay() == 0) {
            currentWeather = weather.randomiseWeather();
            reactToWeather(currentWeather);
        }

        // Provide space for newborn creatures.
        List<Creature> newCreatures = new ArrayList<>();
        // Let all rabbits act.
        Iterator<Creature> it = creatures.iterator();
        while (it.hasNext()) {
            List<Creature> newCreaturesTemp = new ArrayList<>();
            Creature creature = it.next();
            creature.act(newCreaturesTemp, isDayTime());
            infect(creature);
            if (!creature.isAlive()) {
                it.remove();
            }
            newCreatures.addAll(newCreaturesTemp);
        }

        // Add the newly born foxes and rabbits to the main lists.
        creatures.addAll(newCreatures);

        view.showStatus(step, field);
        view.showWeather(currentWeather);
        view.showTime(clock);
    }","Run the simulation from its current state for a single step.
Increment the time and every day randomise a new weather condition.
Iterate over the whole field updating the state of creature.",Simulator.java,392.0,3
3,"public void reset() {
        step = 0;
        creatures.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,392.0,3
4,"private void populate() {
        Random rand = Randomizer.getRandom();
        field.clear();


        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                boolean alreadyPopulated = false;
                for (Creature CreatureType : creatureTypes) {
                    if (!alreadyPopulated) {
                        if (rand.nextDouble() <= CreatureType.getCreationProbability()) {
                            Location location = new Location(row, col);
                            Creature newCreature = CreatureType.getCreature(true, field, location);
                            creatures.add(newCreature);
                            alreadyPopulated = true;
                        }
                    }
                }
            }
            // else leave the location empty.
        }
    }",Randomly populate the field with creatures.,Simulator.java,392.0,3
5,"private void delay(int millisec) {
        try {
            Thread.sleep(millisec);
        } catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.

@param millisec The time to pause for, in milliseconds",Simulator.java,392.0,3
6,"private Boolean isDayTime() {
        return (clock.whatIsTheTime() >= 6 && clock.whatIsTheTime() <18 );
    }","Returns whether or not it is day time.

@return true if the time is at the middle of the day, false otherwise",Simulator.java,392.0,3
7,"private void infect(Creature creature) {
        if (disease.isInfected()) {
            creature.setInfected(true);
            creature.setTimeUntilDeath(disease.getTimeUntilDeath());
        }
    }","Infects a creature with a given probability.
@param creature the creature getting infected",Simulator.java,392.0,3
8,"private void reactToWeather(String weather) {
        switch (weather) {
            case ""Rain"": { //When raining, plants grow an extra step
                List<Creature> newCreatures = new ArrayList<>();
                // Let all creatures act.
                Iterator<Creature> it = creatures.iterator();
                while (it.hasNext()) {
                    List<Creature> newCreaturesTemp = new ArrayList<>();
                    Creature creature = it.next();
                    if (creature instanceof Plant) {
                        creature.act(newCreaturesTemp, isDayTime());
                        if (!creature.isAlive()) {
                            it.remove();
                        }
                        newCreatures.addAll(newCreaturesTemp);
                    }
                }
                // Add the newly born creatures to the main lists.
                creatures.addAll(newCreatures);
                break;
            }
            case ""Fog"": { //when foggy, preys move an extra step
                List<Creature> newCreatures = new ArrayList<>();

                Iterator<Creature> it = creatures.iterator();
                while (it.hasNext()) {
                    List<Creature> newCreaturesTemp = new ArrayList<>();
                    Creature creature = it.next();
                    if (creature instanceof Prey) {
                        creature.act(newCreaturesTemp, isDayTime());
                        if (!creature.isAlive()) {
                            it.remove();
                        }
                        newCreatures.addAll(newCreaturesTemp);
                    }
                }
                creatures.addAll(newCreatures);
                break;

            }
            case ""Poisonous gas"": { // When poisonous gas, animals die with a given probability
                Iterator<Creature> it = creatures.iterator();
                while (it.hasNext()) {
                    Creature creature = it.next();
                    if (creature instanceof Animal) {
                        if (rand.nextInt(100) < 5) {
                            creature.setDead();
                        }
                    }


                }
                break;
            }
            default:
                break;

        }
    }","Certain weather conditions trigger responses from creatures.
@param weather the current weather",Simulator.java,392.0,3
0,"public String getPopulationDetails(Field field) {
        StringBuffer buffer = new StringBuffer();
        if (!countsValid) {
            generateCounts(field);
        }
        for (Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.

@return A string describing what is in the field.",FieldStats.java,392.0,3
1,"public void reset() {
        countsValid = false;
        for (Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,392.0,3
2,"public void incrementCount(Class creatureClass) {
        Counter count = counters.get(creatureClass);
        if (count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(creatureClass.getName());
            counters.put(creatureClass, count);
        }
        count.increment();
    }","Increment the count for one class of creature.

@param creatureClass The class of creature to increment.",FieldStats.java,392.0,3
3,"public void countFinished() {
        countsValid = true;
    }",Indicate that an creature count has been completed.,FieldStats.java,392.0,3
4,"public boolean isViable(Field field) {
        // How many counts are non-zero.
        int nonZero = 0;
        if (!countsValid) {
            generateCounts(field);
        }
        for (Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if (info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.

@return true If there is more than one species alive.",FieldStats.java,392.0,3
5,"private void generateCounts(Field field) {
        reset();
        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                Object creature = field.getObjectAt(row, col);
                if (creature != null) {
                    incrementCount(creature.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.

@param field The field to generate the stats for.",FieldStats.java,392.0,3
0,"public boolean equals(Object obj) {
        if (obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        } else {
            return false;
        }
    }",Implement content equality.,Location.java,392.0,3
1,"public String toString() {
        return row + "","" + col;
    }","Return a string of the form row,column

@return A string representation of the location.",Location.java,392.0,3
2,"public int hashCode() {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.

@return A hashcode for the location.",Location.java,392.0,3
3,"public int getRow() {
        return row;
    }",@return The row.,Location.java,392.0,3
4,"public int getCol() {
        return col;
    }",@return The column.,Location.java,392.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,392.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,392.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,392.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,392.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,392.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,392.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,392.0,3
0,"public void clear() {
        for (int row = 0; row < depth; row++) {
            for (int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,392.0,3
1,"public void clear(Location location) {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.

@param location The location to clear.",Field.java,392.0,3
2,"public void place(Object creature
            , int row, int col) {
        place(creature, new Location(row, col));
    }","Place an creature
at the given location.
If there is already an creature
at the location it will
be lost.

@param creature
The creature
to be placed.
@param row    Row coordinate of the location.
@param col    Column coordinate of the location.",Field.java,392.0,3
3,"public void place(Object creature, Location location) {
        field[location.getRow()][location.getCol()] = creature;
    }","Place an creature
at the given location.
If there is already an creature at the location it will
be lost.

@param creature   The creature to be placed.
@param location Where to place the creature.",Field.java,392.0,3
4,"public Object getObjectAt(Location location) {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the creature at the given location, if any.

@param location Where in the field.
@return The creature at the given location, or null if there is none.",Field.java,392.0,3
5,"public Object getObjectAt(int row, int col) {
        return field[row][col];
    }","Return the creature at the given location, if any.

@param row The desired row.
@param col The desired column.
@return The creature at the given location, or null if there is none.",Field.java,392.0,3
6,"public List<Location> getFreeAdjacentLocations(Location location) {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for (Location next : adjacent) {
            if (getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.

@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,392.0,3
7,"public Location freeAdjacentLocation(Location location) {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if (free.size() > 0) {
            return free.get(0);
        } else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.

@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,392.0,3
8,"public List<Location> adjacentLocations(Location location) {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if (location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for (int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if (nextRow >= 0 && nextRow < depth) {
                    for (int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if (nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.

@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,392.0,3
9,"public int getDepth() {
        return depth;
    }","Return the depth of the field.

@return The depth of the field.",Field.java,392.0,3
10,"public int getWidth() {
        return width;
    }","Return the width of the field.

@return The width of the field.",Field.java,392.0,3
0,"public Tiger getCreature(Boolean randomAge, Field newField, Location location) {
        return new Tiger(randomAge, newField, location);
    }","Returns a tiger with the given attributes.

@param randomAge true if age is random, false otherwise
@param newField  field of the animal
@param location  location of the animal
@return tiger",Tiger.java,392.0,3
1,"@Override
    public void act(List<Creature> newAnimals, boolean dayTime) {
        if (!dayTime) {
            super.act(newAnimals, dayTime);
        }
        else {
            incrementHunger();
            incrementTimeUntilDeath();
        }
    }","Tigers only move during the night. During the day, they still get hungrier and if infected, they get closer to death
@param newAnimals A list to receive newly born animals.
@param dayTime True if it is during the day, false if it is the night",Tiger.java,392.0,3
2,"protected boolean isTheSame(Object animal) {
        return this.getClass().isInstance(animal);
    }","Checks whether a given animal is of the same type as this animal - a tiger

@param animal given animal
@return true if same type, false otherwise",Tiger.java,392.0,3
0,"public void act(List<Creature> newCreatures, boolean dayTime) {
        incrementAge();
        incrementHunger();
        if (isAlive()) {
            giveBirth(newCreatures);
            // Try to move into a free location.
            Location newLocation = findFood();
            if (newLocation == null) {
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if (newLocation != null) {
                setLocation(newLocation);
            } else {
                // Overcrowding.
                setDead();
            }
            if (isAlive() && getInfected()) {
                Field field = getField();
                List<Location> adjacent = field.adjacentLocations(getLocation());
                Iterator<Location> it = adjacent.iterator();
                while (it.hasNext()) {
                    Location where = it.next();
                    Object creature = field.getObjectAt(where);
                    if (creature instanceof Animal) {
                        if (rand.nextInt(9) <= 3) ((Animal) creature).setInfected(true);
                    }
                }
                incrementTimeUntilDeath();
            }
        }
    }","Make this animal act - that is: make it do
whatever it wants/needs to do.

@param newCreatures A list to receive newly born animals.",Animal.java,392.0,3
1,"protected void incrementHunger() {
        hungerLevel--;
        if (hungerLevel <= 0) {
            setDead();
         }
    }","Increments the hunger of the animal. If the hunger level is below '0', the animal dies.",Animal.java,392.0,3
2,"protected void giveBirth(List<Creature> newCreatures) {
        // New creatures are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        boolean alreadyHadKids=false;
        while (it.hasNext()) {
            Location where = it.next();
            Object creature = field.getObjectAt(where);
            if (this.getFemale() && this.isTheSame(creature)) {
                Animal sameAnimal = (Animal) creature;
                if (!sameAnimal.getFemale()&& !alreadyHadKids) {
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    int births = breed();
                    for (int b = 0; b < births && free.size() > 0; b++) {
                        Location loc = free.remove(0);
                        Creature young = this.getCreature(false, field, loc);
                        newCreatures.add(young);
                        alreadyHadKids=true;
                    }
                }
            }
        }
    }","Check whether or not this creature is to give birth at this step.
New births will be made into free adjacent locations.

@param newCreatures//A list to return newly born animals.",Animal.java,392.0,3
3,"protected boolean canBreed() {
        return this.getAge() >= breedingAge;
    }","An animal can breed if it has reached the breeding age.

@return true if the animal can breed, false otherwise.",Animal.java,392.0,3
4,"protected Boolean getFemale() {
        return this.isFemale;
    }","Returns whether an animal is a female or male.

@return isFemale true if female, false otherwise.",Animal.java,392.0,3
5,"protected int getMaxHungerLevel() {
        return this.maxHungerLevel;
    }","Returns the maximum hunger level of an animal.

@return maxHungerLevel",Animal.java,392.0,3
6,"protected int getHungerLevel() {
        return this.hungerLevel;
    }","Returns the current hunger level of an animal

@return hungerLevel",Animal.java,392.0,3
7,"protected void setHungerLevel(int hungerLevel) {
        this.hungerLevel = hungerLevel;
    }","Sets the hunger level of an animal to the given hunger level.

@param hungerLevel new hunger level of the animal",Animal.java,392.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,94.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,94.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,94.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,94.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,94.0,3
0,"public boolean isFood(Object object) 
    {
        if (object instanceof Corn) {
            return true;
        }

        return false;
    }","Check wheather the parameter is food or not.

@return wheather the parameter is food or not.
@param object the object the mouse is going to eat.",Mouse.java,94.0,3
1,"public void act(List<Animal> newMice, boolean isDay, String weather)
    {
        SpreadDisease();
        
        weatherEffect(weather);
        
        incrementAge(MAX_AGE);
        incrementHunger();
        incrementThirsty();
        diseaseCauseDeath();
        if(isAlive()) {
            if(findMate()) {
                giveBirth(newMice);
            }
            Location newLocation = findFood();
            if(newLocation == null) {
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                setDead();
            }
        }
    }","This is what the mouse does most of the time - it runs
around and eats the corns. Sometimes it will breed, die of hunder or old age or get disease.

@param newMice A list to return newly born mice.
@param isDay Indicate wheather it is a day or night.
@param weather The weather the mouse is in.",Mouse.java,94.0,3
2,"public int breed()
    {
        int births = 0;
        if (canBreed(BREEDING_AGE) && rand.nextDouble() <= NEW_BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Mouse.java,94.0,3
3,"public void giveBirth(List<Animal> newMice)
    {
        // New mice are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            String gender = Randomizer.getRandomGender();
           
            boolean isSick = false;
            if (isSick())
            {
                isSick = Randomizer.getRandomIsSick();
            }
            Mouse young = new Mouse(false, field, loc, gender, isSick);
            newMice.add(young);
        }
    }","Check whether or not this mouse is to give birth at this step.
New births will be made into free adjacent locations.

@param newMice A list to return newly born mice.",Mouse.java,94.0,3
4,"public boolean isMate(Object object) 
    {
        boolean result = false;

        if (object instanceof Mouse) {
            Mouse mouse = (Mouse) object;
            
            if (mouse.isAlive() && mouse.canBreed(BREEDING_AGE)&& !(mouse.getGender().equals(this.getGender()))) {
                result = true;
            }
        }

        return  result;
    }","Check wheather the adjacent mouse can be a partner(mate).

@param object The adjacent object.
@return wheather or not the adjacent mouse can be a partner.",Mouse.java,94.0,3
5,"public void weatherEffect (String weather)
    {
        
        if (weather.equals(""Sunny"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY;
        }
        else if (weather.equals(""Cloudy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.9;
        }
        else if (weather.equals(""Rainy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.8;
        }     
        else if (weather.equals(""Windy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.85;
        }
    }","According to the weather, the mouse get effected on the breeding probability.

@param weather The string of weather.",Mouse.java,94.0,3
0,"public void act(List<Corn> newCorn, String weather)
    {
        incrementLifeTime();
        if(isAlive()) {
            weatherEffect(weather);
            giveBirth(newCorn);
        }
    }","This is what corn does most of the time - it grows and breed.
When it grows enough, it dies.

@param newCorn A list to return newly born corn.
@param weather The weather corn is in.",Corn.java,94.0,3
1,"public void giveBirth(List<Corn> newCorn) 
    {
        // New corn are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = null;
        int births = breed();
        if (null != field) {
            free = field.getFreeAdjacentLocations(getLocation());
        }
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Corn corn = new Corn(field, loc);
            newCorn.add(corn);
        }
    }","Check whether or not this corn is to give birth at this step.
New births will be made into free adjacent locations.

@param newCorn A list to return newly born corn.",Corn.java,94.0,3
2,"public int breed() 
    {
        int births = 0;
        if (rand.nextDouble() <= NEW_GROWING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Corn.java,94.0,3
3,"public void weatherEffect (String weather)
    {
        if (weather.equals(""Sunny""))
        {
            NEW_GROWING_PROBABILITY = GROWING_PROBABILITY;
        }
        if (weather.equals(""Cloudy""))
        {
            NEW_GROWING_PROBABILITY = GROWING_PROBABILITY * 0.8;
        }
        if (weather.equals(""Rainy""))
        {
            NEW_GROWING_PROBABILITY = GROWING_PROBABILITY * 1.1;
        }
        if (weather.equals(""Windy""))
        {
            NEW_GROWING_PROBABILITY = GROWING_PROBABILITY * 0.9;
        }
    }","According to the weather, corn get effected on the breeding probability.

@param weather The string of weather.",Corn.java,94.0,3
4,"private void incrementLifeTime()
    {
        life++;
        if(life > MAX_LIFE) {
            setDead();
        }
    }",Increase the age of corn.,Corn.java,94.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,94.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,94.0,3
2,"public static String getRandomGender() 
    {
        String gender;
        
        int randomInt = rand.nextInt(100);

        if (randomInt % 2 == 0) {
            gender = ""Male"";
        }
        else{
            gender = ""Female""; 
        }
        return gender;
    }",@return the random string of gender. (Male or Female),Randomizer.java,94.0,3
3,"public static boolean getRandomIsSick()
    {
       if (rand.nextInt(20) <= 2){
            return true;
       }
        else{
            return false;
       }
    }",@return the animal is sick or not randomly.,Randomizer.java,94.0,3
0,"public boolean isFood(Object object)
    {
        if (object instanceof Snake && rand.nextDouble()<= NEW_SNAKE_HUNT_PROBABILITY) {
            return true;
        }
        else if(object instanceof Chicken && rand.nextDouble()<= NEW_CHICKEN_HUNT_PROBABILITY) {
            return true;
        }
        
        return false;
    }","Check wheather the parameter is food or not.

@return wheather the parameter is food or not.
@param object the object the eagle is going to eat.",Eagle.java,94.0,3
1,"public void act(List<Animal> newEagles, boolean isDay, String weather)
    {
        // New eagles are born into adjacent locations.
        // Get a list of adjacent free locations.
        SpreadDisease();
        timeEffect(isDay);
        weatherEffect(weather);
        incrementAge(MAX_AGE);
        incrementHunger();
        incrementThirsty();
        diseaseCauseDeath();
        if(isAlive()) {
            if(findMate()) {
                giveBirth(newEagles);
            }
            Location newLocation = findFood();
            if(newLocation == null) {
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                setDead();
            }
        }
    }","This is what the ealge does most of the time - it hunts
for either snake or chicken. In the process, it might breed, die of hunger, disease or old age.

@param newEagles A list to return newly born eagles.
@param isDay Indicate wheather it is a day or night.
@param weather The weather the eagle is in.",Eagle.java,94.0,3
2,"public int breed()
    {
        int births = 0;
        if (canBreed(BREEDING_AGE) && rand.nextDouble() <= NEW_BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Eagle.java,94.0,3
3,"public void giveBirth(List<Animal> newEagles)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            String gender = Randomizer.getRandomGender();
           
            boolean isSick =false;
            if (isSick()){
                isSick = Randomizer.getRandomIsSick();
            }
            Eagle young = new Eagle(false, field, loc, gender, isSick);
            newEagles.add(young);
        }
    }","Check whether or not this eagle is to give birth at this step.
New births will be made into free adjacent locations.

@param newEagles A list to return newly born eagles.",Eagle.java,94.0,3
4,"public boolean isMate(Object object)
    {
        boolean result = false;

        if (object instanceof Eagle) {
            Eagle eagle = (Eagle) object;
            
            if (eagle.isAlive() && eagle.canBreed(BREEDING_AGE) && !(eagle.getGender().equals(this.getGender()))) {
                result = true;
            }
        }
        
        return  result;
    }","Check wheather the adjacent eagle can be a partner(mate).

@param object The adjacent object.
@return wheather or not the adjacent eagle can be a partner.",Eagle.java,94.0,3
5,"public void weatherEffect (String weather)
    {
        if (weather.equals(""Sunny"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY;
        }
        else if (weather.equals(""Cloudy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.9;
        }
        else if (weather.equals(""Rainy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.8;
        }     
        else if (weather.equals(""Windy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.85;
        }
    }","According to the weather, the ealge get effected on the breeding probability.

@param weather The string of weather.",Eagle.java,94.0,3
6,"public void timeEffect (boolean isDay)
    {
        if(isDay) {
            NEW_SNAKE_HUNT_PROBABILITY = SNAKE_HUNT_PROBABILITY*0.9;
            NEW_CHICKEN_HUNT_PROBABILITY = CHICKEN_HUNT_PROBABILITY*0.9;
        }
        else if(!isDay) {
            NEW_SNAKE_HUNT_PROBABILITY = SNAKE_HUNT_PROBABILITY*1.1;
            NEW_CHICKEN_HUNT_PROBABILITY = CHICKEN_HUNT_PROBABILITY*1.1;
        }
    }","If it is during the day, the probability of hunting increased.
or it is decreased.

@param isDay Indicate wheather it is during the day or not.",Eagle.java,94.0,3
0,"public boolean isFood(Object object)
    {
        if (object instanceof Cat && rand.nextDouble()<= NEW_CAT_HUNT_PROBABILITY) {
            return true;
        }
        else if(object instanceof Chicken && rand.nextDouble()<= NEW_CHICKEN_HUNT_PROBABILITY) {
            return true;
        }
        
        return false;
    }","Check wheather the parameter is food or not.

@return wheather the parameter is food or not.
@param object the object the snake is going to eat.",Snake.java,94.0,3
1,"public void act(List<Animal> newSnakes, boolean isDay, String weather)
    {
        // New snakes are born into adjacent locations.
        // Get a list of adjacent free locations.
        SpreadDisease(); 
        timeEffect(isDay);
        weatherEffect(weather);
        incrementAge(MAX_AGE);
        incrementHunger();
        incrementThirsty();
        diseaseCauseDeath();
        if(isAlive()) {
            if(findMate()) {
                giveBirth(newSnakes);
            }
            Location newLocation = findFood();
            if(newLocation == null) {
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                setDead();
            }
        }
    }","This is what the snake does most of the time - it hunts
for either chicken or cat. In the process, it might breed, die of hunger, disease or old age.

@param newSnakes A list to return newly born snakes.
@param isDay Indicate wheather it is a day or night.
@param weather The weather the snake is in.",Snake.java,94.0,3
2,"public int breed()
    {
        int births = 0;
        if (canBreed(BREEDING_AGE) && rand.nextDouble() <= NEW_BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Snake.java,94.0,3
3,"public void giveBirth(List<Animal> newSnakes)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            String gender = Randomizer.getRandomGender();
           
            boolean isSick =false;
            if (isSick()){
                isSick = Randomizer.getRandomIsSick();
            }
            Snake young = new Snake(false, field, loc, gender, isSick);
            newSnakes.add(young);
        }
    }","Check whether or not this snake is to give birth at this step.
New births will be made into free adjacent locations.

@param newSnakes A list to return newly born snakes.",Snake.java,94.0,3
4,"public boolean isMate(Object object)
    {
        boolean result = false;

        if (object instanceof Snake) {
            Snake snake = (Snake) object;
            
            if (snake.isAlive() && snake.canBreed(BREEDING_AGE) && !(snake.getGender().equals(this.getGender()))) {
                result = true;
            }
        }

        return  result;
    }","Check wheather the adjacent snake can be a partner(mate).

@param object The adjacent object.
@return wheather or not the adjacent snake can be a partner.",Snake.java,94.0,3
5,"public void weatherEffect (String weather)
    {
        if (weather.equals(""Sunny"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY;
        }
        else if (weather.equals(""Cloudy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.9;
        }
        else if (weather.equals(""Rainy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.8;
        }     
        else if (weather.equals(""Windy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.85;
        }
    }","According to the weather, the snake get effected on the breeding probability.

@param weather The string of weather.",Snake.java,94.0,3
6,"public void timeEffect (boolean isDay)
    {
        if(isDay) {
            NEW_CAT_HUNT_PROBABILITY = CAT_HUNT_PROBABILITY*0.9;
            NEW_CHICKEN_HUNT_PROBABILITY = CHICKEN_HUNT_PROBABILITY*0.9;
        }
        else if(!isDay) {
            NEW_CAT_HUNT_PROBABILITY = CAT_HUNT_PROBABILITY*1.1;
            NEW_CHICKEN_HUNT_PROBABILITY = CHICKEN_HUNT_PROBABILITY*1.1;
        }
    }","If it is during the day, the probability of hunting increased.
or it is decreased.

@param isDay Indicate wheather it is during the day or not.",Snake.java,94.0,3
0,"public static String getRandomWeather()
    {
        weather = weathers.get(rand.nextInt(weathers.size() - 1));
        return weather;
    }",@return random string of weather.,Weather.java,94.0,3
0,"public void act(List<Water> newWater)
    {
        turnDirty();
    }","This is what water do most of the time - it appears and gets dirty.
if it left over some days, it rots.

@param newWater A list to return newly born corn.",Water.java,94.0,3
1,"private void turnDirty()
    {
        dirtyLevel++;
        if(dirtyLevel > MAX_DIRTY_LEVEL){
            setDead();
        }
    }","The water get dirty. If it left over some days, it rots(dies).",Water.java,94.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,94.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,94.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,94.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,94.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of species.

@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,94.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,94.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,94.0,3
3,"public void showStatus(int step, Field field,String weather, boolean isDay)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        
        stepLabel.setText(STEP_PREFIX + step);
        this.weather.setText(WEATHER_PREFIX + weather);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,94.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,94.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,94.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(60);   // comment this to run more fast.
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.

@param numSteps The number of steps to run for.",Simulator.java,94.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals and plants.
        List<Corn> newCorns = new ArrayList<>();       
        List<Animal> newAnimals = new ArrayList<>();     
        List<Water> newWater = new ArrayList<>();  
        // Let all animals and plants act.
        if (step % 5 == 0)
        {
            isDay = !isDay;
        }
        if (step % 10 == 0)
        {
            currentWeather = weather.getRandomWeather();
        }
        
        for(Iterator<Species> it = species.iterator(); it.hasNext(); ) {
            Species species = it.next();
            Animal animal = null;
            
            if (species instanceof Animal) {
                animal = (Animal) species;

                if (!animal.isAlive()) {
                    it.remove();

                } 
                else {
                    animal.act(newAnimals, isDay, currentWeather);
                }

            }
            if (species instanceof Corn) {
                Corn corn = (Corn) species;
                if (!corn.isAlive()) {
                    it.remove();

                } 
                else {
                    corn.act(newCorns, currentWeather);
                }
            }
            if (species instanceof Water) {
                Water water = (Water) species;
                if (!water.isAlive()) {
                    it.remove();

                } 
                else {
                    water.act(newWater);
                }
            }
        }
               
        // Add the newly born animals and plants to the main lists.
        this.createCorn();
        this.createWater();
        species.addAll(newAnimals);
        species.addAll(newCorns);
        species.addAll(newWater);
        view.showStatus(step,field,currentWeather,isDay);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each species.",Simulator.java,94.0,3
3,"public void reset()
    {
        step = 0;
        species.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step,field,currentWeather,isDay);
    }",Reset the simulation to a starting position.,Simulator.java,94.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= CAT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Cat cat = new Cat(true, field, location,Randomizer.getRandomGender(),Randomizer.getRandomIsSick());
                    species.add(cat);
                }
                else if(rand.nextDouble() <= MOUSE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Mouse mouse = new Mouse(true, field, location,Randomizer.getRandomGender(),Randomizer.getRandomIsSick());
                    species.add(mouse);
                }
                
                else if(rand.nextDouble() <= CHICKEN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Chicken chicken = new Chicken(true, field, location,Randomizer.getRandomGender(),Randomizer.getRandomIsSick());
                    species.add(chicken);
                }
                
                else if(rand.nextDouble() <= SNAKE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Snake snake = new Snake(true, field, location,Randomizer.getRandomGender(),Randomizer.getRandomIsSick());
                    species.add(snake);
                }
                else if(rand.nextDouble() <= EAGLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Eagle eagle = new Eagle(true, field, location,Randomizer.getRandomGender(),Randomizer.getRandomIsSick());
                    species.add(eagle);
                }
                else if(rand.nextDouble() <= CORN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Corn corn= new Corn( field, location);
                    species.add(corn);
                }
                else if(rand.nextDouble() <= WATER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Water water= new Water( field, location);
                    species.add(water);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with all animals and plants.,Simulator.java,94.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,94.0,3
6,"private void createCorn() 
    {
        Random rand = Randomizer.getRandom();
        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                Location location = new Location(row, col);
                Species species = null;
                if (rand.nextDouble() <= CORN_CREATION_PROBABILITY_EACH_STEP) {

                    species = new Corn(field, location);
                    this.species.add(species);
                }
            }
        }
    }",Create corn randomly in the simulation.,Simulator.java,94.0,3
7,"private void createWater() 
    {
        Random rand = Randomizer.getRandom();
        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                Location location = new Location(row, col);
                Species species = null;
                if (rand.nextDouble() <= WATER_CREATION_PROBABILITY_EACH_STEP) {

                    species = new Water(field, location);
                    this.species.add(species);
                }
            }
        }
    }",Create water randomly in the simulation.,Simulator.java,94.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,94.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,94.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,94.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,94.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,94.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,94.0,3
0,"public boolean isFood(Object object) 
    {
        if (object instanceof Mouse && rand.nextDouble()<= NEW_MOUSE_HUNT_PROBABILITY) {
            return true;
        }
        
        return false;
    }","Check wheather the parameter is food or not.

@return wheather the parameter is food or not.
@param object the object the cat is going to eat.",Cat.java,94.0,3
1,"public void act(List<Animal> newCats, boolean isDay, String weather)
    {
        // New cats are born into adjacent locations.
        // Get a list of adjacent free locations.
        SpreadDisease();
        timeEffect(isDay);
        weatherEffect(weather);
        incrementAge(MAX_AGE);
        incrementHunger();
        incrementThirsty();
        diseaseCauseDeath();
        if(isAlive()) {
            if(findMate()) {
                giveBirth(newCats);
            }
            Location newLocation = findFood();
            if(newLocation == null) {
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                setDead();
            }
        }
    }","This is what the cat does most of the time - it hunts
for mouse. In the process, it might breed, die of hunger, disease or old age.

@param newCats A list to return newly born cats.
@param isDay Indicate wheather it is a day or night.
@param weather The weather the cat is in.",Cat.java,94.0,3
2,"public int breed() 
    {
        int births = 0;
        if (canBreed(BREEDING_AGE) && rand.nextDouble() <= NEW_BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Cat.java,94.0,3
3,"public void giveBirth(List<Animal> newCats) 
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            String gender = Randomizer.getRandomGender();
           
            boolean isSick =false;
            if (isSick()) {
                isSick = Randomizer.getRandomIsSick();
            }
            Cat young = new Cat(false, field, loc, gender, isSick);
            newCats.add(young);
        }
    }","Check whether or not this cat is to give birth at this step.
New births will be made into free adjacent locations.

@param newCats A list to return newly born cats.",Cat.java,94.0,3
4,"public boolean isMate(Object object) 
    {
        boolean result = false;

        if (object instanceof Cat) {
            Cat cat = (Cat) object;
            
            if (cat.isAlive() && cat.canBreed(BREEDING_AGE) && !(cat.getGender().equals(this.getGender()))) {
                result = true;
            }
        }
        
        return  result;
    }","Check wheather the adjacent cat can be a partner(mate).

@param object The adjacent object.
@return wheather or not the adjacent cat can be a partner.",Cat.java,94.0,3
5,"public void weatherEffect (String weather)
    {
        if (weather.equals(""Sunny"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY;
        }
        else if (weather.equals(""Cloudy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.9;
        }
        else if (weather.equals(""Rainy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.8;
        }     
        else if (weather.equals(""Windy"")) {
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.85;
        }
    }","According to the weather, the cat get effected on the breeding probability.

@param weather The string of weather.",Cat.java,94.0,3
6,"public void timeEffect (boolean isDay)
    {
        if(isDay) {
            NEW_MOUSE_HUNT_PROBABILITY = MOUSE_HUNT_PROBABILITY*1.1;
        }
        else if(!isDay) {
            NEW_MOUSE_HUNT_PROBABILITY = MOUSE_HUNT_PROBABILITY*0.9;
        }
        
    }","If it is during the day, the probability of hunting increased.
or it is decreased.

@param isDay Indicate wheather it is during the day or not.",Cat.java,94.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,94.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,94.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,94.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,94.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,94.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,94.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,94.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,94.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,94.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,94.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,94.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,94.0,3
0,"public boolean isFood(Object object)
    {
        if (object instanceof Corn) {
            return true;
        }

        return false;
    }","Check wheather the parameter is food or not.

@return wheather the parameter is food or not.
@param object the object the chicken is going to eat.",Chicken.java,94.0,3
1,"public void act(List<Animal> newChickens, boolean isDay, String weather)
    {
        // New chickens are born into adjacent locations.
        // Get a list of adjacent free locations.
        SpreadDisease();
        weatherEffect(weather);
       
        incrementAge(MAX_AGE);
        incrementHunger(); 
        incrementThirsty();
        diseaseCauseDeath();
        if(isAlive()){
            if(findMate()){
                giveBirth(newChickens);
            }
            Location newLocation = findFood();
            if(newLocation == null){
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null){
                setLocation(newLocation);
            }
            else{
                setDead();
            }
        }
    }","This is what the chicken does most of the time - it runs
around and eats the corns. Sometimes it will breed, die of hunger or old age or get disease.

@param newChickens A list to return newly born chickens.
@param isDay Indicate wheather it is a day or night.
@param weather The weather the chicken is in.",Chicken.java,94.0,3
2,"public int breed()
    {
        int births = 0;
        if (canBreed(BREEDING_AGE) && rand.nextDouble() <= NEW_BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return The number of births (may be zero).",Chicken.java,94.0,3
3,"public void giveBirth(List<Animal> newChickens)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            String gender = Randomizer.getRandomGender();
           
            boolean isSick =false;
            if (isSick()){
                isSick = Randomizer.getRandomIsSick();
            }
            Chicken young = new Chicken(false, field, loc, gender, isSick);
            newChickens.add(young);
        }
    }","Check whether or not this chicken is to give birth at this step.
New births will be made into free adjacent locations.

@param newChickens A list to return newly born chickens.",Chicken.java,94.0,3
4,"public boolean isMate(Object object)
    {
        boolean result = false;

        if (object instanceof Chicken) {
            Chicken chicken = (Chicken) object;
            
            if (chicken.isAlive() && chicken.canBreed(BREEDING_AGE) && !(chicken.getGender().equals(this.getGender()))) {
                result = true;
            }
        }

        return  result;
    }","Check wheather the adjacent chicken can be a partner(mate).

@param object The adjacent object.
@return wheather or not the adjacent chicken can be a partner.",Chicken.java,94.0,3
5,"public void weatherEffect (String weather)
    {
        
        if (weather.equals(""Sunny"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY;
        }
        else if (weather.equals(""Cloudy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.9;
        }
        else if (weather.equals(""Rainy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.8;
        }     
        else if (weather.equals(""Windy"")){
            NEW_BREEDING_PROBABILITY = BREEDING_PROBABILITY*0.85;
        }
    }","According to the weather, the chicken get effected on the breeding probability.

@param weather The string of weather.",Chicken.java,94.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,94.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,94.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,94.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,94.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,94.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,94.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,94.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,94.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,94.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,94.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,94.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,94.0,3
0,"protected boolean isDrink(Object object) 
    {
        if (object instanceof Water) {
            return true;
        }

        return false;
    }","Check wheather the parameter is water or not.

@return wheather the parameter is water or not.
@param object the object the animal is going to drink.",Animal.java,94.0,3
1,"protected void incrementAge(int maxAge) 
    {
        age++;
        if (age > maxAge) {
          setDead();
        }
    }","Increase the age of the animal.
If the animal aged over the maximum, it dies.

@param maxAge Within the maximum age, it increased.",Animal.java,94.0,3
2,"protected void incrementHunger() 
    {
        foodLevel--;
        if (foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger of the animal.
If the hunger level gets less than 0, it dies.",Animal.java,94.0,3
3,"protected void incrementThirsty() 
    {
        waterLevel--;
        if (waterLevel <= 0) {
            setDead();
        }
    }","Increase the thirsty level of the animal.
If the thirsty level gets less than 0, it dies.",Animal.java,94.0,3
4,"protected String getGender()
    {
        return gender;
    }","Access method of variable: gender

@return The string of gender. (Male, Female)",Animal.java,94.0,3
5,"protected boolean canBreed(int breedingAge)
    {
        return age >= breedingAge;
    }","An animal can breed if it has reached the breeding age.

@param breedingAge The age that the animal is able to breed.
@return true if the rabbit can breed, false otherwise.",Animal.java,94.0,3
6,"public void setSick(boolean sick) 
    {
        isSick = sick;
    }","Make the animal sick.

@param sick Wheather the animal is sick or not.",Animal.java,94.0,3
7,"public boolean isSick() 
    {
        return isSick;
    }",Indicate wheather the animal is sick or not.,Animal.java,94.0,3
8,"protected void diseaseCauseDeath()
    {
        if(isSick){
            if(rand.nextDouble() <= mortalityRate){
                setDead();
            }
        }
    }","If the animal is sick, it might dies up to the mortality rate.",Animal.java,94.0,3
9,"protected Location findFood() 
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while (it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if (isFood(object)) {
                Species species = (Species) object;
                if (species.isAlive()) {
                    foodLevel=15;
                    species.setDead();
                    return where;
                }
            }
        }while (it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if (isDrink(object)) {
                Water water = (Water) object;
                if (water.isAlive()) {
                    waterLevel=15;
                    water.setDead();
                    return where;
                }
            }
        }
        
        return null;
    }","Look for foods adjacent to the current location.
Only the first live foods is eaten.

@return Where food was found, or null if it wasn't.",Animal.java,94.0,3
10,"protected boolean findMate() 
    {
        boolean haveMate = false;
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while (it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if (isMate(animal)) {
                haveMate = true;
                break;
            }
        }
        return haveMate;
    }","Look for mate adjacent to the current location.

@return true mate was found, or false if it wasn't.",Animal.java,94.0,3
11,"protected void SpreadDisease() 
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        while (it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if (object instanceof  Animal)
            {
                Animal animal = (Animal) object;
                if(isSick()){
                    animal.setSick(Randomizer.getRandomIsSick());
                } else if (animal.isSick()){
                    setSick(Randomizer.getRandomIsSick());
                }

            }
        }
    }",The disease spread when the animals meet in the adjacent location.,Animal.java,94.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the species is alive or not.
@return true if the animal is still alive.",Species.java,94.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the species is no longer alive.
It is removed from the field.",Species.java,94.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the species's location.
@return The species's location.",Species.java,94.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the species at the new location in the given field.
@param newLocation The species's new location.",Species.java,94.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the species's field.
@return The species's field.",Species.java,94.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
        classes = colors.keySet();
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GraphView.java,606.0,3
1,"public void showStatus(DateTime dateTime, Field field)
    {
        graph.update(dateTime, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param dateTime The current date and time of the simulation.
@param field The field whose status is to be displayed.",GraphView.java,606.0,3
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GraphView.java,606.0,3
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GraphView.java,606.0,3
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        JPanel bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel("" "");
        bottom.add(countLabel);
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,GraphView.java,606.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,606.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,606.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,606.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,606.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,606.0,3
0,"public int getRainFallValue()
    {
        return rainFallValue;
    }",@return the amount of rain in the grid.,WeatherTile.java,606.0,3
0,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",ActingThing.java,606.0,3
1,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",ActingThing.java,606.0,3
2,"protected void remove()
    {
        location = null;
        field = null;
    }",Remove the actor,ActingThing.java,606.0,3
3,"protected void setLocation(Location newLocation)
    {
        location = newLocation;
        field.place(this, newLocation);

    }","place the actor to a new location.
Update the location in the field aswell.",ActingThing.java,606.0,3
4,"protected DateTime getDateTime()
    {
        return dateTime;
    }",@return the current date and time,ActingThing.java,606.0,3
5,"protected boolean canAct()
    {
        return field!=null;
    }",@return ture if the actor is still in the field.,ActingThing.java,606.0,3
0,"public void act(LivingThing thing)
    {

        if(thing.canAct()&&thing instanceof Animal){
            Animal affectedAnimal = (Animal)thing;
            List<Location> adjacent = affectedAnimal.getField().adjacentLocations(affectedAnimal.getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Animal animal = affectedAnimal.getField().getAnimalAt(where);
                if(animal!=null&&rand.nextDouble()<=TRANSMITTION_PROBABILITY){
                    animal.setDisease(this);
                }

            }

            if(rand.nextDouble()<=ILL_PROBABILITY){
                affectedAnimal.decrementHuntingDistance();
            }
        }

        if(rand.nextDouble()<=KILLING_PROBABILITY){
            thing.setDead();
        }

    }","A disease action. That is to transmit,to make an animal ill, to kill a living thing.",Disease.java,606.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,606.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,606.0,3
0,"public void place(ActingThing thing)
    {
        if(thing instanceof Animal){
            animal = (Animal)thing;
        }
        else if (thing instanceof Plant){
            plant = (Plant)thing;
        }
        else{
            cWeather = (CentralWeather)thing;
        }
    }",Place an actor into the grid.,Grid.java,606.0,3
1,"public void setWater()
    {
        water = new WaterTile();
    }",Place a watertile into the grid.,Grid.java,606.0,3
2,"public void setWeather(int rainFallValue,int fogValue)
    {
        weather = new WeatherTile(rainFallValue,fogValue);
    }","Place a weathertile into the grid.
@param rainFallValue, how much rain the tile will give to the plant.",Grid.java,606.0,3
3,"public Animal getAnimal()
    {
        if(animal!=null&&animal.canAct()){
            return animal;
        }
        return null;
    }",@return the living animal in the grid,Grid.java,606.0,3
4,"public WaterTile getWater()
    {
        return water;
    }",@return the watertile,Grid.java,606.0,3
5,"public WeatherTile getWeather()
    {
        return weather;
    }",@return the weathertile,Grid.java,606.0,3
6,"public CentralWeather getCWeather()
    {
        return cWeather;
    }",@return the centre point of weather,Grid.java,606.0,3
7,"public Plant getPlant()
    {
        if(plant!=null&&plant.canAct()){
            return plant;
        }
        return null;
    }",@return the living plant in the grid,Grid.java,606.0,3
8,"public void clear()
    {
        animal = null;
        plant = null;
        water = null;
        weather = null;
        cWeather = null;
    }",Set to empty grid,Grid.java,606.0,3
9,"public void clearAnimal()
    {
        animal = null;
    }",No animal in this grid,Grid.java,606.0,3
10,"public void clearPlant()
    {
        plant = null;
    }",No plant in this grid,Grid.java,606.0,3
11,"public void clearWeather()
    {
        weather = null;
    }",No weather in this grid,Grid.java,606.0,3
12,"public void clearCWeather()
    {
        cWeather=null;
    }",No central weather in this grid,Grid.java,606.0,3
0,"public void act(List<LivingThing> things)
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {  
        decrementRainFallValue();
        if(canAct()){
            Location newLocation = getField().freeAdjacentWeatherLocation(getLocation());
            if(newLocation!=null){
                setLocation(newLocation);
            }
            spread();
        }
    }","Simulate the movement of the cloud.
Only the mid point will move and every time it moves to a new location the mid point will spread.
@param things to have the same signature to override the act method from the ActingThing class.",CentralWeather.java,606.0,3
1,"public void spread()
    {
        Location mid = getLocation();
        Field field = getField();
        field.setWeather(mid,rainFallValue,fogValue);
        //basically drawing a circle but with random radii
        for(int i=0;i<=360;i+=5){
            double angle = Math.toRadians(i);
            int r = rand.nextInt(maximum_size-minimum_size+1)+minimum_size;
            int spreadRainFallValue = rainFallValue;
            //set the weather from inside to the outside
            for(int k=1;k<=r;k++){
                //decay the rain fall value
                spreadRainFallValue = rand.nextInt(spreadRainFallValue/2+1)+spreadRainFallValue/2;
                //cos(angle)=x/r
                //x is how many grids to the right
                int x = (int)(Math.round(k*Math.cos(angle)));
                //sin(angle)=y/r
                //y is how many grids to the bottom
                int y = (int)(Math.round(k*Math.sin(angle)));
                //check if the location is outside the field
                if(!(mid.getRow()+y<0||mid.getCol()+x<0||mid.getRow()+y>=field.getDepth()||mid.getCol()+x>=field.getWidth())){
                    Location location = new Location(mid.getRow()+y,mid.getCol()+x);
                    if(!field.hasWeather(mid.getRow()+y,mid.getCol()+x)){
                        field.setWeather(location, spreadRainFallValue,fogValue);
                    }

                }
            }
        }
    }",The mid point will set the weather with a decaying rain fall value in a random shape(a circle like shape).,CentralWeather.java,606.0,3
2,"private void decrementRainFallValue()
    {
        rainFallValue *=0.98;
        if(rainFallValue<20){
            getField().clearCentralWeather(getLocation());
            remove();
            counter--;
        }
    }","Decay the rain fall value of the mid point.
This can result in the removal of the cloud.",CentralWeather.java,606.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(getLocation() != null) {
            getField().clearCentralWeather(getLocation());
        }
        super.setLocation(newLocation);
    }",Allow the mid point to move from original location to a new location,CentralWeather.java,606.0,3
4,"public static int getCounter()
    {
        return counter;
    }",@return the number of clouds remaining in the field.,CentralWeather.java,606.0,3
0,"private void giveBirth(Animal animal,List<LivingThing> newAnimals) 
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        // New animals are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = animal.getField();
        DateTime dateTime = animal.getDateTime();
        List<Location> free = field.getFreeAdjacentLocations(animal.getLocation());

        int births = breed(animal);
        //all animals breed in the same way
        for(int b = 0; b < births && free.size() > 0&&free.size()-b>=births; b++) {
            Location loc = free.remove(0);
            Class[] paraType= new Class[4];
            paraType[0]=boolean.class;
            paraType[1]=Field.class;
            paraType[2]=Location.class;
            paraType[3]=DateTime.class;
            //only know the actural type of the animal at runtime
            //create a new object by the constructor
            Animal newAnimal = animal.getClass().getDeclaredConstructor(paraType).newInstance(false,field,loc,dateTime);
            newAnimals.add(newAnimal);
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newAnimals A list to return newly born animals.",Female.java,606.0,3
1,"private int breed(Animal animal)
    {
        int births = 0;
        if(canBreed(animal) && isOppositeSexNearBy(animal)&&rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;

        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Female.java,606.0,3
2,"public Location behave(Animal animal,List<LivingThing> newAnimals) 
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        giveBirth(animal, newAnimals);
        //no movement
        return null;
    }","Female give births.
@return null as no movement is created.",Female.java,606.0,3
0,"public void act(List<LivingThing> newPlants)
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        incrementAge();

        if(canAct()) { 
            if(isSunny()){
                sunLevel=max_sunLevel;
            }

            incrementWaterLevel();

            grow(newPlants);
        }
    }","Make this plant act - that is to get water,get sun light and grow.
@param newPlants A list to receive newly born Plants.",Plant.java,606.0,3
1,"private void grow(List<LivingThing> newPlants)
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        // New plants are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        DateTime dateTime = getDateTime();
        List<Location> free = field.getFreeAdjacentPlantLocations(getLocation());

        int births = breed();
        //all plants grow in the same way
        for(int b = 0; b < births && free.size() > 0&&free.size()-b>=births; b++) {
            Location loc = free.remove(0);
            Class[] paraType= new Class[4];
            paraType[0]=boolean.class;
            paraType[1]=Field.class;
            paraType[2]=Location.class;
            paraType[3]=DateTime.class;
            //only know the actural type of the plant at runtime
            //create a new object by the constructor
            Plant newPlant = this.getClass().getDeclaredConstructor(paraType).newInstance(false,field,loc,dateTime);
            newPlants.add(newPlant);
        }
    }","Make this plant grow- reproduce same type of plants in the free adjacent grids.
@param newPlants A list to receive newly born Plants.",Plant.java,606.0,3
2,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= breeding_Probability) {
            births = rand.nextInt(max_litter_size) + 1;

        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Plant.java,606.0,3
3,"protected boolean canBreed()
    {
        return getAge() >= breeding_age&&isSunny();
    }",@return true if breeding age is meeted and the weather is sunny in the grid.,Plant.java,606.0,3
4,"private boolean isSunny()
    {
        Field field = getField();
        WeatherTile weather = field.getWeatherAt(getLocation());
        return getDateTime().isDay()&&weather==null;
    }",@return true if the weather is sunny in the grid.,Plant.java,606.0,3
5,"protected void setData(int foodValue,int max_age,int max_sunLevel, int max_waterLevel, int max_litter_size, double breeding_Probability)
    {
        setData(foodValue, max_age);
        this.max_sunLevel = max_sunLevel;
        this.max_waterLevel=max_waterLevel;
        this.max_litter_size=max_litter_size;
        this.breeding_Probability=breeding_Probability;
        breeding_age= (int) (max_age*0.1);
        sunLevel=max_sunLevel;
        waterLevel=max_waterLevel;
    }",Set the data of the plant once the type is known.,Plant.java,606.0,3
6,"protected void setRandomAge()
    {
        super.setRandomAge();
        sunLevel = rand.nextInt(max_sunLevel);
        waterLevel= rand.nextInt(max_waterLevel);
    }",Set random age for the simulation to start,Plant.java,606.0,3
7,"private void decrementLevel()
    {
        waterLevel--;
        sunLevel--;
        if(sunLevel<=0||waterLevel<=0){
            setDead();
        }

    }","Decrease the water and sun levels of the plant.
This can result in the plant's death.",Plant.java,606.0,3
8,"private void incrementWaterLevel()
    {
        Field field = getField();
        WeatherTile weather = field.getWeatherAt(getLocation());
        if(weather!=null){
            waterLevel+=weather.getRainFallValue();
            if(waterLevel>max_waterLevel){
                waterLevel=max_waterLevel;
            }
        }

    }",Simulate the plant gets water from the rain.,Plant.java,606.0,3
0,"public void showStatus(DateTime dateTime, Field field)
    {
        super.showStatus(dateTime,field);

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object thing=field.getPlantAt(row, col);
                if(thing != null) {
                    stats.incrementCount(thing.getClass());
                    fieldView.drawMark(col, row, getColor(thing.getClass()));
                }
                else if ((thing = field.getWaterAt(row, col))!= null) {
                    fieldView.drawMark(col, row, getColor(thing.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }

            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",PlantView.java,606.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,606.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,GridView.java,606.0,3
2,"protected Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,606.0,3
3,"public void showStatus(DateTime dateTime, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + dateTime.getStep()+""    ""+dateTime.getDateTime());
        stats.reset();

        fieldView.preparePaint();

        
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GridView.java,606.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,606.0,3
5,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,606.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,606.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,606.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,606.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,606.0,3
0,"public void showStatus(DateTime dateTime, Field field)
    {
        super.showStatus(dateTime,field);

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                WeatherTile thing=field.getWeatherAt(row, col);
                if(thing != null) {
                    stats.incrementCount(thing.getClass());
                    fieldView.drawMark(col, row, getColor(thing));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }

            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",WeatherView.java,606.0,3
0,"public void showStatus(DateTime dateTime, Field field)
    {
        super.showStatus(dateTime,field);

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object thing=field.getAnimalAt(row, col);
                if(thing != null) {
                    stats.incrementCount(thing.getClass());
                    fieldView.drawMark(col, row, getColor(thing.getClass()));
                }

                else if ((thing = field.getWaterAt(row, col))!= null) {
                    fieldView.drawMark(col, row, getColor(thing.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }

            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",AnimalView.java,606.0,3
0,"public void runLongSimulation()
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,606.0,3
1,"public void simulate(int numSteps)
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {

        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }

    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,606.0,3
2,"public void simulateOneStep()
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        dateTime.increment();

        field.clearAllWeather();

        if(CentralWeather.getCounter()<=5)
        {
            things.addAll(field.fillWeather(NUMBER_OF_CLOUD,CLOUD_MAX_SIZE,CLOUD_MIN_SIZE,dateTime));
        }
        // Provide space for newborn living things
        List<LivingThing> newThings = new ArrayList<>();   
        // Let all actors act.
        for(Iterator<ActingThing> it = things.iterator(); it.hasNext(); ) {
            ActingThing thing = it.next();
            thing.act(newThings);
            if(! thing.canAct()) {
                it.remove();
            }
        }

        // Add the newly born living things to the main lists.
        things.addAll(newThings);
        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
actors.",Simulator.java,606.0,3
3,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(dateTime, field);
        }
    }",update all the views,Simulator.java,606.0,3
4,"public void reset()
    {
        dateTime.reset();
        things.clear();
        populate();
        // Show the starting state in the view.
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,606.0,3
5,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        field.fillWater(NUMBER_OF_WATERBODY,WATER_MAX_SIZE,WATER_MIN_SIZE);
        things.addAll(field.fillWeather(NUMBER_OF_CLOUD,CLOUD_MAX_SIZE,CLOUD_MIN_SIZE,dateTime));
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Location location = new Location(row, col);
                if(!field.hasWater(location)){
                    if(rand.nextDouble() <= WILDDOG_CREATION_PROBABILITY) {
                        WildDog wildDog = new WildDog(true, field, location,dateTime);
                        things.add(wildDog);
                    }
                    else if(rand.nextDouble() <= HARE_CREATION_PROBABILITY) {
                        Hare hare = new Hare(true, field, location,dateTime);
                        things.add(hare);
                    }
                    else if(rand.nextDouble() <= WARTHOG_CREATION_PROBABILITY) {
                        Warthog warthog = new Warthog(true, field, location,dateTime);
                        things.add(warthog);
                    }
                    else if(rand.nextDouble() <= HYENA_CREATION_PROBABILITY){
                        Hyena hyena = new Hyena(true, field, location,dateTime);
                        things.add(hyena);
                    }
                    else if(rand.nextDouble() <= WILDEBEEST_CREATION_PROBABILITY){
                        WildeBeest wildBeest = new WildeBeest(true, field, location,dateTime);
                        things.add(wildBeest);
                    }
                    else if(rand.nextDouble() <= TOPI_CREATION_PROBABILITY){
                        Topi topi = new Topi(true, field, location,dateTime);
                        things.add(topi);
                    }
                    else if(rand.nextDouble() <= LION_CREATION_PROBABILITY){
                        Lion lion = new Lion(true, field, location,dateTime);
                        things.add(lion);
                    }
                    if(rand.nextDouble() <= STARGRASS_CREATION_PROBABILITY){
                        StarGrass starGrass = new StarGrass(true, field, location,dateTime);
                        things.add(starGrass);
                    }
                    else if(rand.nextDouble() <= REDOATGRASS_CREATION_PROBABILITY){
                        RedOatGrass redOatGrass = new RedOatGrass(true, field, location,dateTime);
                        things.add(redOatGrass);
                    }

                }
                // else leave the location empty.
            }
        }

    }","Randomly fill the field with animals,plants,water,weather.",Simulator.java,606.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,606.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,606.0,3
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,606.0,3
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,606.0,3
3,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,606.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,606.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,606.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object thing=field.getAnimalAt(row, col);;
               
                if(thing != null) {
                    incrementCount(thing.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,606.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,606.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,606.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,606.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,606.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,606.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,606.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,606.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,606.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,606.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,606.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,606.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,606.0,3
0,"public Location behave(Animal animal,List<LivingThing> newAnimals)
    {

        if(canBreed(animal)){
            Field field =animal.getField();
            Location loc = animal.getLocation();
            Location targetLoc = nearestFemale(animal);
            if(targetLoc!=null){
                return field.shortestWayFirstStep(loc, targetLoc, animal.getHuntingDistance());
            }

        }

        return null;
    }","A male will find a female and breed.
@return the best movement to find the nearest female.",Male.java,606.0,3
1,"private Location nearestFemale(Animal animal)
    {
        Field field = animal.getField();
        for(int i =1;i<=animal.getHuntingDistance();i++){
            List<Location> adjacent = field.adjacentLocations(animal.getLocation(),i);
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Animal mate = (Animal)field.getAnimalAt(where);
                if(mate!=null){
                    if(mate.getGender().canBreed(mate)){
                        if(mate.getGender() instanceof Female&& mate.getClass().equals(animal.getClass())) {
                            if(mate.canAct()) { 
                                return mate.getLocation();
                            }
                        }
                    }
                }

            }

        }
        return null;
    }","Search for a female within the hunting distance.
Only the first found female will be located.
@return the location of the nearest female.",Male.java,606.0,3
0,"protected boolean canBreed(Animal animal)
    {
        return animal.getAge() >= breeding_age && animal.getAge()<=breeding_end;
    }",@return true if the animal's age is between breeding_age and breeding_end.,Gender.java,606.0,3
1,"protected boolean isOppositeSexNearBy(Animal animal)
    {
        Field field = animal.getField();
        List<Location> adjacent = field.adjacentLocations(animal.getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Animal mate = (Animal)field.getAnimalAt(where);
            if(mate!=null){
                if(animal.getGender() instanceof Male){
                    if(mate.getGender().canBreed(mate)){
                        if(mate.getGender() instanceof Female&& mate.getClass().equals(animal.getClass())) {
                            if(mate.canAct()) { 
                                return true;
                            }
                        }
                    }
                }
                else{
                    if(mate.getGender().canBreed(mate)){
                        if(mate.getGender() instanceof Male&& mate.getClass().equals(animal.getClass())) {
                            if(mate.canAct()) { 
                                return true;
                            }
                        }
                    }
                }

            }

        }
        return false;
    }",@return true if the animal has same type and different gender animal in the adjacent grid.,Gender.java,606.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col].clear();
            }
        }
    }",Empty the field.,Field.java,606.0,3
1,"public void clearAnimal(Location location)
    {
        field[location.getRow()][location.getCol()].clearAnimal();
    }","Clear the animal in given location.
@param location The location to clear.",Field.java,606.0,3
2,"public void clearPlant(Location location)
    {
        field[location.getRow()][location.getCol()].clearPlant();
    }","Clear the plant in given location.
@param location The location to clear.",Field.java,606.0,3
3,"public void clearWeather(Location location)
    {
        field[location.getRow()][location.getCol()].clearWeather();
    }","Clear the weather in given location.
@param location The location to clear.",Field.java,606.0,3
4,"public void clearCentralWeather(Location location)
    {
        field[location.getRow()][location.getCol()].clearCWeather();
    }","Clear the weather mid point  in given location.
@param location The location to clear.",Field.java,606.0,3
5,"public void place(ActingThing thing, int row, int col)
    {
        place(thing, new Location(row, col));
    }","Place an actor at the given location.
@param thing The actor to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,606.0,3
6,"public void place(ActingThing thing, Location location)
    {
        field[location.getRow()][location.getCol()].place(thing);
    }","Place an actor at the given location.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,606.0,3
7,"public Animal getAnimalAt(Location location)
    {
        return getAnimalAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,606.0,3
8,"public Animal getAnimalAt(int row, int col)
    {
        return field[row][col].getAnimal();
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,606.0,3
9,"public Plant getPlantAt(Location location)
    {
        return getPlantAt(location.getRow(), location.getCol());
    }","Return the plant at the given location, if any.
@param location Where in the field.
@return The plant at the given location, or null if there is none.",Field.java,606.0,3
10,"public WaterTile getWaterAt(Location location)
    {
        return getWaterAt(location.getRow(), location.getCol());
    }","Return the water at the given location, if any.
@param location Where in the field.
@return The water at the given location, or null if there is none.",Field.java,606.0,3
11,"public WaterTile getWaterAt(int row, int col)
    {
        return field[row][col].getWater();
    }","Return the water at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The water at the given location, or null if there is none.",Field.java,606.0,3
12,"public WeatherTile getWeatherAt(int row, int col)
    {
        return field[row][col].getWeather();
    }","Return the weather at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The weather at the given location, or null if there is none.",Field.java,606.0,3
13,"public WeatherTile getWeatherAt(Location location)
    {
        return getWeatherAt(location.getRow(), location.getCol());
    }","Return the weather at the given location, if any.
@param location Where in the field.
@return The weather at the given location, or null if there is none.",Field.java,606.0,3
14,"public CentralWeather getCWeatherAt(Location location)
    {
        return field[location.getRow()][ location.getCol()].getCWeather();
    }","Return the centre weather at the given location, if any.
@param location Where in the field.
@return The centre weather at the given location, or null if there is none.",Field.java,606.0,3
15,"public Plant getPlantAt(int row, int col)
    {
        return field[row][col].getPlant();
    }","Return the plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The plant at the given location, or null if there is none.",Field.java,606.0,3
16,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,606.0,3
17,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getAnimalAt(next) == null&&getWaterAt(next)==null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations for animal
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,606.0,3
18,"public List<Location> getFreeAdjacentPlantLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getPlantAt(next) == null&&getWaterAt(next)==null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations for plants.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,606.0,3
19,"private List<Location> getFreeAdjacentWeatherLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getCWeatherAt(next)==null ) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations for central weathers(only mid point will move)
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,606.0,3
20,"public Location freeAdjacentWeatherLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentWeatherLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location for central weather that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,606.0,3
21,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location for animal that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,606.0,3
22,"public List<Location> adjacentLocations(Location location,int distance)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -distance; roffset <= distance; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -distance; coffset <= distance; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            if(nextRow==row-distance || nextCol == col-distance || nextRow==row+distance|| nextCol == col+distance){
                                locations.add(new Location(nextRow, nextCol));
                            }
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of outer layer locations of the given distance of the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@param distance how many grids away from the location.
@return A list of locations adjacent to that given.",Field.java,606.0,3
23,"public List<Location> adjacentLocations(Location location)
    {
        return adjacentLocations(location,1);
    }","Return a shuffled list of adjacent locations of the given one
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,606.0,3
24,"public boolean isValid(Location location)
    {
        return location.getRow()>=0&&location.getRow()<depth&&location.getCol()>=0&&location.getCol()<width;
    }",@return true if the location is lie within the field.,Field.java,606.0,3
25,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,606.0,3
26,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,606.0,3
27,"public Location shortestWayFirstStep(Location slocation,Location dlocation,int size)
    {
        Queue<LocationNode> queue = new LinkedList<>();
        LocationNode [][] nodes= new LocationNode[depth][width];
        queue.add(new LocationNode(slocation.getRow(),slocation.getCol(),0));
        boolean[][] visited = new boolean[depth][width];
        visited[slocation.getRow()][slocation.getCol()]=true;
        Location newdlocation = freeAdjacentLocation(dlocation);//because the target occupied the dlocation
        while(newdlocation==null){
            dlocation =randomAdjacentLocation(dlocation);
            newdlocation = freeAdjacentLocation(dlocation);
        }

        while(!queue.isEmpty()){
            LocationNode currentNode= queue.remove();

            if (currentNode.equals(newdlocation)){
                return recursiveFindNode(nodes,currentNode);
            }
            //To avoid a bad path and searching through the entire field
            if(currentNode.getDistance()>size){
                return null;
            }
            for(Location l:getFreeAdjacentLocations(currentNode)){
                if(!visited[l.getRow()][l.getCol()]){
                    visited[l.getRow()][l.getCol()]=true;
                    LocationNode x = new LocationNode(l.getRow(),l.getCol(),currentNode.getDistance()+1);
                    queue.add(x);
                    nodes[l.getRow()][l.getCol()]=x;
                }
            }
        }
        //no possible path
        return null;
    }","Find the shortest way from one location to one location.
By using the BFS algorithm, search until the search layer is equal to the size given or the destination is found.
Each grid that is free with in the size will be given a distance(how many grids away) from the source location.
The goal is to find a shortest path to the target.
But since the animal can only walk a grid away so only the first step is required.
Why not find a move with the shortest distance to the target just like the runAway method in the animal class?
This is because that method will not ensure a path to the target as the future movements of that method can be blocked.

Not a efficient algorithm so need to keep the size low.
@param slocation the source location
@param dlocation the destination
@param size the search size, that is how many layers to search.
E.g. The destination is two grids away amd the shortest path may require the animal to walk to 10 grids away,
if the size is 6, this method will stop searching at 7 grids away and say not possible to move to that location with this searching size.
@return The first step of the shortest path to the target, return null if the target is unreachable within the size.",Field.java,606.0,3
28,"private Location recursiveFindNode(LocationNode[][] nodes,LocationNode node)
    {
        //stop when found
        if(node.getDistance()==1){
            return new Location(node.getRow(),node.getCol());
        }
        else{
            //find a node with one less distance and call the method again
            List<Location> freeLocs= getFreeAdjacentLocations(node);
            for(Location L: freeLocs){
                LocationNode n = nodes[L.getRow()][L.getCol()];
                if(n!=null&&n.getDistance()==(node.getDistance() -1)){
                    return recursiveFindNode(nodes,n );
                }
            }
            //should never reach here as there must be a node with one less distance
            return null;
        }
    }","Find the location that has distance of 1 after the destination node is found
@param nodes all visited nodes are in the array, the unvisited one will be null;
@param node the current node, at the start it will be the destination node
@return the location with distance is 1 from the starting node.",Field.java,606.0,3
29,"public void fillWater(int number_of_waterbody,int maximum_size,int minimum_size)
    {
        for(int i=0;i<number_of_waterbody;i++){
            int size = rand.nextInt(maximum_size-minimum_size+1)+minimum_size;
            Location randomLocation = new Location(rand.nextInt(depth),rand.nextInt(width));
            recursiveSetWaterInGrid(randomLocation, size);
        }

    }","Fill the field with random number of WaterTile of random shape for the simulation to start
@param maximum_size the maximum number of tiles of one water body
@param minimum_size the minimum number of tiles of one water body",Field.java,606.0,3
30,"public List<CentralWeather> fillWeather(int number_of_cloud,int maximum_size,int minimum_size,DateTime dateTime)
    {
        List<CentralWeather> weathers= new LinkedList<>();
        for(int j=0;j<number_of_cloud;j++){
            int midRainFallValue = rand.nextInt(200)+150;
            int fogValue = rand.nextInt(8)+1;
            Location mid = new Location(rand.nextInt(depth),rand.nextInt(width));

            CentralWeather midWeather = new CentralWeather(this,mid,dateTime,midRainFallValue,fogValue,maximum_size,minimum_size);
            field[mid.getRow()][mid.getCol()].place(midWeather);
            midWeather.spread();
            weathers.add(midWeather);

        }
        return weathers;
    }","Fill the field with random centre of cloud
And then create cloud shape by calling the spread method int CentralWeather class.
@param maximum_size the maximum radius of a cloud
@param minimum_size the minimum radius of a cloud
@return a list of the centre of cloud for the simulotor to call act method.",Field.java,606.0,3
31,"protected boolean hasWeather(int row,int col)
    {
        return field[row][col].getWeather()!=null;
    }",@return true if the gird has cloud.,Field.java,606.0,3
32,"private void recursiveSetWaterInGrid(Location location,int size)
    {
        if(size == 0||location ==null){//end if meet the size or walk to a dead end
            return;
        }
        else{
            field[location.getRow()][location.getCol()].setWater();
            recursiveSetWaterInGrid(freeAdjacentLocation(location), size-1);
        }
    }","Perform a random walk and fill the walk path with water tiles
Stop when walk to a dead end or the size is meeted.
@param location the current location of the walk, if it is null a dead end is reach.
@param size the maximum size of the waterbody.",Field.java,606.0,3
33,"public void setWeather(Location location,int rainFallValue,int fogValue)
    {
        field[location.getRow()][location.getCol()].setWeather(rainFallValue,fogValue);
    }",Set a weathertile in a grid.,Field.java,606.0,3
34,"public boolean hasWater(Location location)
    {
        return field[location.getRow()][location.getCol()].getWater()!=null;
    }",@return true if the location has water,Field.java,606.0,3
35,"public double getDistance(Location a,Location b)
    {
        return Math.sqrt(Math.pow(a.getCol()- b.getCol(),2)+Math.pow(a.getRow()- b.getRow(),2));
    }",@return distance between two points,Field.java,606.0,3
36,"public void clearAllWeather()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col].clearWeather();
            }
        }
    }",clear all weathertile in the field but not the centre weather,Field.java,606.0,3
0,"public void increment()
    {
        step++;
        time++;
        if(time>=24){
            date++;
            time=0;
        }

    }","increment the step, date and time",DateTime.java,606.0,3
1,"public String getDateTime()
    {
        if(time<10){
            return ""Day: ""+date +"" 0""+time+"":00"";
        }
        else{
            return ""Day: ""+date +"" ""+ time+"":00"";
        }
    }",@return the date and time in this format: Day: 5 14:00,DateTime.java,606.0,3
2,"public int getStep()
    {
        return step;
    }",@return the current step,DateTime.java,606.0,3
3,"public void reset()
    {
        date = 0;
        time = 0;
        step = 0;
    }",set the time to the start which is 0,DateTime.java,606.0,3
4,"public boolean isDay()
    {
        return time>=DAY_START&&time<=DAY_END;
    }",@return true if the time is between day start and end.,DateTime.java,606.0,3
0,"public void act(List<LivingThing> newAnimals)
    throws java.lang.reflect.InvocationTargetException,IllegalAccessException,InstantiationException,NoSuchMethodException
    {
        incrementThristy();
        incrementAge();
        incrementHunger();
        if(getDisease()!=null){
            getDisease().act(this);
        }
        currentHuntingDistance=bestHuntingDistance;
        if(canAct()) {      
            affectedbyFog();
            Location newLocation;
            Location predatorLocation = senseDanger();
            if(predatorLocation!=null){
                newLocation = runAwayFrom(predatorLocation);
            }
            else if(isThristy()){
                //Move towards a source of water if found.
                newLocation = findWater();
            }
            else if(isHungry()){
                // Move towards a source of food if found.
                newLocation= findFood();
            }
            else{
                newLocation =gender.behave(this,newAnimals);
            }
            if(newLocation == null) { 
                // No movement - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","Make this animal act - that is to eat,drink,breed,run
@param newAnimals A list to receive newly born animals.",Animal.java,606.0,3
1,"private Location findFood()
    {
        Field field = getField();
        for(int i =1;i<=currentHuntingDistance;i++){
            List<Location> adjacent = field.adjacentLocations(getLocation(),i);
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Animal animal = field.getAnimalAt(where);
                Plant plant = field.getPlantAt(where); 
                if(canEat(animal)) {
                    if(i==1){
                        return eat(animal);
                    }
                    else{
                        //Move towards the animal
                        return field.shortestWayFirstStep(getLocation(), animal.getLocation(), currentHuntingDistance);
                    }
                }
                else if(canEat(plant)){
                    if(i==1){
                        return eat(plant);
                    }
                    else{
                        //Move towards the plant
                        return field.shortestWayFirstStep(getLocation(), plant.getLocation(), currentHuntingDistance);
                    }
                }
            }
        }
        return null;
    }","Look for all living things within the hunting distance to the current location.
Only the first living thing is eaten.
@return Where food was found, or null if it wasn't.",Animal.java,606.0,3
2,"private Location findWater()
    {
        Field field = getField();
        for(int i =1;i<=currentHuntingDistance*3;i++){
            List<Location> adjacent = field.adjacentLocations(getLocation(),i);
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                WaterTile water = field.getWaterAt(where);
                if(water!=null){
                    if(i==1){
                        thirstyLevel=max_thirstyLevel;
                        if(water.getDisease()!=null){
                            setDisease(water.getDisease());
                        }
                    }
                    else{
                        //Move towards the water source
                        return field.shortestWayFirstStep(getLocation(), where, currentHuntingDistance*3);
                    }
                }

            }
        }
        return null;
    }","Look for waters within the hunting distance*3 to the current location.
Only the first water found will be located
@return Where water was found, or null if it wasn't.",Animal.java,606.0,3
3,"private Location senseDanger()
    {
        Field field = getField();
        //it is less likely for the prey to see the predator
        int awareDistance = rand.nextInt(currentHuntingDistance+1)/2;
        for(int i =1;i<=awareDistance;i++){
            List<Location> adjacent = field.adjacentLocations(getLocation(),i);
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Animal animal = field.getAnimalAt(where);
                if(animal!=null&&predators.contains(animal.getClass())){
                    return animal.getLocation();
                }

            }
        }
        return null;
    }","Look for predator within the aware distance to the current location.
Only the first predator found will be located
@return Where predator was found, or null if it wasn't.",Animal.java,606.0,3
4,"private Location runAwayFrom(Location predatorLocation)
    {
        List<Location> possibleMoves = getField().getFreeAdjacentLocations(getLocation());
        if(possibleMoves.size()==0){
            //all adjacent grids are occupied
            //try to see if the animal can eat the adjacent animals to run
            return findFood();
        }
        double greatestDistance = 0;
        int index=0;
        for(int i=0;i<possibleMoves.size();i++){
            double distance= getField().getDistance(possibleMoves.get(i), predatorLocation);
            if(distance>greatestDistance){
                index = i;
                greatestDistance = distance;
            }
        }
        return possibleMoves.get(index);
    }","Find the best possible location to stay away from the predator
@return a free location that has the greatest distance from the predator.",Animal.java,606.0,3
5,"private boolean canEat(LivingThing thing)
    {
        if(thing==null){
            return false;
        }

        return foodSource.contains(thing.getClass());
    }","Check if the animal can eat the given living entity.
@param A living entity (can be null)
@return true if it can eat the thing.",Animal.java,606.0,3
6,"private Location eat(LivingThing thing)
    {
        if(thing.canAct()) { 
            thing.setDead();
            if(thing.getDisease()!=null){
                setDisease(thing.getDisease());
            }
            foodLevel += thing.getFoodValue();
            if(foodLevel> max_foodLevel){
                foodLevel = max_foodLevel;
            }

            return thing.getLocation();
        }
        return null;
    }","Simulate the eat action of an animal.
Kill the living thing and increase the food level of the animal.
@param A living entity
@return the location of the living thing",Animal.java,606.0,3
7,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();

        }
    }",Make this animal more hungry. This could result in the animal's death.,Animal.java,606.0,3
8,"protected void addFoodSource(Class thingClass)
    {
        foodSource.add(thingClass);
    }","add a food source for the animal
@param the class of an living entity that the animal will eat",Animal.java,606.0,3
9,"protected void addPredator(Class predatorClass)
    {
        predators.add(predatorClass);
    }","add a predator for the animal
@param the class of an living entity that will eat the animal",Animal.java,606.0,3
10,"protected Gender getGender()
    {
        return gender;
    }",@return the gender of the animal,Animal.java,606.0,3
11,"protected boolean isHungry()
    {
        return (foodLevel<=0.6*max_foodLevel);
    }",@return true if the animal is hungry,Animal.java,606.0,3
12,"protected boolean isThristy()
    {
        return (thirstyLevel<=0.3*max_thirstyLevel);
    }",@return true if the animal is thristy,Animal.java,606.0,3
13,"protected void incrementThristy()
    {
        thirstyLevel--;
        if(thirstyLevel<=0){
            setDead();

        }
    }",Make this animal more thristy. This could result in the animal's death.,Animal.java,606.0,3
14,"private void setGender(int max_litter_size,double breeding_probability)
    {
        int breeding_age= (int)Math.round(getMaxAge()*0.2);
        int breeding_end= (int)Math.round(getMaxAge()*0.8);
        if(rand.nextInt(2)==0){
            gender = new Male( breeding_age,breeding_end);
        }
        else{
            gender = new Female(breeding_age,breeding_end,max_litter_size,breeding_probability);
        } 
    }","Set the gender of the animal.
50% chance being a male,50% chance being a female.
@param the maximum children an animal can have, the probability of breeding",Animal.java,606.0,3
15,"protected void setRandomAge()
    {
        super.setRandomAge();
        foodLevel = rand.nextInt(max_foodLevel);
        thirstyLevel=  rand.nextInt(max_thirstyLevel);
    }",Set up randomAge for the simulation starting point,Animal.java,606.0,3
16,"protected void setData(int foodValue,int max_age,int max_foodLevel,int max_thirstyLevel,int huntingDistance,int max_litter_size,double breeding_probability)
    {
        setData(foodValue, max_age);
        this.max_foodLevel=max_foodLevel;
        this.max_thirstyLevel=max_thirstyLevel;
        this.bestHuntingDistance= huntingDistance;
        currentHuntingDistance=bestHuntingDistance;
        setGender(max_litter_size,breeding_probability);
        foodLevel = max_foodLevel;
        thirstyLevel= max_thirstyLevel;

    }",Set the data of the animal once the type is known.,Animal.java,606.0,3
17,"protected void setLocation(Location newLocation)
    {
        if(getLocation() != null) {
            getField().clearAnimal(getLocation());
        }
        super.setLocation(newLocation);
    }","Allow movement in the field by
setting the animal's location.",Animal.java,606.0,3
18,"protected int getHuntingDistance()
    {
        return currentHuntingDistance;
    }",@return the hunting distance of the animal.,Animal.java,606.0,3
19,"protected void setHuntingDistance(int huntingDistance)
    {
        this.bestHuntingDistance= huntingDistance;
    }",Allow changing the hunting distance of the animal.,Animal.java,606.0,3
21,"private void affectedbyFog()
    {
        Field field =getField();
        Location location = getLocation();
        WeatherTile weather = field.getWeatherAt(location);
        if(weather !=null){
            currentHuntingDistance=bestHuntingDistance-weather.getFogValue();
            if(currentHuntingDistance<1){
                currentHuntingDistance=1;
            }
        }
    }",Decrease the hunting distance by the fog,Animal.java,606.0,3
0,"protected boolean canAct()
    {
        return alive;
    }","Check whether the living entity is alive or not.
@return true if the living entity is still alive.",LivingThing.java,606.0,3
1,"protected void setDead()
    {
        alive = false;
        if(getLocation() != null) {
            if(this instanceof Animal){
                getField().clearAnimal(getLocation());
            }
            else{
                getField().clearPlant(getLocation());
            }
            remove();
        }
    }","Indicate that the living entity is no longer alive.
It is removed from the field.",LivingThing.java,606.0,3
2,"protected int getFoodValue()
    {
        return foodValue;
    }",@return how much energy the living entity worth,LivingThing.java,606.0,3
3,"protected void incrementAge()
    {
        age++;
        if(age > max_age) {
            setDead();
        }
    }",Increase the age. This could result in the living entity's death.,LivingThing.java,606.0,3
4,"protected void setRandomAge()
    {
        age = rand.nextInt(max_age);
    }","Set a random age for the living entity.
Used for the starting of the simulation.",LivingThing.java,606.0,3
5,"protected void setData(int foodValue,int max_age)
    {
        this.foodValue = foodValue;
        this.max_age=max_age;
        age = 0;
    }",Set up the data for the living thing.,LivingThing.java,606.0,3
6,"protected int getMaxAge()
    {
        return max_age;
    }",@return the maximum age of the living thing.,LivingThing.java,606.0,3
7,"protected int getAge()
    {
        return age;
    }",@return the current age of the living thing.,LivingThing.java,606.0,3
8,"protected Disease getDisease()
    {
        return disease;
    }",@return the disease of the living thing (can be null),LivingThing.java,606.0,3
9,"protected void setDisease(Disease disease)
    {
        this.disease = disease;
    }","Give a disease to the living thing
@param disease a kind of disease",LivingThing.java,606.0,3
0,"protected Animal castAnimal(Object animal)
    {
        Bear bear = (Bear)animal;

        return bear;
    }","This method cast the object passed as a parameter to the type of the
class bear and returns the casted object.
@return Animal bear.",Bear.java,421.0,2
1,"protected Animal castPrey(Object animal)
    {
        Deer deer = (Deer) animal;

        return deer;
    }",Sets the prey - deer,Bear.java,421.0,2
2,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A bear can breed if it has reached the breeding age.,Bear.java,421.0,2
3,"protected int getMAX_AGE()
    {
        return MAX_AGE;
    }","This method returns the maximum age that a bear can reach.
@return int MAX_AGE",Bear.java,421.0,2
4,"protected int getAge()
    {
        return age;
    }","This method returns the age that a bear has.
@return int age",Bear.java,421.0,2
5,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","This method returns the breeding probability of a bear.
@return int BREEDING_PROBABILITY",Bear.java,421.0,2
6,"protected Random getRandom()
    {
        return rand;
    }","This method return the random factor created in the Bear class.
@return Random rand",Bear.java,421.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","This method returns the max litter size of a bear.
@return int MAX_LITTER_SIZE",Bear.java,421.0,2
8,"protected boolean isPrey(Object animal)
    {
        return (animal instanceof Deer);
    }","This method checks wheter the object passed in the method is an instance
of the type of prey that the bear hunts.
@return boolean value",Bear.java,421.0,2
9,"protected void updateFoodLevel()
    {
        foodLevel =  DEER_FOOD_VALUE;
    }",This method assigns the food value of the prey to the food level of each bear.,Bear.java,421.0,2
10,"protected int getFoodLevel()
    {
        return foodLevel;
    }","This method returns the food level of a bear at a given time.
@return int foodLevel",Bear.java,421.0,2
11,"protected String getGender()
    {
        return gender;
    }","This method returns the gender of each bear.
@return String gender",Bear.java,421.0,2
12,"protected boolean checkInstance(Object animal)
    {
        return (animal instanceof Bear);
    }","This method cheks if the object passed as a parameter is an instance of the
class Bear and returns a boolean value.
@return boolean value",Bear.java,421.0,2
0,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,421.0,2
1,"protected int getMAX_AGE()
    {
        return MAX_AGE;
    }","This method returns the maximum age that a rabbit can reach.
@return int MAX_AGE",Rabbit.java,421.0,2
2,"protected int getAge()
    {
        return age;
    }","This method returns the age of a rabbit.
@return int age",Rabbit.java,421.0,2
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","This method returns the breeding probability of the rabbit.
@return int BREEDING_PROBABILITY",Rabbit.java,421.0,2
4,"protected Random getRandom()
    {
        return rand;
    }","This method returns the random factor created in the Rabbit class.
@return Random rand.",Rabbit.java,421.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","This method return the max litter size of the rabbit.
@return int MAX_LITTER_SIZE",Rabbit.java,421.0,2
6,"protected String getGender()
    {
        return gender;
    }","This method returns the gender of each rabbit.
@return String gender",Rabbit.java,421.0,2
7,"protected boolean checkInstance(Object animal)
    {
        return (animal instanceof Rabbit);
    }","This method checks if the object passed as a parameter is an instance of this class.
and returns a boolean value as a result
@return true is the object is an instance of the class.",Rabbit.java,421.0,2
8,"protected Animal castAnimal(Object animal)
    {
        Rabbit rabbit = (Rabbit)animal;
        
        return rabbit;
    }","This method cast the object passed as a paramter to the type Rabbit and returns
the casted object.
@return Animal rabbit",Rabbit.java,421.0,2
9,"protected boolean isFood(Object plant)
    {
        return (plant instanceof Grass);
    }","This method checks if the object passed as a parameter is an instance of the rabbit's
food source.
@return true is the object is an instance of the rabbit's food source.",Rabbit.java,421.0,2
10,"protected Plant  castFood(Object plant)
    {
       Grass grass = (Grass) plant;
       
       return grass;
    }","This method cast the object passed as a paramter to the rabbit's food source type
and returns the casted object.",Rabbit.java,421.0,2
11,"protected void updateFoodLevel()
    {
        foodLevel = GRASS_FOOD_VALUE;
    }","This method updates the foodLevel of each rabbit by assigning the value of the food source
to the variable foodLevel",Rabbit.java,421.0,2
12,"protected int getFoodLevel()
    {
        return foodLevel;
    }","Returns the current food level of a rabbit.
@return int foodLevel",Rabbit.java,421.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,421.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,421.0,2
0,"public String getRandomWeather()
    {
        int randomIndex = random.nextInt(weatherList.size());
        String weather = weatherList.get(randomIndex);

        return weather;
    }","Returns a random weather condition from the ArrayList.

@return weather Random weather.",Weather.java,421.0,2
0,"public void populate(List<Actor> actors,Field field)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY ) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    actors.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY ) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    actors.add(rabbit);
                }
                else if(rand.nextDouble() <= WOLF_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Wolf wolf = new Wolf(true, field, location);
                    actors.add(wolf);
                }
                else if(rand.nextDouble() <= BEAR_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Bear bear = new Bear(true, field, location);
                    actors.add(bear);
                }
                else if(rand.nextDouble() <= DEER_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Deer deer = new Deer(true, field, location);
                    actors.add(deer);
                }
                else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Grass grass = new Grass(field, location);
                    actors.add(grass);
                }
                // else leave the location empty.
            }
        }
    }",This method randomly populated the field with various animals.,PopulationGenerator.java,421.0,2
1,"public void setColor(SimulatorView view)
    {
        view.setColor(Rabbit.class, Color.ORANGE);
        view.setColor(Fox.class, Color.BLUE);
        view.setColor(Wolf.class, Color.GRAY);
        view.setColor(Deer.class, Color.BLACK);
        view.setColor(Bear.class, Color.RED);
        view.setColor(Grass.class,Color.GREEN);
    }","This method sets the color of all the subclasses of the animal class.
The animals will be represented in the simulator by the color set by tis method.",PopulationGenerator.java,421.0,2
0,"public void incrementTime()
    {
        time ++;
    }",Increments the time by one every step.,Time.java,421.0,2
1,"public void setTime()
    {
        if(time == 20){
            changeTime();
            currentWeather = weather.getRandomWeather();
            time = 0;
        }
    }",Changes the time of day and weather conditions every 20 steps.,Time.java,421.0,2
2,"public String getCurrentWeather()
    {
        return currentWeather;
    }","Returns the current weather condition.

@return currentWeather The current weather condition",Time.java,421.0,2
3,"private void changeTime()
    {
        if(isNight == true)
        {
            isDay = true;
            isNight = false;
        }
        else if(isNight == false)
        {
            isDay = false;
            isNight = true;
        }
    }",Changes the time of day. This is called in the setTime method.,Time.java,421.0,2
4,"public boolean getNight()
    {
        return isNight;
    }","Checks whether it is night.

@return isNight Returns true during nighttime.",Time.java,421.0,2
0,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The animal's new location.",Plant.java,421.0,2
1,"public void act(List<Actor> newPlants)
    {
        incrementLifesSpan();
        if(simulator.getWeather() == ""rain""){
            generatePlants(newPlants);
        }
    }",This method implements the behaviour of a plant in the simulation.,Plant.java,421.0,2
2,"protected void generatePlants(List<Actor> newPlants)
    {
        Field field = getField();
       
        if(field!= null){
            List<Location> locations = getField().getFreeAdjacentLocations(getLocation());

            for(int i=0;locations.size()>0;i++)
            { 
                Location loc = locations.remove(0);
                Grass newGrass = new Grass(field, loc);
                newPlants.add(newGrass);
            }
        }
    }",This method generated new plants that will appear in the simualtor.,Plant.java,421.0,2
3,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,421.0,2
4,"protected Field getField()
    {
        return field;
    }",This method returns the field in which the plants's are created.,Plant.java,421.0,2
5,"public boolean isAlive()
    {
        return alive;
    }","Check whether the plants are stiil alive.
@return true if the plant is still alive.",Plant.java,421.0,2
6,"public void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","This method sets the boolean value alive of each plant object to false and
deletes the plant from the simulation.",Plant.java,421.0,2
7,"private void incrementLifesSpan()
    {
        int lifeSpan = getPlantAge();
        lifeSpan++;

        if(lifeSpan > getPlantMaxAge())
        {
            setDead();
        }
    }","This method increments the ""age"" of the plant. Each plant can be displayed in the simulator for a certain
amount of steps.This method is called every time the plant acts.",Plant.java,421.0,2
0,"public void act(List<Actor> newPrey)
    {
        incrementAge();
        incrementHunger();
        //An animal can act unless it is dead or during a blizzard.
        if(isAlive() && !simulator.getTime() && simulator.getWeather() != ""blizzard"") {
            //Animals cannot propagate when it is too hot.
            if(simulator.getWeather() != ""heat""){
                giveBirth(newPrey);
            }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Prey.java,421.0,2
1,"protected void incrementHunger()
    {
        int foodLevel = getFoodLevel();
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this animal more hungry. This could result in the animal's death.,Prey.java,421.0,2
2,"protected Location findFood()
    {
        List<Location> adjacent = getField().adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = getField().getObjectAt(where);
            if(isFood(plant)) {
                if(castFood(plant).isAlive())
                {
                    castFood(plant).setDead();
                    updateFoodLevel();
                    return where;
                }   
            }
        }
        return null;
    }","Look for plants adjacent to the current location.
@return Where food was found, or null if it wasn't.",Prey.java,421.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,421.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,421.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,421.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,421.0,2
0,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A deer can breed if it has reached the breeding age.
@return true if the deer can breed, false otherwise.",Deer.java,421.0,2
1,"protected int getMAX_AGE()
    {
        return MAX_AGE;
    }","This method returns the maximum age that a deer can reach.
@return int MAX_AGE",Deer.java,421.0,2
2,"protected int getAge()
    {
        return age;
    }","This method returns the age of a deer.
@return int age",Deer.java,421.0,2
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","This method returns the breeding probability of the deer.
@return int BREEDING_PROBABILITY",Deer.java,421.0,2
4,"protected Random getRandom()
    {
        return rand;
    }","This method returns the random factor created in the deer class.
@return Random rand.",Deer.java,421.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","This method return the max litter size of the deer.
@return int MAX_LITTER_SIZE",Deer.java,421.0,2
6,"protected String getGender()
    {
        return gender;
    }","This method returns the gender of each deer.
@return String gender",Deer.java,421.0,2
7,"protected boolean checkInstance(Object animal)
    {
        return (animal instanceof Deer);
    }","This method checks if the object passed as a parameter is an instance of the
class Deer and returns a boolean value.
@return boolean true is the object is an instance of the class Deer",Deer.java,421.0,2
8,"protected Animal castAnimal(Object animal)
    {
        Deer deer = (Deer)animal;

        return deer;
    }","This method cast the object passed as a paramter to the type deer and returns
the casted object.
@return Animal deer",Deer.java,421.0,2
9,"protected boolean isFood(Object plant)
    {
        return (plant instanceof Grass);
    }","This method checks if the object passed as a parameter is an instance of the
Deer food source and returns a boolean value.
@return boolean true if it is an instance of the food source class.",Deer.java,421.0,2
10,"protected Plant  castFood(Object plant)
    {
        Grass grass = (Grass) plant;

        return grass;
    }","This method casts the object passed on as a parameter to the type of food source of the deer.
and returns the casted object.
@return Plant grass",Deer.java,421.0,2
11,"protected void updateFoodLevel()
    {
        foodLevel = GRASS_FOOD_VALUE;
    }","This method updates the food level of a deer by assigning the food value of the grass to the foodLevel
variable.",Deer.java,421.0,2
12,"protected int getFoodLevel()
    {
        return foodLevel;
    }","This method returns the food level of each deer.
@return int foodLevel.",Deer.java,421.0,2
0,"public void act(List<Actor> newPredators)
    {        
        incrementAge();
        incrementHunger();
        //The predator will act unless it is dead or during a blizzard.
        if(isAlive() && simulator.getTime() && simulator.getWeather() != ""blizzard"") {
            //Animals can't have offspring if it is too hot.
            if(simulator.getWeather() != ""heat""){
                giveBirth(newPredators);
            }
            // Move towards a source of food if found.

            Location newLocation = findFood();

            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().randomAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null && getField().getObjectAt(newLocation) == null || getField().getObjectAt(newLocation) instanceof Plant) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the predator does most of the time: it hunts for
its prey. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newPredators A list to return newly born predators.",Predator.java,421.0,2
1,"protected void incrementHunger()
    {
        int foodLevel = getFoodLevel();
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this predator more hungry. This could result in the predator's death.,Predator.java,421.0,2
2,"protected Location findFood()
    {

        List<Location> adjacent = getField().adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = getField().getObjectAt(where);
            if(isPrey(animal)) {
                //A predator can only hunt if it is not too foggy in the habitat.
                if(castPrey(animal).isAlive() && simulator.getWeather() != ""fog"") { 
                    castPrey(animal).setDead();
                    updateFoodLevel();
                    return where;
                }
            }
        }
        return null;
    }","Look for the prey adjacent to the current location.
Only the first live prey animal is eaten.
@return Where food was found, or null if it wasn't.",Predator.java,421.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,421.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,421.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,421.0,2
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,421.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,421.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,421.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(120);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,421.0,2
2,"public void simulateOneStep()
    {
        step++;
        
        time.incrementTime();
        time.setTime();
        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>();        
        // Let all actors act.
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actors = it.next();
            actors.act(newActors);
            if(! actors.isAlive()) {
                it.remove();
            }
        }

        // Add the newly born actors to the main lists.
        actors.addAll(newActors);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal.",Simulator.java,421.0,2
3,"public void reset()
    {
        step = 0;
        actors.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,421.0,2
4,"public static boolean getTime()
    {
        return time.getNight();
    }","Returns whether it is night or not.

@return time.getNight() Returns true if it is night.",Simulator.java,421.0,2
5,"public static String getWeather()
    {
        return time.getCurrentWeather();
    }","Returns the current weather condition.

@return time.getCurrentWeather() Returns a String weather condition.",Simulator.java,421.0,2
6,"private void populate()
    {
        generator.populate(actors,field);
    }",Randomly populate the field with predators and their prey.,Simulator.java,421.0,2
7,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,421.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,421.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,421.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,421.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,421.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,421.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,421.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,421.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,421.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,421.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,421.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,421.0,2
0,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,421.0,2
1,"protected int getMAX_AGE()
    {
        return MAX_AGE;
    }","This method returns the maximum age that a fox can reach.
@return int MAX_AGE",Fox.java,421.0,2
2,"protected int getAge()
    {
        return age;
    }","This method returns the age that a fox has.
@return int age",Fox.java,421.0,2
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","This method returns the breeding probability of a fox.
@return int BREEDING_PROBABILITY",Fox.java,421.0,2
4,"protected Random getRandom()
    {
        return rand;
    }","This method return the random factor created in the Fox class.
@return Random rand",Fox.java,421.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","This method returns the max litter size of a fox.
@return int MAX_LITTER_SIZE",Fox.java,421.0,2
6,"protected boolean isPrey(Object animal)
    {
        return (animal instanceof Rabbit);
    }","This method checks wheter the object passed in the method is an instance
of the type of prey that the fox hunts.
@return boolean value",Fox.java,421.0,2
7,"protected void updateFoodLevel()
    {
        foodLevel =  RABBIT_FOOD_VALUE;
    }",This method assigns the food value of the prey to the food level of each fox.,Fox.java,421.0,2
8,"protected int getFoodLevel()
    {
        return foodLevel;
    }","This method returns the food level of a fox at a given time.
@return int foodLevel",Fox.java,421.0,2
9,"protected Animal castPrey(Object animal)
    {
        Rabbit rabbit = (Rabbit) animal;
        
        return rabbit;
    }","This method cast the animal object to the type of prey that the foxes hunt
and returns the animal objected casted to the type of prey that the fox hunts.
@return Animal rabbit",Fox.java,421.0,2
10,"protected String getGender()
    {
        return gender;
    }","This method returns the gender of each fox.
@return String gender",Fox.java,421.0,2
11,"protected boolean checkInstance(Object animal)
    {
        return (animal instanceof Fox);
    }","This method cheks if the object passed as a parameter is an instance of the
class Fox and returns a boolean value.
@return boolean value",Fox.java,421.0,2
12,"protected Animal castAnimal(Object animal)
    {
        Fox fox = (Fox)animal;
        
        return fox;
    }","This method cast the object passed as a parameter to the type of the
class Fox and returns the casted object.
@return Animal fox.",Fox.java,421.0,2
0,"protected Animal castAnimal(Object animal)
    {
        Wolf wolf = (Wolf)animal;

        return wolf;
    }","This method cast the object passed as a parameter to the type of the
class Wolf and returns the casted object.
@return Animal wolf.",Wolf.java,421.0,2
1,"protected Animal castPrey(Object animal)
    {
        Rabbit rabbit = (Rabbit) animal;

        return rabbit;
    }",Sets the prey - rabbit.,Wolf.java,421.0,2
2,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A wolf can breed if it has reached the breeding age.,Wolf.java,421.0,2
3,"protected int getMAX_AGE()
    {
        return MAX_AGE;
    }","This method returns the maximum age that a wolf can reach.
@return int MAX_AGE",Wolf.java,421.0,2
4,"protected int getAge()
    {
        return age;
    }","This method returns the age that a wolf has.
@return int age",Wolf.java,421.0,2
5,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","This method returns the breeding probability of a wolf.
@return int BREEDING_PROBABILITY",Wolf.java,421.0,2
6,"protected Random getRandom()
    {
        return rand;
    }","This method return the random factor created in the Wolf class.
@return Random rand",Wolf.java,421.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","This method returns the max litter size of a wolf.
@return int MAX_LITTER_SIZE",Wolf.java,421.0,2
8,"protected boolean isPrey(Object animal)
    {
        return (animal instanceof Rabbit);
    }","This method checks wheter the object passed in the method is an instance
of the type of prey that the wolf hunts.
@return boolean value",Wolf.java,421.0,2
9,"protected void updateFoodLevel()
    {
        foodLevel =  RABBIT_FOOD_VALUE;
    }",This method assigns the food value of the prey to the food level of each wolf.,Wolf.java,421.0,2
10,"protected int getFoodLevel()
    {
        return foodLevel;
    }","This method returns the food level of a wolf at a given time.
@return int foodLevel",Wolf.java,421.0,2
11,"protected String getGender()
    {
        return gender;
    }","This method returns the gender of each wolf.
@return String gender",Wolf.java,421.0,2
12,"protected boolean checkInstance(Object animal)
    {
        return (animal instanceof Wolf);
    }","This method cheks if the object passed as a parameter is an instance of the
class wolf and returns a boolean value.
@return boolean value",Wolf.java,421.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,421.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,421.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,421.0,2
3,"public void place(Object actor, Location location)
    {
        field[location.getRow()][location.getCol()] = actor;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,421.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,421.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,421.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,421.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,421.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,421.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,421.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,421.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,421.0,2
0,"protected int getPlantAge()
    {
        return grassAge;
    }","This method returns the current ""age"" of the plant.
@return grassLifeSpan;",Grass.java,421.0,2
1,"protected int getPlantMaxAge()
    {
        return MAX_AGE;
    }","This method returns the maximum 'age'that a plant can reach.
@return int",Grass.java,421.0,2
0,"public boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,421.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,421.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,421.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,421.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,421.0,2
5,"protected void incrementAge()
    {
        int age = getAge();

        if(age > getMAX_AGE()) {
            setDead();
        }
    }","Increase the age.
This could result in the animal's death.",Animal.java,421.0,2
6,"protected void giveBirth(List<Actor> newAnimals)
    {
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        Object animal = field.getObjectAt(location);
        int births = breed();
        if(animal instanceof Rabbit){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Rabbit young = new Rabbit(false,field, loc);
                newAnimals.add(young);
            }
        }
        else if(animal instanceof Fox)
        {
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Fox young = new Fox(true, field, loc);
                newAnimals.add(young);
            }
        }
        else if(animal instanceof Wolf){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Wolf young = new Wolf(true, field, loc);
                newAnimals.add(young);
            }
        }
        else if(animal instanceof Bear){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Bear young = new Bear(true, field, loc);
                newAnimals.add(young);
            }
        }
        else if(animal instanceof Deer){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Deer young = new Deer(false, field, loc);
                newAnimals.add(young);
            }
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newAnimals A list to return newly born animals.",Animal.java,421.0,2
7,"protected int breed()
    {
        int births = 0;
        List<Location> adjacent = getField().adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        if(canBreed() && getRandom().nextDouble() <= getBreedingProbability() ) 
        {
            while(it.hasNext() ) {
                Location where = it.next();
                String animalGender = getGender();
                Object animal = getField().getObjectAt(where);

                if(checkInstance(animal) && castAnimal(animal).canBreed()){

                    String adjacentAnimalGender  = castAnimal(animal).getGender();

                    if(!adjacentAnimalGender.equals(animalGender))
                    {
                        births = getRandom().nextInt(getMaxLitterSize()) + 1;
                       
                    }
                }
            }
        }

        return births;
    }","This method checks if the animal can breed and then checks all the adjacent locations
for other animals of the same gender that have reached the breeding age and that
have a opsite gender.

@return The number of births (may be zero).",Animal.java,421.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,256.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,256.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,256.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,256.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,256.0,3
0,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return The age at which a Fly starts to breed.
@return The age at which a Bat starts to breed.",Bat.java,256.0,3
1,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births.
@return the maximum number of births",Bat.java,256.0,3
2,"public double getBreedingProbability()
    {
        return  BREEDING_PROBABILITY;
    }","Return the likelihood of a Bat breeding.
@return the likelihood of a Bat breeding",Bat.java,256.0,3
3,"public Class getFoodType()
    {
        return FOOD_TYPE;
    }","Return the type of food the Bat eats
@return the type of food the Bat eats",Bat.java,256.0,3
4,"public void act(List<Actor> newBats)
    {
        // age by time 
        this.incrementAge();
        // get hungry
        this.incrementHunger();
        
        if(isActive()) {
            this.giveBirth(newBats); 
            this.findFood(FOOD_TYPE);
            
            // Move towards a source of food if found.
            Location newLocation = this.findFood(FOOD_TYPE);
            
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                
                // Reproduce more when the weather is sunny
                if(this.getField().getWeather() == Weather.SUNNY){
                    this.giveBirth(newBats);
                }
                
                this.getField().isAnimalAdjacent(this);
                
                // Die when it gets a disease
                if(this.getDisease() == Disease.RABIES || 
                    this.getDisease() == Disease.FLU ){
                        this.setDead();
                }  
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Bat does most of the time: it hunts for
Flys. In the process, it might breed, die of hunger,
die of a disease or die of old age.
@param newBats A list to return newly born Bats.",Bat.java,256.0,3
5,"public int breed()
    {
        int births = 0;
        if(this.canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Bat.java,256.0,3
6,"@Override
    public void giveBirth(List<Actor> newBats)
    {
      int births = this.breed();
      // List of free adjacent locations
      List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
      for(int b = 0; b < births && free.size() > 0; b++) {  
        Location loc = free.remove(0);
        // Initialise a new bat
        Bat young = new Bat(false, this.getField(), loc);
        // Add it to the list of new bats
        newBats.add(young);
      }
    }","Check whether or not this bat is to give birth at this step.
New births will be made into free adjacent locations.
@param newBats A list to return newly born bats.",Bat.java,256.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,256.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,256.0,3
0,"public int getValue()
    {
        return value;
    }",Return the current value.,NumberDisplay.java,256.0,3
1,"public String getDisplayValue()
    {
        if(value < 10) {
            return ""0"" + value;
        }
        else {
            return """" + value;
        }
    }","Return the display value (that is, the current value as a two-digit
String. If the value is less than ten, it will be padded with a leading
zero).",NumberDisplay.java,256.0,3
2,"public void setValue(int replacementValue)
    {
        if((replacementValue >= 0) && (replacementValue < limit)) {
            value = replacementValue;
        }
    }","Set the value of the display to the new specified value. If the new
value is less than zero or over the limit, do nothing.",NumberDisplay.java,256.0,3
3,"public void increment()
    {
        value = (value + 1) % limit;
    }","Increment the display value by one, rolling over to zero if the
limit is reached.",NumberDisplay.java,256.0,3
0,"public void timeTick()
    {
        minutes.increment();
        if(minutes.getValue() == 0) {  // it just rolled over!
            hours.increment();
        }
        updateDisplay();
    }","This method should get called once every minute - it makes
the clock display go one minute forward.",ClockDisplay.java,256.0,3
2,"public void setTime(int hour, int minute)
    {
        hours.setValue(hour);
        minutes.setValue(minute);
        updateDisplay();
    }","Set the time of the display to the specified hour and
minute.",ClockDisplay.java,256.0,3
3,"public String getTime()
    {
        return displayString;
    }",Return the current time of this display in the format HH:MM.,ClockDisplay.java,256.0,3
4,"public void updateDisplay()
    {
        displayString = hours.getDisplayValue() + "":"" + 
                        minutes.getDisplayValue();
    }",Update the internal string that represents the display.,ClockDisplay.java,256.0,3
0,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return The age at which a Fly starts to breed.
@return The age at which a Fly starts to breed.",Frog.java,256.0,3
1,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births.
@return the maximum number of births",Frog.java,256.0,3
2,"public Class getFoodType()
    {
        return FOOD_TYPE;
    }","Return the type of food the frig eats
@return the type of food the frog eats",Frog.java,256.0,3
3,"public double getBreedingProbability()
    {
        return  BREEDING_PROBABILITY;
    }","Return the likelihood of a Frog breeding.
@return the likelihood of a Frog breeding",Frog.java,256.0,3
4,"@Override
    public void act(List<Actor> newFrogs)
    {
        // age by time
        incrementAge();
        // get hungry
        incrementHunger();
        
        if(isActive()) {
            this.giveBirth(newFrogs);
            this.findFood(FOOD_TYPE);
            
            // Decrement hunger when food is found
            if(this.getField().isFoodAdjacent(this))
            {
                this.decrementHunger();
            }
            
            // Try to move into a free location.
            Location newLocation = this.findFood(this.getFoodType());
            if(newLocation != null) {
                setLocation(newLocation);
                
                // Reproduce more when the weather is sunny
                if(this.getField().getWeather() == Weather.SUNNY){
                    this.giveBirth(newFrogs);
                }
                
                // Die when it gets a disease
                if(this.getField().isAnimalAdjacent(this) && this.getDisease() 
                    == Disease.RABIES || this.getDisease() == Disease.FLU){
                        this.setDead();
                } 
            }
                 
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the frog does most of the time: it hunts for
flies. In the process, it might breed, die of hunger,
die of a disease or die of old age.
@param newFrogs A list to return newly born frogs.",Frog.java,256.0,3
5,"@Override
    public void giveBirth(List<Actor> newFrogs)
    {
      int births = this.breed();
      // List of free adjacent locations
      List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
      for(int b = 0; b < births && free.size() > 0; b++) {  
        Location loc = free.remove(0);
        // initialise a new frog
        Frog young = new Frog(false, this.getField(), loc);
        // Add it to the list of new frogs
        newFrogs.add(young);
       }
    }","Check whether or not this frog is to give birth at this step.
New births will be made into free adjacent locations.
@param newFrogs A list to return newly born frogs.",Frog.java,256.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,256.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,256.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,256.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,256.0,3
0,"public void act(List<Actor> newHumans)
    {
        // age by time
        this.incrementAge();
        // get hungry
        this.incrementHunger();
        
        if(isActive()) {
            this.giveBirth(newHumans);
            
            // Move towards a source of food if found.
            Location newLocation = this.findFood(FOOD_TYPE);
            
            if(this.getField().getWeather() == Weather.SNOWY || 
                this.getField().getWeather() == Weather.RAINY)
            {
                this.incrementHunger();
            }
            
            // See if it was possible to move.
            if(this.isActive() && newLocation != null) {
                setLocation(newLocation);
                if(this.getField().getWeather() == Weather.SUNNY){
                    this.giveBirth(newHumans);
                }
                
                this.getField().isAnimalAdjacent(this);
                
                if(this.getDisease() == Disease.RABIES 
                    || this.getDisease() == Disease.FLU ){
                    this.setDead();
                }
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the human does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newhumans A list to return newly born humans.",Human.java,256.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return The age at which a Fly starts to breed.
@return The age at which a Human starts to breed.",Human.java,256.0,3
2,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births.
@return the maximum number of births",Human.java,256.0,3
3,"public double getBreedingProbability()
    {
        return  BREEDING_PROBABILITY;
    }","Return the likelihood of a Human breeding.
@return the likelihood of a Human breeding",Human.java,256.0,3
4,"public Class getFoodType()
    {
        return FOOD_TYPE;
    }","Return the type of food the human eats
@return the type of food the Human eats",Human.java,256.0,3
5,"@Override
    public void giveBirth(List<Actor> newHumans)
    {
      int births = this.breed();
      // Lists of free adjacent locations
      List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
      for(int b = 0; b < births && free.size() > 0; b++) {  
        Location loc = free.remove(0);
        // Initialise a new human
        Human young = new Human(false, this.getField(), loc);
        // Add it to the list of new humans
        newHumans.add(young);
      }
    }","Check whether or not this human is to give birth at this step.
New births will be made into free adjacent locations.
@param newHuman A list to return newly born human.",Human.java,256.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,256.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,256.0,3
2,"public void setClock(ClockDisplay clock)
    {
        timeLabel.setText(clock.getTime());
    }",Display the cock at the top of the window,SimulatorView.java,256.0,3
3,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,256.0,3
4,"public void showStatus(int step, Field field , ClockDisplay clock)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        timeLabel.setText(clock.getTime());
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param clock the displays time it is taking",SimulatorView.java,256.0,3
5,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,256.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,256.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,256.0,3
2,"public void simulateOneStep()
    {
        step++;
        clock.timeTick(step);
        clock.updateDisplay();
        field.changeWeather();
            
        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>();        
        // Let all actors act.
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            if(! actor.isActive()) {
                it.remove();
            }
            else{
                actor.act(newActors);
            }
        }
               
        // Add the newly born actors to the main lists.
        actors.addAll(newActors);
        view.showStatus(step, field , clock);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each actor.",Simulator.java,256.0,3
3,"public void reset()
    {
        step = 0;
        populate();
        // Show the starting state in the view.
        view.showStatus(step, field, clock);
    }",Reset the simulation to a starting position.,Simulator.java,256.0,3
4,"private void populate()
    {
        actors = new ArrayList<Actor>();
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Location location = new Location(row, col);
                //Class<? extends Animal> species = SPECIES.get(speciesIndex);
                Animal animal; //= new species(true, field, location, gender);
                if (rand.nextDouble() < 0.5){
                    //if random is between 0 and 0.5 then generate an animal
                    //else generate a new plant
                    int species = rand.nextInt(SPECIES);
                    
                    switch(species){
                        case 0:
                            animal = new Bat(true, field, location );
                            break;
                        case 1:
                            animal = new Fly(true, field, location);
                            break;
                        case 2:
                            animal = new Cow(true, field, location);
                            break;
                        case 3:
                            animal = new Frog(true, field, location);
                            break;
                        default:
                            animal = new Human(true, field, location);
                   }
                   actors.add(animal);
                }
                else{
                    //random in range 2
                    int plantSpecies= rand.nextInt(PLANT_SPECIES);
                    
                    Plant plant;
                    
                    switch(plantSpecies){
                        case 0:
                            plant = new Grass(true, location, field);
                            break;
                        default:
                            plant = new Flower(true, location, field); 
                   }
                   actors.add(plant);
                   // else leave the location empty.
              }
          }
       }
    }",Randomly populate the field with actors.,Simulator.java,256.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,256.0,3
0,"public boolean isActive()
   {
       return alive;
   }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Actor.java,256.0,3
1,"public void setDead()
   {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
   }","Indicate that the animal is no longer alive.
It is removed from the field.",Actor.java,256.0,3
5,"public void incrementAge()
   {
       age++;
       if(age > getMaxAge()) {
           setDead();
       }
   }","Increase the age.
This could result in the animal's death.",Actor.java,256.0,3
6,"public int getMaxAge()
   {
       return maxAge;
   }","Return the maximum age of this animal.
@return the maximum age of this animal.",Actor.java,256.0,3
7,"protected void setLocation(Location newLocation)
   {
       if(location != null) {
           field.clear(location);
       }
        
       location = newLocation;
       field.place(this, newLocation);
   }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Actor.java,256.0,3
0,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return The age at which a Cow starts to breed.
@return The age at which a Cow starts to breed.",Cow.java,256.0,3
1,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births.
@return the maximum number of births.",Cow.java,256.0,3
2,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a Cow breeding.
@return the likelihood of a Cow breeding.",Cow.java,256.0,3
3,"public Class getFoodType()
    {
        return FOOD_TYPE;
    }","Return the type of food the Cow eats.
@return the type of food the Cow eats.",Cow.java,256.0,3
4,"public void act(List<Actor> newCows)
    {
        // age by time
        incrementAge();
        //get hungry
        incrementHunger();
        
        if(isActive()) {
            this.giveBirth(newCows);
            this.findFood(FOOD_TYPE);
            
            // Decrement hunger if food is found
            if(this.getField().isFoodAdjacent(this)){
                this.decrementHunger();
            }
            
            // Move towards a source of food if found.
            Location newLocation = this.findFood(this.getFoodType());
            
            if(newLocation != null) {
                
                setLocation(newLocation);
                
                // Reproduce more when the weather is sunny
                if(this.getField().getWeather() == Weather.SUNNY){
                    this.giveBirth(newCows);
                }
                
                this.getField().isAnimalAdjacent(this);
                
                // Die when it gets a disease
                if(this.getDisease() == Disease.RABIES || 
                    this.getDisease() == Disease.FLU ){
                        this.setDead();
                }
            
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","* This is what the Cow does most of the time:it looks for
grass. In the process, it might breed, die of hunger,
die of a disease or die of old age.
@param newCows A list to return newly born cows.",Cow.java,256.0,3
5,"@Override
    public void giveBirth(List<Actor> newCows)
    {
      int births = this.breed();
      // List of free adjacent locations
      List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
      for(int b = 0; b < births && free.size() > 0; b++) {  
        Location loc = free.remove(0);
        // Initialise a new Cow
        Cow young = new Cow(false, this.getField(), loc);
        // Add it to the list of new Cows
        newCows.add(young);
      }
    }","Check whether or not this cow is to give birth at this step.
New births will be made into free adjacent locations.
@param newCows A list to return newly born cows.",Cow.java,256.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,256.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,256.0,3
2,"public void incrementCount(Class actorClass)
    {
        Counter count = counters.get(actorClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(actorClass.getName());
            counters.put(actorClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,256.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,256.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,256.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object actor = field.getObjectAt(row, col);
                if(actor != null) {
                    incrementCount(actor.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,256.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,256.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,256.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,256.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,256.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,256.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,256.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,256.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,256.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,256.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,256.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,256.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,256.0,3
0,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return The age at which a Fly starts to breed.
@return The age at which a Fly starts to breed.",Fly.java,256.0,3
1,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births.
@return the maximum number of births",Fly.java,256.0,3
2,"public double getBreedingProbability()
    {
        return  BREEDING_PROBABILITY;
    }","Return the likelihood of a Fly breeding.
@return the likelihood of a Fly breeding",Fly.java,256.0,3
3,"public Class getFoodType()
    {
        return FOOD_TYPE;
    }","Return the type of food the Fly eats
@return the type of food the Fly eats",Fly.java,256.0,3
4,"@Override
    public void act(List<Actor> newFlies)
    {
        // age by time
        incrementAge();
        //get hungry
        incrementHunger();
        
        if(isActive()) {
            this.giveBirth(newFlies);
            this.findFood(FOOD_TYPE);
            
            // Decrement hunger if food is found
            if(this.getField().isFoodAdjacent(this)){
                this.decrementHunger();
            }
            
            // Move towards a source of food if found.
            Location newLocation = this.findFood(this.getFoodType());
            
            if(newLocation != null) {
                setLocation(newLocation);
                // Reproduce more if the weather is sunny
                if(this.getField().getWeather() == Weather.SUNNY){
                    this.giveBirth(newFlies);
                }
            }
            else {
                // Overcrowding.
                setDead();
            }
            
            // Fly dies when it has a disease
            if(this.getDisease() == Disease.RABIES || 
                this.getDisease() == Disease.FLU )
            {
                this.setDead();
            }
        }
    }","*This is what the fly does most of the time:it looks for
flowers. In the process, it might breed, die of hunger,
die of disease, or die of old age.
@param newFlies A list to return newly born flies.",Fly.java,256.0,3
5,"@Override
    public void giveBirth(List<Actor> newFlies)
    {
        int births = this.breed();
        // List of free adjacent locations 
        List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
        for(int b = 0; b < births && free.size() > 0; b++) {  
            Location loc = free.remove(0);
            // Initialise a new fly
            Fly young = new Fly(false, this.getField(), loc);
            // Add it to the list of new Flies
            newFlies.add(young);
        }
    }","Check whether or not this fly is to give birth at this step.
New births will be made into free adjacent locations.
@param newFlies A list to return newly born flies.",Fly.java,256.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,256.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,256.0,3
4,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,256.0,3
5,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,256.0,3
6,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,256.0,3
7,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,256.0,3
8,"public boolean isMaleAdjacent(Animal animal)
    {
        List<Location> adjLocations = adjacentLocations(animal.getLocation());
        for (Location location : adjLocations) {
            Object object = getObjectAt(location);
            if(object.getClass() == animal.getClass()) {
                Animal possibleMaleAnimal = (Animal) object;
                if(possibleMaleAnimal.getGender() == Gender.MALE) return true;
            }
        }
        return false;
    }","Checks the gender of other animals in adjacent locations
@param animal The given animal
@return true if the animal of the opposite gender is found, otherwise return false",Field.java,256.0,3
9,"public boolean isFoodAdjacent(Animal animal)
    {
        List<Location> adjLocations = adjacentLocations(animal.getLocation());
        for (Location location : adjLocations) {
           Object object = getObjectAt(location);
            if(object != null && object.getClass() == animal.getFoodType()) {
                Actor food = (Actor) object;
                food.setDead();
                return true;
            }
        }
        return false;
    }","Checks if food is in adjacent locations
@return true if food is found, return false otherwise",Field.java,256.0,3
11,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,256.0,3
12,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,256.0,3
13,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,256.0,3
14,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,256.0,3
15,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,256.0,3
16,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,256.0,3
0,"public void pollenate(List<Actor> newGrass)
    {
        if (rand.nextDouble() <= BREEDING_PROBABILITY){
            int pollenation = this.getRand().nextInt(POLLENATION_RATE) + 1;
            
            // List of free adjacent locations
            List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
            
            for(int b = 0; b < pollenation && free.size() > 0; b++) {  
                Location loc = free.remove(0);
                //Initialise a new grass 
                Grass young = new Grass(false, loc, this.getField());
                //Add it to the list of new grass
                newGrass.add(young);
             }
        }
    }","Grass pollenates to produce more grass if the neighboring cell was empty
@param newGrass A list of new grass",Grass.java,256.0,3
1,"public void act(List<Actor> newGrass)
    {
        this.incrementAge();
        
        if(isActive()){
          this.pollenate(newGrass);
          
          // Die if the weather is snowy
          if(this.getField().getWeather() == Weather.SNOWY && rand.nextDouble() < 0.5){
             this.setDead();
          }
         
          // Pollenate more when the weather is sunny
          if(this.getField().getWeather() == Weather.SUNNY){
             this.pollenate(newGrass);
          }
        }
    }","This is what the grass does most of the time:it pollenates
and might die of snow.
Grass pollenates more when the weather is sunny
@param newGrass A list to return new grass.",Grass.java,256.0,3
2,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the max age of grass,Grass.java,256.0,3
0,"public void haveDisease()
   {
        int probability = rand.nextInt(2);
        
        if(probability == 0){
            this.disease = Disease.RABIES;
        }
        else if (probability == 1){
            this.disease = Disease.FLU;
        }
        else{
            this.disease = Disease.NOTHING;
        }
   }","Randomly check if the animal is diagnosed with a disease
Diseases range from Rabies, Flu, or nothing",Animal.java,256.0,3
1,"public Disease getDisease()
   {
       return this.disease;
   }",@return the disease of the animal,Animal.java,256.0,3
2,"public Disease setDisease(Disease disease)
   {
       this.disease = disease;
       return this.disease;
   }","Generates a disease of the animal
@return the disease of the animal",Animal.java,256.0,3
3,"public Gender getGender()
   {
       return this.gender;
   }",@return gender of animal,Animal.java,256.0,3
4,"public boolean canBreed()
   {
        return this.gender == Gender.FEMALE && age >= getBreedingAge() &&
            this.getField().isMaleAdjacent(this);
   }","An animal can breed if it has reached the breeding age.
@return true if the animal can breed",Animal.java,256.0,3
5,"public int breed()
   {
       int births = 0;
       if(canBreed() && rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(maxLitterSize) + 1;
       }
       return births;
   }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,256.0,3
6,"public void incrementHunger()
   {
       foodLevel--;
       if(foodLevel <= 0) {
           this.setDead();
       }
   }",Make this fox more hungry. This could result in the fox's death.,Animal.java,256.0,3
7,"public void decrementHunger()
   {
       this.foodLevel += this.foodValue;
   }","Make this fox less hungry.
Food level of the animal is added by adding the value of the food eaten",Animal.java,256.0,3
8,"public <T extends Actor> Location findFood(Class<T> foodType)
   {
       Field field = getField();
       List<Location> adjacent = field.adjacentLocations(this.getLocation());
       Iterator<Location> it = adjacent.iterator();
       while(it.hasNext()) {
           Location where = it.next();
           Object animal = field.getObjectAt(where);
           if(animal != null && animal.getClass() == foodType ) {
               T food = (T) animal;
               if(food.isActive()) { 
                   food.setDead();
                   this.decrementHunger();
                   return where;
               }
           }
         return null;
       }
       return this.getLocation();
   }","Find food in neighboring cells
The food that the animal has eaten is set dead after
@param foodType The type of food that this animal eats
@return the location of food if found or null if isn't",Animal.java,256.0,3
0,"public void pollenate(List<Actor> newFlowers)
    {
      if(rand.nextDouble() <= BREEDING_PROBABILITY ){
          int pollenation = rand.nextInt(POLLENATION_RATE) + 1;
          
          // List of free adjacent locations
          List<Location> free = this.getField().getFreeAdjacentLocations(getLocation());
          
          for(int b = 0; b < pollenation && free.size() > 0; b++) {  
              Location loc = free.remove(0);
              //Initialise a new flower 
              Flower young = new Flower(false, loc, this.getField());
              //Add it to the list of new grass
              newFlowers.add(young);
          }
      }
    }",@param newFlowers A list of newly created flowers,Flower.java,256.0,3
1,"public void act(List<Actor> newFlowers)
    {
        this.incrementAge();
        
        if(isActive()){ 
             this.pollenate(newFlowers);
             
             // Die if the weather is snowy
             if(this.getField().getWeather() == Weather.SNOWY && rand.nextDouble() < 0.5){
                 this.setDead();
             }
         
             // Pollenate more when the weather is sunny
             if(this.getField().getWeather() == Weather.SUNNY){
                 this.pollenate(newFlowers);
             }
        }
    }","This is what a flower does most of the time:it pollenates
and might die of snow.
A flower pollenates more when the weather is sunny
@param newGrass A list to return new grass.",Flower.java,256.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return the max age that the flower can live to,Flower.java,256.0,3
0,"public void actDay(List<Animal> newBears,List<Disease> diseases)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newBears);   
            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the bear does most of the time: it hunts for
foxes. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newBears A list to return newly born foxes.",Bear.java,637.0,1
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Bear.java,637.0,1
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Bear.java,637.0,1
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Velociraptor) {
                Velociraptor velociraptor = (Velociraptor) animal;
                if (velociraptor.isAlive()) {
                    velociraptor.setDead();
                    foodLevel = VELOCIRAPTOR_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for bears adjacent to the current location.
Only the first live bear is eaten.
@return Where food was found, or null if it wasn't.",Bear.java,637.0,1
5,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Bear) {
                Bear bear = (Bear) animal;
                // this only works if current instance of bear is female as the simulation
                // will also eventually loop through and do this same method on the adjacent bear
                // this prevents the pair of bears from breeding twice in one step.
                if(this.isFemale() && !(bear.isFemale())) { 
                    return true;
                }
            }
        }
        return false;
    }","Looks for fellow foxes of the opposite sex in adjacent locations.
@returns True if a male bear is found and this bear is female otherwise False.",Bear.java,637.0,1
6,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        if (findMate()){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Bear young = new Bear(false, field, loc);
                newFoxes.add(young);
            }
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Bear.java,637.0,1
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Bear.java,637.0,1
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Bear.java,637.0,1
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,637.0,1
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,637.0,1
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,637.0,1
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,637.0,1
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,637.0,1
0,"private int incrementAge()
    {
        age++;
         if(age > MAX_AGE) {
        setDead();
        }
        return age;
    }","Increments the age of PsilocybinMushroom and if the age of the mushroom is larger than the max age it uses setDead method.
@return age",PsilocybinMushroom.java,637.0,1
1,"public void actDay(List<Plant> newPsilocybinMushroom) { 
        incrementAge();
        }","Simulates the mushrooms activity at day, during day it does not doing anything other than age.
@param newPsilocybinMushroom",PsilocybinMushroom.java,637.0,1
2,"public void actNight(List<Plant> newPsilocybinMushrooms) {
         incrementAge();
         if(isAlive()) {
            spread(newPsilocybinMushrooms); 
         }
      }","Simulates the mushrooms activity at night, during night it increments age and spreads in the area around it.
@param newPsilocybinMushrooms",PsilocybinMushroom.java,637.0,1
3,"public void spread(List<Plant> newPsilocybinMushrooms) 
         {
        // New PsilocybinMushroom spread into adjacent locations.
        // Get a list of adjacent locations with space for PsilocybinMushroom.
        if(age > 0 && age % NEW_PsilocybinMushroom == 0) {
            Field field = getField();
            List<Location> locations = field.adjacentLocations(getLocation());
            //boolean spread = false;
            int seeds = 1;
            for(Location location : locations) {
               ArrayList<Plant> currentPlants = location.ReturnPlants();
               while(seeds == 1) {
                  if(currentPlants.size() < 10) {
                     PsilocybinMushroom newPlant = new PsilocybinMushroom(false, field, location);
                     newPsilocybinMushrooms.add(newPlant);
                     seeds--;
                    }
                }
            }
        }
    }","Simulates the mushrooms growth/expansion, only if age is less than 0 and the age is a multiple of 2. If requirements
are met the mushroom spreads to the adjacent locations.
@param newPsilocybinMushrooms",PsilocybinMushroom.java,637.0,1
0,"public boolean spread(){
        return (rand.nextDouble() <= contagiousness);
    }",The disease will spread after a certain number of steps,Disease.java,637.0,1
1,"public boolean infect(){
        return (rand.nextDouble() <= chanceOfInfection);
    }",@Return,Disease.java,637.0,1
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,637.0,1
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,637.0,1
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant  is alive or not.
@return true if the plant  is still alive.",Plant.java,637.0,1
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant  is no longer alive.
It is removed from the field.",Plant.java,637.0,1
2,"protected Location getLocation()
    {
        return location;
    }","Return the plant 's location.
@return The plant 's location.",Plant.java,637.0,1
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant  at the new location in the given field.
@param newLocation The plant 's new location.",Plant.java,637.0,1
4,"protected Field getField()
    {
        return field;
    }","Return the plant 's field.
@return The plant 's field.",Plant.java,637.0,1
0,"public List<Disease> diseses()
    {
        return diseases;
        }","returns the list of all the monkey's diseases.
@return list of monkey's diseases",Monkey.java,637.0,1
1,"public void actDay(List<Animal> newMonkey, List<Disease> diseases)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
            diseaseStuff(diseases);
            giveBirth(newMonkey);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) {
                newLocation = getField().freeAdjacentLocation(getLocation());;
            }
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","Representation of what happens to the monkey during the day and what it does, aswell as the diseases the monkey has.
Its hunger and age increases, it finds food and it breeds.
@param newMonkey A list to return newly born monkeys.
@param diseases A list likely to return new disease",Monkey.java,637.0,1
2,"public void actNight(List<Animal> newMonkeys, List<Disease> diseases)
    {
        incrementAge();
    }","Representation of what the monkey does during night.(just ages)
@param newMonkey A list to return newly born monkeys.
@param diseases A list likely to return new disease",Monkey.java,637.0,1
3,"private void diseaseStuff(List<Disease> newDiseases) {
        Iterator<Disease> it = newDiseases.iterator();
        while(it.hasNext()) {
            Disease newDisease = it.next();
            if(newDisease.canBeInfected(this) && newDisease.infect()){
                System.out.print(newDisease);
                diseases.add(newDisease);
                maxAge *= newDisease.returnAgeDecrease();
            }
        }
    }",@param newDiseases List of new diseases,Monkey.java,637.0,1
4,"private void incrementHunger() {
        foodLevel--;
        if(foodLevel <=0) {
            setDead();
        }
    }",reduces monkeys food level by one and checks if monkey has died,Monkey.java,637.0,1
5,"private Location findFood() 
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Marijuana) {
                Marijuana marijuana = (Marijuana) plant;
                if (marijuana.isAlive()) {
                    marijuana.setDead();
                    foodLevel = Marijuana_FOOD_VALUE;
                    return where;
                }
            }
           
        
        }
         return null;
    }","looks any food in adjacent locations and then returns the location of the food.
@returns location where food is.",Monkey.java,637.0,1
6,"private void incrementAge()
    {
        age++;
        if(age > maxAge) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Monkey.java,637.0,1
7,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Monkey) {
                Monkey monkey = (Monkey) animal;
                if(monkey.isFemale() != this.isFemale()) { 
                    if(monkey.canBreed() && this.canBreed()) {
                        return true;
                    }
                }
            }
        }
        return false;
    }","looks for other monkeys of opposite gender in adjacent locations and then tries to breed with it.
@returns true if it can breed, otherwise false.",Monkey.java,637.0,1
8,"private void giveBirth(List<Animal> newMonkeys)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        if(findMate()){
            int births = breed();
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Monkey young = new Monkey(false, field, loc);
                newMonkeys.add(young);
            }
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Monkey.java,637.0,1
9,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Monkey.java,637.0,1
10,"private boolean canBreed()
    {
        if (!(previouslyBirthed)){
            previouslyBirthed = true;
            return age >= BREEDING_AGE;
        }
        else{
            previouslyBirthed = false;
            return false;
        }
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Monkey.java,637.0,1
0,"public void actDay(List<Animal> newVelociraptors,List<Disease> diseases)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newVelociraptors);   
            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the velociraptor does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newVelociraptors A list to return newly born velociraptores.",Velociraptor.java,637.0,1
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the velociraptor's death.,Velociraptor.java,637.0,1
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this velociraptor more hungry. This could result in the velociraptor's death.,Velociraptor.java,637.0,1
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Monkey) {
                Monkey monkey = (Monkey) animal;
                if(monkey.isAlive()) { 
                    monkey.setDead();
                    foodLevel = MONKEY_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Worm) {
                Worm worm = (Worm) animal;
                if(worm.isAlive()) { 
                    worm.setDead();
                    foodLevel = WORM_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Monkeys and Worms adjacent to the current location
Only the first live animal nearest is eaten
@return where food was found, or null if it wasnt",Velociraptor.java,637.0,1
5,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Velociraptor) {
                Velociraptor velociraptor = (Velociraptor) animal;
                if(this.isFemale() != velociraptor.isFemale()){ 
                    return true;
                }
            }
        }
        return false;
    }","Looks for fellow velociraptores of the opposite sex in adjacent locations.
@returns True if a velociraptor of the opposite gender is found otherwise False.",Velociraptor.java,637.0,1
6,"private void giveBirth(List<Animal> newVelociraptors)
    {
        // New velociraptores are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        //if (findMate()){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Velociraptor young = new Velociraptor(false, field, loc);
                newVelociraptors.add(young);
            }
        //}
    }","Check whether or not this velociraptor is to give birth at this step.
New births will be made into free adjacent locations.
@param newVelociraptors A list to return newly born velociraptores.",Velociraptor.java,637.0,1
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Velociraptor.java,637.0,1
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A velociraptor can breed if it has reached the breeding age.,Velociraptor.java,637.0,1
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,637.0,1
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,637.0,1
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,637.0,1
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,637.0,1
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,637.0,1
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,637.0,1
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,637.0,1
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object object = field.getObjectAt(row, col);
                if(object != null && object instanceof Animal ) {
                    stats.incrementCount(object.getClass());
                    fieldView.drawMark(col, row, getColor(object.getClass()));
                }
                else if(object != null && object instanceof Plant) {
                    stats.incrementCount(object.getClass());
                    fieldView.drawMark(col, row, getColor(object.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,637.0,1
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,637.0,1
1,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,637.0,1
2,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,637.0,1
3,"public void simulateOneStep()
    {
        step++;
        if (step%2000 >= 1000){
            if (isDay){
                isDay = false;
            }
        }
        else{
            if (!(isDay)){
                isDay = true;
            }
        }
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();
        List<Plant> newPlants = new ArrayList<>();
        // Let all rabbits act.
        if (isDay) {
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.actDay(newAnimals, diseases);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        for(Iterator<Plant> i = plants.iterator(); i.hasNext(); ) {
                Plant plant = i.next();
                plant.actDay(newPlants);
                if(! plant.isAlive()) {
                    i.remove();
                }
            }  
        }
        else {
             for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.actNight(newAnimals,diseases);
                if(! animal.isAlive()) {
                    it.remove();
                }
            }
            for(Iterator<Plant> i = plants.iterator(); i.hasNext(); ) {
                Plant plant = i.next();
                plant.actNight(newPlants);
                if(! plant.isAlive()) {
                    i.remove();
                }
            }  
            
            
            
            
            
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal and plant",Simulator.java,637.0,1
4,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        isDay = true;
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,637.0,1
5,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= DRAGON_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Dragon dragon= new Dragon(true, field, location);
                    animals.add(dragon);
                }
                if(rand.nextDouble() <= BEAR_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Bear bear = new Bear(true, field, location);
                    animals.add(bear);
                }
                else if(rand.nextDouble() <= VELOCIRAPTOR_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Velociraptor velociraptor= new Velociraptor(true, field, location);
                    animals.add(velociraptor);
                }
                else if(rand.nextDouble() <= Monkey_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Monkey monkey = new Monkey(true, field, location);
                    animals.add(monkey);
                }
                 else if(rand.nextDouble() <= WORM_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Worm worm = new Worm(true, field, location);
                    animals.add(worm);
                }
                 else if(rand.nextDouble() <= PSILOCYBINMUSHROOM_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    PsilocybinMushroom psilocybinmushroom = new PsilocybinMushroom(true, field, location);
                    plants.add(psilocybinmushroom);
                }
                else if(rand.nextDouble() <= MARIJUANA_CREATION_PROBABILITY) {
                Location location = new Location(row, col);
                Marijuana Marijuana = new Marijuana(true, field, location);
                plants.add(Marijuana);
                //else leave the location empty. 
                }
            }
        }
    }",Randomly populate the field with animals and plants.,Simulator.java,637.0,1
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,637.0,1
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,637.0,1
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,637.0,1
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,637.0,1
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,637.0,1
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,637.0,1
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,637.0,1
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,637.0,1
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,637.0,1
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,637.0,1
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,637.0,1
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,637.0,1
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,637.0,1
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,637.0,1
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,637.0,1
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,637.0,1
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,637.0,1
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,637.0,1
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,637.0,1
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,637.0,1
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,637.0,1
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,637.0,1
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,637.0,1
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,637.0,1
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,637.0,1
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,637.0,1
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,637.0,1
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,637.0,1
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,637.0,1
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,637.0,1
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,637.0,1
0,"public void actDay(List<Animal> newWorms,List<Disease> diseases)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newWorms);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the worm does most of the time: it hunts for
mushrooms. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newWorms A list to return newly born worms.",Worm.java,637.0,1
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the worm's death.,Worm.java,637.0,1
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this worm more hungry. This could result in the worm's death.,Worm.java,637.0,1
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof PsilocybinMushroom) {
                PsilocybinMushroom psilocybinmushroom = (PsilocybinMushroom) plant;
                if(psilocybinmushroom.isAlive()) { 
                    psilocybinmushroom.setDead();
                    foodLevel = PSILOCYBINMUSHROOM_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for mushrooms adjacent to the current location.
Only the first mushroom is eaten.
@return Where food was found, or null if it wasn't.",Worm.java,637.0,1
5,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Worm) {
                Worm worm = (Worm) animal;
                if(this.isFemale() != worm.isFemale()){ 
                    return true;
                }
            }
        }
        return false;
    }","Looks for fellow worms of the opposite sex in adjacent locations.
@returns True if a worm of the opposite gender is found otherwise False.",Worm.java,637.0,1
6,"private void giveBirth(List<Animal> newWorms)
    {
        // New worms are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        //if (findMate()){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Worm young = new Worm(false, field, loc);
                newWorms.add(young);
            }
        //}
    }","Check whether or not this worm is to give birth at this step.
New births will be made into free adjacent locations.
@param newWorms A list to return newly born worms.",Worm.java,637.0,1
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Worm.java,637.0,1
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A worm can breed if it has reached the breeding age.,Worm.java,637.0,1
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,637.0,1
1,"protected boolean isFemale()
    {
        return hasLadyParts;
    }","Check whether the animal is female.
@return true if the animal is female",Animal.java,637.0,1
2,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,637.0,1
3,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,637.0,1
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,637.0,1
5,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,637.0,1
0,"public void actDay(List<Animal> newBears,List<Disease> diseases)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newBears);     
            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the bear does most of the time: it hunts for
dragons. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newBears A list to return newly born dragons.",Dragon.java,637.0,1
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the dragon's death.,Dragon.java,637.0,1
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this dragon more hungry. This could result in the dragon's death.,Dragon.java,637.0,1
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Velociraptor) {
                Velociraptor velociraptor = (Velociraptor) animal;
                if (velociraptor.isAlive()) {
                    velociraptor.setDead();
                    foodLevel = VELOCIRAPTOR_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Monkey) {
                Monkey monkey = (Monkey) animal;
                if (monkey.isAlive()) {
                    monkey.setDead();
                    foodLevel = Monkey_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Bear) {
                Bear bear = (Bear) animal;
                if (bear.isAlive()) {
                    bear.setDead();
                    foodLevel = BEAR_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Dragon.java,637.0,1
5,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dragon) {
                Dragon bear = (Dragon) animal;
                // this only works if current instance of bear is female as the simulation
                // will also eventually loop through and do this same method on the adjacent bear
                // this prevents the pair of bears from breeding twice in one step.
                if(this.isFemale() && !(bear.isFemale())) { 
                    return true;
                }
            }
        }
        return false;
    }","Looks for fellow dragons of the opposite sex in adjacent locations.
@returns True if a male bear is found and this bear is female otherwise False.",Dragon.java,637.0,1
6,"private void giveBirth(List<Animal> newFoxes)
    {
        // New dragons are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        if (findMate()){
            for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Dragon young = new Dragon(false, field, loc);
                newFoxes.add(young);
            }
        }
    }","Check whether or not this dragon is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born dragons.",Dragon.java,637.0,1
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Dragon.java,637.0,1
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A dragon can breed if it has reached the breeding age.,Dragon.java,637.0,1
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,260.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,260.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,260.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,260.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,260.0,3
0,"public int getPlantCount()
    {
        return plant.getCount();
        
    }",Get the amount of plant at this tile (between 0 and 1) as determined by the Plant class,PlantTile.java,260.0,3
1,"protected int getMinCount()
    {
        return minCount;
    }",@return the min value (plant tile with least amount of plant),PlantTile.java,260.0,3
2,"protected int getMinMedCount()
    {
        return minMedCount;
    }",@return the min-med value,PlantTile.java,260.0,3
3,"protected int getMedCount()
    {
        return medCount;
    }",@return the medium value (plant tile with middle amount of plant),PlantTile.java,260.0,3
4,"protected int getMedMaxCount()
    {
        return medMaxCount;
    }",@return the medium value (plant tile with middle amount of plant),PlantTile.java,260.0,3
5,"protected int getMaxCount()
    {
        return maxCount;
    }",@return the max value (plant tile with maximum amount of plant),PlantTile.java,260.0,3
6,"public Actor getOrganism()
    {
        if(getAnimal() != null) {
            return getAnimal();
        }
        else {
            return plant;
        }
    }","Checks for an animal located at tile and returns it, otherwise checks for a plant located at tile and returns it.
@return Organism at tile, prioritising animal, or null.",PlantTile.java,260.0,3
7,"public Plant getPlant()
    {
        return plant;
    }",@return the plant at this PlantTile,PlantTile.java,260.0,3
8,"protected Color determineColor()
    {
        int count = getPlantCount();
        if(count < getMinCount()) return getMinColor();
        else if(count < getMinMedCount()) return getMinMedColor();
        else if(count < getMedCount()) return getMedColor();
        else if(count < getMedMaxCount()) return getMedMaxColor();
        else return getMaxColor();
    }",Determine the color of the PlantTile,PlantTile.java,260.0,3
0,"public static void acidTrip() throws IOException
    {
        for (int x=0; x<bi.getWidth(); x++) {
            for (int y=0; y<bi.getHeight(); y++) {
                int color = bi.getRGB(x, y);
        
                // use unsigned right shifts to obtain the red, green, and blue color values (RGB), respectively
                int R = (color>>>16) & 0xFF;
                int G = (color>>>8) & 0xFF;
                int B = (color>>>0) & 0xFF;
                
                R+=10;
                G+=10;
                B+=10;
                
                String stringRGB = """" + R + G + B;
                int newRGB = Integer.parseInt(stringRGB);
    
                bi.setRGB(x, y, newRGB);
            }
        }
        
        ImageIO.write(bi, ""png"", new File(""noise.png""));
    }",Acidify the noise map. This creates a very nice optical illusion.,TerrainGenerator.java,260.0,3
1,"public static float getLuminance(int row, int col)
    {
        // searches the image as a 
        
        int color = bi.getRGB(row, col);
        
        // use unsigned right shifts to obtain the red, green, and blue color values (RGB), respectively
        int R = (color>>>16) & 0xFF;
        int G = (color>>>8) & 0xFF;
        int B = (color>>>0) & 0xFF;
        
        // formula used to calculate luminance, better than using (R+G+B)/3
        // https://stackoverflow.com/questions/687261/converting-rgb-to-grayscale-intensity
        float luminance = (R*0.216f + G*0.7152f + B*0.0722f)/255;
        //float luminance = ((R+G+B)/3)/255;
        return luminance;
    }","Obtain the luminance (a value between 0 and 1) of a specific tile (row,col)
@param col, the column (x-coordinate, width) of the tile
@param row, the row (y-coordinate, height) of the tile
@return the luminance (as a float). The higher the value, the brighter the pixel.",TerrainGenerator.java,260.0,3
0,"static Tile determineTile(float luminance)
    {
        if (luminance < DEEP_WATER + rand.nextInt(5)/100) return new DeepWater();
        else if (luminance < SHALLOW_WATER) return new ShallowWater();
        else if (luminance < SEA_BED) return new SeaBed();
        else if (luminance < SAND) return new Sand();
        else if (luminance < GRASS) return new Grass();
        else if (luminance < ROCK) return new Rock();
        else return new Snow();
    }","Give back the exact colors for the ranges of luminances

@param luminance, the luminance value (0<x<1) of the 'pixel'
@param col, effectively the x axis
@param row, effectively the y axis",Grassland.java,260.0,3
1,"static void flood()
    {
        //float val = rand.nextInt(200)/10000; // generate a value between 0.0001-0.02
        float val = increment; // generate a value between 0.0001-0.02
        incDeepWater(val);
        incShallowWater(val);
    }","Introduce rising sea levels/flooding (i.e. more water)
*Shallow water and Grass may change",Grassland.java,260.0,3
2,"static void drought()
    {
        //float val = rand.nextInt(200)/10000; // generate a value between 0.0001-0.02
        float val = increment;
        decDeepWater(val);
        decShallowWater(val);
    }","Decrease the sea levels (i.e. more land)
*Shallow water and Deep water may change",Grassland.java,260.0,3
3,"static float getIncrement()
    {
        return increment;
    }",@return get the increment value,Grassland.java,260.0,3
4,"static float getDeepWaterThreshold()
    {
        return DEEP_WATER;
    }",@return get the increment value,Grassland.java,260.0,3
5,"static float getShallowWaterThreshold()
    {
        return SHALLOW_WATER;
    }",@return get the increment value,Grassland.java,260.0,3
6,"static float getSandThreshold()
    {
        return SAND;
    }",@return get the increment value,Grassland.java,260.0,3
7,"static float getGrassThreshold()
    {
        return GRASS;
    }",@return get the increment value,Grassland.java,260.0,3
8,"static void incDeepWater(float val)
    {
        DEEP_WATER+=val;
    }",Set DEEP_WATER value,Grassland.java,260.0,3
9,"static void decDeepWater(float val)
    {
        DEEP_WATER-=val;
    }",Set DEEP_WATER value,Grassland.java,260.0,3
10,"static void incShallowWater(float val)
    {
        SHALLOW_WATER+=val;
    }",Increment SHALLOW_WATER value,Grassland.java,260.0,3
11,"static void decShallowWater(float val)
    {
        SHALLOW_WATER-=val;
    }",Decrement SHALLOW_WATER value,Grassland.java,260.0,3
12,"static void incGrass(float val)
    {
        GRASS+=val;
    }",Increment GRASS value,Grassland.java,260.0,3
13,"static void decGrass(float val)
    {
        GRASS-=val;
    }",Decrement GRASS value,Grassland.java,260.0,3
0,"protected void clearAnimal()
    {
        this.animal = null;
    }",Set the tile's current animal to null.,Tile.java,260.0,3
1,"protected void setAnimal(Actor animal)
    {
        this.animal = animal;
    }",Set the tile's current animal.,Tile.java,260.0,3
2,"protected Actor getAnimal()
    {
        return animal;
    }",@return the tile's current animal,Tile.java,260.0,3
3,"public Actor getOrganism()
    {
        return animal;
    }","Checks for an animal located at tile and returns it, otherwise checks for a plant located at tile and returns it.
@return Organism at tile, prioritising animal, or null.",Tile.java,260.0,3
4,"protected Plant getPlant()
    {
        return null;
    }","@return the tile's current plant (null), which will be overwritten ONLY within PlantTile class",Tile.java,260.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
        classes = new ArrayList<>(colors.keySet());
        
        //add label for each class to display population count
        JLabel label = new JLabel("" "");
        label.setForeground(color);
        countLabels.put(animalClass, label);
        bottom.add(label);
    }","Define a color to be used for a given class of animal, and initialise the animal's label.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",PopulationGraph.java,260.0,3
1,"public void showStatus(int step, Field field, boolean isDay, int currentDarkness)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param isDay, true=day, false=night. *Currently not used",PopulationGraph.java,260.0,3
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",PopulationGraph.java,260.0,3
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,PopulationGraph.java,260.0,3
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabels = new HashMap<>();
        
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,PopulationGraph.java,260.0,3
0,"protected Color getColor()
    {
        Collections.shuffle(colorArray);
        return colorArray.get(0);
    }",Determine the color of the Snow Tile,Snow.java,260.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,260.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,260.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {

    }","Define a color to be used for a given class of animal, and initialise the animal's label.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GrassGraph.java,260.0,3
1,"public void showStatus(int step, Field field, boolean isDay, int currentDarkness)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param isDay, true=day, false=night. *Currently not used",GrassGraph.java,260.0,3
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GrassGraph.java,260.0,3
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GrassGraph.java,260.0,3
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""GrassGraph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel ("" "");
        countLabel.setForeground(GREEN);
        bottom.add(countLabel);

        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(1000, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,GrassGraph.java,260.0,3
0,"public double eval(double x, double y) {
    
        //Place input coordinates onto grid.
        double stretchOffset = (x + y) * STRETCH_CONSTANT_2D;
        double xs = x + stretchOffset;
        double ys = y + stretchOffset;
        
        //Floor to get grid coordinates of rhombus (stretched square) super-cell origin.
        int xsb = fastFloor(xs);
        int ysb = fastFloor(ys);
        
        //Skew out to get actual coordinates of rhombus origin. We'll need these later.
        double squishOffset = (xsb + ysb) * SQUISH_CONSTANT_2D;
        double xb = xsb + squishOffset;
        double yb = ysb + squishOffset;
        
        //Compute grid coordinates relative to rhombus origin.
        double xins = xs - xsb;
        double yins = ys - ysb;
        
        //Sum those together to get a value that determines which region we're in.
        double inSum = xins + yins;

        //Positions relative to origin point.
        double dx0 = x - xb;
        double dy0 = y - yb;
        
        //We'll be defining these inside the next block and using them afterwards.
        double dx_ext, dy_ext;
        int xsv_ext, ysv_ext;
        
        double value = 0;

        //Contribution (1,0)
        double dx1 = dx0 - 1 - SQUISH_CONSTANT_2D;
        double dy1 = dy0 - 0 - SQUISH_CONSTANT_2D;
        double attn1 = 2 - dx1 * dx1 - dy1 * dy1;
        if (attn1 > 0) {
            attn1 *= attn1;
            value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, dx1, dy1);
        }

        //Contribution (0,1)
        double dx2 = dx0 - 0 - SQUISH_CONSTANT_2D;
        double dy2 = dy0 - 1 - SQUISH_CONSTANT_2D;
        double attn2 = 2 - dx2 * dx2 - dy2 * dy2;
        if (attn2 > 0) {
            attn2 *= attn2;
            value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, dx2, dy2);
        }
        
        if (inSum <= 1) { //We're inside the triangle (2-Simplex) at (0,0)
            double zins = 1 - inSum;
            if (zins > xins || zins > yins) { //(0,0) is one of the closest two triangular vertices
                if (xins > yins) {
                    xsv_ext = xsb + 1;
                    ysv_ext = ysb - 1;
                    dx_ext = dx0 - 1;
                    dy_ext = dy0 + 1;
                } else {
                    xsv_ext = xsb - 1;
                    ysv_ext = ysb + 1;
                    dx_ext = dx0 + 1;
                    dy_ext = dy0 - 1;
                }
            } else { //(1,0) and (0,1) are the closest two vertices.
                xsv_ext = xsb + 1;
                ysv_ext = ysb + 1;
                dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;
                dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;
            }
        } else { //We're inside the triangle (2-Simplex) at (1,1)
            double zins = 2 - inSum;
            if (zins < xins || zins < yins) { //(0,0) is one of the closest two triangular vertices
                if (xins > yins) {
                    xsv_ext = xsb + 2;
                    ysv_ext = ysb + 0;
                    dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;
                    dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;
                } else {
                    xsv_ext = xsb + 0;
                    ysv_ext = ysb + 2;
                    dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;
                    dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;
                }
            } else { //(1,0) and (0,1) are the closest two vertices.
                dx_ext = dx0;
                dy_ext = dy0;
                xsv_ext = xsb;
                ysv_ext = ysb;
            }
            xsb += 1;
            ysb += 1;
            dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;
            dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;
        }
        
        //Contribution (0,0) or (1,1)
        double attn0 = 2 - dx0 * dx0 - dy0 * dy0;
        if (attn0 > 0) {
            attn0 *= attn0;
            value += attn0 * attn0 * extrapolate(xsb, ysb, dx0, dy0);
        }
        
        //Extra Vertex
        double attn_ext = 2 - dx_ext * dx_ext - dy_ext * dy_ext;
        if (attn_ext > 0) {
            attn_ext *= attn_ext;
            value += attn_ext * attn_ext * extrapolate(xsv_ext, ysv_ext, dx_ext, dy_ext);
        }
        
        return value / NORM_CONSTANT_2D;
    }",2D OpenSimplex Noise.,OpenSimplexNoise.java,260.0,3
1,"public double eval(double x, double y, double z) {
    
        //Place input coordinates on simplectic honeycomb.
        double stretchOffset = (x + y + z) * STRETCH_CONSTANT_3D;
        double xs = x + stretchOffset;
        double ys = y + stretchOffset;
        double zs = z + stretchOffset;
        
        //Floor to get simplectic honeycomb coordinates of rhombohedron (stretched cube) super-cell origin.
        int xsb = fastFloor(xs);
        int ysb = fastFloor(ys);
        int zsb = fastFloor(zs);
        
        //Skew out to get actual coordinates of rhombohedron origin. We'll need these later.
        double squishOffset = (xsb + ysb + zsb) * SQUISH_CONSTANT_3D;
        double xb = xsb + squishOffset;
        double yb = ysb + squishOffset;
        double zb = zsb + squishOffset;
        
        //Compute simplectic honeycomb coordinates relative to rhombohedral origin.
        double xins = xs - xsb;
        double yins = ys - ysb;
        double zins = zs - zsb;
        
        //Sum those together to get a value that determines which region we're in.
        double inSum = xins + yins + zins;

        //Positions relative to origin point.
        double dx0 = x - xb;
        double dy0 = y - yb;
        double dz0 = z - zb;
        
        //We'll be defining these inside the next block and using them afterwards.
        double dx_ext0, dy_ext0, dz_ext0;
        double dx_ext1, dy_ext1, dz_ext1;
        int xsv_ext0, ysv_ext0, zsv_ext0;
        int xsv_ext1, ysv_ext1, zsv_ext1;
        
        double value = 0;
        if (inSum <= 1) { //We're inside the tetrahedron (3-Simplex) at (0,0,0)
            
            //Determine which two of (0,0,1), (0,1,0), (1,0,0) are closest.
            byte aPoint = 0x01;
            double aScore = xins;
            byte bPoint = 0x02;
            double bScore = yins;
            if (aScore >= bScore && zins > bScore) {
                bScore = zins;
                bPoint = 0x04;
            } else if (aScore < bScore && zins > aScore) {
                aScore = zins;
                aPoint = 0x04;
            }
            
            //Now we determine the two lattice points not part of the tetrahedron that may contribute.
            //This depends on the closest two tetrahedral vertices, including (0,0,0)
            double wins = 1 - inSum;
            if (wins > aScore || wins > bScore) { //(0,0,0) is one of the closest two tetrahedral vertices.
                byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsb - 1;
                    xsv_ext1 = xsb;
                    dx_ext0 = dx0 + 1;
                    dx_ext1 = dx0;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb + 1;
                    dx_ext0 = dx_ext1 = dx0 - 1;
                }

                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0;
                    if ((c & 0x01) == 0) {
                        ysv_ext1 -= 1;
                        dy_ext1 += 1;
                    } else {
                        ysv_ext0 -= 1;
                        dy_ext0 += 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1;
                }

                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsb;
                    zsv_ext1 = zsb - 1;
                    dz_ext0 = dz0;
                    dz_ext1 = dz0 + 1;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz0 - 1;
                }
            } else { //(0,0,0) is not one of the closest two tetrahedral vertices.
                byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.
                
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsb;
                    xsv_ext1 = xsb - 1;
                    dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb + 1;
                    dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysb;
                    ysv_ext1 = ysb - 1;
                    dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsb;
                    zsv_ext1 = zsb - 1;
                    dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                }
            }

            //Contribution (0,0,0)
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value += attn0 * attn0 * extrapolate(xsb + 0, ysb + 0, zsb + 0, dx0, dy0, dz0);
            }

            //Contribution (1,0,0)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1);
            }

            //Contribution (0,1,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;
            double dz2 = dz1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2);
            }

            //Contribution (0,0,1)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3);
            }
        } else if (inSum >= 2) { //We're inside the tetrahedron (3-Simplex) at (1,1,1)
        
            //Determine which two tetrahedral vertices are the closest, out of (1,1,0), (1,0,1), (0,1,1) but not (1,1,1).
            byte aPoint = 0x06;
            double aScore = xins;
            byte bPoint = 0x05;
            double bScore = yins;
            if (aScore <= bScore && zins < bScore) {
                bScore = zins;
                bPoint = 0x03;
            } else if (aScore > bScore && zins < aScore) {
                aScore = zins;
                aPoint = 0x03;
            }
            
            //Now we determine the two lattice points not part of the tetrahedron that may contribute.
            //This depends on the closest two tetrahedral vertices, including (1,1,1)
            double wins = 3 - inSum;
            if (wins < aScore || wins < bScore) { //(1,1,1) is one of the closest two tetrahedral vertices.
                byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsb + 2;
                    xsv_ext1 = xsb + 1;
                    dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb;
                    dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    if ((c & 0x01) != 0) {
                        ysv_ext1 += 1;
                        dy_ext1 -= 1;
                    } else {
                        ysv_ext0 += 1;
                        dy_ext0 -= 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsb + 1;
                    zsv_ext1 = zsb + 2;
                    dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;
                }
            } else { //(1,1,1) is not one of the closest two tetrahedral vertices.
                byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsb + 1;
                    xsv_ext1 = xsb + 2;
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb;
                    dx_ext0 = dx0 - SQUISH_CONSTANT_3D;
                    dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysb + 1;
                    ysv_ext1 = ysb + 2;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy0 - SQUISH_CONSTANT_3D;
                    dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                }

                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsb + 1;
                    zsv_ext1 = zsb + 2;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;
                } else {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz0 - SQUISH_CONSTANT_3D;
                    dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                }
            }
            
            //Contribution (1,1,0)
            double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx3, dy3, dz3);
            }

            //Contribution (1,0,1)
            double dx2 = dx3;
            double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx2, dy2, dz2);
            }

            //Contribution (0,1,1)
            double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dy1 = dy3;
            double dz1 = dz2;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx1, dy1, dz1);
            }

            //Contribution (1,1,1)
            dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
            dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
            dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value += attn0 * attn0 * extrapolate(xsb + 1, ysb + 1, zsb + 1, dx0, dy0, dz0);
            }
        } else { //We're inside the octahedron (Rectified 3-Simplex) in between.
            double aScore;
            byte aPoint;
            boolean aIsFurtherSide;
            double bScore;
            byte bPoint;
            boolean bIsFurtherSide;

            //Decide between point (0,0,1) and (1,1,0) as closest
            double p1 = xins + yins;
            if (p1 > 1) {
                aScore = p1 - 1;
                aPoint = 0x03;
                aIsFurtherSide = true;
            } else {
                aScore = 1 - p1;
                aPoint = 0x04;
                aIsFurtherSide = false;
            }

            //Decide between point (0,1,0) and (1,0,1) as closest
            double p2 = xins + zins;
            if (p2 > 1) {
                bScore = p2 - 1;
                bPoint = 0x05;
                bIsFurtherSide = true;
            } else {
                bScore = 1 - p2;
                bPoint = 0x02;
                bIsFurtherSide = false;
            }
            
            //The closest out of the two (1,0,0) and (0,1,1) will replace the furthest out of the two decided above, if closer.
            double p3 = yins + zins;
            if (p3 > 1) {
                double score = p3 - 1;
                if (aScore <= bScore && aScore < score) {
                    aScore = score;
                    aPoint = 0x06;
                    aIsFurtherSide = true;
                } else if (aScore > bScore && bScore < score) {
                    bScore = score;
                    bPoint = 0x06;
                    bIsFurtherSide = true;
                }
            } else {
                double score = 1 - p3;
                if (aScore <= bScore && aScore < score) {
                    aScore = score;
                    aPoint = 0x01;
                    aIsFurtherSide = false;
                } else if (aScore > bScore && bScore < score) {
                    bScore = score;
                    bPoint = 0x01;
                    bIsFurtherSide = false;
                }
            }
            
            //Where each of the two closest points are determines how the extra two vertices are calculated.
            if (aIsFurtherSide == bIsFurtherSide) {
                if (aIsFurtherSide) { //Both closest points on (1,1,1) side

                    //One of the two extra points is (1,1,1)
                    dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb + 1;

                    //Other extra point is based on the shared axis.
                    byte c = (byte)(aPoint & bPoint);
                    if ((c & 0x01) != 0) {
                        dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 2;
                        ysv_ext1 = ysb;
                        zsv_ext1 = zsb;
                    } else if ((c & 0x02) != 0) {
                        dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb;
                        ysv_ext1 = ysb + 2;
                        zsv_ext1 = zsb;
                    } else {
                        dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb;
                        ysv_ext1 = ysb;
                        zsv_ext1 = zsb + 2;
                    }
                } else {//Both closest points on (0,0,0) side

                    //One of the two extra points is (0,0,0)
                    dx_ext0 = dx0;
                    dy_ext0 = dy0;
                    dz_ext0 = dz0;
                    xsv_ext0 = xsb;
                    ysv_ext0 = ysb;
                    zsv_ext0 = zsb;

                    //Other extra point is based on the omitted axis.
                    byte c = (byte)(aPoint | bPoint);
                    if ((c & 0x01) == 0) {
                        dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb - 1;
                        ysv_ext1 = ysb + 1;
                        zsv_ext1 = zsb + 1;
                    } else if ((c & 0x02) == 0) {
                        dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 1;
                        ysv_ext1 = ysb - 1;
                        zsv_ext1 = zsb + 1;
                    } else {
                        dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;
                        dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;
                        dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;
                        xsv_ext1 = xsb + 1;
                        ysv_ext1 = ysb + 1;
                        zsv_ext1 = zsb - 1;
                    }
                }
            } else { //One point on (0,0,0) side, one point on (1,1,1) side
                byte c1, c2;
                if (aIsFurtherSide) {
                    c1 = aPoint;
                    c2 = bPoint;
                } else {
                    c1 = bPoint;
                    c2 = aPoint;
                }

                //One contribution is a permutation of (1,1,-1)
                if ((c1 & 0x01) == 0) {
                    dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb - 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb + 1;
                } else if ((c1 & 0x02) == 0) {
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb - 1;
                    zsv_ext0 = zsb + 1;
                } else {
                    dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;
                    dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;
                    dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;
                    xsv_ext0 = xsb + 1;
                    ysv_ext0 = ysb + 1;
                    zsv_ext0 = zsb - 1;
                }

                //One contribution is a permutation of (0,0,2)
                dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;
                dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;
                dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;
                xsv_ext1 = xsb;
                ysv_ext1 = ysb;
                zsv_ext1 = zsb;
                if ((c2 & 0x01) != 0) {
                    dx_ext1 -= 2;
                    xsv_ext1 += 2;
                } else if ((c2 & 0x02) != 0) {
                    dy_ext1 -= 2;
                    ysv_ext1 += 2;
                } else {
                    dz_ext1 -= 2;
                    zsv_ext1 += 2;
                }
            }

            //Contribution (1,0,0)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1);
            }

            //Contribution (0,1,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;
            double dz2 = dz1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2);
            }

            //Contribution (0,0,1)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3);
            }

            //Contribution (1,1,0)
            double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx4, dy4, dz4);
            }

            //Contribution (1,0,1)
            double dx5 = dx4;
            double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;
            double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;
            if (attn5 > 0) {
                attn5 *= attn5;
                value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx5, dy5, dz5);
            }

            //Contribution (0,1,1)
            double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;
            double dy6 = dy4;
            double dz6 = dz5;
            double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;
            if (attn6 > 0) {
                attn6 *= attn6;
                value += attn6 * attn6 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx6, dy6, dz6);
            }
        }
 
        //First extra vertex
        double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0;
        if (attn_ext0 > 0)
        {
            attn_ext0 *= attn_ext0;
            value += attn_ext0 * attn_ext0 * extrapolate(xsv_ext0, ysv_ext0, zsv_ext0, dx_ext0, dy_ext0, dz_ext0);
        }

        //Second extra vertex
        double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1;
        if (attn_ext1 > 0)
        {
            attn_ext1 *= attn_ext1;
            value += attn_ext1 * attn_ext1 * extrapolate(xsv_ext1, ysv_ext1, zsv_ext1, dx_ext1, dy_ext1, dz_ext1);
        }
        
        return value / NORM_CONSTANT_3D;
    }",3D OpenSimplex Noise.,OpenSimplexNoise.java,260.0,3
2,"public double eval(double x, double y, double z, double w) {
    
        //Place input coordinates on simplectic honeycomb.
        double stretchOffset = (x + y + z + w) * STRETCH_CONSTANT_4D;
        double xs = x + stretchOffset;
        double ys = y + stretchOffset;
        double zs = z + stretchOffset;
        double ws = w + stretchOffset;
        
        //Floor to get simplectic honeycomb coordinates of rhombo-hypercube super-cell origin.
        int xsb = fastFloor(xs);
        int ysb = fastFloor(ys);
        int zsb = fastFloor(zs);
        int wsb = fastFloor(ws);
        
        //Skew out to get actual coordinates of stretched rhombo-hypercube origin. We'll need these later.
        double squishOffset = (xsb + ysb + zsb + wsb) * SQUISH_CONSTANT_4D;
        double xb = xsb + squishOffset;
        double yb = ysb + squishOffset;
        double zb = zsb + squishOffset;
        double wb = wsb + squishOffset;
        
        //Compute simplectic honeycomb coordinates relative to rhombo-hypercube origin.
        double xins = xs - xsb;
        double yins = ys - ysb;
        double zins = zs - zsb;
        double wins = ws - wsb;
        
        //Sum those together to get a value that determines which region we're in.
        double inSum = xins + yins + zins + wins;

        //Positions relative to origin point.
        double dx0 = x - xb;
        double dy0 = y - yb;
        double dz0 = z - zb;
        double dw0 = w - wb;
        
        //We'll be defining these inside the next block and using them afterwards.
        double dx_ext0, dy_ext0, dz_ext0, dw_ext0;
        double dx_ext1, dy_ext1, dz_ext1, dw_ext1;
        double dx_ext2, dy_ext2, dz_ext2, dw_ext2;
        int xsv_ext0, ysv_ext0, zsv_ext0, wsv_ext0;
        int xsv_ext1, ysv_ext1, zsv_ext1, wsv_ext1;
        int xsv_ext2, ysv_ext2, zsv_ext2, wsv_ext2;
        
        double value = 0;
        if (inSum <= 1) { //We're inside the pentachoron (4-Simplex) at (0,0,0,0)

            //Determine which two of (0,0,0,1), (0,0,1,0), (0,1,0,0), (1,0,0,0) are closest.
            byte aPoint = 0x01;
            double aScore = xins;
            byte bPoint = 0x02;
            double bScore = yins;
            if (aScore >= bScore && zins > bScore) {
                bScore = zins;
                bPoint = 0x04;
            } else if (aScore < bScore && zins > aScore) {
                aScore = zins;
                aPoint = 0x04;
            }
            if (aScore >= bScore && wins > bScore) {
                bScore = wins;
                bPoint = 0x08;
            } else if (aScore < bScore && wins > aScore) {
                aScore = wins;
                aPoint = 0x08;
            }
            
            //Now we determine the three lattice points not part of the pentachoron that may contribute.
            //This depends on the closest two pentachoron vertices, including (0,0,0,0)
            double uins = 1 - inSum;
            if (uins > aScore || uins > bScore) { //(0,0,0,0) is one of the closest two pentachoron vertices.
                byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsb - 1;
                    xsv_ext1 = xsv_ext2 = xsb;
                    dx_ext0 = dx0 + 1;
                    dx_ext1 = dx_ext2 = dx0;
                } else {
                    xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb + 1;
                    dx_ext0 = dx_ext1 = dx_ext2 = dx0 - 1;
                }

                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb;
                    dy_ext0 = dy_ext1 = dy_ext2 = dy0;
                    if ((c & 0x01) == 0x01) {
                        ysv_ext0 -= 1;
                        dy_ext0 += 1;
                    } else {
                        ysv_ext1 -= 1;
                        dy_ext1 += 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 1;
                }
                
                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb;
                    dz_ext0 = dz_ext1 = dz_ext2 = dz0;
                    if ((c & 0x03) != 0) {
                        if ((c & 0x03) == 0x03) {
                            zsv_ext0 -= 1;
                            dz_ext0 += 1;
                        } else {
                            zsv_ext1 -= 1;
                            dz_ext1 += 1;
                        }
                    } else {
                        zsv_ext2 -= 1;
                        dz_ext2 += 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 1;
                }
                
                if ((c & 0x08) == 0) {
                    wsv_ext0 = wsv_ext1 = wsb;
                    wsv_ext2 = wsb - 1;
                    dw_ext0 = dw_ext1 = dw0;
                    dw_ext2 = dw0 + 1;
                } else {
                    wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb + 1;
                    dw_ext0 = dw_ext1 = dw_ext2 = dw0 - 1;
                }
            } else { //(0,0,0,0) is not one of the closest two pentachoron vertices.
                byte c = (byte)(aPoint | bPoint); //Our three extra vertices are determined by the closest two.
                
                if ((c & 0x01) == 0) {
                    xsv_ext0 = xsv_ext2 = xsb;
                    xsv_ext1 = xsb - 1;
                    dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_4D;
                    dx_ext2 = dx0 - SQUISH_CONSTANT_4D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb + 1;
                    dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx_ext2 = dx0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x02) == 0) {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb;
                    dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext1 = dy_ext2 = dy0 - SQUISH_CONSTANT_4D;
                    if ((c & 0x01) == 0x01) {
                        ysv_ext1 -= 1;
                        dy_ext1 += 1;
                    } else {
                        ysv_ext2 -= 1;
                        dy_ext2 += 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1;
                    dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext1 = dy_ext2 = dy0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x04) == 0) {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb;
                    dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext1 = dz_ext2 = dz0 - SQUISH_CONSTANT_4D;
                    if ((c & 0x03) == 0x03) {
                        zsv_ext1 -= 1;
                        dz_ext1 += 1;
                    } else {
                        zsv_ext2 -= 1;
                        dz_ext2 += 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1;
                    dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext1 = dz_ext2 = dz0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x08) == 0) {
                    wsv_ext0 = wsv_ext1 = wsb;
                    wsv_ext2 = wsb - 1;
                    dw_ext0 = dw0 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw0 - SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 + 1 - SQUISH_CONSTANT_4D;
                } else {
                    wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb + 1;
                    dw_ext0 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw_ext2 = dw0 - 1 - SQUISH_CONSTANT_4D;
                }
            }

            //Contribution (0,0,0,0)
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0 - dw0 * dw0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value += attn0 * attn0 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 0, dx0, dy0, dz0, dw0);
            }

            //Contribution (1,0,0,0)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_4D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_4D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_4D;
            double dw1 = dw0 - 0 - SQUISH_CONSTANT_4D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 0, dx1, dy1, dz1, dw1);
            }

            //Contribution (0,1,0,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_4D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_4D;
            double dz2 = dz1;
            double dw2 = dw1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 0, dx2, dy2, dz2, dw2);
            }

            //Contribution (0,0,1,0)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_4D;
            double dw3 = dw1;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 0, dx3, dy3, dz3, dw3);
            }

            //Contribution (0,0,0,1)
            double dx4 = dx2;
            double dy4 = dy1;
            double dz4 = dz1;
            double dw4 = dw0 - 1 - SQUISH_CONSTANT_4D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 1, dx4, dy4, dz4, dw4);
            }
        } else if (inSum >= 3) { //We're inside the pentachoron (4-Simplex) at (1,1,1,1)
            //Determine which two of (1,1,1,0), (1,1,0,1), (1,0,1,1), (0,1,1,1) are closest.
            byte aPoint = 0x0E;
            double aScore = xins;
            byte bPoint = 0x0D;
            double bScore = yins;
            if (aScore <= bScore && zins < bScore) {
                bScore = zins;
                bPoint = 0x0B;
            } else if (aScore > bScore && zins < aScore) {
                aScore = zins;
                aPoint = 0x0B;
            }
            if (aScore <= bScore && wins < bScore) {
                bScore = wins;
                bPoint = 0x07;
            } else if (aScore > bScore && wins < aScore) {
                aScore = wins;
                aPoint = 0x07;
            }
            
            //Now we determine the three lattice points not part of the pentachoron that may contribute.
            //This depends on the closest two pentachoron vertices, including (0,0,0,0)
            double uins = 4 - inSum;
            if (uins < aScore || uins < bScore) { //(1,1,1,1) is one of the closest two pentachoron vertices.
                byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsb + 2;
                    xsv_ext1 = xsv_ext2 = xsb + 1;
                    dx_ext0 = dx0 - 2 - 4 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx_ext2 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb;
                    dx_ext0 = dx_ext1 = dx_ext2 = dx0 - 4 * SQUISH_CONSTANT_4D;
                }

                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    if ((c & 0x01) != 0) {
                        ysv_ext1 += 1;
                        dy_ext1 -= 1;
                    } else {
                        ysv_ext0 += 1;
                        dy_ext0 -= 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb;
                    dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 4 * SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    if ((c & 0x03) != 0x03) {
                        if ((c & 0x03) == 0) {
                            zsv_ext0 += 1;
                            dz_ext0 -= 1;
                        } else {
                            zsv_ext1 += 1;
                            dz_ext1 -= 1;
                        }
                    } else {
                        zsv_ext2 += 1;
                        dz_ext2 -= 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb;
                    dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 4 * SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x08) != 0) {
                    wsv_ext0 = wsv_ext1 = wsb + 1;
                    wsv_ext2 = wsb + 2;
                    dw_ext0 = dw_ext1 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 - 2 - 4 * SQUISH_CONSTANT_4D;
                } else {
                    wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb;
                    dw_ext0 = dw_ext1 = dw_ext2 = dw0 - 4 * SQUISH_CONSTANT_4D;
                }
            } else { //(1,1,1,1) is not one of the closest two pentachoron vertices.
                byte c = (byte)(aPoint & bPoint); //Our three extra vertices are determined by the closest two.
                
                if ((c & 0x01) != 0) {
                    xsv_ext0 = xsv_ext2 = xsb + 1;
                    xsv_ext1 = xsb + 2;
                    dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D;
                    dx_ext2 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb;
                    dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx_ext2 = dx0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x02) != 0) {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1;
                    dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext1 = dy_ext2 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    if ((c & 0x01) != 0) {
                        ysv_ext2 += 1;
                        dy_ext2 -= 1;
                    } else {
                        ysv_ext1 += 1;
                        dy_ext1 -= 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb;
                    dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext1 = dy_ext2 = dy0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x04) != 0) {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1;
                    dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext1 = dz_ext2 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    if ((c & 0x03) != 0) {
                        zsv_ext2 += 1;
                        dz_ext2 -= 1;
                    } else {
                        zsv_ext1 += 1;
                        dz_ext1 -= 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb;
                    dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext1 = dz_ext2 = dz0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c & 0x08) != 0) {
                    wsv_ext0 = wsv_ext1 = wsb + 1;
                    wsv_ext2 = wsb + 2;
                    dw_ext0 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D;
                } else {
                    wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb;
                    dw_ext0 = dw0 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw_ext2 = dw0 - 3 * SQUISH_CONSTANT_4D;
                }
            }

            //Contribution (1,1,1,0)
            double dx4 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dy4 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dz4 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dw4 = dw0 - 3 * SQUISH_CONSTANT_4D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 0, dx4, dy4, dz4, dw4);
            }

            //Contribution (1,1,0,1)
            double dx3 = dx4;
            double dy3 = dy4;
            double dz3 = dz0 - 3 * SQUISH_CONSTANT_4D;
            double dw3 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 1, dx3, dy3, dz3, dw3);
            }

            //Contribution (1,0,1,1)
            double dx2 = dx4;
            double dy2 = dy0 - 3 * SQUISH_CONSTANT_4D;
            double dz2 = dz4;
            double dw2 = dw3;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 1, dx2, dy2, dz2, dw2);
            }

            //Contribution (0,1,1,1)
            double dx1 = dx0 - 3 * SQUISH_CONSTANT_4D;
            double dz1 = dz4;
            double dy1 = dy4;
            double dw1 = dw3;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 1, dx1, dy1, dz1, dw1);
            }

            //Contribution (1,1,1,1)
            dx0 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D;
            dy0 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D;
            dz0 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D;
            dw0 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D;
            double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0 - dw0 * dw0;
            if (attn0 > 0) {
                attn0 *= attn0;
                value += attn0 * attn0 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 1, dx0, dy0, dz0, dw0);
            }
        } else if (inSum <= 2) { //We're inside the first dispentachoron (Rectified 4-Simplex)
            double aScore;
            byte aPoint;
            boolean aIsBiggerSide = true;
            double bScore;
            byte bPoint;
            boolean bIsBiggerSide = true;
            
            //Decide between (1,1,0,0) and (0,0,1,1)
            if (xins + yins > zins + wins) {
                aScore = xins + yins;
                aPoint = 0x03;
            } else {
                aScore = zins + wins;
                aPoint = 0x0C;
            }
            
            //Decide between (1,0,1,0) and (0,1,0,1)
            if (xins + zins > yins + wins) {
                bScore = xins + zins;
                bPoint = 0x05;
            } else {
                bScore = yins + wins;
                bPoint = 0x0A;
            }
            
            //Closer between (1,0,0,1) and (0,1,1,0) will replace the further of a and b, if closer.
            if (xins + wins > yins + zins) {
                double score = xins + wins;
                if (aScore >= bScore && score > bScore) {
                    bScore = score;
                    bPoint = 0x09;
                } else if (aScore < bScore && score > aScore) {
                    aScore = score;
                    aPoint = 0x09;
                }
            } else {
                double score = yins + zins;
                if (aScore >= bScore && score > bScore) {
                    bScore = score;
                    bPoint = 0x06;
                } else if (aScore < bScore && score > aScore) {
                    aScore = score;
                    aPoint = 0x06;
                }
            }
            
            //Decide if (1,0,0,0) is closer.
            double p1 = 2 - inSum + xins;
            if (aScore >= bScore && p1 > bScore) {
                bScore = p1;
                bPoint = 0x01;
                bIsBiggerSide = false;
            } else if (aScore < bScore && p1 > aScore) {
                aScore = p1;
                aPoint = 0x01;
                aIsBiggerSide = false;
            }
            
            //Decide if (0,1,0,0) is closer.
            double p2 = 2 - inSum + yins;
            if (aScore >= bScore && p2 > bScore) {
                bScore = p2;
                bPoint = 0x02;
                bIsBiggerSide = false;
            } else if (aScore < bScore && p2 > aScore) {
                aScore = p2;
                aPoint = 0x02;
                aIsBiggerSide = false;
            }
            
            //Decide if (0,0,1,0) is closer.
            double p3 = 2 - inSum + zins;
            if (aScore >= bScore && p3 > bScore) {
                bScore = p3;
                bPoint = 0x04;
                bIsBiggerSide = false;
            } else if (aScore < bScore && p3 > aScore) {
                aScore = p3;
                aPoint = 0x04;
                aIsBiggerSide = false;
            }
            
            //Decide if (0,0,0,1) is closer.
            double p4 = 2 - inSum + wins;
            if (aScore >= bScore && p4 > bScore) {
                bScore = p4;
                bPoint = 0x08;
                bIsBiggerSide = false;
            } else if (aScore < bScore && p4 > aScore) {
                aScore = p4;
                aPoint = 0x08;
                aIsBiggerSide = false;
            }
            
            //Where each of the two closest points are determines how the extra three vertices are calculated.
            if (aIsBiggerSide == bIsBiggerSide) {
                if (aIsBiggerSide) { //Both closest points on the bigger side
                    byte c1 = (byte)(aPoint | bPoint);
                    byte c2 = (byte)(aPoint & bPoint);
                    if ((c1 & 0x01) == 0) {
                        xsv_ext0 = xsb;
                        xsv_ext1 = xsb - 1;
                        dx_ext0 = dx0 - 3 * SQUISH_CONSTANT_4D;
                        dx_ext1 = dx0 + 1 - 2 * SQUISH_CONSTANT_4D;
                    } else {
                        xsv_ext0 = xsv_ext1 = xsb + 1;
                        dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        dx_ext1 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c1 & 0x02) == 0) {
                        ysv_ext0 = ysb;
                        ysv_ext1 = ysb - 1;
                        dy_ext0 = dy0 - 3 * SQUISH_CONSTANT_4D;
                        dy_ext1 = dy0 + 1 - 2 * SQUISH_CONSTANT_4D;
                    } else {
                        ysv_ext0 = ysv_ext1 = ysb + 1;
                        dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        dy_ext1 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c1 & 0x04) == 0) {
                        zsv_ext0 = zsb;
                        zsv_ext1 = zsb - 1;
                        dz_ext0 = dz0 - 3 * SQUISH_CONSTANT_4D;
                        dz_ext1 = dz0 + 1 - 2 * SQUISH_CONSTANT_4D;
                    } else {
                        zsv_ext0 = zsv_ext1 = zsb + 1;
                        dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        dz_ext1 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c1 & 0x08) == 0) {
                        wsv_ext0 = wsb;
                        wsv_ext1 = wsb - 1;
                        dw_ext0 = dw0 - 3 * SQUISH_CONSTANT_4D;
                        dw_ext1 = dw0 + 1 - 2 * SQUISH_CONSTANT_4D;
                    } else {
                        wsv_ext0 = wsv_ext1 = wsb + 1;
                        dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        dw_ext1 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    }
                    
                    //One combination is a permutation of (0,0,0,2) based on c2
                    xsv_ext2 = xsb;
                    ysv_ext2 = ysb;
                    zsv_ext2 = zsb;
                    wsv_ext2 = wsb;
                    dx_ext2 = dx0 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext2 = dy0 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext2 = dz0 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 - 2 * SQUISH_CONSTANT_4D;
                    if ((c2 & 0x01) != 0) {
                        xsv_ext2 += 2;
                        dx_ext2 -= 2;
                    } else if ((c2 & 0x02) != 0) {
                        ysv_ext2 += 2;
                        dy_ext2 -= 2;
                    } else if ((c2 & 0x04) != 0) {
                        zsv_ext2 += 2;
                        dz_ext2 -= 2;
                    } else {
                        wsv_ext2 += 2;
                        dw_ext2 -= 2;
                    }
                    
                } else { //Both closest points on the smaller side
                    //One of the two extra points is (0,0,0,0)
                    xsv_ext2 = xsb;
                    ysv_ext2 = ysb;
                    zsv_ext2 = zsb;
                    wsv_ext2 = wsb;
                    dx_ext2 = dx0;
                    dy_ext2 = dy0;
                    dz_ext2 = dz0;
                    dw_ext2 = dw0;
                    
                    //Other two points are based on the omitted axes.
                    byte c = (byte)(aPoint | bPoint);
                    
                    if ((c & 0x01) == 0) {
                        xsv_ext0 = xsb - 1;
                        xsv_ext1 = xsb;
                        dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_4D;
                        dx_ext1 = dx0 - SQUISH_CONSTANT_4D;
                    } else {
                        xsv_ext0 = xsv_ext1 = xsb + 1;
                        dx_ext0 = dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x02) == 0) {
                        ysv_ext0 = ysv_ext1 = ysb;
                        dy_ext0 = dy_ext1 = dy0 - SQUISH_CONSTANT_4D;
                        if ((c & 0x01) == 0x01)
                        {
                            ysv_ext0 -= 1;
                            dy_ext0 += 1;
                        } else {
                            ysv_ext1 -= 1;
                            dy_ext1 += 1;
                        }
                    } else {
                        ysv_ext0 = ysv_ext1 = ysb + 1;
                        dy_ext0 = dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x04) == 0) {
                        zsv_ext0 = zsv_ext1 = zsb;
                        dz_ext0 = dz_ext1 = dz0 - SQUISH_CONSTANT_4D;
                        if ((c & 0x03) == 0x03)
                        {
                            zsv_ext0 -= 1;
                            dz_ext0 += 1;
                        } else {
                            zsv_ext1 -= 1;
                            dz_ext1 += 1;
                        }
                    } else {
                        zsv_ext0 = zsv_ext1 = zsb + 1;
                        dz_ext0 = dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x08) == 0)
                    {
                        wsv_ext0 = wsb;
                        wsv_ext1 = wsb - 1;
                        dw_ext0 = dw0 - SQUISH_CONSTANT_4D;
                        dw_ext1 = dw0 + 1 - SQUISH_CONSTANT_4D;
                    } else {
                        wsv_ext0 = wsv_ext1 = wsb + 1;
                        dw_ext0 = dw_ext1 = dw0 - 1 - SQUISH_CONSTANT_4D;
                    }
                    
                }
            } else { //One point on each ""side""
                byte c1, c2;
                if (aIsBiggerSide) {
                    c1 = aPoint;
                    c2 = bPoint;
                } else {
                    c1 = bPoint;
                    c2 = aPoint;
                }
                
                //Two contributions are the bigger-sided point with each 0 replaced with -1.
                if ((c1 & 0x01) == 0) {
                    xsv_ext0 = xsb - 1;
                    xsv_ext1 = xsb;
                    dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_4D;
                    dx_ext1 = dx0 - SQUISH_CONSTANT_4D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb + 1;
                    dx_ext0 = dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x02) == 0) {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0 - SQUISH_CONSTANT_4D;
                    if ((c1 & 0x01) == 0x01) {
                        ysv_ext0 -= 1;
                        dy_ext0 += 1;
                    } else {
                        ysv_ext1 -= 1;
                        dy_ext1 += 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x04) == 0) {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz_ext1 = dz0 - SQUISH_CONSTANT_4D;
                    if ((c1 & 0x03) == 0x03) {
                        zsv_ext0 -= 1;
                        dz_ext0 += 1;
                    } else {
                        zsv_ext1 -= 1;
                        dz_ext1 += 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x08) == 0) {
                    wsv_ext0 = wsb;
                    wsv_ext1 = wsb - 1;
                    dw_ext0 = dw0 - SQUISH_CONSTANT_4D;
                    dw_ext1 = dw0 + 1 - SQUISH_CONSTANT_4D;
                } else {
                    wsv_ext0 = wsv_ext1 = wsb + 1;
                    dw_ext0 = dw_ext1 = dw0 - 1 - SQUISH_CONSTANT_4D;
                }

                //One contribution is a permutation of (0,0,0,2) based on the smaller-sided point
                xsv_ext2 = xsb;
                ysv_ext2 = ysb;
                zsv_ext2 = zsb;
                wsv_ext2 = wsb;
                dx_ext2 = dx0 - 2 * SQUISH_CONSTANT_4D;
                dy_ext2 = dy0 - 2 * SQUISH_CONSTANT_4D;
                dz_ext2 = dz0 - 2 * SQUISH_CONSTANT_4D;
                dw_ext2 = dw0 - 2 * SQUISH_CONSTANT_4D;
                if ((c2 & 0x01) != 0) {
                    xsv_ext2 += 2;
                    dx_ext2 -= 2;
                } else if ((c2 & 0x02) != 0) {
                    ysv_ext2 += 2;
                    dy_ext2 -= 2;
                } else if ((c2 & 0x04) != 0) {
                    zsv_ext2 += 2;
                    dz_ext2 -= 2;
                } else {
                    wsv_ext2 += 2;
                    dw_ext2 -= 2;
                }
            }
            
            //Contribution (1,0,0,0)
            double dx1 = dx0 - 1 - SQUISH_CONSTANT_4D;
            double dy1 = dy0 - 0 - SQUISH_CONSTANT_4D;
            double dz1 = dz0 - 0 - SQUISH_CONSTANT_4D;
            double dw1 = dw0 - 0 - SQUISH_CONSTANT_4D;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 0, dx1, dy1, dz1, dw1);
            }

            //Contribution (0,1,0,0)
            double dx2 = dx0 - 0 - SQUISH_CONSTANT_4D;
            double dy2 = dy0 - 1 - SQUISH_CONSTANT_4D;
            double dz2 = dz1;
            double dw2 = dw1;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 0, dx2, dy2, dz2, dw2);
            }

            //Contribution (0,0,1,0)
            double dx3 = dx2;
            double dy3 = dy1;
            double dz3 = dz0 - 1 - SQUISH_CONSTANT_4D;
            double dw3 = dw1;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 0, dx3, dy3, dz3, dw3);
            }

            //Contribution (0,0,0,1)
            double dx4 = dx2;
            double dy4 = dy1;
            double dz4 = dz1;
            double dw4 = dw0 - 1 - SQUISH_CONSTANT_4D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 1, dx4, dy4, dz4, dw4);
            }
            
            //Contribution (1,1,0,0)
            double dx5 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy5 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz5 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw5 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5 - dw5 * dw5;
            if (attn5 > 0) {
                attn5 *= attn5;
                value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 0, dx5, dy5, dz5, dw5);
            }
            
            //Contribution (1,0,1,0)
            double dx6 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy6 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz6 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw6 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6 - dw6 * dw6;
            if (attn6 > 0) {
                attn6 *= attn6;
                value += attn6 * attn6 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 0, dx6, dy6, dz6, dw6);
            }

            //Contribution (1,0,0,1)
            double dx7 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy7 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz7 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw7 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn7 = 2 - dx7 * dx7 - dy7 * dy7 - dz7 * dz7 - dw7 * dw7;
            if (attn7 > 0) {
                attn7 *= attn7;
                value += attn7 * attn7 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 1, dx7, dy7, dz7, dw7);
            }
            
            //Contribution (0,1,1,0)
            double dx8 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy8 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz8 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw8 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn8 = 2 - dx8 * dx8 - dy8 * dy8 - dz8 * dz8 - dw8 * dw8;
            if (attn8 > 0) {
                attn8 *= attn8;
                value += attn8 * attn8 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 0, dx8, dy8, dz8, dw8);
            }
            
            //Contribution (0,1,0,1)
            double dx9 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy9 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz9 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw9 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn9 = 2 - dx9 * dx9 - dy9 * dy9 - dz9 * dz9 - dw9 * dw9;
            if (attn9 > 0) {
                attn9 *= attn9;
                value += attn9 * attn9 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 1, dx9, dy9, dz9, dw9);
            }
            
            //Contribution (0,0,1,1)
            double dx10 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy10 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz10 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw10 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn10 = 2 - dx10 * dx10 - dy10 * dy10 - dz10 * dz10 - dw10 * dw10;
            if (attn10 > 0) {
                attn10 *= attn10;
                value += attn10 * attn10 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 1, dx10, dy10, dz10, dw10);
            }
        } else { //We're inside the second dispentachoron (Rectified 4-Simplex)
            double aScore;
            byte aPoint;
            boolean aIsBiggerSide = true;
            double bScore;
            byte bPoint;
            boolean bIsBiggerSide = true;
            
            //Decide between (0,0,1,1) and (1,1,0,0)
            if (xins + yins < zins + wins) {
                aScore = xins + yins;
                aPoint = 0x0C;
            } else {
                aScore = zins + wins;
                aPoint = 0x03;
            }
            
            //Decide between (0,1,0,1) and (1,0,1,0)
            if (xins + zins < yins + wins) {
                bScore = xins + zins;
                bPoint = 0x0A;
            } else {
                bScore = yins + wins;
                bPoint = 0x05;
            }
            
            //Closer between (0,1,1,0) and (1,0,0,1) will replace the further of a and b, if closer.
            if (xins + wins < yins + zins) {
                double score = xins + wins;
                if (aScore <= bScore && score < bScore) {
                    bScore = score;
                    bPoint = 0x06;
                } else if (aScore > bScore && score < aScore) {
                    aScore = score;
                    aPoint = 0x06;
                }
            } else {
                double score = yins + zins;
                if (aScore <= bScore && score < bScore) {
                    bScore = score;
                    bPoint = 0x09;
                } else if (aScore > bScore && score < aScore) {
                    aScore = score;
                    aPoint = 0x09;
                }
            }
            
            //Decide if (0,1,1,1) is closer.
            double p1 = 3 - inSum + xins;
            if (aScore <= bScore && p1 < bScore) {
                bScore = p1;
                bPoint = 0x0E;
                bIsBiggerSide = false;
            } else if (aScore > bScore && p1 < aScore) {
                aScore = p1;
                aPoint = 0x0E;
                aIsBiggerSide = false;
            }
            
            //Decide if (1,0,1,1) is closer.
            double p2 = 3 - inSum + yins;
            if (aScore <= bScore && p2 < bScore) {
                bScore = p2;
                bPoint = 0x0D;
                bIsBiggerSide = false;
            } else if (aScore > bScore && p2 < aScore) {
                aScore = p2;
                aPoint = 0x0D;
                aIsBiggerSide = false;
            }
            
            //Decide if (1,1,0,1) is closer.
            double p3 = 3 - inSum + zins;
            if (aScore <= bScore && p3 < bScore) {
                bScore = p3;
                bPoint = 0x0B;
                bIsBiggerSide = false;
            } else if (aScore > bScore && p3 < aScore) {
                aScore = p3;
                aPoint = 0x0B;
                aIsBiggerSide = false;
            }
            
            //Decide if (1,1,1,0) is closer.
            double p4 = 3 - inSum + wins;
            if (aScore <= bScore && p4 < bScore) {
                bScore = p4;
                bPoint = 0x07;
                bIsBiggerSide = false;
            } else if (aScore > bScore && p4 < aScore) {
                aScore = p4;
                aPoint = 0x07;
                aIsBiggerSide = false;
            }
            
            //Where each of the two closest points are determines how the extra three vertices are calculated.
            if (aIsBiggerSide == bIsBiggerSide) {
                if (aIsBiggerSide) { //Both closest points on the bigger side
                    byte c1 = (byte)(aPoint & bPoint);
                    byte c2 = (byte)(aPoint | bPoint);
                    
                    //Two contributions are permutations of (0,0,0,1) and (0,0,0,2) based on c1
                    xsv_ext0 = xsv_ext1 = xsb;
                    ysv_ext0 = ysv_ext1 = ysb;
                    zsv_ext0 = zsv_ext1 = zsb;
                    wsv_ext0 = wsv_ext1 = wsb;
                    dx_ext0 = dx0 - SQUISH_CONSTANT_4D;
                    dy_ext0 = dy0 - SQUISH_CONSTANT_4D;
                    dz_ext0 = dz0 - SQUISH_CONSTANT_4D;
                    dw_ext0 = dw0 - SQUISH_CONSTANT_4D;
                    dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw0 - 2 * SQUISH_CONSTANT_4D;
                    if ((c1 & 0x01) != 0) {
                        xsv_ext0 += 1;
                        dx_ext0 -= 1;
                        xsv_ext1 += 2;
                        dx_ext1 -= 2;
                    } else if ((c1 & 0x02) != 0) {
                        ysv_ext0 += 1;
                        dy_ext0 -= 1;
                        ysv_ext1 += 2;
                        dy_ext1 -= 2;
                    } else if ((c1 & 0x04) != 0) {
                        zsv_ext0 += 1;
                        dz_ext0 -= 1;
                        zsv_ext1 += 2;
                        dz_ext1 -= 2;
                    } else {
                        wsv_ext0 += 1;
                        dw_ext0 -= 1;
                        wsv_ext1 += 2;
                        dw_ext1 -= 2;
                    }
                    
                    //One contribution is a permutation of (1,1,1,-1) based on c2
                    xsv_ext2 = xsb + 1;
                    ysv_ext2 = ysb + 1;
                    zsv_ext2 = zsb + 1;
                    wsv_ext2 = wsb + 1;
                    dx_ext2 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dy_ext2 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dz_ext2 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
                    if ((c2 & 0x01) == 0) {
                        xsv_ext2 -= 2;
                        dx_ext2 += 2;
                    } else if ((c2 & 0x02) == 0) {
                        ysv_ext2 -= 2;
                        dy_ext2 += 2;
                    } else if ((c2 & 0x04) == 0) {
                        zsv_ext2 -= 2;
                        dz_ext2 += 2;
                    } else {
                        wsv_ext2 -= 2;
                        dw_ext2 += 2;
                    }
                } else { //Both closest points on the smaller side
                    //One of the two extra points is (1,1,1,1)
                    xsv_ext2 = xsb + 1;
                    ysv_ext2 = ysb + 1;
                    zsv_ext2 = zsb + 1;
                    wsv_ext2 = wsb + 1;
                    dx_ext2 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    dy_ext2 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    dz_ext2 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    dw_ext2 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D;
                    
                    //Other two points are based on the shared axes.
                    byte c = (byte)(aPoint & bPoint);
                    
                    if ((c & 0x01) != 0) {
                        xsv_ext0 = xsb + 2;
                        xsv_ext1 = xsb + 1;
                        dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D;
                        dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    } else {
                        xsv_ext0 = xsv_ext1 = xsb;
                        dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x02) != 0) {
                        ysv_ext0 = ysv_ext1 = ysb + 1;
                        dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        if ((c & 0x01) == 0)
                        {
                            ysv_ext0 += 1;
                            dy_ext0 -= 1;
                        } else {
                            ysv_ext1 += 1;
                            dy_ext1 -= 1;
                        }
                    } else {
                        ysv_ext0 = ysv_ext1 = ysb;
                        dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x04) != 0) {
                        zsv_ext0 = zsv_ext1 = zsb + 1;
                        dz_ext0 = dz_ext1 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        if ((c & 0x03) == 0)
                        {
                            zsv_ext0 += 1;
                            dz_ext0 -= 1;
                        } else {
                            zsv_ext1 += 1;
                            dz_ext1 -= 1;
                        }
                    } else {
                        zsv_ext0 = zsv_ext1 = zsb;
                        dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_4D;
                    }
                    
                    if ((c & 0x08) != 0)
                    {
                        wsv_ext0 = wsb + 1;
                        wsv_ext1 = wsb + 2;
                        dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
                        dw_ext1 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D;
                    } else {
                        wsv_ext0 = wsv_ext1 = wsb;
                        dw_ext0 = dw_ext1 = dw0 - 3 * SQUISH_CONSTANT_4D;
                    }
                }
            } else { //One point on each ""side""
                byte c1, c2;
                if (aIsBiggerSide) {
                    c1 = aPoint;
                    c2 = bPoint;
                } else {
                    c1 = bPoint;
                    c2 = aPoint;
                }
                
                //Two contributions are the bigger-sided point with each 1 replaced with 2.
                if ((c1 & 0x01) != 0) {
                    xsv_ext0 = xsb + 2;
                    xsv_ext1 = xsb + 1;
                    dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D;
                    dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
                } else {
                    xsv_ext0 = xsv_ext1 = xsb;
                    dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x02) != 0) {
                    ysv_ext0 = ysv_ext1 = ysb + 1;
                    dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    if ((c1 & 0x01) == 0) {
                        ysv_ext0 += 1;
                        dy_ext0 -= 1;
                    } else {
                        ysv_ext1 += 1;
                        dy_ext1 -= 1;
                    }
                } else {
                    ysv_ext0 = ysv_ext1 = ysb;
                    dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x04) != 0) {
                    zsv_ext0 = zsv_ext1 = zsb + 1;
                    dz_ext0 = dz_ext1 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    if ((c1 & 0x03) == 0) {
                        zsv_ext0 += 1;
                        dz_ext0 -= 1;
                    } else {
                        zsv_ext1 += 1;
                        dz_ext1 -= 1;
                    }
                } else {
                    zsv_ext0 = zsv_ext1 = zsb;
                    dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_4D;
                }
                
                if ((c1 & 0x08) != 0) {
                    wsv_ext0 = wsb + 1;
                    wsv_ext1 = wsb + 2;
                    dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
                    dw_ext1 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D;
                } else {
                    wsv_ext0 = wsv_ext1 = wsb;
                    dw_ext0 = dw_ext1 = dw0 - 3 * SQUISH_CONSTANT_4D;
                }

                //One contribution is a permutation of (1,1,1,-1) based on the smaller-sided point
                xsv_ext2 = xsb + 1;
                ysv_ext2 = ysb + 1;
                zsv_ext2 = zsb + 1;
                wsv_ext2 = wsb + 1;
                dx_ext2 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
                dy_ext2 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
                dz_ext2 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
                dw_ext2 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
                if ((c2 & 0x01) == 0) {
                    xsv_ext2 -= 2;
                    dx_ext2 += 2;
                } else if ((c2 & 0x02) == 0) {
                    ysv_ext2 -= 2;
                    dy_ext2 += 2;
                } else if ((c2 & 0x04) == 0) {
                    zsv_ext2 -= 2;
                    dz_ext2 += 2;
                } else {
                    wsv_ext2 -= 2;
                    dw_ext2 += 2;
                }
            }
            
            //Contribution (1,1,1,0)
            double dx4 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dy4 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dz4 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double dw4 = dw0 - 3 * SQUISH_CONSTANT_4D;
            double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4;
            if (attn4 > 0) {
                attn4 *= attn4;
                value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 0, dx4, dy4, dz4, dw4);
            }

            //Contribution (1,1,0,1)
            double dx3 = dx4;
            double dy3 = dy4;
            double dz3 = dz0 - 3 * SQUISH_CONSTANT_4D;
            double dw3 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D;
            double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3;
            if (attn3 > 0) {
                attn3 *= attn3;
                value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 1, dx3, dy3, dz3, dw3);
            }

            //Contribution (1,0,1,1)
            double dx2 = dx4;
            double dy2 = dy0 - 3 * SQUISH_CONSTANT_4D;
            double dz2 = dz4;
            double dw2 = dw3;
            double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2;
            if (attn2 > 0) {
                attn2 *= attn2;
                value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 1, dx2, dy2, dz2, dw2);
            }

            //Contribution (0,1,1,1)
            double dx1 = dx0 - 3 * SQUISH_CONSTANT_4D;
            double dz1 = dz4;
            double dy1 = dy4;
            double dw1 = dw3;
            double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1;
            if (attn1 > 0) {
                attn1 *= attn1;
                value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 1, dx1, dy1, dz1, dw1);
            }
            
            //Contribution (1,1,0,0)
            double dx5 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy5 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz5 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw5 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5 - dw5 * dw5;
            if (attn5 > 0) {
                attn5 *= attn5;
                value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 0, dx5, dy5, dz5, dw5);
            }
            
            //Contribution (1,0,1,0)
            double dx6 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy6 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz6 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw6 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6 - dw6 * dw6;
            if (attn6 > 0) {
                attn6 *= attn6;
                value += attn6 * attn6 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 0, dx6, dy6, dz6, dw6);
            }

            //Contribution (1,0,0,1)
            double dx7 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dy7 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz7 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw7 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn7 = 2 - dx7 * dx7 - dy7 * dy7 - dz7 * dz7 - dw7 * dw7;
            if (attn7 > 0) {
                attn7 *= attn7;
                value += attn7 * attn7 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 1, dx7, dy7, dz7, dw7);
            }
            
            //Contribution (0,1,1,0)
            double dx8 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy8 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz8 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw8 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double attn8 = 2 - dx8 * dx8 - dy8 * dy8 - dz8 * dz8 - dw8 * dw8;
            if (attn8 > 0) {
                attn8 *= attn8;
                value += attn8 * attn8 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 0, dx8, dy8, dz8, dw8);
            }
            
            //Contribution (0,1,0,1)
            double dx9 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy9 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dz9 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dw9 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn9 = 2 - dx9 * dx9 - dy9 * dy9 - dz9 * dz9 - dw9 * dw9;
            if (attn9 > 0) {
                attn9 *= attn9;
                value += attn9 * attn9 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 1, dx9, dy9, dz9, dw9);
            }
            
            //Contribution (0,0,1,1)
            double dx10 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dy10 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D;
            double dz10 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double dw10 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D;
            double attn10 = 2 - dx10 * dx10 - dy10 * dy10 - dz10 * dz10 - dw10 * dw10;
            if (attn10 > 0) {
                attn10 *= attn10;
                value += attn10 * attn10 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 1, dx10, dy10, dz10, dw10);
            }
        }
 
        //First extra vertex
        double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0 - dw_ext0 * dw_ext0;
        if (attn_ext0 > 0)
        {
            attn_ext0 *= attn_ext0;
            value += attn_ext0 * attn_ext0 * extrapolate(xsv_ext0, ysv_ext0, zsv_ext0, wsv_ext0, dx_ext0, dy_ext0, dz_ext0, dw_ext0);
        }

        //Second extra vertex
        double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1 - dw_ext1 * dw_ext1;
        if (attn_ext1 > 0)
        {
            attn_ext1 *= attn_ext1;
            value += attn_ext1 * attn_ext1 * extrapolate(xsv_ext1, ysv_ext1, zsv_ext1, wsv_ext1, dx_ext1, dy_ext1, dz_ext1, dw_ext1);
        }

        //Third extra vertex
        double attn_ext2 = 2 - dx_ext2 * dx_ext2 - dy_ext2 * dy_ext2 - dz_ext2 * dz_ext2 - dw_ext2 * dw_ext2;
        if (attn_ext2 > 0)
        {
            attn_ext2 *= attn_ext2;
            value += attn_ext2 * attn_ext2 * extrapolate(xsv_ext2, ysv_ext2, zsv_ext2, wsv_ext2, dx_ext2, dy_ext2, dz_ext2, dw_ext2);
        }

        return value / NORM_CONSTANT_4D;
    }",4D OpenSimplex Noise.,OpenSimplexNoise.java,260.0,3
0,"public void generateRoad()
    {   
        int startPoint = startRoad+(Math.round(currentRoadStep*slope));
        if (roadConstruction) {
            if (fromTop) {
                for (int col = startPoint; col<(startPoint + 8); col++) {
                    field.getField()[currentRoadStep][col] = new Tarmac();
                }
                currentRoadStep++;
                if (currentRoadStep == field.getDepth()) roadConstruction = false;
            }
            else {
                for (int row = startPoint; row<(startPoint + 8); row++) {
                    field.getField()[row][currentRoadStep] = new Tarmac();
                }
                currentRoadStep++;
                if (currentRoadStep == field.getWidth()) roadConstruction = false;
            }
        }
    }",Generate the road tiles at appropriate locations in the field.,Road.java,260.0,3
1,"public void createRoad()
    {
        if (fromTop) { // top to bottom
            startRoad = rand.nextInt(field.getWidth()-5)+5; // create the start point within sensible bounds
            int end = field.getWidth() - startRoad;
            slope = (float)(end-startRoad)/field.getDepth(); // obtain the (inverted) gradient of our road
        }
        else { // left to right
            startRoad = rand.nextInt(field.getDepth()-5)+5; // create the start point within sensible bounds
            int end = field.getDepth() - startRoad;
            slope = (float)(end-startRoad)/field.getWidth(); // obtain the (inverted) gradient of our road
        }
    }","Create a random value for the road's starting point, and calculate the road's slope.",Road.java,260.0,3
0,"public boolean isFlooding()
    {
        return isFlooding;
    }",@return true if it is currently flooding.,Weather.java,260.0,3
1,"public boolean isDroughting()
    {
        return isDroughting;
    }",@return true if it is currently droughting.,Weather.java,260.0,3
2,"public void determineFog()
    {
        isFog = fogTime > 0;
        if (!isFog && rand.nextDouble()<0.01) {fogTime = rand.nextInt(25) + 12; } // value between 12 and 24 inclusive
    }",Determine if fog is currently occuring.,Weather.java,260.0,3
3,"public void determineStates()
    {
        if (currentRainOrSun > 0.5) isRaining = true;
        else isRaining = false;

        if (currentRainOrSun > floodingThreshold) {
            isFlooding = true; 
            isDroughting = false;
        }
        else if (currentRainOrSun < droughtThreshold) {
            isDroughting = true; 
            isFlooding = false;
        }
        else {
            isDroughting = false;
            isFlooding = false;
        }
    }","Determine if a drought or flood is currently occuring, and if it is raining or sunny.",Weather.java,260.0,3
4,"public void step()
    {
        // decrement the amount of time
        fogTime--;
        weatherSteps--;

        // determine if a a new weather state may occur
        determineFog();

        if (weatherSteps <= 0) {
            currentRainOrSun = rand.nextDouble();
            weatherSteps = rand.nextInt(maxWeatherLength) + minWeatherLength;
            determineStates();
        }
    }","Decrement the amount of time that rain and/or fog is currently running for. If they're not running, do nothing.",Weather.java,260.0,3
5,"public boolean isFog()
    {
        return isFog;
    }",@return true if it's foggy,Weather.java,260.0,3
6,"public boolean isRaining()
    {
        return isRaining;
    }",@return true if it's raining,Weather.java,260.0,3
0,"public void act(List<Actor> newPlants, boolean isDay, boolean harshWeather)
    {
        if (harshWeather) decCount(rand.nextInt(5));
        else if (isDay) incCountOne();
    }","This is what the plant does most of the time.
The plants will either grow during the day or not grow (die) in harsh weather.
@param newAnimals A list to return newly born animals.
@param isDay True if it is day, False if not.
@param harshWeather True if weather is harsh, False if not",Plant.java,260.0,3
1,"public int getCount()
    {
        return plantCount;
    }","Get the count of the plant.
@return count.",Plant.java,260.0,3
2,"public void incCountOne()
    {
        plantCount = ((plantCount+=10) > 1000) ? 1000 : plantCount;   
    }",Increment the plant's count by 10.,Plant.java,260.0,3
3,"public void incCount(int amount)
    {
        plantCount = ((plantCount+=amount)>1000) ? 1000 : plantCount;
    }","Increment the plant's count by an amount.
@param Integer amount to be incremented by.",Plant.java,260.0,3
4,"public void decCount(int amount)
    {
        plantCount = ((plantCount-=amount)>1000) ? 1000 : plantCount;
    }","Decrement the plant's count by an amount.
@param Integer amount to be decremented by.",Plant.java,260.0,3
5,"public void getEaten()
    {
        plantCount -= 50;
    }",Reduce the plant's count when eaten.,Plant.java,260.0,3
6,"public int getFoodValue()
    {
        return 1;
    }",@return the plant's food value for animals that consume it.,Plant.java,260.0,3
7,"public boolean isAvailable()
    {
        return plantCount>10;
    }",@return whether or not the plant is currently available (i.e. eatable),Plant.java,260.0,3
0,"public Color getMinColor()
    {
        return MIN_COLOR;
    }",@return the min color,ShallowWater.java,260.0,3
1,"public Color getMinMedColor()
    {
        return MIN_MED_COLOR;
    }",@return the min med color,ShallowWater.java,260.0,3
2,"public Color getMedColor()
    {
        return MED_COLOR;
    }",@return the med color,ShallowWater.java,260.0,3
3,"public Color getMedMaxColor()
    {
        return MED_MAX_COLOR;
    }",@return the med max color,ShallowWater.java,260.0,3
4,"public Color getMaxColor()
    {
        return MAX_COLOR;
    }",@return the max color,ShallowWater.java,260.0,3
0,"protected List<Location> getAdjacentLocations()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation()); 
        return adjacent;
    }","Look for prey adjacent to the current location.
Only the first live prey animal is eaten.

@return A list of where food was found, or null if it wasn't.",Prey.java,260.0,3
0,"protected Color getColor()
    {
        Collections.shuffle(colorArray);
        return colorArray.get(0);
    }",Determine the color of the Road Tile,Tarmac.java,260.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,260.0,3
1,"private Color getColor(Class<?> animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,260.0,3
2,"public void showStatus(int step, Field field, boolean isDay, int amount)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        
        boolean isRaining = field.getWeather().isRaining();
        boolean isFog = field.getWeather().isFog();
        boolean isFlooding = field.getWeather().isFlooding();
        boolean isDroughting = field.getWeather().isDroughting;
        
        
        stepLabel.setText(STEP_PREFIX + step + "" Day: "" + isDay + "" isRaining: "" + isRaining + "" isFog: "" + isFog + "" isFlooding: "" + isFlooding + "" isDroughting: "" + isDroughting);
        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object obj = field.getAnimalAt(row, col);
                Animal animal = (Animal) obj;
                if(animal != null) {
                    Class<?> cls = animal.getClass();
                    stats.incrementCount(cls, 1);
                    fieldView.drawMark(row, col, animal.getColor());
                }
                else {
                    // determine the correct color of the topographical map
                    Color color = field.getTile(row, col).determineColor();
                    int R = color.getRed();
                    int G = color.getGreen();
                    int B = color.getBlue();
                    for(int i = 0; i < amount; i++) {
                        R -= Math.round(R*0.05);
                        G -= Math.round(G*0.05);
                        B -= Math.round(B*0.05);
                    }
                    color = new Color(R, G, B);
                    fieldView.drawMark(row, col, color);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GridView.java,260.0,3
3,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,260.0,3
4,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,260.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return The pike's max age.,Pike.java,260.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return The pike's breeding age,Pike.java,260.0,3
2,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return The pike's breeding probability,Pike.java,260.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return The pike's max litter size (max amount of babies able to be created at once),Pike.java,260.0,3
4,"public Set<Class> getPrey()
    {
        return PREY_SET;
    }",@return The set of the pike's prey animals.,Pike.java,260.0,3
5,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return The pike's food value to it's predators.,Pike.java,260.0,3
6,"public int getMaxFullness()
    {
        return MAX_FULLNESS;
    }",@return The pike's maximum fullness level.,Pike.java,260.0,3
7,"protected double getBreedingFullness()
    {
        return BREEDING_FULLNESS;
    }",@return The animal's breeding fullness value,Pike.java,260.0,3
8,"public Color[] getColors()
    {
        return colors;
    }",@return the set of the animal's possible colors.,Pike.java,260.0,3
9,"public Set<Class> getWalkableTiles()
    {
        return WALKABLE_TILES;
    }",@return The pike's walkable tiles,Pike.java,260.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,260.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,260.0,3
2,"public void increment(int increment)
    {
        count+= increment;
    }","Increment the current count by specified increment.
@param int increment",Counter.java,260.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,260.0,3
0,"protected Color getColor()
    {
        Collections.shuffle(colorArray);
        return colorArray.get(0);
    }",Determine the color of the SeaBed Tile,SeaBed.java,260.0,3
0,"protected List<Location> getAdjacentLocations()
    {
        Field field = getField();
        
        int sight = 2;
        if (field.getWeather().isFog()) sight = Randomizer.getRandom().nextInt(2); // predator's sight will limited to 0 or 1
        
        List<Location> adjacent = field.adjacentLocations(getLocation(), sight);    
        return adjacent;
    }",Return a list of adjacent locations from which to look for food.,Predator.java,260.0,3
0,"protected Color getColor()
    {
        Collections.shuffle(colorArray);
        return colorArray.get(0);
    }",Determine the color of the Rock Tile,Rock.java,260.0,3
0,"public void initialiseAnimals()
    {
        Object[] lionParams = new Object[] {0.07, Grass.class};
        Object[] zebraParams = new Object[] {0.24, Grass.class};
        Object[] sticklebackParams = new Object[] {0.24, DeepWater.class};
        Object[] pikeParams = new Object[] {0.07, DeepWater.class};
        Object[] alligatorParams = new Object[] {0.03, ShallowWater.class};

        animalNames.put(""Lion"", lionParams);
        animalNames.put(""Zebra"", zebraParams);
        animalNames.put(""Stickleback"", sticklebackParams);
        animalNames.put(""Pike"", pikeParams);
        animalNames.put(""Alligator"", alligatorParams);
    }","Populate the Map of animal names, their creation probabilities and their creation locations.",Simulator.java,260.0,3
1,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,260.0,3
2,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            // delay(30);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,260.0,3
3,"public void simulateOneStep()
    {
        step++;
        
        // commit the necessary changes as determined by weather
        determineWeatherEvents();
        determineDay();
        
        
        for(int i =0; i < roadList.size(); i++) {
            roadList.get(i).generateRoad();
        }
        
        
        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>();
        // Let all animals act.
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            actor.act(newActors, isDay, drought); // parameter isDay to determine day/night specific actions
            if(! actor.isActive()) {
                it.remove();
            }
        }

        // Add the newly born animals to the main list.
        actors.addAll(newActors);
        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
actor in the simulation",Simulator.java,260.0,3
4,"public void reset()
    {
        step = 0;
        actors.clear();
        for (SimulatorView view : views) {
            view.reset();
        }

        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,260.0,3
5,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(step, field, isDay, currentDarkness);
        }
    }",Update all existing views.,Simulator.java,260.0,3
6,"private void populate()
    {
        generateField();  // Initialise terrain tiles, and plants where applicable. 
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Set<String> names = animalNames.keySet();
                Iterator<String> it = names.iterator();
                boolean notPopulated = true;
                while(it.hasNext() && notPopulated) {
                    String name = it.next();
                    Object prob = animalNames.get(name)[0];
                    double probability = (Double) prob;
                    Object tile = animalNames.get(name)[1];
                    Class tileClass = (Class) tile;
                    if(rand.nextDouble() <= probability) {
                        Location location = new Location(row, col);
                        if(field.getTile(location).getClass() == tileClass){
                            try{
                                Object obj = Class.forName(name).getConstructor(boolean.class, Field.class, Location.class, int.class).newInstance(true, field, location, 0);
                                Actor animal = (Animal) obj;
                                actors.add(animal);
                            }
                            catch(ReflectiveOperationException e) {
                                System.out.println(e);
                            }
                        }
                    }

                    // else leave the location empty.
                }
            }
        }
    }",Randomly populate the field with the animals using reflection.,Simulator.java,260.0,3
7,"public void generateField()
    {
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                float luminance = TerrainGenerator.getLuminance(row, col);
                field.getField()[row][col] = Grassland.determineTile(luminance);
                Plant newPlant = field.getTile(row, col).getPlant();
                if(newPlant != null) {actors.add(newPlant);}
            }
        }
    }","Generate the field with correct Tile type, depending on TerrainGenerator.",Simulator.java,260.0,3
8,"public void generateFloodTiles()
    {
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if (!(field.getTile(row, col) instanceof Tarmac)) {
                    float luminance = TerrainGenerator.getLuminance(row, col);
                    if(luminance > (Grassland.getDeepWaterThreshold() - Grassland.getIncrement()) && luminance < Grassland.getDeepWaterThreshold() 
                    || luminance > (Grassland.getShallowWaterThreshold() - Grassland.getIncrement()) && luminance < Grassland.getShallowWaterThreshold()) {
                        field.getField()[row][col] = Grassland.determineTile(luminance);
                        Plant newPlant = field.getTile(row, col).getPlant();
                        if(newPlant != null) {actors.add(newPlant);}
                    }
                }
            }
        }
    }",Generate ONLY the tiles which have been recognized to change because of a flood.,Simulator.java,260.0,3
9,"public void generateDroughtTiles()
    {
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if (!(field.getTile(row, col) instanceof Tarmac)) {
                    float luminance = TerrainGenerator.getLuminance(row, col);
                    if(luminance < (Grassland.getDeepWaterThreshold() + Grassland.getIncrement()) && luminance > Grassland.getDeepWaterThreshold() 
                    || luminance < (Grassland.getShallowWaterThreshold() + Grassland.getIncrement()) && luminance > Grassland.getShallowWaterThreshold()) {
                        field.getField()[row][col] = Grassland.determineTile(luminance);
                        Plant newPlant = field.getTile(row, col).getPlant();
                        if(newPlant != null) {actors.add(newPlant);}
                    }
                }
            }
        }
    }",Generate ONLY the tiles which have been recognized to change because of a drought.,Simulator.java,260.0,3
10,"public void createRoad()
    {
        Road road = new Road(field);
        roadList.add(road);
    }",Create a new road and add it to the List of roads.,Simulator.java,260.0,3
11,"public void determineWeatherEvents()
    {
        Weather weather = field.getWeather();

        weather.step();  // Let weather object act for one step.
        if(weather.isFlooding() == true) {
            Grassland.flood();
            generateFloodTiles();
            drought = false;
        }
        else if(weather.isDroughting() == true) {
            Grassland.drought();
            generateDroughtTiles();
            drought = true;
        }
        else drought = false;
    }",Act on weather. Droughting causes multiple side effects.,Simulator.java,260.0,3
12,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,260.0,3
13,"private void determineDay()
    {
        isDay = (step % dayLength) < 12;

        // construct a darkness gradient which will be happen throughout day/night cycles
        int val;
        if (step%dayLength < 9) val = 0;
        else if (step%dayLength == 9 || step%dayLength == 23) val = 1;
        else if (step%dayLength == 10 || step%dayLength == 22) val = 2;
        else if (step%dayLength == 11 || step%dayLength == 21) val = 3;
        else val = 4;

        setCurrentDarkness(val);
    }","Determine if it's currently day (0-11) or night (12-23)
Thus there are 24 'time steps' in a day, 12 per day, 12 per night",Simulator.java,260.0,3
14,"private boolean isDay()
    {
        return isDay;
    }","@return True, if it's day. False, otherwise.",Simulator.java,260.0,3
15,"private void setCurrentDarkness(int value)
    {
        currentDarkness = value;
    }","Set the currentDarkness value to a specified value
@param value  The value to which currentDarkness will be set to",Simulator.java,260.0,3
16,"private int getCurrentDarkness()
    {
        return currentDarkness;
    }",@return how how many 'darkness' values the tiles must currently have,Simulator.java,260.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return The zebra's max age.,Zebra.java,260.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return The zebra's breeding age.,Zebra.java,260.0,3
2,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return The zebra's breeding probability.,Zebra.java,260.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return The zebra's maximum litter size.,Zebra.java,260.0,3
4,"public Set<Class> getPrey()
    {
        return PREY_SET;
    }",@return The set of the zebra's prey animals.,Zebra.java,260.0,3
5,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return The zebra's food value to it's predators.,Zebra.java,260.0,3
6,"public int getMaxFullness()
    {
        return MAX_FULLNESS;
    }",@return The zebra's max fullness.,Zebra.java,260.0,3
7,"protected double getBreedingFullness()
    {
        return BREEDING_FULLNESS;
    }",@return The animal's breeding fullness value.,Zebra.java,260.0,3
8,"public Color[] getColors()
    {
        return colors;
    }",@return the set of the zebra's possible colors.,Zebra.java,260.0,3
9,"public Set<Class> getWalkableTiles()
    {
        return WALKABLE_TILES;
    }",@return The zebra's walkable tiles,Zebra.java,260.0,3
0,"protected Color determineColor()
    {
        return color;
    }","determine the color of tile buy randomly picking a color from a provided list
@return the 0th index of the shuffled colors list (effectively a random color)",NonPlantTile.java,260.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,260.0,3
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,260.0,3
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,260.0,3
3,"public void incrementCount(Class animalClass, int increment)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment(increment);
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,260.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,260.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,260.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getAnimalAt(row, col);
                
                if(animal != null) {
                    incrementCount(animal.getClass(), 1);
                }
                Object plantobj = field.getPlantAt(row, col);
                if(plantobj != null) {
                    Plant plant = (Plant) plantobj;
                    incrementCount(plant.getClass(), plant.getCount());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,260.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,260.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,260.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,260.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,260.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,260.0,3
0,"public boolean isActive()
    {
        return alive;
    }","Check whether the organism is active/alive or not.
@return true if the organism is active/alive.",Organism.java,260.0,3
1,"public void setInactive()
    {
        alive = false;
    }",Set the organism's state to inactive,Organism.java,260.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,260.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,260.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,260.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,260.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,260.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,260.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,260.0,3
0,"public Tile[][] getField()
    {
        return field;
    }",@return The array of tiles.,Field.java,260.0,3
1,"public TerrainGenerator getTR()
    {
        return tr;
    }",@return TerrainGenerator Object,Field.java,260.0,3
2,"public Weather getWeather()
    {
        return weather;
    }","@return Weather, the current weather of the field.",Field.java,260.0,3
3,"public Tile getTile(Location location)
    {
        return field[location.getRow()][location.getCol()];
    }",@return tile at given location.,Field.java,260.0,3
4,"public Tile getTile(int row, int col)
    {
        return field[row][col];
    }","@return tile at given location.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,260.0,3
5,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                getTile(row, col).clearAnimal();
            }
        }
    }",Empty the field of animals.,Field.java,260.0,3
6,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()].clearAnimal();
    }","Clear the given location of its animal.
@param location The location to clear.",Field.java,260.0,3
7,"public void place(Actor animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,260.0,3
8,"public void place(Actor animal, Location location)
    {
        field[location.getRow()][location.getCol()].setAnimal(animal);
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,260.0,3
9,"public Object getAnimalAt(Location location)
    {
        return getAnimalAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,260.0,3
10,"public Object getAnimalAt(int row, int col)
    {
        return field[row][col].getAnimal();
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,260.0,3
11,"public Object getOrganismAt(Location location)
    {
        return getOrganismAt(location.getRow(), location.getCol());
    }","Return the organism at the given location.
An animal will be returned, if any, otherwise the plant object at location will be returned, if any.
@param location Where in the field.
@return The organism at the given location, or null if there is none.",Field.java,260.0,3
12,"public Object getOrganismAt(int row, int col)
    {
        return field[row][col].getOrganism();
    }","Return the organism at the given location.
An animal will be returned, if any, otherwise the plant object at location will be returned, if any.
@param row The desired row.
@param col The desired column.
@return The organism at the given location, or null if there is none.",Field.java,260.0,3
13,"public Object getPlantAt(Location location)
    {
        return getPlantAt(location.getRow(), location.getCol());
    }","Return the plant at the given location, if any.
@param location Where in the field.
@return The plant at the given location, or null if there is none.",Field.java,260.0,3
14,"public Object getPlantAt(int row, int col)
    {
        return field[row][col].getPlant();
    }","Return the plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The plant at the given location, or null if there is none.",Field.java,260.0,3
15,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,260.0,3
16,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getAnimalAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,260.0,3
17,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,260.0,3
18,"public List<Location> adjacentLocations(Location location)
    {
        return adjacentLocations(location, 1);
    }","Return a shuffled list of locations adjacent to the given one, with a predefined offset of 1.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,260.0,3
19,"public List<Location> adjacentLocations(Location location, int offset)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        
        if (offset == 0) return locations; // the animal currently cannot see, return an empty list
        
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -offset; roffset <= offset; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -offset; coffset <= offset; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@param offset How far to 'look' / offset the adjacent locations returned
@return A list of locations adjacent to that given.",Field.java,260.0,3
20,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,260.0,3
21,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,260.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return The lion's max age.,Lion.java,260.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return The lion's breeding age.,Lion.java,260.0,3
2,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return The lion's breeding probability,Lion.java,260.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return The lion's max litter size (max amount of babies able to be created at once),Lion.java,260.0,3
4,"public Set<Class> getPrey()
    {
        return PREY_SET;
    }",@return The set of the lion's prey animals.,Lion.java,260.0,3
5,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return The lion's food value to its predators.,Lion.java,260.0,3
6,"public int getMaxFullness()
    {
        return MAX_FULLNESS;
    }",@return The lion's max fullness.,Lion.java,260.0,3
7,"protected double getBreedingFullness()
    {
        return BREEDING_FULLNESS;
    }",@return The animal's breeding fullness value,Lion.java,260.0,3
8,"public Color[] getColors()
    {
        return colors;
    }",@return the set of the lion's possible colors.,Lion.java,260.0,3
9,"public Set<Class> getWalkableTiles()
    {
        return WALKABLE_TILES;
    }",@return The lion's walkable tiles as a set,Lion.java,260.0,3
0,"public Color getMinColor()
    {
        return MIN_COLOR;
    }",@return the min color,Grass.java,260.0,3
1,"public Color getMinMedColor()
    {
        return MIN_MED_COLOR;
    }",@return the min med color,Grass.java,260.0,3
2,"public Color getMedColor()
    {
        return MED_COLOR;
    }",@return the med color,Grass.java,260.0,3
3,"public Color getMedMaxColor()
    {
        return MED_MAX_COLOR;
    }",@return the med max color,Grass.java,260.0,3
4,"public Color getMaxColor()
    {
        return MAX_COLOR;
    }",@return the max color,Grass.java,260.0,3
0,"public void act(List<Actor> newAnimals, boolean isDay, boolean drought)
    {
        boolean isAwake = isAwake(isDay);
        incrementAge();
        if (drought && rand.nextDouble()<0.005) setDead(); // small chance to die by dehydration. This extends to aquatic animals too.
        if (isAwake) {
            decrementFoodLevel();
            if(isAlive()) {
                giveBirth(newAnimals);            
                // Move towards a source of food if found.
                Location newLocation = findFood();
                
                newLocation = move(newLocation);
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
        //otherwise, do nothing (the animal is currently asleep)
    }","This is what the animal does most of the time: it looks for
prey. In the process, it might breed, die of hunger,
or die of old age.
@param newAnimals A list to return newly born animals.
@param isDay True if it is day, False if not.
@param harshWeather True if weather is harsh, False if not.",Animal.java,260.0,3
1,"protected Location move(Location newLocation)
    {
        if(newLocation == null) { 
            // No food found - try to move to a free location.
            List<Location> newLocations = getField().getFreeAdjacentLocations(getLocation());
            Iterator<Location> it = newLocations.iterator();
            boolean searching = true;
            while(it.hasNext() && searching){
                Location loc = it.next();
                if(isWalkable(loc)){
                    newLocation = loc;
                    searching = false;
                }
            }
        }
        return newLocation;
    }","Attempt to move, or do nothing if the location has already been supplied by findFood()

@param newLocation The location returned from findFood(), which could be null.
@return newLocation The new location, which could be null.",Animal.java,260.0,3
2,"protected Location findFood()
    {
        // Check for animals that have a null location 
        if(getLocation() == null){
            return null;
        }

        Field field = getField();
        List<Location> adjacent = getAdjacentLocations();
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object food = field.getOrganismAt(where);
            if(isWalkable(where) && food != null && isPrey(food) && isHungry()) {
                Organism prey = (Organism) food;
                if(prey.isAvailable()) { 
                    prey.getEaten();
                    setFoodLevel(prey.getFoodValue());
                    return where;
                }
            }
        }
        return null;
    }","Look for prey adjacent to the current location.
Only the first live prey animal is eaten.
@return Where food was found, or null if it wasn't.",Animal.java,260.0,3
3,"protected void giveBirth(List<Actor> newAnimals)
    {
        //Check the animal is female and therefore can give birth.
        if(isFemale){
            // A mate must be located in an adjacent location.
            // Get a list of adjacent locations.
            Field field = getField();
            List<Location> adjacent = getAdjacentLocations();

            Iterator<Location> it = adjacent.iterator();
            boolean lookingForMate = true;
            while(it.hasNext() && lookingForMate) {
                Location where = it.next();
                Object object = field.getAnimalAt(where);
                Animal animal = (Animal) object;
                if(isCompatible(animal) && !animal.getIsFemale() && animal.isAlive()) {
                    // New animals are born into adjacent locations.
                    // Get a list of adjacent free locations.
                    List<Location> free = field.getFreeAdjacentLocations(getLocation());
                    int births = breed();
                    for(int b = 0; b < births && free.size() > 0; b++) {
                        Location loc = free.remove(0);
                        int diseaseState = diseaseTransmission(animal);
                        Actor young = newAnimal(false, field, loc, diseaseState);
                        newAnimals.add(young);
                    }
                    lookingForMate = false; //Terminate search once a mate is found.
                }
            }      
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newAnimals A list to return newly born animals.",Animal.java,260.0,3
4,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,260.0,3
5,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,260.0,3
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,260.0,3
7,"protected void setLocationNull()
    {
        this.location = null;
    }",Set animal's location to null.,Animal.java,260.0,3
8,"protected void setFieldNull()
    {
        this.field = null;
    }",Set animal's field to null.,Animal.java,260.0,3
9,"protected boolean isAlive()
    {
        return isActive();
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,260.0,3
10,"protected boolean isAvailable()
    {
        return isActive();
    }","Check whether the animal can be eaten.
@return true if the animal can be eaten",Animal.java,260.0,3
11,"public void getEaten()
    {
        setDead();
    }",The default action for an animal once it gets eaten is to be set to dead,Animal.java,260.0,3
12,"protected void setDead()
    {
        setInactive();
        if(getLocation() != null) {
            getField().clear(getLocation());
            setLocationNull();
            setFieldNull();
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,260.0,3
13,"protected Color getColor()
    {
        return getColors()[diseaseState];
    }","Determine the animal's current color based off it's health
@return bright color if healthy, medium dark if carrier, dark if infected",Animal.java,260.0,3
14,"protected int getDiseaseState()
    {
        return diseaseState;
    }","Get the animal's disease state
@return int diseaseState.",Animal.java,260.0,3
15,"protected void setDiseaseState(int diseaseState)
    {
        this.diseaseState = diseaseState;
    }","Set the animal's disease state
@param int diseaseState.",Animal.java,260.0,3
16,"protected int diseaseTransmission(Animal animal)
    {
        int diseaseState = animal.getDiseaseState() + this.getDiseaseState();
        diseaseState = diseaseState > 2 ? 2 : diseaseState;
        return diseaseState;
    }","Determine the disease state of the offspring generated by giveBirth().
@param The animal being mated with.
@return int diseaseState.",Animal.java,260.0,3
17,"protected int getFoodLevel()
    {
        return foodLevel;
    }","Return the animal's food level.
@return The animal's food level.",Animal.java,260.0,3
18,"protected void decrementFoodLevel()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this animal more hungry. This could result in the animal's death.,Animal.java,260.0,3
19,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the animal's age. This could result in the animal's death.,Animal.java,260.0,3
20,"protected void setAge(int age)
    {
        this.age = age;
    }","Set the animal's age
@param The animal's age",Animal.java,260.0,3
21,"protected int getAge()
    {
        return age;
    }","Get the animal's age.
@return the animal's age",Animal.java,260.0,3
22,"protected void setFoodLevel(int preyFoodValue)
    {
        int newLevel = getFoodValue() + preyFoodValue;
        foodLevel = ( newLevel > getMaxFullness()) ? getMaxFullness() : newLevel;
    }","Update the animal's food value. If it's over its max fullness, set to max level.
@param preyFoodValue The prey's food value.",Animal.java,260.0,3
23,"protected boolean getIsFemale()
    {
        return isFemale;
    }","Get the animal's gender.
@return true if the animal is Female",Animal.java,260.0,3
24,"protected boolean canBreed()
    {
        return (getAge() >= getBreedingAge() && getFoodLevel() >= (getBreedingFullness() * getMaxFullness()) && rand.nextDouble() <= getBreedingProbability());
    }","An animal can breed if it has reached the breeding age, has a foodlevel above the threshold, and happens to succesfully impregnate.
@return true if the animal can breed, false otherwise.",Animal.java,260.0,3
25,"protected int breed()
    {
        int births = 0;
        if(canBreed()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,260.0,3
26,"public boolean isAwake(boolean isDay)
    {
        boolean isAwake = --sleep < 0;
        if(!isDay && isAwake) {
            sleep = (rand.nextInt(10) - 2); // set sleep field to random integer, Max. sleep 8 steps. Will stay awake if integer is negative.
        }

        return isAwake;
    }","Check if the animal is to fall asleep, and
@param isDay - true if it is day, false if it is night
@return True if the animal is awake, false if it is asleep.",Animal.java,260.0,3
27,"protected boolean isCompatible(Actor animal)
    {
        if(animal instanceof Animal){
            Animal mate = (Animal) animal;

            return this.getClass() == mate.getClass() && this.getDiseaseState() != 2 && mate.getDiseaseState() != 2;
        }
        else{
            return false;
        }
    }","@param animal Animal to be checked.
@return True if the animal is a compatible mate (same species).",Animal.java,260.0,3
28,"protected boolean isWalkable(Location location)
    {
        return getWalkableTiles().contains(getField().getTile(location).getClass());
    }","First, the getWalkableTiles() will obtain the set of the specific animal's walkable tiles, and then
it will check if the location contains a tile within that set.

@param Location location.
@return True if the animal can walk on given location, otherwise false.",Animal.java,260.0,3
29,"protected boolean isHungry()
    {
        return foodLevel < 0.8 * getMaxFullness();
    }","@return True if the animal is hungry (Food Level is less than 80% of Maximum Fullness), or False otherwise.",Animal.java,260.0,3
30,"protected Actor newAnimal(boolean randomAge, Field field, Location location, int diseaseState)
    {
        Actor newAnimal = null;
        try { 
            newAnimal =this.getClass().getConstructor(boolean.class, Field.class, Location.class, int.class).newInstance(randomAge, field, location, diseaseState);
        }
        catch(ReflectiveOperationException e) {
            System.out.println(e);
        }
        return newAnimal;
    }","Call the animal's constructor and return the newly created animal object.
@param randomAge True if the animal is to be created with a random age, or false if not.
@param field The field currently occupied.
@param location The location within the field.
@param diseaseState An integer representing the animal's current disease state.
@return the new animal created.",Animal.java,260.0,3
31,"protected boolean isPrey(Object food) 
    {
        return getPrey().contains(food.getClass());
    }","@param food An animal that is potentially eaten by this animal.
@return true, if the animal parameter is a prey species of this animal.",Animal.java,260.0,3
0,"protected Color getColor()
    {
        Collections.shuffle(colorArray);
        return colorArray.get(0);
    }",Determine the color of the Sand Tile,Sand.java,260.0,3
0,"@Override
    public boolean isAwake(boolean isDay)
    {
        boolean isAwake = !super.isAwake(isDay);
        return isAwake;
    }","Check if the animal is to fall asleep, for Alligator which is Nocturnal - active during night, inactive during day.
@param isDay - true if it is day, false if it is night.
@param isDay - true if animal is awake, false if it is not.",Alligator.java,260.0,3
1,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return The alligator's max age.,Alligator.java,260.0,3
2,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return The alligator's breeding age.,Alligator.java,260.0,3
3,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return The alligator's breeding probability,Alligator.java,260.0,3
4,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return The alligator's max litter size (max amount of babies able to be created at once),Alligator.java,260.0,3
5,"public Set<Class> getPrey()
    {
        return PREY_SET;
    }",@return The set of the alligator's prey animals.,Alligator.java,260.0,3
6,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return The alligator's food value to its predators.,Alligator.java,260.0,3
7,"public int getMaxFullness()
    {
        return MAX_FULLNESS;
    }",@return The alligator's maximum fullness level.,Alligator.java,260.0,3
8,"protected double getBreedingFullness()
    {
        return BREEDING_FULLNESS;
    }",@return The animal's breeding fullness value,Alligator.java,260.0,3
9,"public Color[] getColors()
    {
        return colors;
    }",@return the set of the alligator's's possible colors.,Alligator.java,260.0,3
10,"public Set<Class> getWalkableTiles()
    {
        return WALKABLE_TILES;
    }",@return The alligator's walkable tiles,Alligator.java,260.0,3
0,"public static void generate(int height, int width, double featureSize, long seed)
        throws IOException {
        
        OpenSimplexNoise noise = new OpenSimplexNoise(seed);
        BufferedImage image = new BufferedImage(height, width, BufferedImage.TYPE_BYTE_GRAY);
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                double value = noise.eval(x / featureSize, y / featureSize, 0.0);
                int rgb = 0x010101 * (int)((value + 1) * 127.5);
                image.setRGB(y, x, rgb);
            }
        }
        ImageIO.write(image, ""png"", new File(""noise.png""));
    }","Generate a new noise map with designated parameters
@param width, the width of the noise map
@param height, the height of the noise map
@param featureSize, the relative size of the features (smaller featureSize = more grainy image)",OpenSimplexNoiseCreate.java,260.0,3
1,"public static void generate()
        throws IOException {
        generate(DEFAULT_HEIGHT, DEFAULT_WIDTH, DEFAULT_FEATURE_SIZE, DEFAULT_SEED);
    }",Generate a noise map with default dimensions and feature size,OpenSimplexNoiseCreate.java,260.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return The stickleback's max age.,Stickleback.java,260.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }",@return The stickleback's breeding age.,Stickleback.java,260.0,3
2,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",@return The stickleback's breeding probability.,Stickleback.java,260.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",@return The stickleback's max litter size (max amount of babies able to be created at once).,Stickleback.java,260.0,3
4,"public Set<Class> getPrey()
    {
        return PREY_SET;
    }",@return The set of the stickleback's prey animals.,Stickleback.java,260.0,3
5,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return The stickleback's food value to it's predators.,Stickleback.java,260.0,3
6,"public int getMaxFullness()
    {
        return MAX_FULLNESS;
    }",@return The stickleback's max fullness.,Stickleback.java,260.0,3
7,"protected double getBreedingFullness()
    {
        return BREEDING_FULLNESS;
    }",@return The animal's breeding fullness value.,Stickleback.java,260.0,3
8,"public Set<Class> getWalkableTiles()
    {
        return WALKABLE_TILES;
    }",@return The set of the stickleback's walkable tiles.,Stickleback.java,260.0,3
9,"public Color[] getColors()
    {
        return colors;
    }",@return the set of the stickleback's possible colors.,Stickleback.java,260.0,3
0,"public Color getMinColor()
    {
        return MIN_COLOR;
    }",@return the min color,DeepWater.java,260.0,3
1,"public Color getMinMedColor()
    {
        return MIN_MED_COLOR;
    }",@return the min med color,DeepWater.java,260.0,3
2,"public Color getMedColor()
    {
        return MED_COLOR;
    }",@return the med color,DeepWater.java,260.0,3
3,"public Color getMedMaxColor()
    {
        return MED_MAX_COLOR;
    }",@return the med max color,DeepWater.java,260.0,3
4,"public Color getMaxColor()
    {
        return MAX_COLOR;
    }",@return the max color,DeepWater.java,260.0,3
0,"public void act(List<Animal> newVoles)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            
            if(getSex()){
               giveBirth(newVoles); 
             }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocationAnimal(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
            
            
         }
         if(isAlive()){
           if(canSick && rand.nextDouble() <= ILLNESS_PROBABILITY){
                getSick();
                antiBody();
            }
          if(getAnimalState()){
                sick();
            }
        }
    }","This is what the vole does most of the time - it runs
around. Sometimes it will breed, sick or die of old age.
@param newVoles A list to return newly born voles.",Vole.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the vole's death.",Vole.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this vole more hungry. This could result in the fox's death.,Vole.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Rice) {
                Rice rice = (Rice) plant;
                if(rice.isAlive()) { 
                    rice.setDead();
                    foodLevel = RICE_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for grass adjacent to the current location.
Only the first live grass is eaten.
@return Where food was found, or null if it wasn't.",Vole.java,214.0,2
4,"private void giveBirth(List<Animal> newVoles)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Vole) { 
               Vole vole1 = (Vole) animal;
               if(vole1.getSex() != this.getSex() ){
                 List<Location> free = field.getFreeAdjacentLocationsAnimal(getLocation());
                 int births = breed();
                 for(int b = 0; b < births && free.size() > 0; b++) {
                  Location loc = free.remove(0);
                  Vole young = new Vole(false, field, loc);
                  newVoles.add(young);
                 }
               }
            }
        }
    }","Check whether or not this vole is to give birth at this step.
New births will be made into free adjacent locations.
@param newVoles A list to return newly born voles.",Vole.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Vole.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A vole can breed if it has reached the breeding age.
@return true if the vole can breed, false otherwise.",Vole.java,214.0,2
7,"private void sick()
    {
       spread();
       if(rand.nextDouble() <= ILLNESS_DEATH_PROBABILITY ) {
            setDead();
        }else if(rand.nextDouble() <= ILLNESS_CURE_PROBABILITY){
            getCure();
        }
    }","The sick preformence of vole. it will spread of disease and
determine if voles will die from disease or heal themselves",Vole.java,214.0,2
8,"private void spread()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Vole) { 
               Vole vole = (Vole) animal;
               if(vole.getCanSick()){
                  vole.getSick();
                  vole.antiBody();
                 }
            }
        }
    }",Transmit disease to surrounding voles.,Vole.java,214.0,2
9,"public boolean getCanSick()
    {
        return canSick;
    }","A vole can sick if it don't have antibodies
@return true if the vole can sick, false otherwise.",Vole.java,214.0,2
10,"public void antiBody()
    {
        canSick = false;
    }","Creat an antibody, if the vole sick once, it will never sick twice.",Vole.java,214.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,214.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,214.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,214.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,214.0,2
0,"public void act(List<Plant> newRice)
    {
        incrementAge();
        if(isAlive()) {
               giveBirth(newRice);          

          
        }
    }","This is what the rice does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRice A list to return newly born rice.",Rice.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rice's death.",Rice.java,214.0,2
2,"private void giveBirth(List<Plant> newRice)
    {
        // New rice are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocationsPlant(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rice young = new Rice(false, field, loc);
            newRice.add(young);
            
        }
    }","Check whether or not this rice is to give birth at this step.
New births will be made into free adjacent locations.
@param newRice A list to return newly born rice.",Rice.java,214.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rice.java,214.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rice can breed if it has reached the breeding age.
@return true if the rice can breed, false otherwise.",Rice.java,214.0,2
0,"public void act(List<Animal> newLocusts)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if(getSex()){
               giveBirth(newLocusts); 
             }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocationAnimal(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
         }
    }","This is what the locust does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newLocusts A list to return newly born locusts.",Locust.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the locust's death.",Locust.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this locust more hungry. This could result in the locust's death.,Locust.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Rice) {
                Rice rice = (Rice) plant;
                if(rice.isAlive()) { 
                    rice.setDead();
                    foodLevel = RICE_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Locust.java,214.0,2
4,"private void giveBirth(List<Animal> newLocusts)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Locust) { 
               Locust locust1 = (Locust) animal;
               if(locust1.getSex() != this.getSex() ){
                 List<Location> free = field.getFreeAdjacentLocationsAnimal(getLocation());
                 int births = breed();
                 for(int b = 0; b < births && free.size() > 0; b++) {
                  Location loc = free.remove(0);
                  Locust young = new Locust(false, field, loc);
                  newLocusts.add(young);
                 }
               }
            }
        }
    }","Check whether or not this locust is to give birth at this step.
New births will be made into free adjacent locations.
@param newLocusts A list to return newly born locusts.",Locust.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Locust.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A locust can breed if it has reached the breeding age.
@return true if the locust can breed, false otherwise.",Locust.java,214.0,2
0,"public void act(List<Animal> newWeasels)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if(getSex()){
            giveBirth(newWeasels);  
           }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocationAnimal(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
           }
             if(isAlive()){
              if(canSick && rand.nextDouble() <= ILLNESS_PROBABILITY){
                getSick();
                antiBody();
              }
              if(getAnimalState()){
                sick();
              }
        }
        }
    }","This is what the weasel does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newWeasels A list to return newly born weasels.",Weasel.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the weasel's death.,Weasel.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this weasel more hungry. This could result in the weasel's death.,Weasel.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Snake) {
                Snake snake = (Snake) animal;
                if(snake.isAlive()) { 
                    snake.setDead();
                    foodLevel = SNAKE_FOOD_VALUE;
                    return where;
                }
            }else if(animal instanceof Vole) {
                Vole vole = (Vole) animal;
                if(vole.isAlive()) { 
                    vole.setDead();
                    foodLevel = VOLE_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Weasel.java,214.0,2
4,"private void giveBirth(List<Animal> newWeasels)
    {
        // New weasels are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Weasel) { 
               Weasel weasel1 = (Weasel) animal;
               if(weasel1.getSex() != this.getSex() ){
                List<Location> free = field.getFreeAdjacentLocationsAnimal(getLocation());
                int births = breed();
               for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Weasel young = new Weasel(false, field, loc);
                newWeasels.add(young);
               }
               }
            }
        }
    }","Check whether or not this weasel is to give birth at this step.
New births will be made into free adjacent locations.
@param newWeasels A list to return newly born weasels.",Weasel.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Weasel.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A weasel can breed if it has reached the breeding age.,Weasel.java,214.0,2
7,"private void sick()
    {
       spread();
       if(rand.nextDouble() <= ILLNESS_DEATH_PROBABILITY ) {
            setDead();
        }else if(rand.nextDouble() <= ILLNESS_CURE_PROBABILITY){
            getCure();
        }
    }","The sick preformence of rabbit. it will spread of disease and
determine if rabbits will die from disease or heal themselves",Weasel.java,214.0,2
8,"private void spread()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Vole) { 
               Vole vole = (Vole) animal;
               if(vole.getCanSick()){
                  vole.getSick();
                  vole.antiBody();
                 }
            }
        }
    }",Transmit disease to surrounding rabbits.,Weasel.java,214.0,2
9,"public boolean getCanSick()
    {
        return canSick;
    }","A rabbit can sick if it don't have antibodies
@return true if the rabbit can sick, false otherwise.",Weasel.java,214.0,2
10,"public void antiBody()
    {
        canSick = false;
    }","Creat an antibody, if the rabbit sick once, it will never sick twice.",Weasel.java,214.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,214.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,214.0,2
0,"public void act(List<Animal> newSnakes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if(getSex()){
            giveBirth(newSnakes);  
           }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocationAnimal(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the snake does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSnakes A list to return newly born snakes.",Snake.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the snake's death.,Snake.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this snake more hungry. This could result in the snake's death.,Snake.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Vole) {
                Vole vole = (Vole) animal;
                if(vole.isAlive()) { 
                    vole.setDead();
                    foodLevel = VOLE_FOOD_VALUE;
                    return where;
                }
            }else if(animal instanceof Frog) {
                Frog frog = (Frog) animal;
                if(frog.isAlive()) { 
                    frog.setDead();
                    foodLevel = FROG_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Snake.java,214.0,2
4,"private void giveBirth(List<Animal> newSnakes)
    {
        // New snakes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Snake) { 
               Snake snake1 = (Snake) animal;
               if(snake1.getSex() != this.getSex() ){
                List<Location> free = field.getFreeAdjacentLocationsAnimal(getLocation());
                int births = breed();
               for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Snake young = new Snake(false, field, loc);
                newSnakes.add(young);
               }
               }
            }
        }
    }","Check whether or not this snake is to give birth at this step.
New births will be made into free adjacent locations.
@param newSnakes A list to return newly born snakes.",Snake.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Snake.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A snake can breed if it has reached the breeding age.,Snake.java,214.0,2
0,"public void Rain(List<Plant> plants,SimulatorView view)
    {
        if(rain){
        view.changeToRain();
        // Provide space for newborn plants.
        List<Plant> newPlants = new ArrayList<>();
            for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            // Let all plants act.
            plant.act(newPlants);
            if(! plant.isAlive()) {
                it.remove();
            }
         }
        // Add the newly born animals to the main lists.
        plants.addAll(newPlants);
        } else{
          view.changeToSunny();
        }
    }","The behavior of raining.Plants will be active on rainy days.
@param plants  List of plants in the field.
@param view  A graphical view of the simulation",Weather.java,214.0,2
1,"public void nextWeather()
    {
        Random rand = Randomizer.getRandom();
        rain = rand.nextBoolean();
    }",Get next random weather.,Weather.java,214.0,2
0,"public void day(List<Animal> animals)
    {
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            
            animal.act(newAnimals);
          
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        
        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);
    
    }","The behavior of day time.All animal will be active at day time.
@param animals  List of animals in the field.",Time.java,214.0,2
1,"public void night(List<Animal> animals)
    {
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            //Only the vole can act in the night
            if(animal instanceof Vole){
             animal.act(newAnimals);
            }
          
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        
        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);
    
    }","The behavior of night time.Only vole will be active at day time.
@param animals  List of animals in the field.",Time.java,214.0,2
0,"public void act(List<Animal> newFrogs)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if(getSex()){
            giveBirth(newFrogs);  
           }
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocationAnimal(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the frog does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFrogs A list to return newly born frogs.",Frog.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the frog's death.,Frog.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this frog more hungry. This could result in the frog's death.,Frog.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Locust) {
                Locust locust = (Locust) animal;
                if(locust.isAlive()) { 
                    locust.setDead();
                    foodLevel = LOCUST_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Frog.java,214.0,2
4,"private void giveBirth(List<Animal> newFrogs)
    {
        // New frogs are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Frog) { 
               Frog frog1 = (Frog) animal;
               if(frog1.getSex() != this.getSex() ){
                List<Location> free = field.getFreeAdjacentLocationsAnimal(getLocation());
                int births = breed();
               for(int b = 0; b < births && free.size() > 0; b++) {
                Location loc = free.remove(0);
                Frog young = new Frog(false, field, loc);
                newFrogs.add(young);
               }
               }
            }
        }
    }","Check whether or not this frog is to give birth at this step.
New births will be made into free adjacent locations.
@param newFrogs A list to return newly born frogs.",Frog.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Frog.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A frog can breed if it has reached the breeding age.,Frog.java,214.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,214.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,214.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,214.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,214.0,2
0,"public void setColor(Class actorClass, Color color)
    {
        colors.put(actorClass, color);
    }","Define a color to be used for a given class of actor.
@param actorClass The actor's Class object.
@param color The color to be used for the given class.",SimulatorView.java,214.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,214.0,2
2,"private Color getColor(Class actorClass)
    {
        Color col = colors.get(actorClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of actor.,SimulatorView.java,214.0,2
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        stepLabel.setText(STEP_PREFIX + step);
        timeLabel.setText(TIME_PREFIX + Time);
        weatherLabel.setText(WEATHER_PREFIX + Weather);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object actor = field.getObjectAt(row, col);
                if(actor != null) {
                   stats.incrementCount(actor.getClass());
                   if(actor instanceof Animal ){
                        Animal animal = (Animal) actor;
                       if(animal.getAnimalState()){
                           //give sick animal a darker color
                           fieldView.drawMark(col, row, getColor(actor.getClass()).darker());
                       }else{
                           fieldView.drawMark(col, row, getColor(actor.getClass()));
                             
                       }}else{
                      // give color for other things
                      fieldView.drawMark(col, row, getColor(actor.getClass()));
                   }
                 
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,214.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,214.0,2
5,"public void changeToNight()
    {
            Time = ""Night""+""      "";
    }",Display the night of time.,SimulatorView.java,214.0,2
6,"public void changeToDay()
    {
        Time = ""Daytime"";
    }",Display the day of time.,SimulatorView.java,214.0,2
7,"public void changeToRain()
    {
        Weather = ""Rainy"";
    }",Display the rainy of weather.,SimulatorView.java,214.0,2
8,"public void changeToSunny()
    {
        Weather = ""Sunny"";
    }",Display the sunny of weather.,SimulatorView.java,214.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,214.0,2
1,"public void simulate(int numSteps)
    {
        boolean clock;
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
           if(step%20 < 10){
             clock = true;
             simulateOneStep(clock);
            }
           else{
             clock = false;
             simulateOneStep(clock);
           }
            
           if(step%5 == 0){
                weather.nextWeather();
           }
        
           delay(100);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,214.0,2
2,"public void simulateOneStep(boolean clock)
    {
        step++;
        if(clock == true){
            time.day(animals);
            view.changeToDay();
        }else if (clock == false){
            time.night(animals);
            view.changeToNight();
        }
        //Judging plant action based on weather
        weather.Rain(plants,view);
        
        view.showStatus(step, field);   
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
actor.",Simulator.java,214.0,2
3,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,214.0,2
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clearAll();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SNAKE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Snake snake = new Snake(true, field, location);
                    animals.add(snake);
                }
                else if(rand.nextDouble() <= VOLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Vole vole = new Vole(true, field, location);
                    animals.add(vole);
                }
                else if(rand.nextDouble() <= RICE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rice rice = new Rice(true, field, location);
                    plants.add(rice);
                }
                else if(rand.nextDouble() <= LOCUST_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Locust locust = new Locust(true, field, location);
                    animals.add(locust);
                }
                else if(rand.nextDouble() <= FROG_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Frog frog = new Frog(true, field, location);
                    animals.add(frog);
                }
                else if(rand.nextDouble() <= WEASEL_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Weasel weasel = new Weasel(true, field, location);
                    animals.add(weasel);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,214.0,2
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,214.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the actor is alive or not.
@return true if the actor is still alive.",Actor.java,214.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the actor is no longer alive.
It is removed from the field.",Actor.java,214.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the actor's location.
@return The actor's location.",Actor.java,214.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the actor at the new location in the given field.
@param newLocation The actor's new location.",Actor.java,214.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the actor's field.
@return The actor's field.",Actor.java,214.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,214.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,214.0,2
2,"public void incrementCount(Class actorClass)
    {
        Counter count = counters.get(actorClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(actorClass.getName());
            counters.put(actorClass, count);
        }
        count.increment();
    }","Increment the count for one class of actor.
@param actorClass The class of actor to increment.",FieldStats.java,214.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an actor count has been completed.,FieldStats.java,214.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,214.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object actor = field.getObjectAt(row, col);
                if(actor != null) {
                    incrementCount(actor.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of actors.
These are not kept up to date as actors
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,214.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,214.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,214.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,214.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,214.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,214.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,214.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,214.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,214.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,214.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,214.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,214.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,214.0,2
0,"public void clearAll()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
               if( field[row][col] != null){
                   field[row][col].clear();
            } 
                
            }
        }
    }",Empty all the field.,Field.java,214.0,2
1,"public void assign()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
               field[row][col] = new Stack();
            }
        }
    }",Make all the field to be a stack.,Field.java,214.0,2
2,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()].pop();
    }","Clear the top of given location.
@param location The location to clear.",Field.java,214.0,2
3,"public void place(Object actor, int row, int col)
    {
        place(actor, new Location(row, col));
    }","Place an actor at the given location.
@param actor The actor to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,214.0,2
4,"public void place(Object actor, Location location)
    {
        field[location.getRow()][location.getCol()].push(actor);
        
    }","Place an actor at the given location.
@param actor The actor to be placed.
@param location Where to place the actor.",Field.java,214.0,2
5,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the actor at the given location, if any.
@param location Where in the field.
@return The animal at the top of stack in the given location,
or null if there is none.",Field.java,214.0,2
6,"public Object getObjectAt(int row, int col)
    {
        if(field[row][col].empty()){
            return null;
        }else{
            return field[row][col].peek();
        }
        
    }","Return the actor at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the top of stack in the given location,
or null if there is none",Field.java,214.0,2
7,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,214.0,2
8,"public List<Location> getFreeAdjacentLocationsAnimal(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null || getObjectAt(next) instanceof Plant) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations for animal.
Animal can walk on the grass.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,214.0,2
9,"public List<Location> getFreeAdjacentLocationsPlant(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations for plant.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,214.0,2
10,"public Location freeAdjacentLocationAnimal(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocationsAnimal(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location of animal. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,214.0,2
11,"public Location freeAdjacentLocationPlant(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocationsPlant(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location of plant. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,214.0,2
12,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,214.0,2
13,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,214.0,2
14,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,214.0,2
0,"protected boolean getSex()
    {
        return sex;
    }","Get gender of animal.
@return true if animal is female, false is male.",Animal.java,214.0,2
1,"protected boolean getAnimalState()
    {
        return sick;
    }","Get state of animal to determain weather the animal is sick.
@return true if animal is sick, return false if animal is not sick.",Animal.java,214.0,2
2,"protected void getSick()
    {
        sick = true;
    }",Set the animal to sick,Animal.java,214.0,2
3,"protected void getCure()
    {
        sick = false;
    }",Set animal not to sick.,Animal.java,214.0,2
0,"public Base returnMyType(boolean randomAge, Field field, Location location){
        return new Rabbit(true, field, location);
    }",Return the type of the Rabbit,Rabbit.java,12.0,2
0,"public boolean getSexMale() 
    {
        return this.sexMale;
    }",Check to see if the sex is male.,Base.java,12.0,2
1,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Base.java,12.0,2
2,"protected void setDead() 

    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Base.java,12.0,2
3,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Base.java,12.0,2
4,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Base.java,12.0,2
5,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Base.java,12.0,2
6,"protected void giveBirth(List<Base> newBases)
    {
        // Get a list of adjacent free locations.
        // Then places the new born in the location.

        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0 && canBreed(); b++) {
            Location loc = free.remove(0);
            newBases.add(returnMyType(false, field, loc));

        }
    }","Check whether or not the animal has met the condtions to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Base.java,12.0,2
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Base.java,12.0,2
8,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Base.java,12.0,2
9,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Base.java,12.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,12.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,12.0,2
0,"public void setTime(int steps)
    {
        hour = steps%hourMode;
    }","For very 24 steps, we return the modulus of the total step
giving us the current hour in the simulator.",Time.java,12.0,2
1,"public int getTime(){
        return hour;
    }",Returns the current time,Time.java,12.0,2
2,"public boolean isNight(){
        return (hour < 6 || hour > 20 || hour == 0);
    }",Sets the field is night to true between the hours off 20:00 and 06:00,Time.java,12.0,2
0,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object base = field.getObjectAt(where);
            if(base instanceof Plants) {
                Plants plants = (Plants) base;
                if(plants.isAlive() && plants.canBreed()) { 
                    plants.setDead();
                    foodLevel += PLANT_FOOD_LEVEL;
                    if (foodLevel > PLANT_FOOD_LEVEL) {
                        foodLevel = PLANT_FOOD_LEVEL;
                    }
                    return where;
                }
            }
        } 
        return null;
    }","The prey looks through the adjacent cells and then sees if any of them are plants
if they are it will eat the plant and increase the food value level by the PLANT_FOOD_LEVEL.",Prey.java,12.0,2
1,"public void act(List<Base> newPrey, Time time)
    {
        incrementHunger();
        if(!time.isNight()){
            incrementAge();
            
        if(isAlive()) {
            giveBirth(newPrey);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
              newLocation = getField().freeAdjacentLocation(getLocation());
            }

            if(newLocation != null) {
                setLocation(newLocation);
                if (isInfected) {
                    spreadInfection();
                    countdown--;
                    if (countdown == 0) {
                        setDead();
                    }
                }
            }
            else {
                // Overcrowding.
                setDead();
            }
                
          }
        }
    }","This is what the pary does most of the time - it runs
around. Sometimes it will breed or die of old age.
At night it sleeps so it dosnt moves but it does still get hungry.
@param newPrey A list to return newly born prey.",Prey.java,12.0,2
2,"protected void spreadInfection()
    {
        List<Location> adjacent = field.adjacentLocations(getLocation());
        for (Location loc : adjacent) {
            Object obj = field.getObjectAt(loc);
            if (obj != null  && obj instanceof Prey) {  // only carries out when there is an animal
                Prey prey = (Prey) obj;
                if (rand.nextDouble() < 0.05) {
                    prey.isInfected = true;
                }
            }
        }
    }","This spreads the infection to any nearby prey. There is a 5%
chance of catching this infection.",Prey.java,12.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,12.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,12.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,12.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,12.0,2
0,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Prey) {
                Prey prey = (Prey) animal;
                // catching prey is affected by the fog
                double catchPrey;
                if (isFoggy) {
                    catchPrey = rand.nextDouble();
                }
                else {
                    catchPrey = 1;
                }
                // 50% chance of catching prey if its foggy 
                if(prey.isAlive() && catchPrey > 0.5 && prey.canBreed()) { 
                    prey.setDead();
                    foodLevel += PREY_FOOD_LEVEL;
                    if (foodLevel > PREY_FOOD_LEVEL) { 
                        foodLevel = PREY_FOOD_LEVEL;
                    }
                    return where;
                }
                
            }
            if(animal instanceof Plants) {
                Plants plants = (Plants) animal;
                if(plants.isAlive() && canBreed()) { 
                    plants.setDead();
                    foodLevel += PLANT_FOOD_LEVEL;
                    if (foodLevel > PREY_FOOD_LEVEL) {
                        foodLevel = PREY_FOOD_LEVEL;
                    }
                    return where;
                }
            }
        }
        return null;
    }","Look for prey and plants adjacent to the current location.
Only the first prey/plant is eaten.
@return Where food was found, or null if it wasn't.",Predator.java,12.0,2
1,"public void act(List<Base> newPredators, Time time)
    {
        incrementHunger();
        changeWeather();
        incrementAge();   
        if(isAlive()) {
                giveBirth(newPredators);            
                // Move towards a source of food if found.
                Location newLocation = findFood();

                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }   
        
    }","This is what the predator does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Predator.java,12.0,2
2,"private void changeWeather()
        {
           double weatherChance = rand.nextDouble();
            if (!isFoggy) {
                if (weatherChance < 0.2) {
                    setWeather();
                }
            }
            else {
                if (weatherChance < 0.5) {
                    setWeather();
                }
            }

        }","Decides the weather. If it is currently not foggy, there is a 20%
chance of it becoming foggy. If it is already foggy, there is a 50%
chance of it either staying foggy or returning to normal.",Predator.java,12.0,2
3,"public void setWeather()
        {
            isFoggy = !isFoggy;
        }",Changes the weather between foggy and not foggy,Predator.java,12.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,12.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,12.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
        
    }",@return The color to be used for a given class of animal.,SimulatorView.java,12.0,2
3,"public void showStatus(int step, Field field, Time time)
    {
        if(!isVisible()) {
            setVisible(true);
        }
        String concatSignal = """";
        //shows night or day dependent on the time on the gui.
        if(time.isNight()){
            concatSignal = "" Night"";
        }else{
            concatSignal = "" Day"";
        }
        stepLabel.setText(STEP_PREFIX + step + ""     Time:"" + time.getTime() + concatSignal + ""  Colors; Rabbit: Light Gray, Fox: Red, Squirrel: Dark Gray, Eagle: Black, Lion: Orange, Oak Tree: Green"");
        stats.reset() ;
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,12.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,12.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,12.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
             delay(110);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,12.0,2
2,"public void simulateOneStep()
    {
        step++;
        // For ever step increses the hour by one.
        time.setTime(step);
        // Provide space for newborn animals.
        List<Base> newBases = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Base> it = bases.iterator(); it.hasNext(); ) {
            Base base = it.next();
            base.act(newBases, time);
            if(! base.isAlive()) {
                it.remove();
            }
        }
               
        // Add the species to the main lists.
        bases.addAll(newBases);
        
        view.showStatus(step, field, time);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of all the species.",Simulator.java,12.0,2
3,"public void reset()
    {
        step = 0;
        time.setTime(step);
        bases.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field, time);
    }",Reset the simulation to a starting position.,Simulator.java,12.0,2
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    bases.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    bases.add(rabbit);
                }
                else if(rand.nextDouble() <= SQUIRREL_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Squirrel squirrel = new Squirrel(true, field, location);
                    bases.add(squirrel);
                }
                else if(rand.nextDouble() <= EAGLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Eagle eagle = new Eagle(true, field, location);
                    bases.add(eagle);
                }
                else if(rand.nextDouble() <= LION_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lion lion = new Lion(true, field, location);
                    bases.add(lion);
                }
                else if(rand.nextDouble() <= OAKTREE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    OakTree oakTree = new OakTree(true, field, location);
                    bases.add(oakTree);
                }
                
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,12.0,2
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,12.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,12.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,12.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,12.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,12.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,12.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,12.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,12.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,12.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,12.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,12.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,12.0,2
0,"public Base returnMyType(boolean randomAge, Field field, Location location){
        return new Squirrel(true, field, location);
    }",Return the type of the Squirrel,Squirrel.java,12.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,12.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,12.0,2
2,"public void place(Object base, int row, int col)
    {
        place(base, new Location(row, col));
    }","Place an base at the given location.
If there is already an base at the location it will
be lost.
@param base The base to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,12.0,2
3,"public void place(Object base, Location location)
    {
        field[location.getRow()][location.getCol()] = base;
    }","Place an base at the given location.
If there is already an base at the location it will
be lost.
@param base The base to be placed.
@param location Where to place the base.",Field.java,12.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the base at the given location, if any.
@param location Where in the field.
@return The base at the given location, or null if there is none.",Field.java,12.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the base at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The base at the given location, or null if there is none.",Field.java,12.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,12.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,12.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,12.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,12.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,12.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,12.0,2
0,"public boolean getSexMale() 
    {
        return this.sexMale;
    }",Check to see if the sex is male.,Animal.java,12.0,2
1,"protected void incrementHunger()
    {
        foodLevel--;

        if(foodLevel <= 0) {
            setDead();
        }
    }",Increment the hunger of the animal. This could result in the animals death if their hunger value drops to 0.,Animal.java,12.0,2
2,"protected boolean canBreed()
    {
        return (isMaleAdjacent() && !this.sexMale);
    }",Return true if the animal in the adjacent cell is male & current cell female.,Animal.java,12.0,2
3,"protected boolean isMaleAdjacent()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal!=null){
                Base animalCasted = (Base) animal;
                if(this.getClass().equals(animalCasted.getClass())){
                    if(animalCasted.getSexMale()){
                        return true;
                    }
                }
            }
        }
        return false;
    }","Check if the animal in the adjacent cell is male
And of the same class",Animal.java,12.0,2
0,"public void act(List<Base> newPlants, Time time)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newPlants);
        }

    }","This is what the plant does,-
Sometimes it will breed or die of old age.
@param newPlant A list to return new plant.",Plants.java,12.0,2
0,"public Base returnMyType(boolean randomAge, Field field, Location location){
        return new OakTree(true, field, location);
    }",Return the type of Oak tree,OakTree.java,12.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,455.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,455.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,455.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,455.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,455.0,3
0,"public Animal getNewYoung( boolean randomAge, Field field, Location loc, Simulator simulator){
        return new WildChicken( false, field, loc, simulator);
    }","Creates and returns a new animal of this specific species type object, to act as offspring.
@return A new animal of this specific species type object.
@param randomAge If true, the new animal will have a random age.
@param field The field currently occupied.
@param location The location within the field to put the new animal in.",WildChicken.java,455.0,3
1,"public boolean checkMate(Object object){
        if (object instanceof WildChicken){
            WildChicken holdWildChicken = (WildChicken) object;
            if (!this.getGender().equals(holdWildChicken.getGender()) && holdWildChicken.canMate())
                return true;
            else
                return false;
        }
        return false;
    }","Checks if a passed object is of the same type as this species.
@return True if passed object is of the same type as this species, false otherwise",WildChicken.java,455.0,3
2,"public boolean checkFoodType(Object object){ 
        return (object instanceof Fern);
    }","Specifies whether the object passed through the parameter represents the food this species eats.
@return boolean True if the passed object is food for this specific species, false otherwise",WildChicken.java,455.0,3
3,"public void getDisease(){
        diseaseLevel = DISEASE_LEVEL_START_VALUE;
        ActualMaxAge = DISEASED_MAX_AGE;
        ActualBreedingProbability = DISEASED_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DISEASED_MAX_LITTER_SIZE;
        ActualFoodValue = DISEASED_FOOD_VALUE;
    }","Modifies longevity,nutrition and breeding probability values to simulate a sick animal.",WildChicken.java,455.0,3
4,"public void initializeDefaultStats(){
        ActualMaxAge = DEFAULT_MAX_AGE;
        ActualBreedingProbability = DEFAULT_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DEFAULT_MAX_LITTER_SIZE;
        ActualFoodValue = DEFAULT_FOOD_VALUE;
    }","Initializes/changes certain behaviour affecting values to
default values.
Also used to make an animal not sick.",WildChicken.java,455.0,3
5,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Return the value of the BREEDING_AGE constant;
@return Minimum age for breeding for this species.",WildChicken.java,455.0,3
6,"public int getDefaultMaxAge(){
        return DEFAULT_MAX_AGE;
    }","Returns the value of the normal age an animal of this species may live up to
@return int Maximum age a healthy animal of this species may live up to.",WildChicken.java,455.0,3
7,"public int getMatingCooldown(){
        return MATING_COOLDOWN;
    }","Returns a number representing the steps an animal of this species
must wait before being able to mate again.
@return int The value of the ""mating cooldown""",WildChicken.java,455.0,3
8,"public boolean movesOrEatsDuringDay(){
        return MOVE_OR_EAT_DURING_DAY;
    }","Specifies if this species moves or eats during the day.
@return true if this species moves or eats during the day, false otherwise",WildChicken.java,455.0,3
9,"public boolean matesDuringDay(){
        return MATE_DURING_DAY;
    }","Specifies if this animal mates during the day.
@return true if this species mates during the day, false otherwise",WildChicken.java,455.0,3
10,"public boolean isHerbivore(){
        return IS_HERBIVORE;
    }","Specifies whether this animal is a herbivore.
@return true if it is, false otherwise",WildChicken.java,455.0,3
11,"public double getDiseaseSpreadingProbability(){
        return DISEASE_SPREADING_PROBABILITY;
    }","Return the probability that this specific species passes on a disease to another animal
@return double value is probability of a disease being passed on to another",WildChicken.java,455.0,3
12,"public int getMaxAge(){
        return ActualMaxAge;
    }","Return the current maximum age this species may live up to.
@return Current maximum age for this species.",WildChicken.java,455.0,3
13,"public double getBreedingProbability(){
        return ActualBreedingProbability;
    }","Return the value dictating how probable this species is to breed.
@return Breeding probability of this species.",WildChicken.java,455.0,3
14,"public int getMaxLitterSize(){
        return ActualMaxLitterSize;
    }","Return the maximum number of offspring this species may have at the moment.
@return Current max litter size for this species.",WildChicken.java,455.0,3
15,"public int getFoodValue(){
        return ActualFoodValue;
    }","Returns the number of steps this animal may survive after having eaten.
@return int The food value for this species",WildChicken.java,455.0,3
0,"public Animal getNewYoung( boolean randomAge, Field field, Location loc, Simulator simulator){
        return new Rat( false, field, loc, simulator);
    }","Creates and returns a new animal of this specific species type object, to act as offspring.
@return A new animal of this specific species type object.
@param randomAge If true, the new animal will have a random age.
@param field The field currently occupied.
@param location The location within the field to put the new animal in.",Rat.java,455.0,3
1,"public boolean checkMate(Object object){
        if (object instanceof Rat){
            Rat holdRat = (Rat) object;
            if (!this.getGender().equals(holdRat.getGender()) && holdRat.canMate())
                return true;
            else
                return false;
        }
        return false;
    }","Checks if a passed object is of the same type as this species.
@return True if passed object is of the same type as this species, false otherwise",Rat.java,455.0,3
2,"public boolean checkFoodType(Object object){ 
        return (object instanceof Rat);
    }","Specifies whether the object passed through the parameter represents the food this species eats.
@return boolean True if the passed object is food for this specific species, false otherwise",Rat.java,455.0,3
3,"public void getDisease(){
        diseaseLevel = DISEASE_LEVEL_START_VALUE;
        ActualMaxAge = DISEASED_MAX_AGE;
        ActualBreedingProbability = DISEASED_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DISEASED_MAX_LITTER_SIZE;
        ActualFoodValue = DISEASED_FOOD_VALUE;
    }","Modifies longevity,nutrition and breeding probability values to simulate a sick animal.",Rat.java,455.0,3
4,"public void initializeDefaultStats(){
        ActualMaxAge = DEFAULT_MAX_AGE;
        ActualBreedingProbability = DEFAULT_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DEFAULT_MAX_LITTER_SIZE;
        ActualFoodValue = DEFAULT_FOOD_VALUE;
    }","Initializes/changes certain behaviour affecting values to
default values.
Also used to make an animal not sick.",Rat.java,455.0,3
5,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Return the value of the BREEDING_AGE constant;
@return Minimum age for breeding for this species.",Rat.java,455.0,3
6,"public int getDefaultMaxAge(){
        return DEFAULT_MAX_AGE;
    }","Returns the value of the normal age an animal of this species may live up to
@return int Maximum age a healthy animal of this species may live up to.",Rat.java,455.0,3
7,"public int getMatingCooldown(){
        return MATING_COOLDOWN;
    }","Returns a number representing the steps an animal of this species
must wait before being able to mate again.
@return int The value of the ""mating cooldown""",Rat.java,455.0,3
8,"public boolean movesOrEatsDuringDay(){
        return MOVE_OR_EAT_DURING_DAY;
    }","Specifies if this species moves or eats during the day.
@return true if this species moves or eats during the day, false otherwise",Rat.java,455.0,3
9,"public boolean matesDuringDay(){
        return MATE_DURING_DAY;
    }","Specifies if this animal mates during the day.
@return true if this species mates during the day, false otherwise",Rat.java,455.0,3
10,"public boolean isHerbivore(){
        return IS_HERBIVORE;
    }","Specifies whether this animal is a herbivore.
@return true if it is, false otherwise",Rat.java,455.0,3
11,"public double getDiseaseSpreadingProbability(){
        return DISEASE_SPREADING_PROBABILITY;
    }","Return the probability that this specific species passes on a disease to another animal
@return double value is probability of a disease being passed on to another",Rat.java,455.0,3
12,"public int getMaxAge(){
        return ActualMaxAge;
    }","Return the current maximum age this species may live up to.
@return Current maximum age for this species.",Rat.java,455.0,3
13,"public double getBreedingProbability(){
        return ActualBreedingProbability;
    }","Return the value dictating how probable this species is to breed.
@return Breeding probability of this species.",Rat.java,455.0,3
14,"public int getMaxLitterSize(){
        return ActualMaxLitterSize;
    }","Return the maximum number of offspring this species may have at the moment.
@return Current max litter size for this species.",Rat.java,455.0,3
15,"public int getFoodValue(){
        return ActualFoodValue;
    }","Returns the number of steps this animal may survive after having eaten.
@return int The food value for this species",Rat.java,455.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,455.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,455.0,3
0,"public Animal getNewYoung( boolean randomAge, Field field, Location loc, Simulator simulator){
        return new Snake( false, field, loc, simulator);
    }","Creates and returns a new animal of this specific species type object, to act as offspring.
@return A new animal of this specific species type object.
@param randomAge If true, the new animal will have a random age.
@param field The field currently occupied.
@param location The location within the field to put the new animal in.",Snake.java,455.0,3
1,"public boolean checkMate(Object object){
        if (object instanceof Snake){
            Snake holdSnake = (Snake) object;
            if (!this.getGender().equals(holdSnake.getGender()) && holdSnake.canMate())
                return true;
            else
                return false;
        }
        return false;
    }","Checks if a passed object is of the same type as this species.
@return True if passed object is of the same type as this species, false otherwise",Snake.java,455.0,3
2,"public boolean checkFoodType(Object object){ 
        return (object instanceof Rat || object instanceof Toad);
    }","Specifies whether the object passed through the parameter represents the food this species eats.
@return boolean True if the passed object is food for this specific species, false otherwise",Snake.java,455.0,3
3,"public void getDisease(){
        diseaseLevel = DISEASE_LEVEL_START_VALUE;
        ActualMaxAge = DISEASED_MAX_AGE;
        ActualBreedingProbability = DISEASED_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DISEASED_MAX_LITTER_SIZE;
        ActualFoodValue = DISEASED_FOOD_VALUE;
    }","Modifies longevity,nutrition and breeding probability values to simulate a sick animal.",Snake.java,455.0,3
4,"public void initializeDefaultStats(){
        ActualMaxAge = DEFAULT_MAX_AGE;
        ActualBreedingProbability = DEFAULT_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DEFAULT_MAX_LITTER_SIZE;
        ActualFoodValue = DEFAULT_FOOD_VALUE;
    }","Initializes/changes certain behaviour affecting values to
default values.
Also used to make an animal not sick.",Snake.java,455.0,3
5,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Return the value of the BREEDING_AGE constant;
@return Minimum age for breeding for this species.",Snake.java,455.0,3
6,"public int getDefaultMaxAge(){
        return DEFAULT_MAX_AGE;
    }","Returns the value of the normal age an animal of this species may live up to
@return int Maximum age a healthy animal of this species may live up to.",Snake.java,455.0,3
7,"public int getMatingCooldown(){
        return MATING_COOLDOWN;
    }","Returns a number representing the steps an animal of this species
must wait before being able to mate again.
@return int The value of the ""mating cooldown""",Snake.java,455.0,3
8,"public boolean movesOrEatsDuringDay(){
        return MOVE_OR_EAT_DURING_DAY;
    }","Specifies if this species moves or eats during the day.
@return true if this species moves or eats during the day, false otherwise",Snake.java,455.0,3
9,"public boolean matesDuringDay(){
        return MATE_DURING_DAY;
    }","Specifies if this animal mates during the day.
@return true if this species mates during the day, false otherwise",Snake.java,455.0,3
10,"public boolean isHerbivore(){
        return IS_HERBIVORE;
    }","Specifies whether this animal is a herbivore.
@return true if it is, false otherwise",Snake.java,455.0,3
11,"public double getDiseaseSpreadingProbability(){
        return DISEASE_SPREADING_PROBABILITY;
    }","Return the probability that this specific species passes on a disease to another animal
@return double value is probability of a disease being passed on to another",Snake.java,455.0,3
12,"public int getMaxAge(){
        return ActualMaxAge;
    }","Return the current maximum age this species may live up to.
@return Current maximum age for this species.",Snake.java,455.0,3
13,"public double getBreedingProbability(){
        return ActualBreedingProbability;
    }","Return the value dictating how probable this species is to breed.
@return Breeding probability of this species.",Snake.java,455.0,3
14,"public int getMaxLitterSize(){
        return ActualMaxLitterSize;
    }","Return the maximum number of offspring this species may have at the moment.
@return Current max litter size for this species.",Snake.java,455.0,3
15,"public int getFoodValue(){
        return ActualFoodValue;
    }","Returns the number of steps this animal may survive after having eaten.
@return int The food value for this species",Snake.java,455.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,455.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,455.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,455.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,455.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,455.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,455.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,455.0,3
3,"public void showStatus(int step, int noOfDiseased, Field field, Field plantField)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        

        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    
                    Color colorForAnimal = getColor(animal.getClass());
                    Animal temp = (Animal) animal; // Cast back to animal is needed for determining sex of animal. Field is only populated by Animal subtypes therefore this is a safe choice.
                    if (temp.getGender().equals(""female"")){
                        colorForAnimal = colorForAnimal.darker();
                    }
                    
                    fieldView.drawMark(col, row, colorForAnimal);
                    
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
                
                Object plant = plantField.getObjectAt(row, col);
                if (plant!=null)
                    stats.incrementCount(plant.getClass());
            }
        }
        stats.countFinished();
        
        
        String timeOfDay = null;
        if(step/5 % 2 == 0){
            timeOfDay = ""Day"" ;
        }else{
            timeOfDay = ""Night"";
        }
        
        populationAndTime.setText(POPULATION_PREFIX +  stats.getPopulationDetails(field) + 
                                  "" Diseased:"" + noOfDiseased + "" "" + 
                                  TIME_PREFIX + timeOfDay);
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,455.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,455.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,455.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(30);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,455.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Needed to simulate immunization: past a certain percentage of the total animal population being sick, we consider immunization to take place
        int diseaseCounter = 0;

        // The organisms list does not distinguish between animals and plants, so we need to count
        int animalCounter = 0;

        createNewPlantsCooldown();

        changeTimeOfDay(); 

        List<Organism> newOrganisms = new ArrayList<>();
        for (Iterator<Organism> it = organisms.iterator(); it.hasNext(); ){
            Organism organism = it.next();
            randomizeDisease(organism); // Any animal has a chance to get sick at any point, apart from receiving the sickness from a neighboring animal

            if(diseaseThresholdPassed == true)  // If enough animals are sick, random animals will start to get cured, simulating herd immunization
                randomizeCure(organism);

            if(organism.isDiseased())
                diseaseCounter++;


            if(!(organism instanceof Plant))  // Not ideal, but may prove useful to have
                 animalCounter++;       // organisms generalised in the future
                
            organism.act(newOrganisms);
            if (! organism.isAlive()) 
                it.remove();
        }

        

        if(diseaseCounter > animalCounter/3) // If the percentage of sick animals is high enough, trigger immunization
            diseaseThresholdPassed = true;

        if(diseaseCounter < animalCounter/10) // If the percentage of sick animals drops to below 10%, the flag turns to false and immunization stops
            diseaseThresholdPassed = false;

        organisms.addAll(newOrganisms);
        view.showStatus(step, diseaseCounter, field, plantField);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,455.0,3
3,"private void randomizeDisease(Organism object){
        Random rand = Randomizer.getRandom();
        double diseaseRand = rand.nextDouble();
        if (diseaseRand < 0.01){
            object.getDisease();
        }
    }","/*
With a very small chance, makes the passed organism object sick.",Simulator.java,455.0,3
4,"private void randomizeCure(Organism object){
        Random rand = Randomizer.getRandom();
        double cureRand = rand.nextDouble();
        if (cureRand < 0.7){
            object.cureDisease();
        }
    }","/*
Cures the passed organism object with a 70% chance.",Simulator.java,455.0,3
5,"private void changeTimeOfDay(){
        if(step%5 == 1){
            timeOfDay = !timeOfDay;
        }
    }","/*
Changes the boolean flag that represents the time of day every 5 steps",Simulator.java,455.0,3
6,"private void createNewPlantsCooldown(){
        if (step%PLANTS_COOLDOWN == 1)
        {
            createNewPlants();
        }
    }","/*
Enforces a cooldown between plant population additions",Simulator.java,455.0,3
7,"public void reset()
    {
        step = 0;
        organisms.clear();
        populate();
        populatePlants();

        // Show the starting state in the view.
        view.showStatus(step, 0, field, plantField);
    }",Reset the simulation to a starting position.,Simulator.java,455.0,3
8,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= CAT_CREATION_PROBABILITY) { // 
                    Location location = new Location(row, col);
                    Cat cat = new Cat( true, field, location, this);
                    organisms.add(cat);
                }
                else if(rand.nextDouble() <= RAT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rat rat = new Rat( true, field, location, this);
                    organisms.add(rat);
                }
                else if(rand.nextDouble() <= SNAKE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Snake snake = new Snake( true, field, location, this);
                    organisms.add(snake);
                }
                else if(rand.nextDouble() <= TOAD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Toad toad = new Toad( true, field, location, this);
                    organisms.add(toad);
                }
                else if(rand.nextDouble() <= WILDCHICKEN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    WildChicken wildChicken = new WildChicken( true, field, location, this);
                    organisms.add(wildChicken);
                }

                // else leave the location empty.
            }
        }
    }","Randomly populate the field with cats, rats, snakes, toads and wild chickens.",Simulator.java,455.0,3
9,"public Field getPlantField(){
        return plantField;
    }","Returns the ""plant-level"" field
@return Field the plant field",Simulator.java,455.0,3
10,"private void populatePlants(){
        plantField.clear();  
        createNewPlants();
    }",Populates the plant field from scratch.,Simulator.java,455.0,3
11,"private void createNewPlants(){
        Random rand = Randomizer.getRandom();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {

                Location location = new Location(row, col);
                Object object = plantField.getObjectAt(location);
                if (object==null){
                    if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY){
                        Grass grass = new Grass(true, plantField, location, this);
                        organisms.add(grass);
                    }
                    else if(rand.nextDouble() <= FERN_CREATION_PROBABILITY){
                        Fern fern = new Fern(true, plantField, location, this);
                        organisms.add(fern);
                    }
                }
            }
        }
    }","Adds new plants to the plant field, whether it is already populated or not.",Simulator.java,455.0,3
12,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,455.0,3
13,"public boolean getTimeOfDay(){
        return timeOfDay;
    }","Specifies the time of day
@return true if it is day, false otherwise",Simulator.java,455.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if (info.getCount()>0){
                buffer.append(info.getName());
                buffer.append("": "");
                buffer.append(info.getCount());
                buffer.append(' ');
            }
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,455.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,455.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,455.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,455.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0 && notPlant(key)) { // Plants should not be counted among the animal species, the existence of which determines whether the simulation should keep running
                nonZero++;
            }
        }
        return nonZero > 3; // We want the simulation to end when there are only 3 species left
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,455.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,455.0,3
6,"private boolean notPlant(Class possiblePlantSubclass){
         if (possiblePlantSubclass.getGenericSuperclass().getTypeName().contains(""Plant""))return false;
         else return true;
    }","/*
Determines if the passed Class type object represents a subclass of the Plant class",FieldStats.java,455.0,3
0,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns maximum age this fern plant may live up to in its current state. Fern plants do not get sick, so this value
is the same as the default maximum age.a
@return int Maximum age.",Fern.java,455.0,3
1,"protected void getDisease(){
    }","Grass plants do not get sick, therefore this method has no effect.",Fern.java,455.0,3
2,"public int getDefaultMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age this fernn plant may live up to when healthy.
@return int Maximum age when healthy",Fern.java,455.0,3
0,"public Animal getNewYoung( boolean randomAge, Field field, Location loc, Simulator simulator){
        return new Cat( false, field, loc, simulator);
    }","Creates and returns a new animal of this specific species type object, to act as offspring.
@return A new animal of this specific species type object.
@param randomAge If true, the new animal will have a random age.
@param field The field currently occupied.
@param location The location within the field to put the new animal in.",Cat.java,455.0,3
1,"public boolean checkMate(Object object){
        if (object instanceof Cat){
            Cat holdCat = (Cat) object;
            if (!this.getGender().equals(holdCat.getGender()) && holdCat.canMate())
                return true;
            else
                return false;
        }
        return false;
    }","Checks if a passed object is of the same type as this species.
@return True if passed object is of the same type as this species, false otherwise",Cat.java,455.0,3
2,"public boolean checkFoodType(Object object){ 
        return (object instanceof Rat || object instanceof WildChicken);
    }","Specifies whether the object passed through the parameter represents the food this species eats.
@return boolean True if the passed object is food for this specific species, false otherwise",Cat.java,455.0,3
3,"public void getDisease(){
        diseaseLevel = DISEASE_LEVEL_START_VALUE;
        ActualMaxAge = DISEASED_MAX_AGE;
        ActualBreedingProbability = DISEASED_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DISEASED_MAX_LITTER_SIZE;
        ActualFoodValue = DISEASED_FOOD_VALUE;
    }","Modifies longevity,nutrition and breeding probability values to simulate a sick animal.",Cat.java,455.0,3
4,"public void initializeDefaultStats(){
        ActualMaxAge = DEFAULT_MAX_AGE;
        ActualBreedingProbability = DEFAULT_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DEFAULT_MAX_LITTER_SIZE;
        ActualFoodValue = DEFAULT_FOOD_VALUE;
    }","Initializes/changes certain behaviour affecting values to
default values.
Also used to make an animal not sick.",Cat.java,455.0,3
5,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Return the value of the BREEDING_AGE constant;
@return Minimum age for breeding for this species.",Cat.java,455.0,3
6,"public int getDefaultMaxAge(){
        return DEFAULT_MAX_AGE;
    }","Returns the value of the normal age an animal of this species may live up to
@return int Maximum age a healthy animal of this species may live up to.",Cat.java,455.0,3
7,"public int getMatingCooldown(){
        return MATING_COOLDOWN;
    }","Returns a number representing the steps an animal of this species
must wait before being able to mate again.
@return int The value of the ""mating cooldown""",Cat.java,455.0,3
8,"public boolean movesOrEatsDuringDay(){
        return MOVE_OR_EAT_DURING_DAY;
    }","Specifies if this species moves or eats during the day.
@return true if this species moves or eats during the day, false otherwise",Cat.java,455.0,3
9,"public boolean matesDuringDay(){
        return MATE_DURING_DAY;
    }","Specifies if this animal mates during the day.
@return true if this species mates during the day, false otherwise",Cat.java,455.0,3
10,"public boolean isHerbivore(){
        return IS_HERBIVORE;
    }","Specifies whether this animal is a herbivore.
@return true if it is, false otherwise",Cat.java,455.0,3
11,"public double getDiseaseSpreadingProbability(){
        return DISEASE_SPREADING_PROBABILITY;
    }","Return the probability that this specific species passes on a disease to another animal
@return double value is probability of a disease being passed on to another",Cat.java,455.0,3
12,"public int getMaxAge(){
        return ActualMaxAge;
    }","Return the current maximum age this species may live up to.
@return Current maximum age for this species.",Cat.java,455.0,3
13,"public double getBreedingProbability(){
        return ActualBreedingProbability;
    }","Return the value dictating how probable this species is to breed.
@return Breeding probability of this species.",Cat.java,455.0,3
14,"public int getMaxLitterSize(){
        return ActualMaxLitterSize;
    }","Return the maximum number of offspring this species may have at the moment.
@return Current max litter size for this species.",Cat.java,455.0,3
15,"public int getFoodValue(){
        return ActualFoodValue;
    }","Returns the number of steps this animal may survive after having eaten.
@return int The food value for this species",Cat.java,455.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,455.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,455.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,455.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,455.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,455.0,3
0,"public void cureDisease(){
        diseaseLevel = 0;
    }",Cures this organism of disease.,Organism.java,455.0,3
1,"public void act(List<Organism> newOrganisms){
        incrementAge();
    }",Makes this organism act: makes it do whatever it needs or wants to do.,Organism.java,455.0,3
2,"protected boolean isDiseased(){
        return (diseaseLevel>0);
    }","Specifies whether this organism is diseased.
@return true If this organism has a disease.",Organism.java,455.0,3
3,"protected void decreaseDiseaseLevel(){
        if (diseaseLevel>0)
            diseaseLevel--;
            
        if (diseaseLevel==0)
            cureDisease();
    }","Decreases this organism's disease level (amount of steps until cured), and cures it when appropriate.",Organism.java,455.0,3
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the organism at the new location in the given field.
@param newLocation The organism's new location.",Organism.java,455.0,3
5,"protected Field getField()
    {
        return field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,455.0,3
6,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Makes this organism older by one step.,Organism.java,455.0,3
7,"protected Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,455.0,3
8,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,455.0,3
9,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,455.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,455.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,455.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,455.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,455.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,455.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,455.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,455.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,455.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,455.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,455.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,455.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,455.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,455.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,455.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,455.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,455.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,455.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,455.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,455.0,3
0,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns maximum age this grass plant may live up to in its current state. Grass plants do not get sick, so this value
is the same as the default maximum age.a
@return int Maximum age.",Grass.java,455.0,3
1,"protected void getDisease(){
    }","Grass plants do not get sick, therefore this method has no effect.",Grass.java,455.0,3
2,"public int getDefaultMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age this plant may live up to when healthy.
@return int Maximum age when healthy",Grass.java,455.0,3
0,"public void act(List<Organism> newOrganisms){
        super.act(newOrganisms);

        updateStats();

        if(isAlive()) {
            if(isDiseased()){
                spreadDisease();
            }

            tryToMate(newOrganisms);

            moveOrEat();
        }
    }","Make this animal act - that is: make it do
whatever it wants/needs to do.
@param newOrganisms A list to receive newly born animals.",Animal.java,455.0,3
2,"private void tryToMate(List<Organism> newOrganisms){
        if (
        (matesDuringDay() && simulator.getTimeOfDay()) // simulator.getTimeOfDay() returns true if it is currently day, false if it is night
        ||
        (!matesDuringDay() && !simulator.getTimeOfDay())
        )
        {
            if (canMate())
            {
                Object possibleMate = findMate();
                if (possibleMate!=null)
                {
                    updateMatingCooldown();
                    updateMateCooldown(possibleMate);
                    giveBirth(newOrganisms); 
                }   
            }
        }
    }","Checks if this animal can mate ( adequate time of day, age, neighboring mate, etc ) and makes it mate if possible",Animal.java,455.0,3
3,"private void moveOrEat(){
        if (
        (movesOrEatsDuringDay() && simulator.getTimeOfDay()) // simulator.getTimeOfDay() returns true if it is currently day, false if it is night
        ||
        (!movesOrEatsDuringDay() && !simulator.getTimeOfDay())
        ){

            Location newLocation = null;

            newLocation = findFood(); // next location is set as the location of food if food is found
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","Checks if this animal moves and eats during the current time of day, makes it do so if it is adequate.",Animal.java,455.0,3
4,"protected void spreadDisease(){
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Animal possibleDiseased = (Animal) field.getObjectAt(where);
            if(possibleDiseased != null){
                var diseaseRand = rand.nextDouble();
                if (diseaseRand < getDiseaseSpreadingProbability())
                {
                    possibleDiseased.getDisease();
                }
            }
        }

    }","Searches for any animals in the adjacent cells, and depending on a random value and a given probability, spreads disease to each of them (separately).",Animal.java,455.0,3
5,"public void cureDisease(){
        diseaseLevel = 0;
        initializeDefaultStats();
    }",Cures this animal of disease.,Animal.java,455.0,3
6,"protected boolean canMate(){
        return (matingCooldown==0 && age >= getBreedingAge());
    }","Specifies whether this animal can mate at the moment.
@return true if this animal can mate, false otherwise",Animal.java,455.0,3
7,"private void updateMatingCooldown(){
        matingCooldown = getMatingCooldown();
    }",Sets the mating cooldown to the animal's species' specific value. Makes the animal wait before being able to mate again.,Animal.java,455.0,3
8,"private void decreaseMatingCooldown(){
        if (matingCooldown>0)matingCooldown--;
    }",Counts one step until the animal may mate again.,Animal.java,455.0,3
9,"private void updateMateCooldown(Object mate){
        Animal mateAnimalHolder = (Animal) mate;
        mateAnimalHolder.updateMatingCooldown();
    }","Updates the provided mate's (passed through the parameter) mating cooldown.
@param mate This animal's mate",Animal.java,455.0,3
10,"private Object findMate(){
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object possibleMate = field.getObjectAt(where);
            if(checkMate(possibleMate)) 
                return possibleMate;

        }
        return null;
    }","Looks for a suitable mate for this animal in the adjacent cells.
@return Object A suitable mate that was found, or null if there is none.",Animal.java,455.0,3
11,"public String getGender(){
        return sex;
    }","Returns a string representing the gender of this animal.
@return ""male"" or ""female""",Animal.java,455.0,3
12,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Animal.java,455.0,3
13,"protected void giveBirth(List<Organism> newOrganisms)
    {
        // New animals of same species are born into adjacent locations.
        
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation()); // Get a list of adjacent free locations.
        int births = breed(); // Number of offspring to create. Number can be 0 ( breeding is unsuccesful ) and no offspring will apear
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);

            Animal young = null;

            young = getNewYoung( false, field, loc, simulator); // This method is implemented individually in each subclass
            // so that it returns a new object of the same type as the caller, so, a new animal of the same species.

            newOrganisms.add(young);
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newOrganisms A list to return newly born animals.",Animal.java,455.0,3
14,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,455.0,3
15,"protected Location findFood()
    {
        Field field;
        if (isHerbivore())field = simulator.getPlantField();
        else field = getField();

        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object possibleFood = field.getObjectAt(where);
            if(checkFoodType(possibleFood)) {    
                Organism food = (Organism) possibleFood;
                if(food.isAlive()) { 
                    food.setDead();
                    foodLevel = getFoodValue();
                    return where;
                }
            }
        }
        return null;
    }","Searches neighbouring cells for the correct food type, and makes the animal eat
@return Location The location of the food found, or null if there is no food around.",Animal.java,455.0,3
0,"public Animal getNewYoung( boolean randomAge, Field field, Location loc, Simulator simulator){
        return new Toad( false, field, loc, simulator);
    }","Creates and returns a new animal of this specific species type object, to act as offspring.
@return A new animal of this specific species type object.
@param randomAge If true, the new animal will have a random age.
@param field The field currently occupied.
@param location The location within the field to put the new animal in.",Toad.java,455.0,3
1,"public boolean checkMate(Object object){
        if (object instanceof Toad){
            Toad holdToad = (Toad) object;
            if (!this.getGender().equals(holdToad.getGender()) && holdToad.canMate())
                return true;
            else
                return false;
        }
        return false;
    }","Checks if a passed object is of the same type as this species.
@return True if passed object is of the same type as this species, false otherwise",Toad.java,455.0,3
2,"public boolean checkFoodType(Object object){ 
        return (object instanceof Fern);
    }","Specifies whether the object passed through the parameter represents the food this species eats.
@return boolean True if the passed object is food for this specific species, false otherwise",Toad.java,455.0,3
3,"public void getDisease(){
        diseaseLevel = DISEASE_LEVEL_START_VALUE;
        ActualMaxAge = DISEASED_MAX_AGE;
        ActualBreedingProbability = DISEASED_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DISEASED_MAX_LITTER_SIZE;
        ActualFoodValue = DISEASED_FOOD_VALUE;
    }","Modifies longevity,nutrition and breeding probability values to simulate a sick animal.",Toad.java,455.0,3
4,"public void initializeDefaultStats(){
        ActualMaxAge = DEFAULT_MAX_AGE;
        ActualBreedingProbability = DEFAULT_BREEDING_PROBABILITY;
        ActualMaxLitterSize = DEFAULT_MAX_LITTER_SIZE;
        ActualFoodValue = DEFAULT_FOOD_VALUE;
    }","Initializes/changes certain behaviour affecting values to
default values.
Also used to make an animal not sick.",Toad.java,455.0,3
5,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Return the value of the BREEDING_AGE constant;
@return Minimum age for breeding for this species.",Toad.java,455.0,3
6,"public int getDefaultMaxAge(){
        return DEFAULT_MAX_AGE;
    }","Returns the value of the normal age an animal of this species may live up to
@return int Maximum age a healthy animal of this species may live up to.",Toad.java,455.0,3
7,"public int getMatingCooldown(){
        return MATING_COOLDOWN;
    }","Returns a number representing the steps an animal of this species
must wait before being able to mate again.
@return int The value of the ""mating cooldown""",Toad.java,455.0,3
8,"public boolean movesOrEatsDuringDay(){
        return MOVE_OR_EAT_DURING_DAY;
    }","Specifies if this species moves or eats during the day.
@return true if this species moves or eats during the day, false otherwise",Toad.java,455.0,3
9,"public boolean matesDuringDay(){
        return MATE_DURING_DAY;
    }","Specifies if this animal mates during the day.
@return true if this species mates during the day, false otherwise",Toad.java,455.0,3
10,"public boolean isHerbivore(){
        return IS_HERBIVORE;
    }","Specifies whether this animal is a herbivore.
@return true if it is, false otherwise",Toad.java,455.0,3
11,"public double getDiseaseSpreadingProbability(){
        return DISEASE_SPREADING_PROBABILITY;
    }","Return the probability that this specific species passes on a disease to another animal
@return double value is probability of a disease being passed on to another",Toad.java,455.0,3
12,"public int getMaxAge(){
        return ActualMaxAge;
    }","Return the current maximum age this species may live up to.
@return Current maximum age for this species.",Toad.java,455.0,3
13,"public double getBreedingProbability(){
        return ActualBreedingProbability;
    }","Return the value dictating how probable this species is to breed.
@return Breeding probability of this species.",Toad.java,455.0,3
14,"public int getMaxLitterSize(){
        return ActualMaxLitterSize;
    }","Return the maximum number of offspring this species may have at the moment.
@return Current max litter size for this species.",Toad.java,455.0,3
15,"public int getFoodValue(){
        return ActualFoodValue;
    }","Returns the number of steps this animal may survive after having eaten.
@return int The food value for this species",Toad.java,455.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,83.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,83.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,83.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,83.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,83.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,83.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,83.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,83.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,83.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,83.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,83.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,83.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,83.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,83.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,83.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,83.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,83.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,83.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,83.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,83.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    animals.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    animals.add(rabbit);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,83.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,83.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,83.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,83.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,83.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,83.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,83.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,83.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,83.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,83.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,83.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,83.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,83.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,83.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,83.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,83.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,83.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,83.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,83.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,83.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,83.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,83.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,83.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,83.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,83.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,83.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,83.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,83.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,83.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,83.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,83.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,83.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,83.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,83.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,83.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,83.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,83.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the moose's death.",Moose.java,83.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this moose more hungry. This could result in the moose's death.,Moose.java,83.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive()) {
                    plant.setDead();
                    foodLevel = PLANT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for moose adjacent to the current location.
Only the first live moose is eaten.
@return Where food was found, or null if it wasn't.",Moose.java,83.0,3
3,"protected void giveBirth(List<Animal> newMoose) {
        if (age > BREEDING_AGE) {
            //Look for adjacent animals of the same breed
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object object = field.getObjectAt(where);
                if (object instanceof Moose) {
                    Moose adMoose = (Moose) object;
                    // Check whether the animals are compatible to give birth.
                    if (adMoose.isAlive() && (adMoose.isFemale() && !this.isFemale()) || (!adMoose.isFemale() && this.isFemale())) {
                        if (adMoose.isSick()) {
                            changeSickness();
                            if (MAX_AGE - age < 10) {
                                age = MAX_AGE - age;
                            }
                        }
                        //Give birth in a random adjacent location.
                        List<Location> free = field.getFreeAdjacentLocations(getLocation());
                        int births = breed();
                        for (int b = 0; b < births && free.size() > 0; b++) {
                            Location loc = free.remove(0);
                            Moose young = new Moose(false, field, loc, rand.nextBoolean(), this.isSick());
                            newMoose.add(young);
                        }

                    }
                }
            }
        }
    }","Check whether or not this moose is to give birth at this step.
New births will be made into free adjacent locations.
@param newMoose A list to return newly born moose.",Moose.java,83.0,3
4,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Moose.java,83.0,3
5,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A moose can breed if it has reached the breeding age and it is female.
@return true if the moose can breed, false otherwise.",Moose.java,83.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,83.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,83.0,3
0,"protected void setLocation(Location location)
    {
        if(location != null) {
            field.clear(location);
        }
        this.location = location;
        field.place(this, location);
    }","Place the plant at the given location
@param location The plant's location.",Plant.java,83.0,3
1,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,83.0,3
2,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,83.0,3
3,"protected Field getField() {
        return field;
    }",@return the plant's field.,Plant.java,83.0,3
4,"protected Location getLocation() {
        return location;
    }",@return the plant's location.,Plant.java,83.0,3
0,"public void act(List<Animal> newPreys) {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPreys);
            // Move towards a source of food if found.
            Location newLocation = findFood();
            newLocation = newLocation == null ? getField().freeAdjacentLocation(getLocation()) : null;
                if(newLocation != null) setLocation(newLocation); else setDead();
        }
    }","This is what the prey does most of the time: it looks for
plants. In the process, it might breed, die of hunger,
or die of old age.
@param newPreys A list to return newly born preys.",Prey.java,83.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,83.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,83.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,83.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,83.0,3
0,"public void act(List<Animal> newPredators) {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPredators);
            // Move towards a source of food if found.
            Location newLocation = findFood();
            newLocation = newLocation == null ? getField().freeAdjacentLocation(getLocation()) : null;
            if(newLocation != null) setLocation(newLocation); else setDead();


        }
    }","This is what the predator does most of the time: it hunts for
preys. In the process, it might breed, die of hunger,
or die of old age.
@param newPredators A list to return newly born predators.",Predator.java,83.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,83.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,83.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,83.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();

    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,83.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,83.0,3
0,"private void createButtonsView() {

        JFrame buttonsView = new JFrame(""Buttons"");
        JPanel panel = new JPanel();

        panel.setLayout(new FlowLayout());

        buttonsView.getContentPane().add(panel);

        JButton rainButton = new JButton(""Rain"");
        rainButton.addActionListener(e -> changeWeather(rainButton.getText()));

        JButton fogButton = new JButton(""Fog"");
        fogButton.addActionListener(e -> changeWeather(fogButton.getText()));

        JButton droughtButton = new JButton(""Drought"");
        droughtButton.addActionListener(e -> changeWeather(droughtButton.getText()));

        panel.add(rainButton);
        panel.add(fogButton);
        panel.add(droughtButton);

        buttonsView.pack();
        buttonsView.setVisible(true);
    }",Create a view for the weather buttons.,Simulator.java,83.0,3
1,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,83.0,3
2,"public void simulate(int numSteps)
    {


            for(int step = 1; step <= numSteps && view.isViable(field); step++) {
                simulateOneStep();
                if(time == 24) {
                    time = 0;
                }
                if(22 < time || time < 6) {
                    day = false;
                }else{day = true;}
                delay(60);
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,83.0,3
3,"public void simulateOneStep()
    {
        step++;
        time++;


        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();
        // Let all animals act.
        if( day ) {
            for (Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.act(newAnimals);
                if (!animal.isAlive()) {
                    it.remove();
                }
            }
        }

        //Keep generating plants at random free locations;
        for(int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++){
                Random rand = Randomizer.getRandom();
                double PLANT_PROBABILITY = rand.nextDouble();
                 Location location = new Location(row, col);
                if (field.getObjectAt(location) == null) {
                     if(PLANT_PROBABILITY<baseGrowth){
                     Plant plant = new Plant(field, location);
                    plants.add(plant);
                    }
                }
            }
        }
               
        // Add the newly born animals and plants to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
wolf and moose.",Simulator.java,83.0,3
4,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();

        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,83.0,3
5,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= WOLF_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Wolf wolf = new Wolf(true, field, location, rand.nextBoolean(), rand.nextBoolean());
                    animals.add(wolf);
                }
                else if(rand.nextDouble() <= MOOSE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Moose moose = new Moose(true, field, location, rand.nextBoolean(), rand.nextBoolean());
                    animals.add(moose);
                }
                else if(rand.nextDouble() <= COYOTE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Coyote coyote = new Coyote(true, field, location, rand.nextBoolean(), rand.nextBoolean());
                    animals.add(coyote);
                }
                else if(rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Zebra zebra = new Zebra(true, field, location, rand.nextBoolean(), rand.nextBoolean());
                    animals.add(zebra);
                }
                else if(rand.nextDouble() <= LION_CREATION_PROBABILITY){
                    Location location = new Location(row, col);
                    Lion lion = new Lion(true, field, location, rand.nextBoolean(), rand.nextBoolean());
                    animals.add(lion);
                }
                else if(rand.nextDouble() <= PLANT_CREATION_PROBABILITY){
                    // else leave the location empty.
                        Location location = new Location(row, col);
                        Plant plant = new Plant(field, location);
                        plants.add(plant);
                }
            }
        }
    }",Randomly populate the field with animals and plants.,Simulator.java,83.0,3
6,"private void changeWeather(String label) {
        // If there is a drought, all plants die.
        if(label.equals(""Drought"")) {
            isDrought = ! isDrought;
            //It also stops raining if there is a drought.
            isRain = false;
            for(Plant plant : plants){
                plant.setDead();
            }
        }
        //If it is raining, plants respawn more often.
        else if(label.equals(""Rain"")) {
            isRain = ! isRain;
            //The drought also stops if there is one.
            isDrought = false;
            baseGrowth = 0.0007;
        }
        else {
            isFoggy = ! isFoggy;
            day = false;
        }
    }","Update the behaviour of the animals and plants according to the weather selected.
@param label The label of the button clicked.",Simulator.java,83.0,3
7,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,83.0,3
8,"public int getTime() {
        return time;
    }","Return the time of day.
@return the time of day.",Simulator.java,83.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the zebra's death.",Zebra.java,83.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this zebra more hungry. This could result in the zebra's death.,Zebra.java,83.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object object = field.getObjectAt(where);
            if(object instanceof Plant) {
                Plant plant = (Plant) object;
                if(plant.isAlive()) {
                    plant.setDead();
                    foodLevel = PLANT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for moose adjacent to the current location.
Only the first live moose is eaten.
@return Where food was found, or null if it wasn't.",Zebra.java,83.0,3
3,"protected void giveBirth(List<Animal> newZebras) {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.

        if (age > BREEDING_AGE) {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object object = field.getObjectAt(where);
                if (object instanceof Zebra) {
                    Zebra adZebra = (Zebra) object;
                    // Check whether the animals are compatible to give birth.
                    if (adZebra.isAlive() && (adZebra.isFemale() && !this.isFemale()) || (!adZebra.isFemale() && this.isFemale())) {
                        if (adZebra.isSick()) {
                            changeSickness();
                            if (MAX_AGE - age < 10) {
                                age = MAX_AGE - age;
                            }
                        }
                        List<Location> free = field.getFreeAdjacentLocations(getLocation());
                        int births = breed();
                        for (int b = 0; b < births && free.size() > 0; b++) {
                            Location loc = free.remove(0);
                            Zebra young = new Zebra(false, field, loc, rand.nextBoolean(), this.isSick());
                            newZebras.add(young);
                        }

                    }
                }
            }
        }
    }","Check whether or not this zebra is to give birth at this step.
New births will be made into free adjacent locations.
@param newZebras A list to return newly born zebras.",Zebra.java,83.0,3
4,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Zebra.java,83.0,3
5,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A zebra can breed if it has reached the breeding age and it is female.
@return true if the zebra can breed, false otherwise.",Zebra.java,83.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,83.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,83.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,83.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,83.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,83.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,83.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,83.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,83.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,83.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,83.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,83.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the wolf's death.,Wolf.java,83.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this wolf more hungry. This could result in the wolf's death.,Wolf.java,83.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Moose) {
                Moose moose = (Moose) animal;
                if(moose.isAlive()) { 
                    moose.setDead();
                    foodLevel = MOOSE_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for moose adjacent to the current location.
Only the first live moose is eaten.
@return Where food was found, or null if it wasn't.",Wolf.java,83.0,3
3,"protected void giveBirth(List<Animal> newWolves) {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.

        if (age > BREEDING_AGE) {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object object = field.getObjectAt(where);
                if (object instanceof Wolf) {
                    Wolf adWolf = (Wolf) object;
                    // Check whether the animals are compatible to give birth.
                    if (adWolf.isAlive() && (adWolf.isFemale() && !this.isFemale()) || (!adWolf.isFemale() && this.isFemale())) {
                        if (adWolf.isSick()) {
                            changeSickness();
                            if (MAX_AGE - age < 10) {
                                age = MAX_AGE - age;
                            }
                        }
                        List<Location> free = field.getFreeAdjacentLocations(getLocation());
                        int births = breed();
                        for (int b = 0; b < births && free.size() > 0; b++) {
                            Location loc = free.remove(0);
                            Wolf young = new Wolf(false, field, loc, rand.nextBoolean(), this.isSick());
                            newWolves.add(young);
                        }

                    }
                }
            }
        }
    }","Check whether or not this wolf is to give birth at this step.
New births will be made into free adjacent locations.
@param newWolves A list to return newly born wolves.",Wolf.java,83.0,3
4,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Wolf.java,83.0,3
5,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A wolf can breed if it has reached the breeding age and it is a female.
@return true if it can breed, false otherwise.",Wolf.java,83.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the coyote's death.,Coyote.java,83.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this coyote more hungry. This could result in the coyote's death.,Coyote.java,83.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Moose) {
                Moose moose = (Moose) animal;
                if(moose.isAlive()) {
                    moose.setDead();
                    foodLevel = MOOSE_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for moose adjacent to the current location.
Only the first live moose is eaten.
@return Where food was found, or null if it wasn't.",Coyote.java,83.0,3
3,"protected void giveBirth(List<Animal> newCoyotes) {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.

        if (age > BREEDING_AGE) {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object object = field.getObjectAt(where);
                if (object instanceof Coyote) {
                    Coyote adCoyote = (Coyote) object;
                    // Check whether the animals are compatible to give birth.
                    if (adCoyote.isAlive() && (adCoyote.isFemale() && !this.isFemale()) || (!adCoyote.isFemale() && this.isFemale())) {
                        if (adCoyote.isSick()) {
                            changeSickness();
                            if (MAX_AGE - age < 10) {
                                age = MAX_AGE - age;
                            }
                        }
                        List<Location> free = field.getFreeAdjacentLocations(getLocation());
                        int births = breed();
                        for (int b = 0; b < births && free.size() > 0; b++) {
                            Location loc = free.remove(0);
                            Coyote young = new Coyote(false, field, loc, rand.nextBoolean(), this.isSick());
                            newCoyotes.add(young);
                        }

                    }
                }
            }
        }
    }","Check whether or not this coyote is to give birth at this step.
New births will be made into free adjacent locations.
@param newCoyotes A list to return newly born coyotees.",Coyote.java,83.0,3
4,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Coyote.java,83.0,3
5,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A coyote can breed if it has reached the breeding age and it is a female.
@return true if it can breed, false otherwise.",Coyote.java,83.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,83.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,83.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal or plant at the given location.
If there is already an animal or plant at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,83.0,3
3,"public void place(Object object, Location location)
    {
        field[location.getRow()][location.getCol()] = object;
    }","Place an animal or plant at the given location.
If there is already an animal at the location it will
be lost.
@param object The animal or plant to be placed.
@param location Where to place the animal.",Field.java,83.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal or plant at the given location, if any.
@param location Where in the field.
@return The animal or plant at the given location, or null if there is none.",Field.java,83.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal or plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal or plant at the given location, or null if there is none.",Field.java,83.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,83.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,83.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,83.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,83.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,83.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,83.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the lion's death.,Lion.java,83.0,3
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this lion more hungry. This could result in the lion's death.,Lion.java,83.0,3
2,"protected Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Zebra) {
                Zebra zebra = (Zebra) animal;
                if(zebra.isAlive()) {
                    zebra.setDead();
                    foodLevel = ZEBRA_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for zebras adjacent to the current location.
Only the first live zebra is eaten.
@return Where food was found, or null if it wasn't.",Lion.java,83.0,3
3,"protected void giveBirth(List<Animal> newLions) {
        // New zebras are born into adjacent locations.
        // Get a list of adjacent free locations.

        if (age > BREEDING_AGE) {
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while (it.hasNext()) {
                Location where = it.next();
                Object object = field.getObjectAt(where);
                if (object instanceof Lion) {
                    Lion adLion = (Lion) object;
                    // Check whether the animals are compatible to give birth.
                    if (adLion.isAlive() && (adLion.isFemale() && !this.isFemale()) || (!adLion.isFemale() && this.isFemale())) {
                        if (adLion.isSick()) {
                            changeSickness();
                            if (MAX_AGE - age < 10) {
                                age = MAX_AGE - age;
                            }
                        }
                        List<Location> free = field.getFreeAdjacentLocations(getLocation());
                        int births = breed();
                        for (int b = 0; b < births && free.size() > 0; b++) {
                            Location loc = free.remove(0);
                            Lion young = new Lion(false, field, loc, rand.nextBoolean(), this.isSick());
                            newLions.add(young);
                        }

                    }
                }
            }
        }
    }","Check whether or not this lion is to give birth at this step.
New births will be made into free adjacent locations.
@param newLions A list to return newly born liones.",Lion.java,83.0,3
4,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Lion.java,83.0,3
5,"protected boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale();
    }","A lion can breed if it has reached the breeding age and it is a female.
@return true if it can breed, false otherwise.",Lion.java,83.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,83.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,83.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,83.0,3
3,"protected boolean isFemale() {
        return female;
    }","Return true if the animal is female.
@return true if the animal is female.",Animal.java,83.0,3
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,83.0,3
5,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,83.0,3
6,"protected boolean isSick() {
        return isSick;
    }","Return true if the animal is sick.
@return true is the animal is sick.",Animal.java,83.0,3
7,"protected void changeSickness() {
        isSick = ! isSick;
    }",Change whether the animal is sick or not.,Animal.java,83.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,401.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,401.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,401.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,401.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,401.0,2
0,"public void act(List<Animal> newHares,boolean isDay)
    {
        incrementAge();
        incrementPoison();
        incrementHunger(isDay);

        if(isAlive() && isDay) {           
            // Try to move into a free location.
            if(this.canBreed()){
                findMate(newHares);

            }

            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

        }
    }","This is what the Hare does most of the time - it runs
around and eats berries. Sometimes it will breed or die of old age.
@param newHares A list to return newly born Hares.
@param isDay A boolean to check if its daytime.",Hare.java,401.0,2
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Berries) {
                Berries berries = (Berries) plant;
                if(berries.isAlive()) { 
                    berries.setDead();
                    if(berries.isPoisonous()){
                        this.setPoisoned(true);
                    }
                    foodLevel = Berries_FOOD_VALUE;
                    return where;

                }
            }
        }
        return null;
    }","Look for Berries adjacent to the current location.
Only the first live Berries is eaten.
@return Where food was found, or null if it wasn't.",Hare.java,401.0,2
2,"private void findMate(List<Animal> newHares)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Hare) {
                Hare Hare = (Hare) animal;
                if(Hare.isAlive() && Hare.canBreed() && !Hare.isSameGender(this.isMale()) && !this.isMale()) { 
                    giveBirth(newHares);
                }
            }
        }
    }","This method checks adjacent locations for a potential mate. If the hare finds a mature hare of the opposite sex and is female, It gives birth
@param newHare The list of newborn hares",Hare.java,401.0,2
3,"private void incrementPoison()
    {

        if(isPoisoned() && isAlive()){
            incrementAge();
            poisonLevel++;
            if(poisonLevel % POISON_DURATION == 0){
                this.setPoisoned(false);
            }
        }
    }",Increments the poison level and shortens the hare's lifespan according to its Poison Duration,Hare.java,401.0,2
4,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the Hare's death.",Hare.java,401.0,2
5,"private void giveBirth(List<Animal> newHares)
    {
        // New Hares are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Hare young = new Hare(false, field, loc);
            newHares.add(young);
        }
    }","Check whether or not this Hare is to give birth at this step.
New births will be made into free adjacent locations.
@param newHares A list to return newly born Hares.",Hare.java,401.0,2
6,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Hare.java,401.0,2
7,"private void incrementHunger(boolean isActive)
    {
        if (isActive) {
            foodLevel--;
            if(foodLevel <= 0) {
                setDead();
            }
        }
    }",Make this hare more hungry. This could result in the hare's death.,Hare.java,401.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A Hare can breed if it has reached the breeding age.
@return true if the Hare can breed, false otherwise.",Hare.java,401.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,401.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,401.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,401.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,401.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,401.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,401.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,401.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,401.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,401.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,401.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,401.0,2
0,"public void act(List<Animal> newDeer,boolean isDay)
    {
        incrementAge();
        incrementPoison();
        incrementHunger(isDay);

        if(isAlive() && isDay) {           
            // Try to move into a free location.
            if(this.canBreed()){
                findMate(newDeer);

            }

            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

        }
    }","This is what the Deer does most of the time - it runs
around and feeds on berries. Sometimes it will breed or die of old age.
@param newDeer A list to return newly born Deer.
@param isDay A boolean of whether or not its Daytime.",Deer.java,401.0,2
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Berries) {
                Berries berries = (Berries) plant;
                if(berries.isAlive()) { 
                    berries.setDead();
                    if(berries.isPoisonous()){
                        this.setPoisoned(true);
                    }
                    foodLevel = BERRIES_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Berries adjacent to the current location.
Only the first live Berries is eaten.
@return Where food was found, or null if it wasn't.",Deer.java,401.0,2
2,"private void findMate(List<Animal> newDeer)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Deer) {
                Deer deer = (Deer) animal;
                if(deer.isAlive() && deer.canBreed() && !deer.isSameGender(this.isMale()) && !this.isMale()) { 
                    giveBirth(newDeer);
                }
            }
        }

    }","This method checks adjacent locations for a potential mate. If the deer finds a mature deer of the opposite sex and is female, It gives birth
@param newDeer The list of newborn Deer",Deer.java,401.0,2
3,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the deer's death.",Deer.java,401.0,2
4,"private void incrementPoison()
    {

        if(isPoisoned() && isAlive()){
            incrementAge();
            poisonLevel++;
            if(poisonLevel % POISON_DURATION == 0){
                this.setPoisoned(false);
            }
        }
    }",Increments the poison level and shortens the deer's lifespan according to its Poison Duration,Deer.java,401.0,2
5,"private void incrementHunger(boolean isActive)
    {
        if (isActive) {
            foodLevel--;
            if(foodLevel <= 0) {
                setDead();
            }
        }
    }",Make this deer more hungry. This could result in the deer's death.,Deer.java,401.0,2
6,"private void giveBirth(List<Animal> newdeers)
    {
        // New deers are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Deer young = new Deer(false, field, loc);
            newdeers.add(young);
        }
    }","Check whether or not this deer is to give birth at this step.
New births will be made into free adjacent locations.
@param newdeers A list to return newly born deers.",Deer.java,401.0,2
7,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Deer.java,401.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A deer can breed if it has reached the breeding age.
@return true if the deer can breed, false otherwise.",Deer.java,401.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,401.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,401.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,401.0,2
3,"public void showStatus(int step, Field field, String weather, boolean isDay)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);

        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    if(isDay)
                        fieldView.drawMark(col, row, EMPTY_DAY_COLOR);
                    else
                        fieldView.drawMark(col, row, EMPTY_NIGHT_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        infoLabel.setText(WEATHER_PREFIX + weather + "" | "" + TIME_PREFIX + getTime(step));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,401.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,401.0,2
5,"private String getTime(int step)
    {
        return ((step % 24) + "":00"");
    }","Returns time based on step
@param current step
@return time as a string",SimulatorView.java,401.0,2
0,"public void runLongSimulation()
    {
        simulate(400);
    }","Run the simulation from its current state for a reasonably long period,
(400 steps).",Simulator.java,401.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(45);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,401.0,2
2,"public void simulateOneStep()
    {
        step++;
    

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();  
        List<Plant> newPlants = new ArrayList<>();  
    
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals, isDay());
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.grow(newPlants, isDay(), weather());
            if(! plant.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born wolfes and Hares to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);

        view.showStatus(step, field, weather(), isDay());
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
species",Simulator.java,401.0,2
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field, weather(), isDay());
    }",Reset the simulation to a starting position.,Simulator.java,401.0,2
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= BERRIES_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    List <Location> locations = field.getFreeAdjacentLocations(location); 
                    
                    for(Location loc : locations){
                        Berries berries = new Berries(field, loc);
                        plants.add(berries);
                    }
                    
                    Berries berries = new Berries(field, location);
                    plants.add(berries);
                }
                else if(rand.nextDouble() <= WOLF_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Wolf wolf = new Wolf(true, field, location);
                    animals.add(wolf);
                }
                else if(rand.nextDouble() <= HARE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Hare hare = new Hare(true, field, location);
                    animals.add(hare);
                }
                else if(rand.nextDouble() <= DEER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Deer deer = new Deer(true, field, location);
                    animals.add(deer);
                }
                else if(rand.nextDouble() <= COYOTE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Coyote coyote = new Coyote(true, field, location);
                    animals.add(coyote);
                }
                else if(rand.nextDouble() <= JAGUAR_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Jaguar jaguar = new Jaguar(true, field, location);
                    animals.add(jaguar);
                }
                
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with wolfes and Hares.,Simulator.java,401.0,2
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,401.0,2
6,"private boolean isDay()
    {
        int time = step % 24;
        
        if (time > 5 && time < 18) {
            return true;
        }
        return false;
    }",Returns whether its day or night,Simulator.java,401.0,2
7,"private String weather()
    {
        if ( step % 24 == 0) {
            Random r = new Random();
            weather = r.nextInt(3);
        } 
        
        return weathers.get(weather);
    }",Returns a weather condition,Simulator.java,401.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,401.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,401.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,401.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,401.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,401.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,401.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,401.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,401.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,401.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,401.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,401.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,401.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,401.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,401.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,401.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,401.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,401.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,401.0,2
0,"public void act(List<Animal> newWolves, boolean isDay)
    {
        incrementAge();
        incrementHunger(isDay);
        incrementPoison();

        if(isAlive() && isDay) {           
            if(this.canBreed()){
                findMate(newWolves);
            }
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

        }
    }","This is what the wolf does most of the time: it hunts for
Hares or Deer. In the process, it might breed, die of hunger, suffer poison
or die of old age.
@param field The field currently occupied.
@param newWolves A list to return newly born wolves.
@param isDay A boolean for daytime",Wolf.java,401.0,2
1,"private void findMate(List<Animal> newWolfs)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Wolf) {
                Wolf Wolf = (Wolf) animal;
                if(Wolf.isAlive() && Wolf.canBreed() && !Wolf.isSameGender(this.isMale()) && !this.isMale()) { 
                    giveBirth(newWolfs);
                }
            }
        }

    }","This method checks adjacent locations for a potential mate. If the wolf finds a mature wolf of the opposite sex and is female, It gives birth
@param newWolves The list of newborn wolves",Wolf.java,401.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the wolf's death.,Wolf.java,401.0,2
3,"private void incrementHunger(boolean isActive)
    {
        if (isActive) {
            foodLevel--;
            if(foodLevel <= 0) {
                setDead();
            }
        }
    }",Make this wolf more hungry. This could result in the wolf's death.,Wolf.java,401.0,2
4,"private void incrementPoison()
    {

        if(isPoisoned() && isAlive()){
            incrementAge();
            poisonLevel++;
            if(poisonLevel % POISON_DURATION == 0){
                this.setPoisoned(false);
            }
        }
    }",Increments the poison level and shortens the wolf's lifespan according to its Poison Duration,Wolf.java,401.0,2
5,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Deer) {
                Deer deer= (Deer) animal;
                if(deer.isAlive()) { 
                    deer.setDead();
                    if(deer.isPoisoned()){
                        this.setPoisoned(true);
                    }
                    foodLevel = Deer_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Hare) {
                Hare hare = (Hare) animal;
                if(hare.isAlive()) { 
                    hare.setDead();
                    if(hare.isPoisoned()){
                        this.setPoisoned(true);
                    }
                    foodLevel = Hare_FOOD_VALUE;
                    return where;
                }
            }

        }
        return null;
    }","Look for Hares/Deer adjacent to the current location.
Only the first live Deer is eaten, otherwise a live rabbit is eaten or nothing at all.
Deer/Hares may poison the wolf

@return Where food was found, or null if it wasn't.",Wolf.java,401.0,2
6,"private void giveBirth(List<Animal> newWolves)
    {
        // New wolves are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Wolf young = new Wolf(false, field, loc);
            newWolves.add(young);
        }
        
    }","Check whether or not this wolf is to give birth at this step.
New births will be made into free adjacent locations.
@param newWolves A list to return newly born wolves.",Wolf.java,401.0,2
7,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Wolf.java,401.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A wolf can breed if it has reached the breeding age.,Wolf.java,401.0,2
0,"public void act(List<Animal> newCoyotes, boolean isDay)
    {
        incrementAge();
        incrementPoison();
        incrementHunger(isDay);

        if(isAlive() && isDay) {           

            if(this.canBreed()){
                findMate(newCoyotes);
            }

            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

        }
    }","This is what the coyote does most of the time: it hunts for
Hares/Berries. In the process, it might breed, die of hunger,suffer poison
or die of old age.

@param newCoyotes A list to return newly born coyotes.
@param isDay A boolean for daytime",Coyote.java,401.0,2
1,"private void findMate(List<Animal> newCoyotes)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Coyote) {
                Coyote Coyote = (Coyote) animal;
                if(Coyote.isAlive() && Coyote.canBreed() && !Coyote.isSameGender(this.isMale()) && !this.isMale()) { 
                    giveBirth(newCoyotes);
                }
            }
        }

    }","This method checks adjacent locations for a potential mate. If the coyote finds a mature coyote of the opposite sex and is female, It gives birth
@param newCoyotes The list of newborn coyotes",Coyote.java,401.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the coyote's death.,Coyote.java,401.0,2
3,"private void incrementHunger(boolean isActive)
    {
        if (isActive) {
            foodLevel--;
            if(foodLevel <= 0) {
                setDead();
            }
        }
    }",Make this coyote more hungry. This could result in the coyote's death.,Coyote.java,401.0,2
4,"private void incrementPoison()
    {
        if(isPoisoned() && isAlive()){
            incrementAge();
            poisonLevel++;
            if(poisonLevel % POISON_DURATION == 0){
                this.setPoisoned(false);
            }
        }
    }",Increments the poison level and shortens the coyote's lifespan according to its Poison Duration,Coyote.java,401.0,2
5,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object food = field.getObjectAt(where);
            if(food instanceof Hare) {
                Hare hare = (Hare) food;
                if(hare.isAlive()) { 
                    hare.setDead();
                    if(hare.isPoisoned()){
                        this.setPoisoned(true);
                    }
                    foodLevel = HARE_FOOD_VALUE;
                    return where;
                }
            }
            else if(food instanceof Berries) {
                Berries berries = (Berries) food;
                if(berries.isAlive()) { 
                    berries.setDead();
                    if(berries.isPoisonous()){
                        this.setPoisoned(true);
                    }
                    foodLevel = BERRIES_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Hares/berries adjacent to the current location.
The first live Hare is eaten if not, a shrub of berries is eaten or nothing at all.
@return Where food was found, or null if it wasn't.",Coyote.java,401.0,2
6,"private void giveBirth(List<Animal> newCoyotes)
    {
        // New coyotees are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Coyote young = new Coyote(false, field, loc);
            newCoyotes.add(young);
        }
    }","Check whether or not this coyote is to give birth at this step.
New births will be made into free adjacent locations.
@param newcoyotes A list to return newly born coyotes.",Coyote.java,401.0,2
7,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Coyote.java,401.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A coyote can breed if it has reached the breeding age.,Coyote.java,401.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,401.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,401.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,401.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,401.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,401.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,401.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,401.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,401.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,401.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,401.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,401.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,401.0,2
0,"public void act(List<Animal> newJaguars, boolean isDay)
    {
        incrementAge();
        incrementPoison();
        incrementHunger(!isDay);

        if(isAlive() && !isDay) {          

            if(this.canBreed()){
                findMate(newJaguars);

            }

            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }

        }
    }","This is what the jaguar does most of the time: it hunts for
Deer. In the process, it might breed, die of hunger, get poisoned
or die of old age.

@param field The field currently occupied.
@param newJaguars A list to return newly born Jaguars.
@param isDay A boolean for daytime",Jaguar.java,401.0,2
1,"private void findMate(List<Animal> newJaguars)
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Jaguar) {
                Jaguar Jaguar = (Jaguar) animal;
                if(Jaguar.isAlive() && Jaguar.canBreed() && !Jaguar.isSameGender(this.isMale()) && !this.isMale()) { 
                    giveBirth(newJaguars);
                }
            }
        }

    }","This method checks adjacent locations for a potential mate. If the jaguar finds a mature jaguar of the opposite sex and is female, It gives birth
@param newJaguars The list of newborn Jaguars",Jaguar.java,401.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the jaguar's death.,Jaguar.java,401.0,2
3,"private void incrementHunger(boolean isActive)
    {
        if (isActive) {
            foodLevel--;
            if(foodLevel <= 0) {
                setDead();
            }
        }
    }",Make this jaguar more hungry. This could result in the jaguar's death.,Jaguar.java,401.0,2
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Deer) {
                Deer deer= (Deer) animal;
                if(deer.isAlive()) { 
                    deer.setDead();
                    if(deer.isPoisoned()){
                        this.setPoisoned(true);
                    }
                    foodLevel = DEER_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for Deer adjacent to the current location.
Only the first live Deer is eaten.
@return Where food was found, or null if it wasn't.",Jaguar.java,401.0,2
5,"private void incrementPoison()
    {

        if(isPoisoned() && isAlive()){
            incrementAge();
            poisonLevel++;
            if(poisonLevel % POISON_DURATION == 0){
                this.setPoisoned(false);
            }
        }
    }",Increments the poison level and shortens the jaguar's lifespan according to its Poison Duration,Jaguar.java,401.0,2
6,"private void giveBirth(List<Animal> newJaguars)
    {
        // New Jaguars are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Jaguar young = new Jaguar(false, field, loc);
            newJaguars.add(young);
        }
    }","Check whether or not this jaguar is to give birth at this step.
New births will be made into free adjacent locations.
@param newJaguars A list to return newly born Jaguars.",Jaguar.java,401.0,2
7,"private int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Jaguar.java,401.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A jaguar can breed if it has reached the breeding age.,Jaguar.java,401.0,2
0,"public boolean isMale()
    {
        return male;
    }","Checks if an animal is male
@return boolean of male",Animal.java,401.0,2
1,"public boolean isSameGender(boolean man)
    {
        return male == man ;
    }","Checks if an animal is the same gender
@param the gender of the animal in comparison
@return boolean of same gender",Animal.java,401.0,2
2,"public boolean isPoisoned()
    {
        return poisoned;
    }","Checks if an animal is poison
@return Poison status",Animal.java,401.0,2
3,"public void setPoisoned(boolean poison)
    {
        poisoned = poison;
    }","Sets an animal to be poisoned
@param the poison boolean.",Animal.java,401.0,2
4,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,401.0,2
5,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,401.0,2
6,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,401.0,2
7,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,401.0,2
8,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,401.0,2
0,"public void grow(List<Plant> newBerries,boolean isDay, String weather)
    {
        age++;

        if(isAlive()) {             
            if(isDay && weather.equals(""Rain"")) {
                plantSeed(newBerries);
            }
            
            if (weather.equals(""Snow"")) {
                freeze();
            }
        }
    }","Berries grow in the rain and daytime. They might die in the snow.

@param newBerries: The new berries to be planted
@param isDay checks daytime
@param weather checks weather",Berries.java,401.0,2
1,"private void plantSeed(List<Plant> newBerries)
    {
        // New Hares are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Berries young = new Berries(field, loc);
            newBerries.add(young);
        }
    }","Check whether or not this Berries is to plant seeds at this step.
New Berries will be made into free adjacent locations.
@param newBerries A list to return newly born Berries.",Berries.java,401.0,2
2,"public boolean isPoisonous()
    {
        return isPoisonous;
    }","Checks if this berries is poisonous
@return poison boolean of berries",Berries.java,401.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Berries.java,401.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",Berries can breed if it has reached the breeding age.,Berries.java,401.0,2
5,"private void freeze()
    {
        if(rand.nextDouble() <= FROZEN_DEATH_PROBABILITY){
            setDead();
        }
    }","If berries freeze, they may die",Berries.java,401.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,617.0,0
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,617.0,0
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,617.0,0
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,617.0,0
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,617.0,0
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,617.0,0
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,617.0,0
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,617.0,0
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,617.0,0
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,617.0,0
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,617.0,0
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,617.0,0
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,617.0,0
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,617.0,0
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,617.0,0
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,617.0,0
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,617.0,0
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,617.0,0
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born foxes and rabbits to the main lists.
        animals.addAll(newAnimals);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,617.0,0
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,617.0,0
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location);
                    animals.add(fox);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Rabbit rabbit = new Rabbit(true, field, location);
                    animals.add(rabbit);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,617.0,0
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,617.0,0
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,617.0,0
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,617.0,0
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,617.0,0
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,617.0,0
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,617.0,0
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,617.0,0
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,617.0,0
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,617.0,0
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,617.0,0
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,617.0,0
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,617.0,0
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,617.0,0
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,617.0,0
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,617.0,0
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,617.0,0
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,617.0,0
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,617.0,0
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,617.0,0
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,617.0,0
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,617.0,0
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,617.0,0
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,617.0,0
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,617.0,0
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,617.0,0
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,617.0,0
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,617.0,0
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,617.0,0
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,617.0,0
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,617.0,0
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,617.0,0
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,617.0,0
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,617.0,0
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,617.0,0
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,617.0,0
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,617.0,0
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,136.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,136.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,136.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,136.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,136.0,3
0,"public void grow() {
        size += getGrowingRatio();
    }",The growth method increments the size of the tree,Tree.java,136.0,3
1,"public void decreaseSize(double decreaseRatio) {
        size -= decreaseRatio;
    }","Decrease the size when it gets bites from animals
@param decreaseRatio Decrease Ratio size damage",Tree.java,136.0,3
2,"public double getSize() {
        return size;
    }","Gets the current size of the tree
@return Current Tree size",Tree.java,136.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the bush
@return maximum age of bush",Bush.java,136.0,3
1,"public void act(List<Actor> newBushes)
    {
        super.incrementAge();
        if(isAlive()) {
            doSpread(newBushes);
        }
    }","The bushes spread an grow in age until they die
@param newBushes A list to return newly born bushes.",Bush.java,136.0,3
2,"public void act() {
        incrementAge();
    }","Makes the bushes live throughout the simulation
depending on the simulation steps, each time increasing their age",Bush.java,136.0,3
3,"public int getSpreadingAge()
    {
        return SPREADING_AGE;
    }",Gets the spreading age of the bushes,Bush.java,136.0,3
4,"public int getMaxSeeds()
    {
        return MAX_SEEDS;
    }",Gets the maximum number of seed the bushes can spread,Bush.java,136.0,3
5,"public double getSpreadingProbability()
    {
        return SPREADING_PROBABILITY;
    }",Get the specific probability of the Bushes,Bush.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object plant = field.getObjectAt(where);
                //if bush is found, eat
                if(plant instanceof Bush) {
                    Bush bush = (Bush) plant;
                    if(bush.isAlive()) {
                        bush.setDead();
                        setFoodLevel(getBushFoodValue());
                        return where;
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for bushes adjacent to the current location.
Only the first bush is eaten.
@return Where food was found, or null if it wasn't.",Gazelle.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the gazelles
@return breeding age of gazelles",Gazelle.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the gazelles
@return maximum age of gazelles",Gazelle.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the gazelles
@return maximum amount of babies of the gazelles",Gazelle.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the gazelles
@return probability of breeding of the gazelles",Gazelle.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object plant = field.getObjectAt(where);
                //if tree is found, eat from tree and reduce size
                if(plant instanceof Acacia) {
                    Acacia acacia = (Acacia) plant;
                    if(acacia.isAlive()) {
                        acacia.decreaseSize(10);
                        setFoodLevel(getAcaciaFoodValue());
                        if (acacia.getSize() < 0) {
                            acacia.setDead();
                            return where;
                        }
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for acacia trees adjacent to the current location.
Only the first tree is eaten, but not completely,
reduces its length.
@return Where food was found, or null if it wasn't.",Giraffe.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the giraffes
@return breeding age of giraffes",Giraffe.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the giraffes
@return maximum age of giraffes",Giraffe.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the giraffes
@return maximum amount of babies of the giraffes",Giraffe.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the giraffes
@return probability of breeding of the giraffes",Giraffe.java,136.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,136.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,136.0,3
0,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the tree
@return maximum age of tree",Acacia.java,136.0,3
1,"public void act(List<Actor> newAcacias)
    {
        incrementAge();
        if(isAlive()) {
            grow();
            doSpread(newAcacias);
        }
    }","The trees spread an grow in age and size until they die
@param newAcacias A list to return newly born trees.",Acacia.java,136.0,3
2,"public void act() {
        incrementAge();
    }","Makes the trees live throughout the simulation
depending on the simulation steps, each time increasing their age and size",Acacia.java,136.0,3
3,"public int getSpreadingAge()
    {
        return SPREADING_AGE;
    }",Gets the spreading age of the trees,Acacia.java,136.0,3
4,"public int getMaxSeeds()
    {
        return MAX_SEEDS;
    }",Gets the maximum number of seeds the trees can spread,Acacia.java,136.0,3
5,"public double getSpreadingProbability()
    {
        return SPREADING_PROBABILITY;
    }",Get the specific probability of the trees,Acacia.java,136.0,3
6,"public double getGrowingRatio() {
        return GROWING_RATIO;
    }",Get growth ratio of the tree,Acacia.java,136.0,3
0,"public void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= GAZELLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Gazelle gazelle = new Gazelle(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        gazelle.setInfection();
                    }
                    actors.add(gazelle);
                }
                else if(rand.nextDouble() <= ZEBRA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Zebra zebra = new Zebra(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        zebra.setInfection();
                    }
                    actors.add(zebra);
                }
                else if(rand.nextDouble() <= BABOON_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Baboon baboon = new Baboon(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        baboon.setInfection();
                    }
                    actors.add(baboon);
                }
                else if(rand.nextDouble() <= GIRAFFE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Giraffe giraffe = new Giraffe(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        giraffe.setInfection();
                    }
                    actors.add(giraffe);
                }
                else if(rand.nextDouble() <= LION_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lion lion = new Lion(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        lion.setInfection();
                    }
                    actors.add(lion);
                }
                else if(rand.nextDouble() <= LEOPARD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Leopard leopard = new Leopard(true, field, location);
                    if(rand.nextDouble() <= INFECTED_PROBABILITY) {
                        leopard.setInfection();
                    }
                    actors.add(leopard);
                }
                else if(rand.nextDouble() <= BUSH_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Bush bush = new Bush(true, field, location);
                    actors.add(bush);
                }
                else if(rand.nextDouble() <= ACACIA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Acacia acacia = new Acacia(true, field, location);
                    actors.add(acacia);
                }
                // else leave the location empty.
            }
        }
    }","Randomly populate the field with actors:
animals: lions, leopards, gazelles, zebras, baboons, giraffes
plants: bushes and acacias
Randomly sets the infected species of animals",PopulationGenerator.java,136.0,3
1,"public Field getField()
    {
        return field;
    }",@return The field.,PopulationGenerator.java,136.0,3
2,"public SimulatorView getView()
    {
        return view;
    }",@return The view.,PopulationGenerator.java,136.0,3
3,"public List getActors()
    {
        return actors;
    }",@return The actors list.,PopulationGenerator.java,136.0,3
0,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,136.0,3
1,"public void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the plant's death.,Plant.java,136.0,3
2,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,136.0,3
3,"public boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.

@return true if the plant is still alive.",Plant.java,136.0,3
4,"public int getAge()
    {
        return age;
    }","Get current age of the plant
@return current age of plant",Plant.java,136.0,3
5,"public Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,136.0,3
6,"public Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,136.0,3
7,"public int spread()
    {
        int seeds = 0;
        if(canSpread() && (rand.nextDouble() <= getSpreadingProbability())) {
            seeds = rand.nextInt(getMaxSeeds()) + 1;
        }
        return seeds;
    }","Generate a number representing the number of seeds,
if it can spread.
@return The number of new seeds (may be zero).",Plant.java,136.0,3
8,"protected void doSpread(List<Actor> newPlants)
    {
        // New plants grow into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int seeds = spread();
        for(int b = 0; b < seeds && free.size() > 0; b++) {
            Location loc = free.remove(0);
            if(this instanceof Bush) {
                Bush young = new Bush(false, field, loc);
                newPlants.add(young);
            }
            else if(this instanceof Acacia) {
                Acacia young = new Acacia(false, field, loc);
                newPlants.add(young);
            }
        }
    }","Check whether or not this plant can spread new plants at this step.
New seeds will be made into free adjacent locations.
@param newPlants A list to return newly born plants.",Plant.java,136.0,3
9,"protected boolean canSpread()
    {
        return getAge() > getSpreadingAge();
    }","A plant can spread if it has reached the spreading age
return True if the plant is old enough to spread",Plant.java,136.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,136.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,136.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,136.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object animal = field.getObjectAt(where);
                //if baboon is found first, eat
                if(animal instanceof Baboon) {
                    Baboon baboon = (Baboon) animal;
                    if(baboon.isAlive()) { 
                        baboon.setDead();
                        setFoodLevel(getBaboonFoodValue());
                        return where;
                    }
                }
                //if gazelle is found first, eat
                else if(animal instanceof Gazelle) {
                    Gazelle gazelle = (Gazelle) animal;
                    if(gazelle.isAlive()) {
                        gazelle.setDead();
                        setFoodLevel(getGazelleFoodValue());
                        return where;
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for baboons and gazelles adjacent to the current location.
Only the first live baboonn or gazelle is eaten.
@return Where food was found, or null if it wasn't.",Leopard.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the leopards
@return breeding age of leopards",Leopard.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the leopards
@return maximum age of leopards",Leopard.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the leopards
@return maximum amount of babies of the leopards",Leopard.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the leopards
@return probability of breeding of the leopards",Leopard.java,136.0,3
0,"public void setInfectedLabel(int number, HashSet<String> infectedSpecies) 
    {
        infectedLabel.setText(INFECTED_PREFIX + number + "" animals, infected species: "" + infectedSpecies);
        if(number == 0) {
            infectedLabel.setText(INFECTED_PREFIX + number + "" animals, infected species: 0"");
        }
    }","Update the infectedLabel
@param number The number of infected animals.
@param infectedSpecies The HashSet of Strings that contains the name of infected species.",SimulatorView.java,136.0,3
1,"public JButton resetButton(Simulator simulator) 
    {
            resetButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) 
                {
                    simulator.reset();
                }
            });
            return resetButton;
    }","When pressed, the resetButton should reset the simulation.
@param simulator The simulator makes the button works in our current simulation.
@return resetButton Returns the resetButton.",SimulatorView.java,136.0,3
2,"public void setColor(Class actorClass, Color color)
    {
        colors.put(actorClass, color);
    }","Define a color to be used for a given class of animal.
@param actorClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,136.0,3
3,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,136.0,3
4,"private Color getColor(Class actorClass)
    {
        Color col = colors.get(actorClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,136.0,3
5,"public void showStatus(int step, String time, Field field, Weather weather)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);

        if(weather.isRaining()) {
            infoLabel.setText(WEATHER_PREFIX + ""Raining"");
        }else if(weather.isSunny()) {
            infoLabel.setText(WEATHER_PREFIX + ""Sunny"");
        }else if(weather.isWindy()) {
            infoLabel.setText(WEATHER_PREFIX + ""Windy"");
        }

        //infoLabel.setText(WEATHER_PREFIX + );
        timeLabel.setText(TIME_PREFIX + time);
        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object actor = field.getObjectAt(row, col);
                if(actor != null) {
                    stats.incrementCount(actor.getClass());
                    fieldView.drawMark(col, row, getColor(actor.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param weather The current weather to be displayed.",SimulatorView.java,136.0,3
6,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,136.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,136.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && populationGenerator.getView().isViable(populationGenerator.getField()); step++) {
            simulateOneStep();
            //reset button is not visible while simulation is running
            populationGenerator.getView().resetButton(this).setVisible(false);
            delay(60);  // uncomment this to run more slowly
        }
        //reset button is visible when simulation ends
        populationGenerator.getView().resetButton(this).setVisible(true);
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,136.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>();

        if(step % 5 == 0) {
            isDay = !isDay;
        }

        if(weatherFirstStep + numberOfDaysForWeather == step) {
            numberOfDaysForWeather = random.nextInt(10) + 1;
            weatherFirstStep = step;
            changeWeather();
        }
        
        infectedStats();
        // Update the infection Label on the screen
        populationGenerator.getView().setInfectedLabel(counterForInfectedSpecies, infectedSpecies);
        // Let all actors act.
        // For example, plants (Bushes and Acacias) acts when is day and it is raining
        for(Iterator<Actor> it = populationGenerator.getActors().iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            if(isDay) {
                if(weather.isRaining()) {
                    if(actor instanceof Plant) {
                        actor.act(newActors);
                    }
                    else if(actor instanceof Animal) {
                        actor.act();
                    }
                }
                else {
                    if(actor instanceof Animal) {
                        actor.act(newActors);
                    }
                    else if(actor instanceof Plant) {
                        actor.act();
                    }
                }
            }
            //night
            else {
                if(weather.isRaining()) {
                    if(actor instanceof Plant || actor instanceof Gazelle || 
                       actor instanceof Zebra || actor instanceof Leopard) {
                        actor.act(newActors);
                    }
                    else if(actor instanceof Lion || actor instanceof Baboon || 
                            actor instanceof Giraffe) {
                        actor.act();
                    }
                }
                else {
                    if(actor instanceof Leopard || actor instanceof Gazelle ||  
                       actor instanceof Giraffe) {
                        actor.act(newActors);
                    }
                    else  {
                        actor.act();
                    }
                }
            }
            if(! actor.isAlive()) {
                it.remove();
            }
        }
        // Add the newly born actors to the main lists.
        populationGenerator.getActors().addAll(newActors);
        //stats for day
        if(isDay) {
            populationGenerator.getView().showStatus(step, ""day"", populationGenerator.getField(), weather);
        }
        //stats for night
        else {
            populationGenerator.getView().showStatus(step, ""night"",populationGenerator.getField(), weather);
        }
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each actor.
Generate a random number steps for weather",Simulator.java,136.0,3
3,"private void changeWeather() 
    {
        double rainy_probability = 0.25;
        double windy_probability = 0.25;
        double sunny_probability = 1.0;

        double randomWeather = random.nextDouble();

        //rainy
        if(randomWeather <=  rainy_probability) {
            weather.setSunny(false);
            weather.setWindy(false);
            weather.setRaining(true);
        }
        //windy
        else if(randomWeather <= windy_probability) {
            weather.setSunny(false);
            weather.setWindy(true);
            weather.setRaining(false);
        }
        //sunny
        else if(randomWeather <= sunny_probability) {
            weather.setSunny(true);
            weather.setWindy(false);
            weather.setRaining(false);
        }
    }","Change the weather randomly
The probability for raining is 25%
The probability for windy is 25%
The probability for sunny is 50%",Simulator.java,136.0,3
4,"public void infectedStats() 
    {
        infectedSpecies.clear();
        counterForInfectedSpecies = 0;
        for(Object i : populationGenerator.getActors()) {
            if( (i instanceof Animal) && ((Animal) i).isInfected() ) {
                infectedSpecies.add(i.getClass().getName());
                counterForInfectedSpecies++;
            }
        }
    }","Update the counterForInfectedSpecies at every step
Update the infectedSpecies HashSet at every step",Simulator.java,136.0,3
5,"public void reset()
    {
        populationGenerator.getActors().clear();
        step = 0;
        populationGenerator.populate();
        infectedStats();
        isDay = random.nextBoolean();
        weatherFirstStep = 0;
        numberOfDaysForWeather = random.nextInt(10) + 10;
        changeWeather();
        populationGenerator.getView().setInfectedLabel(counterForInfectedSpecies, infectedSpecies);
        if(isDay) {
            populationGenerator.getView().showStatus(step, ""day"", populationGenerator.getField(), weather);
        }
        else {
            populationGenerator.getView().showStatus(step, ""night"",populationGenerator.getField(), weather);
        }
        populationGenerator.getView().resetButton(this).setVisible(false);
    }",Reset the simulation to a starting position.,Simulator.java,136.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object plant = field.getObjectAt(where);
                //if bush is found, eat
                if(plant instanceof Bush) {
                    Bush bush = (Bush) plant;
                    if(bush.isAlive()) {
                        bush.setDead();
                        setFoodLevel(getBushFoodValue());
                        return where;
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for bushes adjacent to the current location.
Only the first bush is eaten.
@return Where food was found, or null if it wasn't.",Zebra.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the zebras
@return breeding age of zebras",Zebra.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the zebras
@return maximum age of zebras",Zebra.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the zebras
@return maximum amount of babies of the zebras",Zebra.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the zebras
@return probability of breeding of the zebras",Zebra.java,136.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,136.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,136.0,3
2,"public void incrementCount(Class actorClass)
    {
        Counter count = counters.get(actorClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(actorClass.getName());
            counters.put(actorClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param actorClass The class of animal to increment.",FieldStats.java,136.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,136.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,136.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object actor = field.getObjectAt(row, col);
                if(actor != null) {
                    incrementCount(actor.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,136.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,136.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,136.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,136.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,136.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object plant = field.getObjectAt(where);
                //if tree is found, eat from tree and reduce size
                if(plant instanceof Acacia) {
                    Acacia acacia = (Acacia) plant;
                    if(acacia.isAlive()) {
                        acacia.decreaseSize(5);
                        setFoodLevel(getAcaciaFoodValue());
                        if (acacia.getSize() < 0) {
                            acacia.setDead();
                            return where;
                        }
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for acacia trees adjacent to the current location.
Only the first tree is eaten, but not completely,
reduces its length.
@return Where food was found, or null if it wasn't.",Baboon.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the baboons
@return breeding age of baboons",Baboon.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the baboons
@return maximum age of baboons",Baboon.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the baboons
@return maximum amount of babies of the baboons",Baboon.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the baboons
@return probability of breeding of the baboons",Baboon.java,136.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,136.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,136.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,136.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,136.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,136.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,136.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,136.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,136.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,136.0,3
2,"public void place(Object actor, int row, int col)
    {
        place(actor, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param actor The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,136.0,3
3,"public void place(Object actor, Location location)
    {
        field[location.getRow()][location.getCol()] = actor;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param actor The animal to be placed.
@param location Where to place the animal.",Field.java,136.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,136.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,136.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,136.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,136.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,136.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,136.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,136.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,136.0,3
0,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            if(field.getObjectAt(where) != null) {
                Object animal = field.getObjectAt(where);
                //if zebra is found first, eat
                if(animal instanceof Zebra) {
                    Zebra zebra = (Zebra) animal;
                    if(zebra.isAlive()) {
                        zebra.setDead();
                        setFoodLevel(getZebraFoodValue());
                        return where;
                    }
                }
                //if gazelle is found first, eat
                else if(animal instanceof Gazelle)
                {
                    Gazelle gazelle = (Gazelle) animal;
                    if(gazelle.isAlive()) {
                        gazelle.setDead();
                        setFoodLevel(getGazelleFoodValue());
                        return where;
                    }
                }
                //if baboon is found first, eat
                else if(animal instanceof Baboon)
                {
                    Baboon baboon = (Baboon) animal;
                    if(baboon.isAlive()) {
                        baboon.setDead();
                        setFoodLevel(getBaboonFoodValue());
                        return where;
                    }
                }
            }
        }
        //if food is not found, continue looking
        return null;
    }","Look for baboons, zebras, and gazelles adjacent to the current location.
Only the first live baboon, zebra, or gazelle is eaten.
@return Where food was found, or null if it wasn't.",Lion.java,136.0,3
1,"public int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Get the set breeding age of the lions
@return breeding age of lions",Lion.java,136.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Get the maximum age of the of the lions
@return maximum age of lions",Lion.java,136.0,3
3,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Get the maximum amount of babies of the lions
@return maximum amount of babies of the lions",Lion.java,136.0,3
4,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Get the probability of breeding of the lions
@return probability of breeding of the lions",Lion.java,136.0,3
0,"public boolean isInfected() {
        return isInfected;
    }","Checks if the animal is currently infected

@return true if the animal is infected",Animal.java,136.0,3
1,"public void setInfection() {
        isInfected = true;
        healthLevel = 5;
    }",Makes an animal infected,Animal.java,136.0,3
2,"public void setGendre(boolean isFemale)
    {
        this.isFemale = isFemale;
    }","Makes an animal Female (true)
or Male (false)

@param isFemale if True animal becomes Female",Animal.java,136.0,3
3,"public boolean getGendre()
    {
        return isFemale;
    }","Checks if the animal is a Female

@return true if the animal is female",Animal.java,136.0,3
4,"public boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.

@return true if the animal is still alive.",Animal.java,136.0,3
5,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the animal's death.,Animal.java,136.0,3
6,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Decreases the food level of the animal
making the animal hungry until it dies of hunger",Animal.java,136.0,3
7,"protected void incrementInfection()
    {
        healthLevel--;
        if(healthLevel <= 0) {
            setDead();
        }
    }","Decreases the health level of the animal
once it gets infected, after a few steps,
the animal dies",Animal.java,136.0,3
8,"public void act(List<Actor> newActors)
    {
        act();
        if(isAlive()) 
        {
            //gives probability of birth
            giveBirth(newActors);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the Actors do most of the time: it hunts or reproduces.
In the process, it might breed, die of hunger,
or die of old age.

@param newActors A list to return newly born Actors.",Animal.java,136.0,3
9,"public int getFoodLevel() {
        return foodLevel;
    }","Gets the food level of the animal

@return current food level",Animal.java,136.0,3
10,"protected void setFoodLevel(int foodLevel) {
        this.foodLevel = foodLevel;
    }","sets the food level to a specific value

@param foodLevel sets food value",Animal.java,136.0,3
11,"protected int breed()
    {
        int births = 0;
        if(canBreed() && (rand.nextDouble() <= getBreedingProbability())) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return int The number of births (may be zero).",Animal.java,136.0,3
12,"protected void giveBirth(List<Actor> newAnimals)
    {
        // New animals are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            if(this instanceof Gazelle) {
                Gazelle young = new Gazelle(false, field, loc);
                newAnimals.add(young);
            }
            else if(this instanceof Zebra) {
                Zebra young = new Zebra(false, field, loc);
                newAnimals.add(young);
            }
            else if(this instanceof Baboon) {
                Baboon young = new Baboon(false, field, loc);
                newAnimals.add(young);
            }
            else if(this instanceof Giraffe) {
                Giraffe young = new Giraffe(false, field, loc);
                newAnimals.add(young);
            }
            else if(this instanceof Lion) {
                Lion young = new Lion(false, field, loc);
                newAnimals.add(young);
            }
            else if(this instanceof Leopard) {
                Leopard young = new Leopard(false, field, loc);
                newAnimals.add(young);
            }
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newAnimals A list to return newly born animals.",Animal.java,136.0,3
13,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,136.0,3
14,"public void act() {
        incrementAge();
        incrementHunger();
        if(isInfected()) {
            incrementInfection();
        }
        if(isInfected && isAlive()) {
            doSpreadInfection();
        }
    }","Makes the animals live throughout the simulation
depending on the steps, each time increasing their
age, hunger, or death if sick, old, or hungry

@Override method",Animal.java,136.0,3
15,"protected void doSpreadInfection() {
        // Get a list of adjacent locations.
        Field field = getField();
        List<Location> adjacents = field.adjacentLocations(getLocation());
        for (int b = 0; b < adjacents.size() && adjacents.size() > 0; b++) {
            //Locates neigbours of the same species
            //in adjacent locations and infects them
            Location loc = adjacents.remove(b);
            if(field.getObjectAt(loc) != null) {
                Object object = field.getObjectAt(loc);
                if (object instanceof Animal) {
                    Animal animal = (Animal) object;
                    if( ((animal instanceof Gazelle) && (this instanceof Gazelle)) ||
                    ((animal instanceof Zebra) && (this instanceof Zebra)) ||
                    ((animal instanceof Baboon) && (this instanceof Baboon)) ||
                    ((animal instanceof Giraffe) && (this instanceof Giraffe)) ||
                    ((animal instanceof Lion) && (this instanceof Lion)) ||
                    ((animal instanceof Leopard) && (this instanceof Leopard)) ) {
                        animal.setInfection();
                    }
                }
            }
        }
    }",Spreads the infection of an animal to their neighbouring species,Animal.java,136.0,3
16,"protected boolean canSpreadInfection()
    {
        return isInfected;
    }","Checks if the animal is infected and able to spread to
its neighbours

@return boolean True if animal can infect others",Animal.java,136.0,3
17,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,136.0,3
18,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,136.0,3
19,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,136.0,3
20,"protected void setAge(int age)
    {
        this.age = age;
    }","Set specific age for the animal
@param age preferred age of the animal",Animal.java,136.0,3
21,"protected int getAge() 
    {
        return age;
    }","Get current age of the animal
@return current age of animal",Animal.java,136.0,3
22,"protected boolean canBreed()
    {
        List<Location> adjacentLocations = field.adjacentLocations(getLocation());
        for(Location loc : adjacentLocations) {
            if(field.getObjectAt(loc) != null) {
                Object object = field.getObjectAt(loc);
                if (object instanceof Animal) {
                    Animal animal = (Animal) object;
                    if( ((animal instanceof Gazelle) && (this instanceof Gazelle)) ||
                    ((animal instanceof Zebra) && (this instanceof Zebra)) ||
                    ((animal instanceof Baboon) && (this instanceof Baboon)) ||
                    ((animal instanceof Giraffe) && (this instanceof Giraffe)) ||
                    ((animal instanceof Lion) && (this instanceof Lion)) ||
                    ((animal instanceof Leopard) && (this instanceof Leopard)) ) {
                        if ((getAge() >= getBreedingAge() && animal.getAge() >= animal.getBreedingAge())
                        && ((this.isFemale && !animal.getGendre()) ||
                            (!this.isFemale && animal.getGendre()))) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }","An animal can breed if it has reached the breeding age
return True if the animal is old enough to breed",Animal.java,136.0,3
23,"public static int getBushFoodValue() {
        return BUSH_FOOD_VALUE;
    }","Gets the food value of the bush
@return food value of bush",Animal.java,136.0,3
24,"public static int getAcaciaFoodValue() {
        return ACACIA_FOOD_VALUE;
    }","Gets the food value of the acacia
@return food value of acacia",Animal.java,136.0,3
25,"public static int getZebraFoodValue() {
        return ZEBRA_FOOD_VALUE;
    }","Gets the food value of the zebra
@return food value of zebra",Animal.java,136.0,3
26,"public static int getBaboonFoodValue() {
        return BABOON_FOOD_VALUE;
    }","Gets the food value of the baboon
@return food value of baboon",Animal.java,136.0,3
27,"public static int getGazelleFoodValue() {
        return GAZELLE_FOOD_VALUE;
    }","Gets the food value of the gazelle
@return food value of gazelle",Animal.java,136.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,569.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,569.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,569.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,569.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,569.0,3
0,"public boolean isActive()
    {
        return isAlive();
    }","Whether the shark is active or not.
Returns true if the shark is active.",Shark.java,569.0,3
1,"public void act(List<Actor> newSharks)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSharks);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
           int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }          
    }","This is what the shark does most of the time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSharks A list to return newly born sharks.",Shark.java,569.0,3
2,"public void nightAct(List<Actor> newSharks)
    {
        incrementAge();
        incrementHunger();
    }","This is what the shark does at night.
It still ages and increments hunger.",Shark.java,569.0,3
3,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age of the shark.
@return Shark's maximum age.",Shark.java,569.0,3
4,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Returns the breeding age of the shark.
@return Shark's breeding age.",Shark.java,569.0,3
5,"public double getBreedingProb()
    {
        return BREEDING_PROBABILITY;
    }","Returns the breeding probability of the shark.
@return Shark's breeding probability.",Shark.java,569.0,3
6,"public int getLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the litter size of the shark.
@return Shark's maximum litter size.",Shark.java,569.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if (animal instanceof Seahorse) {
                Seahorse seahorse = (Seahorse) animal;
                if(seahorse.isAlive()) { 
                    seahorse.setDead();
                    setFoodLevel(PREY_FOOD_VALUE);
                    return where;
                }
            }
            else if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    setFoodLevel(PREY_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for fish and seahorse adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Shark.java,569.0,3
8,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }                  
                }
            }
        }       
    }","If the shark is next to an infected animal, disease will spread at a set
probability.",Shark.java,569.0,3
9,"private void giveBirth(List<Actor> newSharks)
    {
        // New sharks are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Shark young = new Shark(false, field, loc, true);
            newSharks.add(young);
        }
    }","Check whether or not this shark is to give birth at this step.
A male and female need to be present within the set radius for this to be possible.
New births will be made into free adjacent locations.
@param newSharks A list to return newly born sharks.",Shark.java,569.0,3
10,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Shark) {
                Shark shark = (Shark) animal;
                boolean gender = shark.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Shark.java,569.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,569.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,569.0,3
0,"public boolean isActive()
    {
        return isAlive();
    }","Whether the whale is active or not.
Returns true if the whale is active.",Whale.java,569.0,3
1,"public void nightAct(List<Actor> newWhales)
    {
        incrementAge();
        incrementHunger();
    }","This is what the whale does at night.
It still ages and increments hunger.",Whale.java,569.0,3
2,"public void act(List<Actor> newWhale)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
                giveBirth(newWhale);            
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                    spreadDisease();
                }
                else {
                    // Overcrowding.
                    setDead();
                }
                
                if (isInfected()){
                    int foodLevel = getFoodLevel();
                    foodLevel = foodLevel-3;
                    setFoodLevel(foodLevel);
                }
        }
    }","This is what the whale does most of the time: it hunts for
seal. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newWhale A list to return newly born whale.",Whale.java,569.0,3
3,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age of the whale.
@return Whale's maximum age.",Whale.java,569.0,3
4,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Returns the breeding age of the whale.
@return Whale's breeding age.",Whale.java,569.0,3
5,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Seal) {
                Seal seal = (Seal) animal;
                if(seal.isAlive()) { 
                    seal.setDead();
                    setFoodLevel(SEAL_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for seal adjacent to the current location.
Only the first live seal is eaten.
@return Where food was found, or null if it wasn't.",Whale.java,569.0,3
6,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    } 
                }
            }
        } 
    }","If the whale is next to an infected animal, disease will spread at a set
probability.",Whale.java,569.0,3
7,"private void giveBirth(List<Actor> newWhales)
    {
        // New whale are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = this.breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Whale young = new Whale(false, field, loc, true);
            
            newWhales.add(young);
        }
    }","Check whether or not this whale is to give birth at this step.
A male and female need to be present within the set radius for this to be possible.
New births will be made into free adjacent locations.
@param newWhales A list to return newly born whale.",Whale.java,569.0,3
8,"public double getBreedingProb()
    {
        return BREEDING_PROBABILITY;
    }","Returns the breeding probability of the whale.
@return Whale's breeding probability.",Whale.java,569.0,3
9,"public int getLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the litter size of the whale.
@return Whale's maximum litter size.",Whale.java,569.0,3
10,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Whale) {
                Whale whale = (Whale) animal;
                boolean gender = whale.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Whale.java,569.0,3
3,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,569.0,3
4,"private Color getColor(Class<?> animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,569.0,3
5,"public void showStatus(int step, Field field, int day,int infection, boolean night)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        days.setText(DAYS_PREFIX + day);
        infections.setText(INFECTIONS_PREFIX + infection);
        
        
        if(night){
            timeOfDay.setText(""Night"");
        }
        else{
            timeOfDay.setText(""Day"");
        }
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    Class<?> cls = animal.getClass();
                    stats.incrementCount(cls);
                    fieldView.drawMark(col, row, getColor(cls));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        //population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        whalePop.setText(""Whale: "" + stats.getPopulationCount(field, Whale.class));
        sharkPop.setText(""Shark: "" + stats.getPopulationCount(field, Shark.class));
        sealPop.setText(""Seal: "" + stats.getPopulationCount(field, Seal.class));
        seahorsePop.setText(""Seahorse: "" + stats.getPopulationCount(field, Seahorse.class));
        algaePop.setText(""Algae: "" + stats.getPopulationCount(field, Algae.class));
        fishPop.setText(""Fish: "" + stats.getPopulationCount(field, Fish.class));
        
        
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param day How many days have passed.
@param night If it is daytime or nighttime.",GridView.java,569.0,3
6,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,569.0,3
7,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,569.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,569.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,569.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,569.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,569.0,3
0,"public void runLongSimulation()
    {
        simulate(2000);
    }","Run the simulation from its current state for a reasonably long period,
(2000 steps).",Simulator.java,569.0,3
1,"private void timeOfDay()
    {
        if(dayStep<HOURS){
            dayStep++;
        }
        else{
            dayStep= 1;
            numberOfDays++;
        }
        
        if (dayStep<=12){
            night = false;
        }
        else{
            night = true;
        }

    }","Keeps track of the time of day. Each step is a period of 1 hour.
Daytime and nighttime each last 12 hours.",Simulator.java,569.0,3
2,"private boolean getTimeOfDay()
    {
        return night;
    }","Returns whether it is night as a boolean value.
@return night If it is night time.",Simulator.java,569.0,3
3,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            delay(0);   
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,569.0,3
4,"public void simulateOneStep()
    {
        step++;
        timeOfDay();
        // Provide space for newborn animals.
        List<Actor> newActors = new ArrayList<>();
        List<Animal> newInfections = new ArrayList<>();
        List<Animal> newDeadInfections = new ArrayList<>();
       
        // Let all animals act.
       
        if (night == false){
            for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
                Actor actor = it.next();
                actor.act(newActors);
                if (actor instanceof Animal){
                   Animal a;
                   a= (Animal) actor;
                   
                   if(! a.isActive() && a.isInfected()){
                        newDeadInfections.add(a);
                    }
                    else if(a.isActive() && a.isInfected()){
                        newInfections.add(a);
                    } 
                }
                
                 if(! actor.isActive()) {
                    it.remove();
                }
                
            }
        }
        else{
            for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
                Actor actor = it.next();
                actor.nightAct(newActors);
                if (actor instanceof Animal){
                   Animal a;
                   a= (Animal) actor;
                   if(! a.isActive() && a.isInfected()){
                        newDeadInfections.add(a);
                    }
                    else if(a.isActive() && a.isInfected()){
                        newInfections.add(a);
                    }   
                } 
                
                if(! actor.isActive()) {
                     it.remove();
                }
            }          
        }
       
        //Calculates the current infections in the habitat.
        infections.addAll(newInfections);
        infections.removeAll(newDeadInfections);
        numberOfInfections = infections.size();
             
        // Add the newly born sharks,fish,algae,seals and whales to the main lists.
        actors.addAll(newActors);

        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal.",Simulator.java,569.0,3
5,"public void reset()
    {
        step = 0;
        dayStep = 0;
        numberOfDays = 0;
        numberOfInfections = 0;
        actors.clear();
        infections.clear();
        for (SimulatorView view : views) {
            view.reset();
        }

        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,569.0,3
6,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(step, field, numberOfDays, numberOfInfections , night);
        }
    }",Update all existing views.,Simulator.java,569.0,3
7,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SHARK_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shark shark = new Shark(true, field, location, true);
                    actors.add(shark);
                }
                else if(rand.nextDouble() <= FISH_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fish fish = new Fish(true, field, location, true);
                    actors.add(fish);
                }
                else if(rand.nextDouble() <= SEAL_CREATION_PROBABILITY) {
                    Location location = new Location (row, col);
                    Seal seal = new Seal(true, field, location, true);
                    actors.add(seal);
                }
                else if(rand.nextDouble() <= WHALE_CREATION_PROBABILITY) {
                    Location location = new Location (row, col);
                    Whale whale = new Whale(true, field, location, true);
                    actors.add(whale);
                }
                else if(rand.nextDouble() <=SEAHORSE_CREATION_PROBABILITY){
                    Location location = new Location (row, col);
                    Seahorse seahorse = new Seahorse(true, field, location, true);
                    actors.add(seahorse);
                }
                else if(rand.nextDouble() <=ALGAE_CREATION_PROBABILITY){
                    Location location = new Location (row, col);
                    Algae algae = new Algae(field, location);
                    actors.add(algae);
                }
                // else leave the location empty.
            }
        }
        
        for(Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            if (actor instanceof Animal){
                 Animal a;
                 a= (Animal) actor;
                   
                if(rand.nextDouble() <= INFECTION_PROBABILITY){
                    a.setDisease();
                    infections.add(a);
                    numberOfInfections = infections.size();
                }
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,569.0,3
8,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,569.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,569.0,3
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,569.0,3
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,569.0,3
3,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,569.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,569.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,569.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of animals.
These are not kept up to date as the animals
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,569.0,3
0,"public boolean isActive()
    {
        return isAlive();
    }","Whether the fish is active or not.
Returns true if the fish is active.",Fish.java,569.0,3
1,"public void act(List<Actor> newFish)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFish);            
            // Try to move to a food source.
            Location newLocation = findFood();
            if(newLocation == null){
                //No food is found therefore try to move to a free location
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            //See if it is possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }
    }","This is what the fish does most of the time - it looks for algae and
runs around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born fish.",Fish.java,569.0,3
2,"public void nightAct(List<Actor> newFish)
    {
        incrementAge();
        incrementHunger();
    }","This is what the fish does at night.
It still ages and increments hunger.",Fish.java,569.0,3
3,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age of the fish.
@return Fish's maximum age.",Fish.java,569.0,3
4,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Returns the breeding age of the fish.
@return Fish's breeding age.",Fish.java,569.0,3
5,"public double getBreedingProb()
    {
        return BREEDING_PROBABILITY;
    }","Returns the breeding probability of the fish.
@return Fish's breeding probability.",Fish.java,569.0,3
6,"public int getLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the litter size of the fish.
@return Fish's maximum litter size.",Fish.java,569.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Algae) {
                Algae algae = (Algae) plant;
                if(algae.isActive()) { 
                    algae.setDead();
                    setFoodLevel(ALGAE_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for algae adjacent to the current location.
Only the first live algae is eaten.
@return Where food was found, or null if it wasn't.",Fish.java,569.0,3
8,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                }
            }
        }
    }","If the fish is next to an infected animal, disease will spread at a set
probability.",Fish.java,569.0,3
9,"private void giveBirth(List<Actor> newFish)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fish young = new Fish(false, field, loc, true);
            newFish.add(young);
        }
    }","Check whether or not this fish is ready to give birth at this step.
A male and female need to be present within the set radius for this to be possible.
New births will be made into free adjacent locations.
@param newFish A list to return newly born fish.",Fish.java,569.0,3
10,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                boolean gender = fish.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Fish.java,569.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,569.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,569.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,569.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,569.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,569.0,3
0,"public boolean isActive()
    {
        return isAlive();
    }","Whether the seal is active or not.
Returns true if the seal is active.",Seal.java,569.0,3
1,"public void act(List<Actor> newSeal)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeal);           
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }           
    }","This is what the seal does most of the time - it swims
around and hunts for fish. Sometimes it will breed or die of old age.
@param newFish A list to return newly born seal.
@param field The field currently occupied",Seal.java,569.0,3
2,"public void nightAct(List<Actor> newSeals)
    {
        incrementAge();
        incrementHunger();
    }","This is what the seal does at night.
It still ages and increments hunger.",Seal.java,569.0,3
3,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age of the seal.
@return Seal's maximum age.",Seal.java,569.0,3
4,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Returns the breeding age of the seal.
@return Seal's breeding age.",Seal.java,569.0,3
5,"public double getBreedingProb()
    {
        return BREEDING_PROBABILITY;
    }","Returns the breeding probability of the seal.
@return Seal's breeding probability.",Seal.java,569.0,3
6,"public int getLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the litter size of the seal.
@return Seal's maximum litter size.",Seal.java,569.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    setFoodLevel(FISH_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Seal.java,569.0,3
8,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    } 
                }
            }
        } 
    }","If the seal is next to an infected animal, disease will spread at a set
probability.",Seal.java,569.0,3
9,"private void giveBirth(List<Actor> newSeal)
    {
        // New seal are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seal young = new Seal(false, field, loc, true);
            newSeal.add(young);
        }
    }","Check whether or not this seal is ready to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born seal.",Seal.java,569.0,3
10,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Seal) {
                Seal seal = (Seal) animal;
                boolean gender = seal.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Seal.java,569.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,569.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,569.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,569.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,569.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,569.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,569.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,569.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,569.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,569.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,569.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,569.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,569.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,569.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,569.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,569.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,569.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,569.0,3
10,"public List<Location> radiusLocations(Location location, int radius)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= radius; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= radius; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations within a set radius to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate radius locations.
@return A list of locations within a radius to that given.",Field.java,569.0,3
11,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,569.0,3
12,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,569.0,3
0,"public boolean isActive()
    {
        return isAlive();
    }","Whether the seahorse is active or not.
Returns true if the seahorse is active.",Seahorse.java,569.0,3
1,"public void act(List<Actor> newSeahorse)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeahorse);            
            // Try to move to a food source.
            Location newLocation = findFood();
            if(newLocation == null){
                //No food is found therefore try to move to a free location
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            //See if it is possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }           
    }","This is what the seahorse does most of the time - it looks for algae and
runs around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born seahorse.",Seahorse.java,569.0,3
2,"public void nightAct(List<Actor> newSeahorse)
    {
        incrementAge();
        incrementHunger();
    }","This is what the seahorse does at night.
It still ages and increments hunger.",Seahorse.java,569.0,3
3,"public int getMaxAge(){
        return MAX_AGE;
    }","Returns the maximum age of the seahorse.
@return Seahorse's maximum age.",Seahorse.java,569.0,3
4,"public int getBreedingAge(){
        return BREEDING_AGE;
    }","Returns the breeding age of the seahorse.
@return Seahorse's breeding age.",Seahorse.java,569.0,3
5,"public double getBreedingProb()
    {
        return BREEDING_PROBABILITY;
    }","Returns the breeding probability of the seahorse.
@return Seahorse's breeding probability.",Seahorse.java,569.0,3
6,"public int getLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Returns the litter size of the seahorse.
@return Seahorse's maximum litter size.",Seahorse.java,569.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isActive()) { 
                    algae.setDead();
                    setFoodLevel(ALGAE_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for algae adjacent to the current location.
Only the first live algae is eaten.
@return Where food was found, or null if it wasn't.",Seahorse.java,569.0,3
8,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                }
            }
        }
    }","If the seahorse is next to an infected animal, disease will spread at a set
probability.",Seahorse.java,569.0,3
9,"private void giveBirth(List<Actor> newSeahorse)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seahorse young = new Seahorse(false, field, loc, true);
            newSeahorse.add(young);
        }
    }","Check whether or not this seahorse is ready to give birth at this step.
New births will be made into free adjacent locations.
@param newSeahorse A list to return newly born seahorse.",Seahorse.java,569.0,3
10,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Seahorse) {
                Seahorse seahorse = (Seahorse) animal;
                boolean gender = seahorse.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Seahorse.java,569.0,3
0,"protected void setAge(int nAge){
        age = nAge;
    }","Sets the age of the Animal
@param nAge The new age of the animal",Animal.java,569.0,3
1,"protected int getAge(){
        return age;
    }","Returns the current age of the animal
@return the age of the animal",Animal.java,569.0,3
2,"protected void setFoodLevel(int nFoodLevel){
        foodLevel = nFoodLevel;
    }","Sets the food level of the animal
@param nFoodLevel The new food level of the animal",Animal.java,569.0,3
3,"protected int getFoodLevel(){
        return foodLevel;
    }","Returns the current food level of the animal
@return The food level of the animal",Animal.java,569.0,3
4,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the animal's death.,Animal.java,569.0,3
5,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this animal more hungry. This could result in the animal's death.,Animal.java,569.0,3
6,"public boolean canBreed()
    {
        boolean canbreed= false;
        if (isFemale()){
            if (age >= getBreedingAge()){
                if (getFoodLevel() >= 33){
                    if (checkMate()){
                        canbreed = true;
                    }
                }
            }
        }
        return canbreed;
    }","Checks whether or not the animal meets the conditions to be able to breed
An animal can only breed if their age is greater than the breeding age, if
it's food level is above a certain value and if there is a mate within its
breeding radius.
@return true if the animal can breed",Animal.java,569.0,3
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProb()) {
            births = rand.nextInt(getLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,569.0,3
8,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,569.0,3
9,"protected boolean isFemale()
    {
        return isFemale;
    }","Check whether the animal is female or not.
@return true if the animal is a female.",Animal.java,569.0,3
10,"protected boolean isInfected()
    {
        return isInfected;
    }","Check whether the animal has a disease.
@return true if the animal is diseased.",Animal.java,569.0,3
11,"protected void setDisease()
    {
        isInfected = true;
    }",Indicate that the animal has a disease.,Animal.java,569.0,3
12,"protected void setMale()
    {
        isFemale = false;
    }",Indicate that the animal is a male.,Animal.java,569.0,3
13,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,569.0,3
14,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,569.0,3
15,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,569.0,3
16,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,569.0,3
0,"public void act(List<Actor> newAlgae)
    {
        incrementAge();
        if(isActive()) {
            giveBirth(newAlgae);            
        }
    }","This is what the algae does most of the time - it does not move. Sometimes it will breed or die of old age.
@param newFish A list to return newly born algae.",Algae.java,569.0,3
1,"public void nightAct(List<Actor> newAlgae)
    {
        incrementAge();
    }","What the algae does at night
@param newAlgae A list to receive newly born algae.",Algae.java,569.0,3
2,"public boolean isActive()
    {
       return alive; 
    }","Whether the algae is active or not.
Returns true if the algae is active.",Algae.java,569.0,3
3,"public void setDead()
    {
       alive = false;
       if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }",Set the algae to dead.,Algae.java,569.0,3
4,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the algae's death.,Algae.java,569.0,3
6,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Algae.java,569.0,3
7,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Algae.java,569.0,3
8,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Algae.java,569.0,3
9,"private void giveBirth(List<Actor> newAlgae)
    {
        // New algae are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = reproduce();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Algae young = new Algae(field, loc);
            newAlgae.add(young);
        }
    }","Check whether or not this algae is ready to undergo reproduction at this step.
New births will be made into free adjacent locations.
@param newAlgae A list to return newly born algae.",Algae.java,569.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
        classes = colors.keySet();
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GraphView.java,569.0,3
1,"public void showStatus(int step, Field field, int days,int infections, boolean night)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GraphView.java,569.0,3
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GraphView.java,569.0,3
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GraphView.java,569.0,3
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        JPanel bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel("" "");
        bottom.add(countLabel);
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,GraphView.java,569.0,3
0,"public void act(List<Animal> newSharks)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
            giveBirth(newSharks);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
           int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }          
    }","This is what the shark does most of the time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSharks A list to return newly born sharks.",Shark.java,569.0,3
1,"public void nightAct(List<Animal> newSharks)
    {
        incrementAge();
        incrementHunger();
    }","This is what the animal does at night.
It still ages and increments hunger.",Shark.java,569.0,3
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if (animal instanceof Seahorse) {
                Seahorse seahorse = (Seahorse) animal;
                if(seahorse.isAlive()) { 
                    seahorse.setDead();
                    setFoodLevel(PREY_FOOD_VALUE);
                    return where;
                }
            }
            else if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    setFoodLevel(PREY_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Shark.java,569.0,3
7,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }                  
                }
            }
        }       
    }","If the animal is next to an infected animal, disease will spread at a set
probability.",Shark.java,569.0,3
8,"private void giveBirth(List<Animal> newSharks)
    {
        // New sharks are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Shark young = new Shark(false, field, loc, true);
            newSharks.add(young);
        }
    }","Check whether or not this shark is to give birth at this step.
A male and female need to be present within the set radius for this to be possible.
New births will be made into free adjacent locations.
@param newSharks A list to return newly born sharks.",Shark.java,569.0,3
9,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Shark) {
                Shark shark = (Shark) animal;
                boolean gender = shark.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Shark.java,569.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,569.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,569.0,3
0,"public void nightAct(List<Animal> newWhales)
    {
        incrementAge();
        incrementHunger();
    }","This is what the animal does at night.
It still ages and increments hunger.",Whale.java,569.0,3
1,"public void act(List<Animal> newWhale)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
                giveBirth(newWhale);            
                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                    spreadDisease();
                }
                else {
                    // Overcrowding.
                    setDead();
                }
                
                if (isInfected()){
                    int foodLevel = getFoodLevel();
                    foodLevel = foodLevel-3;
                    setFoodLevel(foodLevel);
                }
            
        }
        
        
    }","This is what the whale does most of the time: it hunts for
seal. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSharks A list to return newly born whale.",Whale.java,569.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Seal) {
                Seal seal = (Seal) animal;
                if(seal.isAlive()) { 
                    seal.setDead();
                    foodLevel = SEAL_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for seal adjacent to the current location.
Only the first live seal is eaten.
@return Where food was found, or null if it wasn't.",Whale.java,569.0,3
5,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                    
                }
            }
        }
        
    }","If the animal is next to an infected animal, disease will spread at a set
probability.",Whale.java,569.0,3
6,"private void giveBirth(List<Animal> newWhales)
    {
        // New whale are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = this.breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Whale young = new Whale(false, field, loc, true);
            
            newWhales.add(young);
        }
    }","Check whether or not this whale is to give birth at this step.
A male and female need to be present within the set radius for this to be possible.
New births will be made into free adjacent locations.
@param newWhales A list to return newly born whale.",Whale.java,569.0,3
9,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Whale) {
                Whale whale = (Whale) animal;
                boolean gender = whale.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Whale.java,569.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,569.0,3
1,"private Color getColor(Class<?> animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,569.0,3
2,"public void showStatus(int step, Field field, int day,int infection, boolean night)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        days.setText(DAYS_PREFIX + day);
        infections.setText(INFECTIONS_PREFIX + infection);
        
        
        if(night){
            timeOfDay.setText(""Night"");
        }
        else{
            timeOfDay.setText(""Day"");
        }
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    Class<?> cls = animal.getClass();
                    stats.incrementCount(cls);
                    fieldView.drawMark(col, row, getColor(cls));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.
@param day How many days have passed.
@param night If it is daytime or nighttime.",GridView.java,569.0,3
3,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,569.0,3
4,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,569.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,569.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,569.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,569.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,569.0,3
0,"public void runLongSimulation()
    {
        simulate(300);
    }","Run the simulation from its current state for a reasonably long period,
(2000 steps).",Simulator.java,569.0,3
1,"private void timeOfDay()
    {
        if(dayStep<HOURS){
            dayStep++;
        }
        else{
            dayStep= 1;
            numberOfDays++;
        }
        
        if (dayStep<=12){
            night = false;
        }
        else{
            night = true;
        }

    }","Keeps track of the time of day. Each step is a period of 1 hour.
Daytime and nighttime each last 12 hours.",Simulator.java,569.0,3
2,"private boolean getTimeOfDay()
    {
        return night;
    }","Returns whether it is night as a boolean value.
@return night If it is night time.",Simulator.java,569.0,3
3,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            delay(30);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,569.0,3
4,"public void simulateOneStep()
    {
        step++;
        timeOfDay();
        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();
        List<Animal> newInfections = new ArrayList<>();
        List<Animal> newDeadInfections = new ArrayList<>();
       
        // Let all animals act.
       
        if (night == false){
            for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.act(newAnimals);
                if(! animal.isAlive() && animal.isInfected()){
                    newDeadInfections.add(animal);
                }
                else if(animal.isAlive() && animal.isInfected()){
                    newInfections.add(animal);
                }
               
                if(! animal.isAlive()) {
                    it.remove();
                }
            }
        }
        else{
            for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.nightAct(newAnimals);
                if(! animal.isAlive() && animal.isInfected()){
                    newDeadInfections.add(animal);
                }
                else if(animal.isAlive() && animal.isInfected()){
                    newInfections.add(animal);
                }
               
                if(! animal.isAlive()) {
                    it.remove();
                }
            }          
        }
       
        //Calculates the current infections in the habitat.
        infections.addAll(newInfections);
        infections.removeAll(newDeadInfections);
        numberOfInfections = infections.size();
             
        // Add the newly born sharks,fish,algae,seals and whales to the main lists.
        animals.addAll(newAnimals);

        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal.",Simulator.java,569.0,3
5,"public void reset()
    {
        step = 0;
        dayStep = 0;
        numberOfDays = 0;
        numberOfInfections = 0;
        animals.clear();
        infections.clear();
        for (SimulatorView view : views) {
            view.reset();
        }

        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,569.0,3
6,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(step, field, numberOfDays, numberOfInfections , night);
        }
    }",Update all existing views.,Simulator.java,569.0,3
7,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SHARK_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shark shark = new Shark(true, field, location, true);
                    animals.add(shark);
                }
                else if(rand.nextDouble() <= FISH_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fish fish = new Fish(true, field, location, true);
                    animals.add(fish);
                }
                else if(rand.nextDouble() <= SEAL_CREATION_PROBABILITY) {
                    Location location = new Location (row, col);
                    Seal seal = new Seal(true, field, location, true);
                    animals.add(seal);
                }
                else if(rand.nextDouble() <= WHALE_CREATION_PROBABILITY) {
                    Location location = new Location (row, col);
                    Whale whale = new Whale(true, field, location, true);
                    animals.add(whale);
                }
                else if(rand.nextDouble() <=SEAHORSE_CREATION_PROBABILITY){
                    Location location = new Location (row, col);
                    Seahorse seahorse = new Seahorse(true, field, location, true);
                    animals.add(seahorse);
                }
                else if(rand.nextDouble() <=ALGAE_CREATION_PROBABILITY){
                    Location location = new Location (row, col);
                    Algae algae = new Algae(true, field, location);
                    animals.add(algae);
                }
                // else leave the location empty.
            }
        }
        
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            if(rand.nextDouble() <= INFECTION_PROBABILITY){
                animal.setDisease();
                infections.add(animal);
                numberOfInfections = infections.size();
            }
        }
    }",Randomly populate the field with foxes and rabbits.,Simulator.java,569.0,3
8,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,569.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,569.0,3
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,569.0,3
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,569.0,3
3,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,569.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,569.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,569.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of animals.
These are not kept up to date as the animals
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,569.0,3
0,"public void act(List<Animal> newFish)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFish);            
            // Try to move to a food source.
            Location newLocation = findFood();
            if(newLocation == null){
                //No food is found therefore try to move to a free location
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            //See if it is possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }
    }","This is what the fish does most of the time - it looks for algae and
runs around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born fish.",Fish.java,569.0,3
1,"public void nightAct(List<Animal> newFish)
    {
        incrementAge();
        incrementHunger();
    }","This is what the animal does at night.
It still ages and increments hunger.",Fish.java,569.0,3
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.setDead();
                    setFoodLevel(ALGAE_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for algae adjacent to the current location.
Only the first live algae is eaten.
@return Where food was found, or null if it wasn't.",Fish.java,569.0,3
7,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                }
            }
        }

    }","If the animal is next to an infected animal, disease will spread at a set
probability.",Fish.java,569.0,3
8,"private void giveBirth(List<Animal> newFish)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fish young = new Fish(false, field, loc, true);
            newFish.add(young);
        }
    }","Check whether or not this fish is ready to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born fish.",Fish.java,569.0,3
9,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                boolean gender = fish.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Fish.java,569.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,569.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,569.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,569.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,569.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,569.0,3
0,"public void act(List<Animal> newSeal)
    {
        incrementAge();
        incrementHunger();
        
        if(isAlive()) {
            giveBirth(newSeal);           
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // Try to move into a free location.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }           
    }","This is what the seal does most of the time - it swims
around and hunts for fish. Sometimes it will breed or die of old age.
@param newFish A list to return newly born seal.
@param field The field currently occupied",Seal.java,569.0,3
1,"public void nightAct(List<Animal> newSeals)
    {
        incrementAge();
        incrementHunger();
    }","This is what the animal does at night.
It still ages and increments hunger.",Seal.java,569.0,3
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    setFoodLevel(FISH_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Seal.java,569.0,3
7,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                    
                }
            }
        }
        
    }","If the animal is next to an infected animal, disease will spread at a set
probability.",Seal.java,569.0,3
8,"private void giveBirth(List<Animal> newSeal)
    {
        // New seal are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seal young = new Seal(false, field, loc, true);
            newSeal.add(young);
        }
    }","Check whether or not this seal is ready to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born seal.",Seal.java,569.0,3
9,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Seal) {
                Seal seal = (Seal) animal;
                boolean gender = seal.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Seal.java,569.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,569.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,569.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,569.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,569.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,569.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,569.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,569.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,569.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,569.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,569.0,3
10,"public List<Location> radiusLocations(Location location, int radius)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= radius; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= radius; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations within a set radius to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate radius locations.
@return A list of locations within a radius to that given.",Field.java,569.0,3
11,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,569.0,3
12,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,569.0,3
0,"public void act(List<Animal> newSeahorse)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeahorse);            
            // Try to move to a food source.
            Location newLocation = findFood();
            if(newLocation == null){
                //No food is found therefore try to move to a free location
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            //See if it is possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
                spreadDisease();
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
        
        if (isInfected()){
            int foodLevel = getFoodLevel();
            foodLevel = foodLevel-3;
            setFoodLevel(foodLevel);
        }           
    }","This is what the seahorse does most of the time - it looks for algae and
runs around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born seahorse.",Seahorse.java,569.0,3
1,"public void nightAct(List<Animal> newSeahorse)
    {
        incrementAge();
        incrementHunger();
    }","This is what the animal does at night.
It still ages and increments hunger.",Seahorse.java,569.0,3
6,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.setDead();
                    setFoodLevel(ALGAE_FOOD_VALUE);
                    return where;
                }
            }
        }
        return null;
    }","Look for algae adjacent to the current location.
Only the first live algae is eaten.
@return Where food was found, or null if it wasn't.",Seahorse.java,569.0,3
7,"private void spreadDisease()
    {
        if(this.isInfected()){
            Field field = getField();
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object animal = field.getObjectAt(where);
                if(animal instanceof Animal) {
                   Animal targetAnimal = (Animal) animal;
                   if(!targetAnimal.isInfected() && rand.nextDouble() <= SPREADING_PROBABILITY){
                       targetAnimal.setDisease();
                    }
                }
            }
        }

    }","If the animal is next to an infected animal, disease will spread at a set
probability.",Seahorse.java,569.0,3
8,"private void giveBirth(List<Animal> newSeahorse)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seahorse young = new Seahorse(false, field, loc, true);
            newSeahorse.add(young);
        }
    }","Check whether or not this seahorse is ready to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born seahorse.",Seahorse.java,569.0,3
9,"protected boolean checkMate()
    {
        Field field = getField();
        List<Location> radius = field.radiusLocations(getLocation(),BREEDING_RADIUS);
        Iterator<Location> it = radius.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            boolean thisGender = this.isFemale();
            if(animal instanceof Seahorse) {
                Seahorse seahorse = (Seahorse) animal;
                boolean gender = seahorse.isFemale();
                if (thisGender!= gender){
                    return true;
                }
            }
        }
        return false;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Seahorse.java,569.0,3
4,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the whale's death.,Animal.java,569.0,3
5,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this seal more hungry. This could result in the seal's death.,Animal.java,569.0,3
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProb()) {
            births = rand.nextInt(getLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,569.0,3
8,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,569.0,3
9,"protected boolean isFemale()
    {
        return isFemale;
    }","Check whether the animal is female or not.
@return true if the animal is a female.",Animal.java,569.0,3
10,"protected boolean isInfected()
    {
        return isInfected;
    }","Check whether the animal has a disease.
@return true if the animal is diseased.",Animal.java,569.0,3
11,"protected void setDisease()
    {
        isInfected = true;
    }",Indicate that the animal has a disease.,Animal.java,569.0,3
12,"protected void setMale()
    {
        isFemale = false;
    }",Indicate that the animal is a male.,Animal.java,569.0,3
13,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,569.0,3
14,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,569.0,3
15,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,569.0,3
16,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,569.0,3
0,"public void act(List<Animal> newAlgae)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newAlgae);            
        }
    }","This is what the algae does most of the time - it does not move. Sometimes it will breed or die of old age.
@param newFish A list to return newly born algae.",Algae.java,569.0,3
6,"protected boolean checkMate()
    {
        return true;
    }","Look for the opposite sex adjacent to the current location.
First mate found will be chosen.
@return If mate was found, or false if it wasn't.",Algae.java,569.0,3
7,"private void giveBirth(List<Animal> newAlgae)
    {
        // New algae are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Algae young = new Algae(false, field, loc);
            newAlgae.add(young);
        }
    }","Check whether or not this algae is ready to undergo reproduction at this step.
New births will be made into free adjacent locations.
@param newAlgae A list to return newly born algae.",Algae.java,569.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,379.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,379.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,379.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,379.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,379.0,3
0,"protected void reproduce(List<Plant> newPlants)
    {
        Field field = getField();
        List<Location> free = field.getFreeSurroundingLocations(getLocation(), 2); 

        int births = seed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Castor seedling = new Castor(false, field, loc);
            newPlants.add(seedling);
        }
    }","Produce new castor plants when it is mature. The new
castor plants are made into free surrounding locations.
@param newPlants A list to return new plants.",Castor.java,379.0,3
1,"protected int getMaxSeedNum()
    {
        return MAX_SEED_NUMBER;
    }","Return the maximum number of seeds a castor plant can produce.
@return the castor plant's maximum seed number.",Castor.java,379.0,3
2,"protected double getDefaultReproductionProbability()
    {
        return REPRODUCTION_PROBABILITY;
    }","Return the likelihood of a castor plant reproducing when
it is not affected by external factors.
@return The castor plant's default reproduction probability.",Castor.java,379.0,3
3,"protected double getGrowthRate()
    {
        return GROWTH_RATE;
    }","Return the castor plant's growth rate.
@return The castor plant's growth rate.",Castor.java,379.0,3
4,"protected int getWhenMature()
    {
        return WHEN_MATURE;
    }","Return the castor plant's growth when it is considered mature.
@return The castor plant's mature growth.",Castor.java,379.0,3
5,"protected double getSurvivalRate()
    {
        return SURVIVAL_RATE;
    }","Return the survival rate of the castor plant when competing
for resources with other plants.
@return The castor plant's survival rate.",Castor.java,379.0,3
6,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the food value of the castor bean when it is eaten.
@return The castor plant's food value.",Castor.java,379.0,3
7,"public boolean getIsPoisonous()
    {
        return IS_POISONOUS;
    }","Check if the castor bean is poisonous.
@return true if the castor plant is poisonous, otherwise,
return false.",Castor.java,379.0,3
0,"protected void giveBirth(List<Animal> newRats, Object animal)
    {
        if (animal instanceof Rat) {
            Rat rat = (Rat) animal;
            if (!rat.getIsFemale()) {
                // New rats are born into surrounding locations.
                // Get a list of free surrounding locations.
                Field field = rat.getField();
                List<Location> free = field.getFreeSurroundingLocations(getLocation(),2);

                int births = breed();
                for(int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    boolean isFemale = chooseGender();
                    Rat young = new Rat(false, isFemale, field, loc);
                    newRats.add(young);
                }
            }
        }
    }","Check whether the given animal is a male rat.
If so, then give birth to a random number of offsprings
in the free locations surrounding it, if there are any.
@param newRats A list to add all the new offspring.
@param animal An animal that could be a male rat.",Rat.java,379.0,3
1,"protected Location checkFood(Object plant, Location where, String weather)
    {
        if(plant instanceof Grass) {
            Grass grass = (Grass) plant;
            if(grass.isAlive()) { 
                grass.setDead();
                changeEnergyLevel(grass.getFoodValue());
                return where;
            }
        } else if(plant instanceof Berry) {
            Berry berry = (Berry) plant;
            if(berry.isAlive()) { 
                berry.setDead();
                changeEnergyLevel(berry.getFoodValue());
                return where;
            }
        } else if(plant instanceof Castor) {
            Castor castor = (Castor) plant;
            if(castor.isAlive()) { 
                castor.setDead();
                changeEnergyLevel(castor.getFoodValue());
                infected();
                return where;
            }
        }
        
        return null;
    }","If one of the plants around it is of its food source,
then eat it and return the location of the plant
that was eaten.
@param plant The plant which the rat might eat.
@param where The location of the plant to be eaten.
@param weather The weather of the simulation.
@return The location of plant that was eaten.",Rat.java,379.0,3
2,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the rat's breeding age.
@return rat's breeding age.",Rat.java,379.0,3
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the rat's breeding probability.
@return rat's breeding probability.",Rat.java,379.0,3
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the rat's maximum litter size.
@return rat's maximum litter size.",Rat.java,379.0,3
5,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the energy derived from the rat when eaten.
@return the energy value derived from eating the rat.",Rat.java,379.0,3
6,"protected int getHungry()
    {
        return HUNGRY;
    }","Return the energy level at which the rat will start
to find food.
@return the energy level when the rat will start to
find food.",Rat.java,379.0,3
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the maximum age that a rat can live up to.
@return The rat's maximum age.",Rat.java,379.0,3
8,"protected boolean getCanSleep()
    {
        return CAN_SLEEP;
    }","Return true if the rat sleeps at nighttime.
@return true if the rat sleeps at night, false otherwise.",Rat.java,379.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,379.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,379.0,3
0,"protected void giveBirth(List<Animal> newSnakes, Object animal)
    {
        if (animal instanceof Snake) {
            Snake snake = (Snake) animal;
            if (!snake.getIsFemale()) {
                // New snakes are born into surrounding locations.
                // Get a list of free surrounding locations.
                Field field = snake.getField();
                List<Location> free = field.getFreeSurroundingLocations(getLocation(), 2);
                int births = breed();
                for(int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    boolean isFemale = chooseGender();
                    Snake young = new Snake(false, isFemale, field, loc);
                    newSnakes.add(young);
                }
            }
        }
    }","Check whether the given animal is a male snake.
If so, then give birth to a random number of offsprings
in the free locations surrounding it, if there are any.
@param newSnakes A list to add all the new offspring.
@param animal An animal that could be a male snake.",Snake.java,379.0,3
1,"protected Location checkFood(Object animal, Location where, String weather)
    {
        if(!weather.equals(""Foggy"")) {
            if(animal instanceof Capybara) {
                Capybara capybara = (Capybara) animal;
                if(capybara.isAlive()) { 
                    capybara.setDead();
                    changeEnergyLevel(capybara.getFoodValue());
                    return where;
                }
            }else if(animal instanceof Rat) {
                Rat rat = (Rat) animal;
                if(rat.isAlive()) { 
                    rat.setDead();
                    changeEnergyLevel(rat.getFoodValue());
                    if(rat.getIsInfected()) {
                        infected();
                    }
                    return where;
                }
            }
        }
        
        return null;
    }","If the weather is not foggy and one of the animals
around it is of its preys, then eat it and return
the location of the animal that was eaten.
@param object The animal that might be eaten.
@param where The location of the animal to be eaten.
@param weather The weather of the simulation.
@return The location of the animal that was eaten.",Snake.java,379.0,3
2,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the snake's breeding age.
@return snake's breeding age.",Snake.java,379.0,3
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the snake's breeding probability.
@return snake's breeding probability.",Snake.java,379.0,3
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the snake's maximum litter size.
@return snake's maximum litter size.",Snake.java,379.0,3
5,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the energy derived from the snake when eaten.
@return the energy value derived from eating the snake.",Snake.java,379.0,3
6,"protected int getHungry()
    {
        return HUNGRY;
    }","Return the energy level at which the snake will start
to find food.
@return the energy level when the snake will start to
find food.",Snake.java,379.0,3
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the maximum age that a snake can live up to.
@return The snake's maximum age.",Snake.java,379.0,3
8,"protected boolean getCanSleep()
    {
        return CAN_SLEEP;
    }","Return true if the snake sleeps at nighttime.
@return true if the snake sleeps at night, false otherwise.",Snake.java,379.0,3
0,"public String getCurrent()
    {
        return current;
    }","Returns the current weather.
@return The String of the current weather.",Weather.java,379.0,3
1,"private void addWeatherTypes()
    {
        weatherTypes.add(""Rainy"");
        weatherTypes.add(""Sunny"");
        weatherTypes.add(""Cloudy"");
    }",Add different weather types to be simulated.,Weather.java,379.0,3
2,"public void changeWeather()
    {
        Random rand = Randomizer.getRandom();
        int weather = rand.nextInt(weatherTypes.size());

        previous = current;
        if (current.equals(""Rainy"") && count == 3) {
            current = ""Foggy"";
        } else {
            current = weatherTypes.get(weather);
        }
        addWeatherHistory(current);

        if (previous.equals(current)) {
            count++;
        } else {
            count = 1;
        }
    }",Changes the current weather by random.,Weather.java,379.0,3
3,"private void addWeatherHistory(String weather)
    {
        weatherHistory.add(weather);
    }","Add current weather into the history of weathers simulated.
@weather The current weather.",Weather.java,379.0,3
4,"public boolean noRainAndSun()
    {
        int size = weatherHistory.size();
        if (size > 3) {
            boolean noRain = true;
            boolean noSun = true;
  
            for(int i = size - 4; i < size-1; i++) {
                if(weatherHistory.get(i).equals(""Rainy"")) {
                    noRain = false;
                }

                if(weatherHistory.get(i).equals(""Sunny"")) {
                    noSun = false;
                }
            }
            
            return noRain && noSun;
        }
        
        return false;
    }","Returns true if there was no rain and no sun for
3 consecutive periods.
@return true if there was no rain and no sun for
3 consecutive periods. Otherwise, false.",Weather.java,379.0,3
0,"public void populate(List<Plant> plants, List<Animal> animals, Field field)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= CASTOR_CREATION_PROBABILITY) {
                    Location location = new Location(row,col);
                    Castor castor = new Castor(true, field, location);
                    plants.add(castor);
                } 
                else if(rand.nextDouble() <= TIGER_CREATION_PROBABILITY) {
                    Location location = new Location(row,col);
                    boolean isFemale = gender(""tiger"");
                    Tiger tiger = new Tiger(true, isFemale, field, location);
                    animals.add(tiger);
                } 
                else if(rand.nextDouble() <= SNAKE_CREATION_PROBABILITY) {
                    Location location = new Location(row,col);
                    boolean isFemale = gender(""snake"");
                    Snake snake = new Snake(true, isFemale, field, location);
                    animals.add(snake);
                }
                else if(rand.nextDouble() <= RAT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    boolean isFemale = gender(""rat"");
                    Rat rat = new Rat(true, isFemale, field, location);
                    animals.add(rat);
                }
                else if(rand.nextDouble() <= DEER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    boolean isFemale = gender(""deer"");
                    Deer deer = new Deer(true, isFemale, field, location);
                    animals.add(deer);
                }
                else if(rand.nextDouble() <= CAPYBARA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    boolean isFemale = gender(""capybara"");
                    Capybara capybara = new Capybara(true, isFemale, field, location);
                    animals.add(capybara);
                }
                else if(rand.nextDouble() <= BERRY_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Berry berry = new Berry(true, field, location);
                    plants.add(berry);
                }
                else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    plants.add(grass);
                }

                // else leave the location empty.
            }
        }
    }","Randomly populate the field with species of animals and plants.
@param plants A list of initial plants in the simulation.
@param animals A list of initial animals in the simulation.
@param field The field of the simulation.",PopulationGenerator.java,379.0,3
1,"public void setColor(SimulatorView view)
    {
        view.setColor(Capybara.class, Color.PINK);
        view.setColor(Tiger.class, Color.ORANGE);
        view.setColor(Rat.class, Color.RED);
        view.setColor(Deer.class, Color.MAGENTA);
        view.setColor(Snake.class, Color.BLACK);
        view.setColor(Grass.class, Color.GREEN);
        view.setColor(Castor.class, Color.GRAY);
        view.setColor(Berry.class, Color.BLUE);
    }","Set the color of each animal and plant class in the simulation.
@param view The graphical view of the simulation.",PopulationGenerator.java,379.0,3
2,"private boolean gender(String animal)
    {
        int count;
        if(!genderCount.containsKey(animal)) {
            genderCount.put(animal, 1);
            return false;
        } else {
            count = genderCount.get(animal);
            count++;
            genderCount.put(animal, count);
        }
        return count % 2 == 0;
    }","Determine the initial gender of the animal.
@param count The count of the animal type created.
@return true if it is a female, otherwise, false if
it is a male.",PopulationGenerator.java,379.0,3
0,"public boolean getIsDay()
    {
        return isDay;
    }","Returns true if it is daytime.
@returns true if daytime, otherwise, return false.",Time.java,379.0,3
1,"public String getString()
    {
        if(isDay) {
            return ""Day"";
        } else {
            return ""Night"";
        }
    }","Returns a short description of the time of day.
@return The String of time of day.",Time.java,379.0,3
2,"public void changeTime()
    {
        isDay = !isDay;
    }",Changes the time of day.,Time.java,379.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,379.0,3
1,"protected Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,379.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,379.0,3
3,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,379.0,3
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,379.0,3
5,"public void act(List<Plant> newPlants, boolean isDay, Weather weather)
    {
        competition();
        
        if(alive && isDay && !weather.noRainAndSun()){
            grow();
            // Plants can only reproduce once they are mature.
            if(growth >= getWhenMature()){
                setReproductionProbability(weather);
                reproduce(newPlants);
            }
        }
    }","Make this plant act - that is: make it do
whatever it wants/needs to do.
@param newPlants A list to receive newly grown plants.
@param isDay The time of day
@param weather The current weather.",Plant.java,379.0,3
6,"protected void grow()
    {
        growth = growth * getGrowthRate();
    }",Increase the growth of the plant.,Plant.java,379.0,3
7,"protected int seed()
    {
        int seeds = 0;
        if(rand.nextDouble() <= reproductionProbability) {
            seeds = rand.nextInt(getMaxSeedNum()) + 1;
        }
        return seeds;
    }","Generate a number representing the number of seeds,
if it can reproduce.
@return The number of seeds (may be zero).",Plant.java,379.0,3
8,"private void setReproductionProbability(Weather weather)
    {
        String currentWeather = weather.getCurrent();
        double prob = getDefaultReproductionProbability();

        if(currentWeather.equals(""rainy"") || currentWeather.equals(""sunny"")) {
            reproductionProbability = prob * 1.3;
        } else {
            reproductionProbability = prob;
        }
    }","Increase reproduction probability if the weather is sunny or rainy,
otherwise, set to default value.
@param weather The current weather",Plant.java,379.0,3
9,"public void competition()
    {
        if (alive) {
            List<Location> free = field.getFreeAdjacentLocations(location);
            
            // Make plants compete with each other if too many plants are around it
            if(free.size() <= 4){
                List<Location> adjacent = field.adjacentLocations(location);
                Iterator<Location> it = adjacent.iterator();
                while(it.hasNext()) {
                    Location where = it.next();
                    Object plant = field.getObjectAt(where);
                    if(plant instanceof Plant){
                        Plant currentPlant = (Plant) plant;
                        if(getSurvivalRate() <= currentPlant.getSurvivalRate()){
                            setDead();
                            return;
                        }
                    }
                }
            }
        }
    }","Check if the plant is able to survive when competing for
resources with adjacent plants. Plants only start competing
when there are many plants crowding around it.",Plant.java,379.0,3
0,"public String getName()
    {
        return name;
    }","Return the name of a simulation type.
@return The short description of this type.",Counter.java,379.0,3
1,"public int getCount()
    {
        return count;
    }","Return the count for a simulation type.
@return The current count for this type.",Counter.java,379.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,379.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,379.0,3
0,"protected void giveBirth(List<Animal> newDeer, Object animal)
    {
        if (animal instanceof Deer) {
            Deer deer = (Deer) animal;
            if (!deer.getIsFemale()) {
                // New deer are born into surrounding locations.
                // Get a list of free surrounding locations.
                Field field = deer.getField();
                List<Location> free = field.getFreeSurroundingLocations(getLocation(),2);
                int births = breed();
                for(int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    boolean isFemale = chooseGender();
                    Deer young = new Deer(false, isFemale, field, loc);
                    newDeer.add(young);
                }
            }
        }
    }","Check whether the given animal is a male deer.
If so, then give birth to a random number of offsprings
in the free locations surrounding it, if there are any.
@param newDeer A list to add all the new offspring.
@param animal An animal that could be a male deer.",Deer.java,379.0,3
1,"protected Location checkFood(Object plant, Location where, String weather)
    {
        if(plant instanceof Grass) {
            Grass grass = (Grass) plant;
            if(grass.isAlive()) { 
                grass.setDead();
                changeEnergyLevel(grass.getFoodValue());
                return where;
            }
        } else if(plant instanceof Berry) {
            Berry berry = (Berry) plant;
            if(berry.isAlive()) { 
                berry.setDead();
                changeEnergyLevel(berry.getFoodValue());
                return where;
            }
        } else if(plant instanceof Castor) {
            Castor castor = (Castor) plant;
            if(castor.isAlive()) { 
                castor.setDead();
                changeEnergyLevel(castor.getFoodValue());
                infected();
                return where;
            }
        }

        return null;
    }","If one of the plants around it is of its food source,
then eat it and return the location of the plant
that was eaten.
@param plant The plant which the deer might eat.
@param where The location of the plant to be eaten.
@param weather The weather of the simulation.
@return The location of plant that was eaten.",Deer.java,379.0,3
2,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the deer's breeding age.
@return deer's breeding age.",Deer.java,379.0,3
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the deer's breeding probability.
@return deer's breeding probability.",Deer.java,379.0,3
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the deer's maximum litter size.
@return deer's maximum litter size.",Deer.java,379.0,3
5,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the energy derived from the deer when eaten.
@return the energy value derived from eating the deer.",Deer.java,379.0,3
6,"protected int getHungry()
    {
        return HUNGRY;
    }","Return the energy level at which the deer will start
to find food.
@return the energy level when the deer will start to
find food.",Deer.java,379.0,3
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the maximum age that a deer can live up to.
@return The deer's maximum age.",Deer.java,379.0,3
8,"protected boolean getCanSleep()
    {
        return CAN_SLEEP;
    }","Return true if the deer sleeps at nighttime.
@return true if the deer sleeps at night, false otherwise.",Deer.java,379.0,3
0,"protected void giveBirth(List<Animal> newCapybaras, Object animal)
    {
        if (animal instanceof Capybara) {
            Capybara capybara = (Capybara) animal;
            if (!capybara.getIsFemale()) {
                // New capybaras are born into surrounding locations.
                // Get a list of free surrounding locations.
                Field field = capybara.getField();
                List<Location> free = field.getFreeSurroundingLocations(getLocation(),2);
                int births = breed();
                for(int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    boolean isFemale = chooseGender();
                    Capybara young = new Capybara(false, isFemale, field, loc);
                    newCapybaras.add(young);
                }
            }
        }
    }","Check whether the given animal is a male capybara.
If so, then give birth to a random number of offsprings
in the free locations surrounding it, if there are any.
@param newCapybaras A list to add all the new offspring.
@param animal An animal that could be a male capybara.",Capybara.java,379.0,3
1,"protected Location checkFood(Object plant, Location where, String weather)
    {
        if(plant instanceof Grass) {
            Grass grass = (Grass) plant;
            if(grass.isAlive()) { 
                grass.setDead();
                changeEnergyLevel(grass.getFoodValue());
                return where;
            }
        } else if(plant instanceof Berry) {
            Berry berry = (Berry) plant;
            if(berry.isAlive()) { 
                berry.setDead();
                changeEnergyLevel(berry.getFoodValue());
                return where;
            }
        }
        
        return null;
    }","If one of the plants around it is of its food source,
then eat it and return the location of the plant
that was eaten.
@param plant The plant which the deer might eat.
@param where The location of the plant to be eaten.
@param weather The weather of the simulation.
@return The location of plant that was eaten.",Capybara.java,379.0,3
2,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the capybara's breeding age.
@return capybara's breeding age.",Capybara.java,379.0,3
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the capybara's breeding probability.
@return capybara's breeding probability.",Capybara.java,379.0,3
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the capybara's maximum litter size.
@return capybara's maximum litter size.",Capybara.java,379.0,3
5,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the energy derived from the capybara when eaten.
@return the energy value derived from eating the capybara.",Capybara.java,379.0,3
6,"protected int getHungry()
    {
        return HUNGRY;
    }","Return the energy level at which the capybara will start
to find food.
@return the energy level when the capybara will start to
find food.",Capybara.java,379.0,3
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the maximum age that a capybara can live up to.
@return The capybara's maximum age.",Capybara.java,379.0,3
8,"protected boolean getCanSleep()
    {
        return CAN_SLEEP;
    }","Return true if the capybara sleeps at nighttime.
@return true if the capybara sleeps at night, false otherwise.",Capybara.java,379.0,3
0,"public void setColor(Class actorClass, Color color)
    {
        colors.put(actorClass, color);
    }","Define a color to be used for a given class of simulation type.
@param actorClass The simulation type's Class object.
@param color The color to be used for the given class.",SimulatorView.java,379.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }","Display a short information label at the top of the window.
@param text The information label.",SimulatorView.java,379.0,3
2,"private Color getColor(Class actorClass)
    {
        Color col = colors.get(actorClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }","Return the color used for a simulation type.
@param actorClass The class of the simulation type.
@return The color to be used for a given class of simulation type.",SimulatorView.java,379.0,3
3,"public void showStatus(String time, String weather, int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        dayNightLabel.setText(DAYNIGHT_PREFIX + time);
        weatherLabel.setText(WEATHER_PREFIX + weather);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,379.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@param field The field of the simulation.
@return true If there is more than one species alive.",SimulatorView.java,379.0,3
0,"public void runLongSimulation()
    {
        simulate(2000);
    }","Run the simulation from its current state for a reasonably long period,
(2000 steps).",Simulator.java,379.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(50);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,379.0,3
2,"public void simulateOneStep()
    {
        step++;
        changeEnvironment();

        // Provide space for newborn animals and plants.
        List<Animal> newAnimals = new ArrayList<>(); 
        List<Plant>  newPlants = new ArrayList<>();

        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals, time.getIsDay(), weather.getCurrent());
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        
        //Let all plants act
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.act(newPlants, time.getIsDay(), weather);
            if(! plant.isAlive()) {
                it.remove();
            }
        }

        // Add the newly reproduced animals and plants to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);

        view.showStatus(time.getString(), weather.getCurrent(), step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal and plant.",Simulator.java,379.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        populationGenerator.populate(plants,animals,field);

        // Show the starting state in the view.
        view.showStatus(time.getString(), weather.getCurrent(), step, field);
    }",Reset the simulation to a starting position.,Simulator.java,379.0,3
4,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,379.0,3
5,"private void changeEnvironment()
    {
        if(step % 50 == 0) {
            time.changeTime();
        }

        if(step % 50 == 0) {
            weather.changeWeather();
        }
    }","Switch day and night time, and change the weather every 50 steps.",Simulator.java,379.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,379.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,379.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,379.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,379.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,379.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,379.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,379.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,379.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,379.0,3
3,"public int getRow()
    {
        return row;
    }","Return the row of the location.
@return The row.",Location.java,379.0,3
4,"public int getCol()
    {
        return col;
    }","Return the column of the location.
@return The column.",Location.java,379.0,3
0,"protected void reproduce(List<Plant> newPlants)
    {
        Field field = getField();
        List<Location> surrounding = field.getFreeSurroundingLocations(getLocation(), 3); 

        int births = seed();
        for(int b = 0; b < births && surrounding.size() > 0; b++) {
            Location loc = surrounding.remove(0);
            Berry seedling = new Berry(false, field, loc);
            newPlants.add(seedling);
        }
    }","Produce new berries when it is mature. The new
berries are made into free surrounding locations.
@param newPlants A list to return new plants.",Berry.java,379.0,3
1,"protected int getMaxSeedNum()
    {
        return MAX_SEED_NUMBER;
    }","Return the maximum number of seeds berries can produce.
@return the berry's maximum seed number.",Berry.java,379.0,3
2,"protected double getDefaultReproductionProbability()
    {
        return REPRODUCTION_PROBABILITY;
    }","Return the likelihood of a berry bush reproducing
when it is not affected by external factors.
@return The berry bush's default reproduction probability.",Berry.java,379.0,3
3,"protected double getGrowthRate()
    {
        return GROWTH_RATE;
    }","Return the berry bush's growth rate.
@return The berry bush's growth rate.",Berry.java,379.0,3
4,"protected int getWhenMature()
    {
        return WHEN_MATURE;
    }","Return the berry bush's growth when it is
considered mature.
@return The berry bush's mature growth.",Berry.java,379.0,3
5,"protected double getSurvivalRate()
    {
        return SURVIVAL_RATE;
    }","Return the survival rate of the berry bush when competing
for resources with other plants.
@return The berry bush's survival rate.",Berry.java,379.0,3
6,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the food value of the berry when it is eaten.
@return The berry bush's food value.",Berry.java,379.0,3
7,"public boolean getIsPoisonous()
    {
        return IS_POISONOUS;
    }","Check if the berry is poisonous.
@return true if the berry is poisonous, otherwise,
return false.",Berry.java,379.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,379.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,379.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,379.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,379.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,379.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,379.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,379.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,379.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,379.0,3
2,"public void place(Object object, int row, int col)
    {
        place(object, new Location(row, col));
    }","Place an animal or plant at the given location.
If there is already an animal or plant at the location
it will be lost.
@param object The animal or plant to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,379.0,3
3,"public void place(Object object, Location location)
    {
        field[location.getRow()][location.getCol()] = object;
    }","Place an animal or plant at the given location.
If there is already an animal or plant at the location
it will be lost.
@param object The animal or plant to be placed.
@param location Where to place the animal or plant.",Field.java,379.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal or plant at the given location, if any.
@param location Where in the field.
@return The animal or plant at the given location, or
null if there is none.",Field.java,379.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal or plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal or plant at the given location, or
null if there is none.",Field.java,379.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,379.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,379.0,3
8,"public List<Location> getFreeSurroundingLocations(Location location, int radius)
    {
        List<Location> free = new LinkedList<>();
        List<Location> surrounding = surroundingLocations(location,radius);
        for(Location next : surrounding) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of locations within a given radius to
the given location. The radius has to be specified.
@param location Get locations surrounding this location.
@param radius The radius of surrounding locations.
@return A list of free surrounding locations.",Field.java,379.0,3
9,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,379.0,3
10,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,379.0,3
11,"public List<Location> surroundingLocations(Location location, int radius)
    {
        assert location != null : ""Null location passed to surroundingLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -radius; roffset <= radius; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -radius; coffset <= radius; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations within a given radius to the given
one. The list will not include the location itself. All locations
will lie within the grid.
@param location The location from which to generate surrounding locations.
@param radius The radius of surrounding locations to the given location.
@return A list of locations surrounding the given location.",Field.java,379.0,3
12,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,379.0,3
13,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,379.0,3
0,"protected void reproduce(List<Plant> newPlants)
    {
        Field field = getField();
        List<Location> free = field.getFreeSurroundingLocations(getLocation(), 6); 

        int births = seed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Grass seedling = new Grass(false, field, loc);
            newPlants.add(seedling);
        }
    }","Produce new grass when it is mature. The new grass are
made into free surrounding locations.
@param newPlants A list to return new plants.",Grass.java,379.0,3
1,"protected int getMaxSeedNum()
    {
        return MAX_SEED_NUMBER;
    }","Return the maximum number of seeds grass can produce.
@return the grass' maximum seed number.",Grass.java,379.0,3
2,"protected double getDefaultReproductionProbability()
    {
        return REPRODUCTION_PROBABILITY;
    }","Return the likelihood of grass reproducing when it is
not affected by external factors.
@return The grass' default reproduction probability.",Grass.java,379.0,3
3,"protected double getGrowthRate()
    {
        return GROWTH_RATE;
    }","Return the grass' growth rate.
@return The grass' growth rate.",Grass.java,379.0,3
4,"protected int getWhenMature()
    {
        return WHEN_MATURE;
    }","Return the grass' growth when it is considered mature.
@return The grass' mature growth.",Grass.java,379.0,3
5,"protected double getSurvivalRate()
    {
        return SURVIVAL_RATE;
    }","Return the survival rate of grass when competing for
resources with other plants.
@return The grass' survival rate.",Grass.java,379.0,3
6,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the food value of grass when it is eaten.
@return The grass' food value.",Grass.java,379.0,3
7,"public boolean getIsPoisonous()
    {
        return IS_POISONOUS;
    }","Check if the grass is poisonous.
@return true if the grass is poisonous, otherwise, return false.",Grass.java,379.0,3
0,"protected void giveBirth(List<Animal> newTigers, Object animal)
    {
        if (animal instanceof Tiger) {
            Tiger tiger = (Tiger) animal;
            if (!tiger.getIsFemale()) {
                // New tigers are born into surrounding locations.
                // Get a list of free surrounding locations.
                Field field = tiger.getField();
                List<Location> free = field.getFreeSurroundingLocations(getLocation(),2);
                int births = breed();
                for(int b = 0; b < births && free.size() > 0; b++) {
                    Location loc = free.remove(0);
                    boolean isFemale = chooseGender();
                    Tiger young = new Tiger(false, isFemale, field, loc);
                    newTigers.add(young);
                }
            }
        }
    }","Check whether the given animal is a male tiger.
If so, then give birth to a random number of offsprings
in the free locations surrounding it, if there are any.
@param newTigers A list to add all the new offspring.
@param animal An animal that could be a male tiger.",Tiger.java,379.0,3
1,"protected Location checkFood(Object animal, Location where, String weather)
    {
        if(!weather.equals(""Foggy"")) {
            if(animal instanceof Capybara) {
                Capybara capybara = (Capybara) animal;
                if(capybara.isAlive()) { 
                    capybara.setDead();
                    changeEnergyLevel(capybara.getFoodValue());
                    return where;
                }
            }else if(animal instanceof Deer) {
                Deer deer = (Deer) animal;
                if(deer.isAlive()) { 
                    deer.setDead();
                    changeEnergyLevel(deer.getFoodValue());
                    if(deer.getIsInfected()) {
                        infected();
                    }
                    return where;
                }
            }
        }

        return null;
    }","If the weather is not foggy and one of the animals
around it is of its preys, then eat it and return
the location of the animal that was eaten.
@param object The animal that might be eaten.
@param where The location of the animal to be eaten.
@param weather The weather of the simulation.
@return The location of the animal that was eaten.",Tiger.java,379.0,3
2,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the tiger's breeding age.
@return tiger's breeding age.",Tiger.java,379.0,3
3,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the tiger's breeding probability.
@return tiger's breeding probability.",Tiger.java,379.0,3
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the tiger's maximum litter size.
@return tiger's maximum litter size.",Tiger.java,379.0,3
5,"protected int getFoodValue()
    {
        return FOOD_VALUE;
    }","Return the energy derived from the tiger when eaten.
@return the energy value derived from eating the snake.",Tiger.java,379.0,3
6,"protected int getHungry()
    {
        return HUNGRY;
    }","Return the energy level at which the tiger will start
to find food.
@return the energy level when the tiger will start to
find food.",Tiger.java,379.0,3
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the maximum age that a tiger can live up to.
@return The tiger's maximum age.",Tiger.java,379.0,3
8,"protected boolean getCanSleep()
    {
        return CAN_SLEEP;
    }","Return true if the tiger sleeps at nighttime.
@return true if the tiger sleeps at night, false otherwise.",Tiger.java,379.0,3
0,"public void act(List<Animal> newAnimals, boolean isDay, String weather)
    {
        incrementAge();
        changeEnergyLevel(-1);

        if(alive) {
            if(!isDay && getCanSleep()) {
                sleep();
                return;
            }

            // Propagate if the animal is a female of breeding age.
            if(isFemale && age >= getBreedingAge()) {
                propagate(newAnimals);  
            }

            // Move towards a source of food if found.
            Location newLocation = findFood(weather);
            if(!alive) {
                return;
            }

            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = field.freeAdjacentLocation(location);
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","Make this animal act - that is: it will age, lose enerygy,
change between a sleeping and an awake state, reproduce,
find food, and move. If it cannot find any food and
it cannot move, then it dies due to overcrowding.
@param newAnimals A list to receive newly born animals.
@param isDay The time of day.
@param weather The current weather of the simulation.",Animal.java,379.0,3
1,"public boolean isAlive()
    {
        return alive;
    }","Return true if the animal is alive, false otherwise.
@return true if the animal is alive, false otherwise.",Animal.java,379.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age of the animal. This could result in it's death.,Animal.java,379.0,3
3,"protected void changeEnergyLevel(int change)
    {
        energyLevel += change;
        if(energyLevel <= 0) {
            setDead();
        }
    }",Make an animal more hungry. This could result it's death.,Animal.java,379.0,3
4,"protected void sleep()
    {
        energyLevel++;
    }",Increase the energy level when the animal is asleep.,Animal.java,379.0,3
5,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,379.0,3
6,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,379.0,3
7,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,379.0,3
8,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,379.0,3
9,"protected boolean getIsFemale()
    {
        return isFemale;
    }","Return true if the animal is female, false if it is male.
@return true if it is female, false if it is male.",Animal.java,379.0,3
10,"protected boolean chooseGender()
    {
        int randomGender = rand.nextInt(2);
        if (randomGender == 0) {
            return true;
        } else {
            return false;
        }
    }","Selects a random gender for each instance of an animal.
@return true if the gender is female, otherwise, gender is male.",Animal.java,379.0,3
11,"protected void propagate(List<Animal> newAnimals)
    {
        Field field = getField();
        List<Location> surrounding = field.surroundingLocations(getLocation(), 2);
        Iterator<Location> it = surrounding.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            giveBirth(newAnimals, animal);
        }
    }","Check the surrounding locations for animals. Then have a
chance to give birth to random number offspring in free
locations surrounding it, if there are any.
@param newAnimals A list to store add the new offspring.",Animal.java,379.0,3
12,"protected int breed()
    {
        int births = 0;
        if(rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,379.0,3
13,"protected Location findFood(String weather)
    {
        if(energyLevel <= getHungry()) {
            List<Location> adjacent = field.adjacentLocations(getLocation());
            Iterator<Location> it = adjacent.iterator();
            while(it.hasNext()) {
                Location where = it.next();
                Object food = field.getObjectAt(where);
                Location l = checkFood(food, where, weather);
                if(l != null){
                    return l;
                }
            }
        } 
        return null;
    }","If the animal's energy level is lower than its hungry level,
check its adjacent locations for food to eat.
@param weather The weather of the simulation.
@return The location of the animal or plant to eat.",Animal.java,379.0,3
14,"protected void infected()
    {
        isInfected = true;
        age += 10;
        changeEnergyLevel(-10);
        if(age > getMaxAge()) {
            setDead();
        }
    }","Set the animal's status to infected, decrease its lifespan
and current energy level. If its age exceeds its maximum
age or it has no energy left, then it dies.",Animal.java,379.0,3
15,"protected boolean getIsInfected()
    {
        return isInfected;
    }","Return true if the animal is infected, otherwise return false.
@return true if the animal is diseased, otherwise return false.",Animal.java,379.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,164.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,164.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,164.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,164.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,164.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,164.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,164.0,2
0,"public boolean isSnowing()
    {
        if (temperature < 0 && rand.nextDouble() <= SNOWING_PROBABILITY){
            snow = true;
        }
        else {
            snow = false;
        }
        return snow;
    }","@return whether it is snowing or not.
It can only snow below zero degrees",Weather.java,164.0,2
1,"public void setSummer()
    {
        summer = !summer;
    }",Changes the season from summer to winter,Weather.java,164.0,2
2,"public boolean globalWarming()
    {
       return globalWarming;
    }",@return whether global warming has occured,Weather.java,164.0,2
3,"public void generateTemp()
    {
        // checks whether global warming will occur and sets temp accordingly
        if(rand.nextDouble() <= GLOBALWARMING_PROBABILITY){
            temperature++; 
            if(temperature >= 30) {
               globalWarming = true;
            }
        }
        // otherwise, checks if it's summer (as temperature can reach higher)
        else if(summer){
            if(rand.nextDouble() <= SET_TEMP_PROBABILITY && temperature <= MAX_SUMMER) {
                temperature ++; 
            }
            else if (temperature >= MIN_SUMMER){
                temperature --;
            }
        }
        // otherwise it's winter
        else{
            if(rand.nextDouble() <= SET_TEMP_PROBABILITY && temperature <= MAX_WINTER) {
                temperature ++; 
            }
            else if (temperature >= MIN_WINTER ){
                temperature --;
            }
        }
    }","Sets the temperature at each step by incrementing/decrementing the
current temperature by one",Weather.java,164.0,2
4,"public double getTemp()
    {
       return temperature;
    }",@return the current temperature for this step,Weather.java,164.0,2
5,"public boolean getSummer()
    {
       return summer;
    }",@return the current season for this step,Weather.java,164.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,164.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,164.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,164.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,164.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,164.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,164.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,164.0,2
3,"public void showStatus(int step, Field field, double temp)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        tempLabel.setText(TEMP_PREFIX + temp);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,164.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,164.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,164.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(50);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,164.0,2
2,"public void simulateOneStep()
    {
        //set the conditions for the animals to act in.
        step.incrementStep();
        step.setDay();

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            //change the animal's behaviour depending on the weather
            weatherChange(animal);
            //let the animals act depending on the time of day
            if(step.isDay()) {
               animal.actDay(newAnimals);
            }
            else {
               animal.actNight(newAnimals);
            }

            if(! animal.isAlive()) {
                it.remove();
            }
            
        }   
         
         //Add the newly born animals to the main lists.
        animals.addAll(newAnimals);
        
        weather.generateTemp();
        view.showStatus(step.getStep(), field, weather.getTemp());
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal.",Simulator.java,164.0,2
3,"public void reset()
    {
        step.reset();
        animals.clear();
        populate(step);
        
        // Show the starting state in the view.
        view.showStatus(step.getStep(), field, weather.getTemp());
    }",Reset the simulation to a starting position.,Simulator.java,164.0,2
4,"private void populate(Step step)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                double prob = rand.nextDouble();
                
                if (prob <= getHIGHEST_CREATION_PROBABILITY()) {
                   Location location = new Location(row, col); 
                   Animal animal = null;
                   if(prob <= FOX_CREATION_PROBABILITY){
                      animal = new Fox(true, field, location, step);
                   }
                   else if(prob <= SEAL_CREATION_PROBABILITY){
                      animal = new Seal(true, field, location, step);
                   }
                   else if(prob <= PENGUIN_CREATION_PROBABILITY){
                      animal = new Penguin(true, field, location, step);
                   }
                   else if(prob <= FISH_CREATION_PROBABILITY){
                      animal = new Fish(true, field, location, step);
                   }
                   else if(prob <= POLARBEAR_CREATION_PROBABILITY){
                      animal = new PolarBear(true, field, location, step);
                   }
                   else if(prob <= ALGAE_CREATION_PROBABILITY){
                      animal = new Algae(true, field, location, step);
                   }
                   animals.add(animal);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with all the animals in the simulation.,Simulator.java,164.0,2
5,"private double getHIGHEST_CREATION_PROBABILITY()
    {
        double[] listProb = {FOX_CREATION_PROBABILITY, SEAL_CREATION_PROBABILITY,
        PENGUIN_CREATION_PROBABILITY, FISH_CREATION_PROBABILITY, 
        POLARBEAR_CREATION_PROBABILITY, ALGAE_CREATION_PROBABILITY};
        
        for (int i = 0; i < listProb.length - 1; i++){
            if(listProb[i + 1] > listProb[i]){
                HIGHEST_CREATION_PROBABILITY = listProb[i + 1];
            }
        }
        return HIGHEST_CREATION_PROBABILITY;
    }",Returns the Highest creation probability among different animals.,Simulator.java,164.0,2
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,164.0,2
7,"private void weatherChange(Animal animal)
    {
       if (weather.globalWarming()) {
           animal.setDead();    
           System.out.println(""GLOBAL WARMING KILLED ME!!!!!"");
       }
             
       if(weather.isSnowing()){
           if(animal instanceof Algae){
                 Algae algae = (Algae) animal;
                 algae.decreaseGrowth();       
           }
           animal.snowingEffect();
       }
       else {
           if (animal instanceof Algae) {
                Algae algae = (Algae) animal;
                algae.resetGrowth(); 
           }
       }
    }",Checks the current weather and updates each animal's actions accordingly,Simulator.java,164.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,164.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,164.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,164.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,164.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,164.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of each animal.
These are not kept up to date as all the animals
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,164.0,2
0,"public void actDay(List<Animal> newFish)
    {
        incrementAge();
        incrementHunger();  
        if(isAlive()) {
            giveBirth(newFish);            
            //Try to move into a free location.
            Location newLocation = findFood();     
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
               setLocation(newLocation); 
            }
            else {
                //Overcrowding.
                setDead();
            }
        }
    }","This is what the fish does most of the time at Daytime - it wonders
around. Sometimes it will breed or die of hunger or old age.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
1,"public void actNight(List<Animal> newFish)
    {            
        incrementHunger();      
        if(isAlive()) {
            giveBirth(newFish);            
        }
    }","This is what the fish does most of the time at Night time - it
gets hungry. Sometimes it will breed.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the fish's death.",Fish.java,164.0,2
3,"private void giveBirth(List<Animal> newFish)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fish young = new Fish(false, field, loc, step);
            newFish.add(young);
        }
    }","Check whether or not this fish is to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
4,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fish.java,164.0,2
5,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Fish.java,164.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A fish can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Fish.java,164.0,2
7,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the fish's death.
At night, it makes the fish hungry more than Day time,
as it cannot hunt for a prey at Night.",Fish.java,164.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,164.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,164.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,164.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,164.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,164.0,2
0,"public void actNight(List<Animal> newPolarBears)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPolarBears);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the polar bear does most of the time: it hunts for
fish and seals. In the process, it might breed, die of hunger,
or die of old age.
@param newFoxes A list to return newly born polar bears.",PolarBear.java,164.0,2
1,"public void actDay(List<Animal> newPolarBears)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPolarBears);            
        }
    }","This is what the polar bear does most of the time at Day time:
In the process, it might breed, die of hunger.
@param newPolarBears A list to return newly born Polar bears.",PolarBear.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the polar bear's death.,PolarBear.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",PolarBear.java,164.0,2
4,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Seal ) {
                Seal seal = (Seal) animal;
                if(seal.isAlive()) { 
                    seal.setDead();
                    foodLevel = SEAL_FOOD_VALUE;
                    return where; 
                }
            }
            else if(animal instanceof Fox ) {
                Fox fox = (Fox) animal;
                if(fox.isAlive()) { 
                    fox.setDead();
                    foodLevel = FOX_FOOD_VALUE;
                    return where; 
                }
            }
        }
        return null;
    }","Look for fish, fox and seals adjacent to the current location.
Only the first live fish/seal/fox is eaten.
@return Where food was found, or null if it wasn't.",PolarBear.java,164.0,2
5,"private boolean isFemale(){
       return female;   
    }",@return true if the polar bear is female,PolarBear.java,164.0,2
6,"private void giveBirth(List<Animal> newPolarBears)
    {
        // New polar bears are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            PolarBear young = new PolarBear(false, field, loc, step);
            newPolarBears.add(young);
        }
    }","Check whether or not this polar bear is to give birth at this step.
New births will be made into free adjacent locations.
@param newPolarBears A list to return newly born polar bears.",PolarBear.java,164.0,2
7,"private int breed() 
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",PolarBear.java,164.0,2
8,"private boolean nextToMale()
    {
        //check through the list of adjacent locations to see if a male polarbear is
        //next to the female polarbear
        boolean found = false;
        Field field = getField();
        List<Location> locations = field.adjacentLocations(getLocation()) ;
        Iterator<Location> it = locations.iterator();
        while(it.hasNext() && !found)
        {  
          if (field.getObjectAt(it.next()) instanceof PolarBear) {
              PolarBear polarBear = (PolarBear) field.getObjectAt(getLocation());
              if (!polarBear.isFemale()) {
                 found = true;
                 return found;
            }             
          }
        }
        return found;
    }","Checks the adjacent locations of the instance to see if
there is a male of the same species in an adjacent square
@return true if a male is found",PolarBear.java,164.0,2
9,"private boolean canBreed()
    {
        return age >= BREEDING_AGE && isFemale() && nextToMale();
    }","A polar bear can breed if it has reached the breeding age,
is a female polar bear, and is next to a male polar bear
@return true if all these conditions apply",PolarBear.java,164.0,2
0,"public void actDay(List<Animal> newSeals)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeals);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the seal does most of the time - it moves
around. Sometimes it will breed or die of old age.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
1,"public void actNight(List<Animal> newSeals)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeals);            
        }
    }","This is what the seal does most of the time at night.
Sometimes it will breed or die of old hunger.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the seal's death.",Seal.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the seal's death.
At night, it makes the seal hungry more than at Day time,
as it cannot hunt for a prey at Night.",Seal.java,164.0,2
4,"private void giveBirth(List<Animal> newSeals)
    {
        // New seals are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seal young = new Seal(false, field, loc, step);
            newSeals.add(young);
        }
    }","Check whether or not this seal is to give birth at this step.
New births will be made into free adjacent locations.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Seal.java,164.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A seal can breed if it has reached the breeding age.
@return true if the seal can breed, false otherwise.",Seal.java,164.0,2
7,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
        }
        return null;
    }","Look for algae adjacent to the current location.
Only the first live algae is eaten.
@return Where food was found, or null if it wasn't.",Seal.java,164.0,2
0,"public void actDay(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time at Day time: it hunts for
food. In the process, it might breed, die of hunger,
or die of old age.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
1,"public void actNight(List<Animal> newFoxes)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
        }
    }","This is what the fox does most of the time at Night time.
In the process, it might breed or die of hunger.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",Fox.java,164.0,2
4,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
            else if(animal instanceof Seal ) {
                Seal seal = (Seal) animal;
                if(seal.isAlive()) { 
                    seal.setDead();
                    foodLevel = SEAL_FOOD_VALUE;
                    return where; 
                }
            }
        }
        return null;
    }","Look for food adjacent to the current location.
Only the first live animal is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,164.0,2
5,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc, step);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,164.0,2
7,"private boolean canBreed()
    {
          return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,164.0,2
0,"public void setDay()
    {  
        if (step % 4 <= 1) { 
           day = true; 
       }
        else {
          day = false;
       } 
       
        if (weather.getSummer()) {
          if (step % 4 <= 2) {  
             day = true; 
          }
          else {
             day = false;
          } 
       }
       else {
           if (step % 4 <= 0) { 
             day = true; 
          }
          else {
             day = false;
          } 
       } 
    }",Sets the day/night status of each step. Two steps represent each day,Step.java,164.0,2
1,"public void setSeason()
    {
        if ( step % 20 == 0 ){
            weather.setSummer();
        }
        else if (step % 20 == 10){
            weather.setSummer();
        }
    }",Sets the season status of each step. Ten steps represent each season,Step.java,164.0,2
2,"public boolean isDay()
    {
        return day;
    }",Returns whether it is day or not,Step.java,164.0,2
3,"public int getStep()
    {
        return step;
    }",Returns the number of steps taken,Step.java,164.0,2
4,"public void incrementStep()
    {
        step ++;
    }",Increments the number of steps taken by one,Step.java,164.0,2
5,"public void reset()
    {
        step = 0;
    }",Resets the number of steps taken to zero,Step.java,164.0,2
0,"public void actDay(List<Animal> newPenguins)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPenguins);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the penguin does most of the time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param newPenguins A list to return newly born penguins.",Penguin.java,164.0,2
1,"public void actNight(List<Animal> newPenguins)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPenguins);            
        }
    }","This is what the Penguin does most of the time at Night time:
In the process, it might breed, die of hunger.
@param newPenguins A list to return newly born Penguins.",Penguin.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the penguin's death.,Penguin.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the penguin's death.
At night, it makes the penguin hungry more than at Day time,
as it cannot hunt for a prey at Night.",Penguin.java,164.0,2
4,"private boolean isFemale(){
       return female;   
    }",@return true if the instance is female,Penguin.java,164.0,2
5,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Penguin.java,164.0,2
6,"private void giveBirth(List<Animal> newPenguins)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Penguin young = new Penguin(false, field, loc, step);
            newPenguins.add(young);
        }
    }","Check whether or not this penguin is to give birth at this step.
New births will be made into free adjacent locations.
@param newPenguins A list to return newly born penguins.",Penguin.java,164.0,2
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Penguin.java,164.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE && female && nextToMale();
    }","A penguin can breed if it has reached the breeding age,
is female, and is next to a male penguin
@return true if all these conditions apply",Penguin.java,164.0,2
9,"private boolean nextToMale()
    {
        //check through the list of adjacent locations to see if a male polarbear is
        //next to the female polarbear
        boolean found = false;
        Field field = getField();
        List<Location> locations = field.adjacentLocations(getLocation()) ;
        Iterator<Location> it = locations.iterator();
        while(it.hasNext() && !found)
        {  
          if (field.getObjectAt(it.next()) instanceof Penguin) {
              Penguin penguin = (Penguin) field.getObjectAt(getLocation());
              if (!penguin.isFemale()) {
                 found = true;
            }
           }
        }
        return found;
    }","Checks the adjacent locations of the instance to see if
there is a male of the same species in an adjacent square
@return true if a male is found",Penguin.java,164.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,164.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,164.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,164.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,164.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,164.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,164.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,164.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,164.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,164.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,164.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,164.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,164.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,164.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,164.0,2
2,"protected boolean isDay()
    {
        return step.isDay();
    }",@return true if it's day,Animal.java,164.0,2
3,"protected Step getStep()
    {
        return step;
    }",@return the current step of the simulation,Animal.java,164.0,2
4,"protected void snowingEffect()
    {
        if(rand.nextDouble() <= DYING_PROBABILITY){
            setDead();
        }
    }",Uses a probability to set an animal to dead if it's snowing,Animal.java,164.0,2
5,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,164.0,2
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,164.0,2
7,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,164.0,2
0,"public void actDay(List<Animal> newAlgae)
    {
        incrementAge();
        if(isAlive()) {
            grow(newAlgae);            
        }
    }","This is what the algae does most of the time at Day time: it
checks to see if it can grow, and it ages and eventually dies.
@param newFoxes A list to return newly born foxes.",Algae.java,164.0,2
1,"public void actNight(List<Animal> newAlgae)
    {
        
    }","As algae is a plant, it doesn't tend to act at night, when
there is no sunlight.",Algae.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the algae's death.,Algae.java,164.0,2
3,"public static void decreaseGrowth(){
        GROWTH_PROBABILITY -= 0.0002;
    }",This decreases the probability that the algae will grow,Algae.java,164.0,2
4,"private void grow(List<Animal> newAlgae)
    {
        // New algae grows into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = canGrow();
        for(int g = 0; g < births && free.size() > 0; g++) {
            Location loc = free.remove(0);
            Algae sapling = new Algae(false, field, loc, step);
            newAlgae.add(sapling);
        }
    }","Check whether or not this plant can grow at this step.
New plants will be put into free adjacent locations.
@param newAlgae A list to return newly grown algae.",Algae.java,164.0,2
5,"private int canGrow() 
    {
        int growths = 0;
        if(rand.nextDouble() <= GROWTH_PROBABILITY) {
            growths = rand.nextInt(GROWTH_SIZE) + 1;
        }
        return growths;
    }","Generate a number representing the number of growths,
if it can grow.
@return The number of growths (may be zero).",Algae.java,164.0,2
6,"public void decreaseHealth()
    {
        health--; 
        if( health <= 0 ){
            setDead();
        }
    }","Decreases the health level of the algae to show it's been
eaten",Algae.java,164.0,2
7,"public void resetGrowth()
    {
       GROWTH_PROBABILITY = 0.01;
    }","This resets the growth probability back to normal after
it has been snowing",Algae.java,164.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,164.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,164.0,2
0,"public boolean isSnowing()
    {
        if (temperature < 0 && rand.nextDouble() <= SNOWING_PROBABILITY){
            snow = true;
        }
        else {
            snow = false;
        }
        return snow;
    }",Returns whether it is snowing or not. It can only snow below zero degrees,Weather.java,164.0,2
1,"public void setSummer()
    {
        summer = !summer;
    }",Changes the season from summer to winter,Weather.java,164.0,2
2,"public boolean globalWarming(){
       return globalWarming;
    }",Returns whether global warming has occured,Weather.java,164.0,2
3,"public void generateTemp()
    {
        // checks whether global warming will occur and sets temp accordingly
        if(rand.nextDouble() <= GLOBALWARMING_PROBABILITY){
            temperature++; 
            if(temperature >= 30) {
               globalWarming = true;
            }
        }
        // otherwise, checks if it's summer (as temperature can reach higher)
        else if(summer){
            if(rand.nextDouble() <= SET_TEMP_PROBABILITY && temperature <= 20.5) {
                temperature ++; 
            }
            else if (temperature >= -10){
                temperature --;
            }
        }
        // otherwise it's winter
        else{
            if(rand.nextDouble() <= SET_TEMP_PROBABILITY && temperature <= 0) {
                temperature ++; 
            }
            else if (temperature >= -50 ){
                temperature --;
            }
           }
    }","Sets the temperature at each step by incrementing/decrementing the
current temperature by one",Weather.java,164.0,2
4,"public double getTemp()
    {
       return temperature;
    }",Returns the current temperature for this step,Weather.java,164.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,164.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,164.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,164.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,164.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,164.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,164.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,164.0,2
3,"public void showStatus(int step, Field field, double temp)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        tempLabel.setText(TEMP_PREFIX + temp);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,164.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,164.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,164.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(50);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,164.0,2
2,"public void simulateOneStep()
    {
        //set the conditions for the animals to act in.
        step.incrementStep();
        step.setDay();

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        
        
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            //change the animal's behaviour depending on the weather
            weatherChange(animal);
            //let the animals act depending on the time of day
            if(step.isDay()) {
               animal.actDay(newAnimals);
            }
            else {
                animal.actNight(newAnimals);
            }

            if(! animal.isAlive()) {
                it.remove();
            }
            
        }


        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);
        weather.generateTemp();
        view.showStatus(step.getStep(), field, weather.getTemp());
        
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
fox and rabbit.",Simulator.java,164.0,2
3,"public void reset()
    {
        step.reset();
        animals.clear();
        populate(step);
        
        // Show the starting state in the view.
        view.showStatus(step.getStep(), field, weather.getTemp());
    }",Reset the simulation to a starting position.,Simulator.java,164.0,2
4,"private void populate(Step step)
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                double prob = rand.nextDouble();
                
                if (prob <= ALGAE_CREATION_PROBABILITY) {
                   Location location = new Location(row, col); 
                   Animal animal = null;
                   if(prob <= FOX_CREATION_PROBABILITY){
                      animal = new Fox(true, field, location, step);
                   }
                   else if(prob <= SEAL_CREATION_PROBABILITY){
                      animal = new Seal(true, field, location, step);
                   }
                   else if(prob <= PENGUIN_CREATION_PROBABILITY){
                      animal = new Penguin(true, field, location, step);
                   }
                   else if(prob <= FISH_CREATION_PROBABILITY){
                      animal = new Fish(true, field, location, step);
                   }
                   else if(prob <= POLARBEAR_CREATION_PROBABILITY){
                      animal = new PolarBear(true, field, location, step);
                   }
                   else if(prob <= ALGAE_CREATION_PROBABILITY){
                      animal = new Algae(true, field, location, step);
                   }
                   animals.add(animal);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with all the animals in the simulation.,Simulator.java,164.0,2
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,164.0,2
6,"private void weatherChange(Animal animal)
    {
       if (weather.globalWarming()) {
           animal.setDead();    
           System.out.println(""GLOBAL WARMING KILLED ME!!!!!"");
       }
             
       if(weather.isSnowing()){
           if(animal instanceof Algae){
                 Algae algae = (Algae) animal;
                 algae.decreaseGrowth();       
           }
           animal.snowingEffect();
       }
       else {
           if (animal instanceof Algae) {
                Algae algae = (Algae) animal;
                algae.resetGrowth(); 
           }
       }
    }",Checks the current weather and updates each animal's actions accordingly,Simulator.java,164.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,164.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,164.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,164.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,164.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,164.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of each animal.
These are not kept up to date as all the animals
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,164.0,2
0,"public void actDay(List<Animal> newFish)
    {
        incrementAge();
        incrementHunger();  
        if(isAlive()) {
            giveBirth(newFish);            
            //Try to move into a free location.
            Location newLocation = findFood();     
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
               setLocation(newLocation); 
            }
            else {
                //Overcrowding.
                setDead();
            }
        }
    }","This is what the fish does most of the time at Daytime - it wonders
around. Sometimes it will breed or die of old age.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
1,"public void actNight(List<Animal> newFoxes)
    {            
        incrementHunger();      
        if(isAlive()) {
            giveBirth(newFoxes);            
        }
    }","This is what the fish does most of the time at Night time - it wonders
around. Sometimes it will breed.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the fish's death.",Fish.java,164.0,2
3,"private void giveBirth(List<Animal> newFish)
    {
        // New fish are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fish young = new Fish(false, field, loc, step);
            newFish.add(young);
        }
    }","Check whether or not this fish is to give birth at this step.
New births will be made into free adjacent locations.
@param newFish A list to return newly born fish.",Fish.java,164.0,2
4,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fish.java,164.0,2
5,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Fish.java,164.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A fish can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Fish.java,164.0,2
7,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",Fish.java,164.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,164.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,164.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,164.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,164.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,164.0,2
0,"public void actDay(List<Animal> newPolarBears)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPolarBears);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the polar bear does most of the time: it hunts for
fish and seals. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born polar bears.",PolarBear.java,164.0,2
1,"public void actNight(List<Animal> newPolarBears)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPolarBears);            
        }
    }","This is what the polar bear does most of the time at Night time: ......Not confirmed
In the process, it might breed, die of hunger.
@param field The field currently occupied.
@param newPolarBears A list to return newly born Polar bears.",PolarBear.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the polar bear's death.,PolarBear.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",PolarBear.java,164.0,2
4,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Seal ) {
                Seal seal = (Seal) animal;
                if(seal.isAlive()) { 
                    seal.setDead();
                    foodLevel = SEAL_FOOD_VALUE;
                    return where; 
                }
            }
        }
        return null;
    }","Look for fish and seals adjacent to the current location.
Only the first live fish/seal is eaten.
@return Where food was found, or null if it wasn't.",PolarBear.java,164.0,2
6,"private void giveBirth(List<Animal> newPolarBears)
    {
        // New polar bears are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            PolarBear young = new PolarBear(false, field, loc, step);
            newPolarBears.add(young);
        }
    }","Check whether or not this polar bear is to give birth at this step.
New births will be made into free adjacent locations.
@param newPolarBears A list to return newly born polar bears.",PolarBear.java,164.0,2
7,"private int breed() 
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",PolarBear.java,164.0,2
9,"private boolean canBreed()
    {
        return age >= BREEDING_AGE && female;
    }",A polar bear can breed if it has reached the breeding age.,PolarBear.java,164.0,2
0,"public void actDay(List<Animal> newSeals)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeals);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the seal does most of the time - it moves
around. Sometimes it will breed or die of old age.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
1,"public void actNight(List<Animal> newSeals)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSeals);            
        }
    }","This is what the seal does most of the time - it moves
around. Sometimes it will breed or die of old age.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the seal's death.",Seal.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",Seal.java,164.0,2
4,"private void giveBirth(List<Animal> newSeals)
    {
        // New seals are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seal young = new Seal(false, field, loc, step);
            newSeals.add(young);
        }
    }","Check whether or not this seal is to give birth at this step.
New births will be made into free adjacent locations.
@param newSeals A list to return newly born seals.",Seal.java,164.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Seal.java,164.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A seal can breed if it has reached the breeding age.
@return true if the seal can breed, false otherwise.",Seal.java,164.0,2
7,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Seal.java,164.0,2
0,"public void actDay(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time at Day time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
1,"public void actNight(List<Animal> newFoxes)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
        }
    }","This is what the fox does most of the time at Night time.
In the process, it might breed or die of hunger.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",Fox.java,164.0,2
4,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
            else if(animal instanceof Algae) {
                Algae algae = (Algae) animal;
                if(algae.isAlive()) { 
                    algae.decreaseHealth();
                    foodLevel = ALGAE_FOOD_VALUE;
                    if (!algae.isAlive()) {
                       return where;
                    }
                    
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,164.0,2
5,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc, step);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,164.0,2
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,164.0,2
7,"private boolean canBreed()
    {
          return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,164.0,2
0,"public void setDay()
    {
       if ( step % 4 <= 1) { 
           day = true; 
        }
       else {
          day = false;
        } 
    }",Sets the day/night status of each step. Two steps represent each day,Step.java,164.0,2
1,"public void setSeason()
    {
        if ( step % 20 == 0 ){
            weather.setSummer();
        }
        else if (step % 20 == 10){
            weather.setSummer();
        }
    }",Sets the season status of each step. Ten steps represent each season,Step.java,164.0,2
2,"public boolean isDay()
    {
       return day;
    }",Returns whether it is day or not,Step.java,164.0,2
3,"public int getStep()
    {
        return step;
    }",Returns the number of steps taken,Step.java,164.0,2
4,"public void incrementStep()
    {
        step ++;
    }",Increments the number of steps taken by one,Step.java,164.0,2
5,"public void reset()
    {
        step = 0;
    }",Resets the number of steps taken to zero,Step.java,164.0,2
0,"public void actDay(List<Animal> newPenguins)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPenguins);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the penguin does most of the time: it hunts for
fish. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newPenguins A list to return newly born penguins.",Penguin.java,164.0,2
1,"public void actNight(List<Animal> newPenguins)
    {
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPenguins);            
        }
    }","This is what the Penguin does most of the time at Night time: ......Not confirmed
In the process, it might breed, die of hunger.
@param field The field currently occupied.
@param newPenguins A list to return newly born Penguins.",Penguin.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the penguin's death.,Penguin.java,164.0,2
3,"private void incrementHunger()
    {
        if(isDay()){
            foodLevel --;
        }
        else{
            foodLevel -= 2;
        }
        
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increase the hunger level. This could result in the polar bear's death.
At night,makes polar bear hungry more than Day time,
as it cannot hunt for a prey at Night.",Penguin.java,164.0,2
5,"private Location findFood()
    {
        Field field = getField();
        Step step = getStep();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Fish) {
                Fish fish = (Fish) animal;
                if(fish.isAlive()) { 
                    fish.setDead();
                    foodLevel = FISH_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for fish adjacent to the current location.
Only the first live fish is eaten.
@return Where food was found, or null if it wasn't.",Penguin.java,164.0,2
6,"private void giveBirth(List<Animal> newPenguins)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Penguin young = new Penguin(false, field, loc, step);
            newPenguins.add(young);
        }
    }","Check whether or not this penguin is to give birth at this step.
New births will be made into free adjacent locations.
@param newPenguins A list to return newly born penguins.",Penguin.java,164.0,2
7,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Penguin.java,164.0,2
8,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A penguin can breed if it has reached the breeding age.,Penguin.java,164.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,164.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,164.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,164.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,164.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,164.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,164.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,164.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,164.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,164.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,164.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,164.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,164.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,164.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,164.0,2
4,"protected void snowingEffect()
    {
        if(rand.nextDouble() <= DYING_PROBABILITY){
            setDead();
        }
    }",Uses a probability to set an animal to dead if it's snowing,Animal.java,164.0,2
5,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,164.0,2
6,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,164.0,2
7,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,164.0,2
0,"public void actDay(List<Animal> newAlgae)
    {
        incrementAge();
        if(isAlive()) {
            grow(newAlgae);            
        }
    }","This is what the algae does most of the time at Day time: it
checks to see if it can grow, and it ages and eventually dies.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Algae.java,164.0,2
1,"public void actNight(List<Animal> newAlgae)
    {
        
    }","As algae is a plant, it doesn't tend to act at night, when
there is no sunlight.",Algae.java,164.0,2
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the algae's death.,Algae.java,164.0,2
3,"public static void decreaseGrowth(){
        GROWTH_PROBABILITY -= 0.0002;
    }",This decreases the probability that the algae will grow,Algae.java,164.0,2
4,"private void grow(List<Animal> newAlgae)
    {
        // New algae grows into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        Step step = getStep();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = canGrow();
        for(int g = 0; g < births && free.size() > 0; g++) {
            Location loc = free.remove(0);
            Algae sapling = new Algae(false, field, loc, step);
            newAlgae.add(sapling);
        }
    }","Check whether or not this plant can grow at this step.
New plants will be put into free adjacent locations.
@param newAlgae A list to return newly grown algae.",Algae.java,164.0,2
5,"private int canGrow() 
    {
        int growths = 0;
        if(rand.nextDouble() <= GROWTH_PROBABILITY) {
            growths = rand.nextInt(GROWTH_SIZE) + 1;
        }
        return growths;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Algae.java,164.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,396.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,396.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,396.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,396.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,396.0,3
0,"public void act(List<Animal> newSharks)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (getGender() == 'f') {
                giveBirth(newSharks);  
            }
            move(); 
            becomeInfected();
            checkInfection();
        }
    }","This is what the shark does most of the time: it hunts for
plankton. In the process, it might breed, die of: hunger, old age
or disease.

@param newSharks A list to return newly born sharks.",Shark.java,396.0,3
1,"public Class getClassToEat() {
        return CLASS_TO_EAT;
    }",@return CLASS_TO_EAT The class that sharks eat.,Shark.java,396.0,3
2,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return MAX_AGE The maximum age of sharks.,Shark.java,396.0,3
3,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return FOOD_VALUE The value that the shark's food level gets set to when it eats.,Shark.java,396.0,3
4,"public double getBreedingProbability() {
        return BREEDING_PROBABILITY;
    }",@return BREEDING_PROBABILITY The probability that the shark breeds.,Shark.java,396.0,3
5,"public int getBreedingAge() {
        return BREEDING_AGE;        
    }",@return BREEDING_AGE The minimum age a shark has to be to breed.,Shark.java,396.0,3
6,"public int getMaxLitterSize() {
        return MAX_LITTER_SIZE;
    }",@return MAX_LITTER_SIZE The maximum number of children a shark can produce when breeding.,Shark.java,396.0,3
7,"public Animal createNewAnimal(Field field, Location loc) {
        Shark newShark = new Shark(false, field, loc);
        return newShark;
    }","Creates a new shark object and returns it.

@param field The field where the new shark is placed.
@param loc The location where the new shark is placed.

@return newShark The new shark object created.",Shark.java,396.0,3
8,"public void nightBehaviour(List<Animal> newAnimals) {
        incrementAge();
        incrementHunger();
    }","At night, sharks do not move but they still become hungry and age.

@param newAnimals List to store new animals created.",Shark.java,396.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,396.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,396.0,3
0,"public void act(List<Animal> newWhales)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (getGender() == 'f') {
                giveBirth(newWhales);
            }          
            move();  
            becomeInfected();
            checkInfection();
        }
    }","This is what the whale does most of the time: it hunts for
shrimp. In the process, it might breed, die of: hunger, old age
or disease.

@param newWhales A list to return newly born whales.",Whale.java,396.0,3
1,"public Class getClassToEat() {
        return CLASS_TO_EAT;
    }",@return CLASS_TO_EAT The class that whales eat.,Whale.java,396.0,3
2,"public Animal createNewAnimal(Field field, Location loc) {
        Whale newWhale = new Whale(false, field, loc);
        return newWhale;
    }","Creates a new whale object and returns it.

@param field The field where the new whale is placed.
@param loc The location where the new whale is placed.

@return newWhale The new whale object created.",Whale.java,396.0,3
3,"public double getBreedingProbability() {
        return BREEDING_PROBABILITY;
    }",@return BREEDING_PROBABILITY The probability that the whale breeds.,Whale.java,396.0,3
4,"public int getBreedingAge() {
        return BREEDING_AGE;        
    }",@return BREEDING_AGE The minimum age a whale has to be to breed.,Whale.java,396.0,3
5,"public int getMaxLitterSize() {
        return MAX_LITTER_SIZE;
    }",@return MAX_LITTER_SIZE The maximum number of children a whale can produce when breeding.,Whale.java,396.0,3
6,"public int getMaxAge() {
        return MAX_AGE;
    }",@return MAX_AGE The maximum age of whales.,Whale.java,396.0,3
7,"public int getFoodValue() {
        return FOOD_VALUE;
    }",@return FOOD_VALUE The value that the whale's food level gets set to when it eats.,Whale.java,396.0,3
8,"public void nightBehaviour(List<Animal> newAnimals) {
        incrementAge();
        incrementHunger();
    }","At night, whales do not move but they still become hungry and age.

@param newAnimals List to store new animals created.",Whale.java,396.0,3
0,"protected void grow(List<Plant> newPlants) {
        Field retrievedField = getField();
        List<Location> emptyLocations = retrievedField.getFreeAdjacentLocations(getLocation());
        
        for (Location freeLocation : emptyLocations) {
            Plant newPlant = createNewPlant(retrievedField, freeLocation);
            newPlants.add(newPlant);
        } 
    }","Checks for any empty spaces to grow.
Creates a new plant if there is an empty space.

@param newPlants A list to receive newly created plants.",Plant.java,396.0,3
0,"public void act(List<Animal> newShrimp)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            if (getGender() == 'f') {
                giveBirth(newShrimp);
            }          
            move(); 
            becomeInfected();
            checkInfection();
        }
    }","This is what the shrimp does most of the time: it searches for
seaweed. In the process, it might breed, die of: hunger, old age
or disease.

@param newShrimp A list to return newly born shrimp.",Shrimp.java,396.0,3
1,"public Class getClassToEat() {
        return CLASS_TO_EAT;
    }",@return CLASS_TO_EAT The class that shrimp eat.,Shrimp.java,396.0,3
2,"public Animal createNewAnimal(Field field, Location loc) {
        Shrimp newShrimp = new Shrimp(false, field, loc);
        return newShrimp;
    }","Creates a new shrimp object and returns it.

@param field The field where the new shrimp is placed.
@param loc The location where the new shrimp is placed.

@return newShrimp The new shrimp object created.",Shrimp.java,396.0,3
3,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return MAX_AGE The maximum age of shrimp.,Shrimp.java,396.0,3
4,"public double getBreedingProbability() {
        return BREEDING_PROBABILITY;
    }",@return BREEDING_PROBABILITY The probability that the shrimp breeds.,Shrimp.java,396.0,3
5,"public int getBreedingAge() {
        return BREEDING_AGE;        
    }",@return BREEDING_AGE The minimum age a shrimp has to be to breed.,Shrimp.java,396.0,3
6,"public int getMaxLitterSize() {
        return MAX_LITTER_SIZE;
    }",@return MAX_LITTER_SIZE The maximum number of children a shrimp can produce when breeding.,Shrimp.java,396.0,3
7,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return FOOD_VALUE The value that the shrimp's food level gets set to when it eats.,Shrimp.java,396.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,396.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,396.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,396.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,396.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,396.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,396.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,396.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,396.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,396.0,3
0,"public static void main(String[] args) {
        Simulator sim = new Simulator();
        sim.runLongSimulation();
    }",Main method to make running a long simulation easier.,Simulator.java,396.0,3
1,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,396.0,3
2,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            //delay(200);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.

@param numSteps The number of steps to run for.",Simulator.java,396.0,3
3,"public void simulateOneStep()
    {
        step++;

        Random random = Randomizer.getRandom();
        int randomNum = random.nextInt(Weather.values().length);
        // Choose a random weather condition.
        currentWeather = Weather.values()[randomNum];

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();        
        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();

            if (isDaytime()) {
                animal.act(newAnimals);
            } else {
                animal.nightBehaviour(newAnimals);
            }

            if(!animal.isAlive()) {
                it.remove();
            }
        }
        
        // Provide space for new plants.
        List<Plant> newPlants = new ArrayList<>();
        // Let all plants grow (act).
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();

            if(!plant.isAlive()) {
                it.remove();
            }

            if (!currentWeather.equals(Weather.LOW_TIDE)) {
                plant.act(newPlants);
            }
        }

        // Add the newly born animals to the main list.
        animals.addAll(newAnimals);
        // Add the newly grown plants to the main list.
        plants.addAll(newPlants);

        view.showStatus(step, field); 
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
animal and plant.",Simulator.java,396.0,3
4,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,396.0,3
5,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SHARK_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shark shark = new Shark(true, field, location);
                    animals.add(shark);
                }
                else if(rand.nextDouble() <= PLANKTON_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Plankton plankton = new Plankton(true, field, location);
                    animals.add(plankton);
                }else if(rand.nextDouble() <= TUNA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Tuna tuna = new Tuna(true, field, location);
                    animals.add(tuna);
                }else if(rand.nextDouble() <= WHALE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Whale whale = new Whale(true, field, location);
                    animals.add(whale);
                }else if(rand.nextDouble() <= SHRIMP_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shrimp shrimp = new Shrimp(true, field, location);
                    animals.add(shrimp);
                }else if(rand.nextDouble() <= SEAWEED_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Seaweed seaweed = new Seaweed(field, location);
                    plants.add(seaweed);
                }

                // else leave the location empty.
            }
        }
    }",Randomly populate the field with animals and plants.,Simulator.java,396.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.

@param millisec The time to pause for, in milliseconds",Simulator.java,396.0,3
7,"public boolean isDaytime() {
        if (step % DAY_NIGHT_CYCLE == 0) {
            daytime = !daytime;
        }
        return daytime;
    }","Returns whether it is daytime or not.
Note that the first day will last 1 less step than the others.

@return daytime Whether it is daytime or not.",Simulator.java,396.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,396.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,396.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,396.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,396.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,396.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,396.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }","Implement content equality.

@param obj Object to check equality against.",Location.java,396.0,3
1,"public String toString()
    {
        return ""("" + row + "","" + col + "")"";
    }","Return a string of the form row,column

@return A string representation of the location.",Location.java,396.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.

@return A hashcode for the location.",Location.java,396.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,396.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,396.0,3
0,"protected boolean isAlive() { 
        return alive; 
    }","Check whether the organism is alive or not.

@return true if the organism is still alive.",Organism.java,396.0,3
1,"protected void setDead() { 
        alive = false; 

        if(location != null) { 
            field.clear(location); 
            location = null; 
            field = null; 
        } 
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,396.0,3
2,"protected Location getLocation() { 
        return location; 
    }",@return location The organism's location.,Organism.java,396.0,3
3,"protected void setLocation(Location newLocation) { 
        if(location != null) { 
            field.clear(location); 
        } 

        location = newLocation; 
        field.place(this, newLocation); 
    }","Place the organism at the new location in the given field.

@param newLocation The organism's new location.",Organism.java,396.0,3
4,"protected Field getField() { 
        return field; 
    }",@return field The organism's field.,Organism.java,396.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,396.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,396.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,396.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,396.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,396.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,396.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,396.0,3
0,"public void act(List<Plant> newPlants){
        if (isAlive()) {
            double growthCheck = random.nextDouble();
        
            if (growthCheck <= getGrowthProbability()) {
                grow(newPlants);
            }
        }
    }","Make this seaweed act - that is: make it do
whatever it wants/needs to do.

@param newPlants A list to receive newly born plants.",Seaweed.java,396.0,3
1,"public Plant createNewPlant(Field field, Location location) {
        Seaweed newSeaweed = new Seaweed(field, location);
        return newSeaweed;
    }","Creates a new seaweed object and returns it.

@param field The field where the new seaweed is placed.
@param loc The location where the new seaweed is placed.

@return newSeaweed The new seaweed object created.",Seaweed.java,396.0,3
2,"public double getGrowthProbability(){
        return GROWTH_PROBABILTY;
    }",@return GROWTH_PROBABILTY The growth probability of the seaweed.,Seaweed.java,396.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,396.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.

@param location The location to clear.",Field.java,396.0,3
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.

@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,396.0,3
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.

@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,396.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.

@param location Where in the field.

@return The animal at the given location, or null if there is none.",Field.java,396.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.

@param row The desired row.
@param col The desired column.

@return The animal at the given location, or null if there is none.",Field.java,396.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.

@param location The location from which to generate an adjacency.

@return A valid location within the grid area.",Field.java,396.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.

@param location Get locations adjacent to this.

@return A list of free adjacent locations.",Field.java,396.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.

@param location The location from which to generate an adjacency.

@return A valid location within the grid area.",Field.java,396.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.

@param location The location from which to generate adjacencies.

@return A list of locations adjacent to that given.",Field.java,396.0,3
10,"public int getDepth()
    {
        return depth;
    }",@return The depth of the field.,Field.java,396.0,3
11,"public int getWidth()
    {
        return width;
    }",@return The width of the field.,Field.java,396.0,3
0,"public void act(List<Animal> newPlanktons)
    {
        incrementAge();
        incrementHunger();

        if(isAlive()) {
            if (getGender() == 'f') {
                giveBirth(newPlanktons);
            }           
            move();
            becomeInfected();
            checkInfection();
        }
    }","This is what the plankton does most of the time - it runs
around. Sometimes it will breed or die of old age.

@param newPlanktons A list to return newly born planktons.",Plankton.java,396.0,3
1,"public Class getClassToEat() {
        return CLASS_TO_EAT;
    }",@return CLASS_TO_EAT The class that plankon eat.,Plankton.java,396.0,3
2,"public Animal createNewAnimal(Field field, Location loc) {
        Plankton newPlankton = new Plankton(false, field, loc);
        return newPlankton;
    }","Creates a new plankon object and returns it.

@param field The field where the new plankon is placed.
@param loc The location where the new plankon is placed.

@return newPlankton The new plankon object created.",Plankton.java,396.0,3
3,"public double getBreedingProbability() {
        return BREEDING_PROBABILITY;
    }",@return BREEDING_PROBABILITY The probability that the plankton breeds.,Plankton.java,396.0,3
4,"public int getBreedingAge() {
        return BREEDING_AGE;        
    }",@return BREEDING_AGE The minimum age a plankton has to be to breed.,Plankton.java,396.0,3
5,"public int getMaxLitterSize() {
        return MAX_LITTER_SIZE;
    }",@return MAX_LITTER_SIZE The maximum number of children a plankton can produce when breeding.,Plankton.java,396.0,3
6,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return MAX_AGE The maximum age of plankton.,Plankton.java,396.0,3
7,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return FOOD_VALUE The value that the plankton's food level gets set to when it eats.,Plankton.java,396.0,3
0,"protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the animal's death.,Animal.java,396.0,3
1,"protected void setAge(int newAge)
    {
        age = newAge;
    }","Sets the age of the animal.

@param newAge The new age of the animal.",Animal.java,396.0,3
2,"protected int getAge()
    {
        return age;
    }",@return age The age of the animal.,Animal.java,396.0,3
3,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }","Increases how hungry the animal is by decreasing their food level.
The animal can die from starvation.",Animal.java,396.0,3
4,"protected void setFoodLevel()
    {
        foodLevel = getFoodValue();
    }",Sets the food level.,Animal.java,396.0,3
5,"protected int getFoodLevel()
    {
        return foodLevel;
    }",@return foodLevel The food level of the animal.,Animal.java,396.0,3
6,"protected char getGender() {
        return gender;
    }",@return gender The gender of the animal.,Animal.java,396.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();

        // Holds the class that the animal eats.
        Class toEat = getClassToEat();

        // If the class that the animal eats is null, 
        // then it is assumed that the animal constantly eats and cannot die of starvation.
        if (toEat == null) {
            setFoodLevel();
            return null;
        }

        // Iterates through the neighbouring locations and checks if there is a food source for them to eat.
        // If there is then, the food level is set to its maximum and the location of the food source is returned.
        // Otherwise, null is returned.
        while(it.hasNext()) {
            Location where = it.next();
            Object food = field.getObjectAt(where);

            if(toEat.isInstance(food)) {
                if (food instanceof Organism) {
                    Organism castedOrganism = (Organism) food;

                    if(castedOrganism.isAlive()) { 
                        castedOrganism.setDead();
                        setFoodLevel();
                        return where;
                    }
                }
            }
        }
        return null;
    }","Look for food adjacent to the current location.
Only the first live piece of food is eaten.

@return Where food was found, or null if it wasn't.",Animal.java,396.0,3
8,"protected void move() {
        // Move towards a source of food if found.
        Location newLocation = findFood();

        if(newLocation == null) { 
            // No food found - try to move to a free location.
            newLocation = getField().freeAdjacentLocation(getLocation());
        }

        // See if it was possible to move.
        if(newLocation != null) {
            setLocation(newLocation);
        }
        else {
            // Overcrowding.
            setDead();
        }
    }","Causes the animal to move into a different cell.
Either towards a food source or a neighbouring empty location.
The animal can also die from overcrowding if there are no empty neighbouring cells.",Animal.java,396.0,3
9,"public String toString(){
        if (this.isAlive()) {
            return ""Animal at location: "" + getLocation().toString();
        }

        return ""Animal is dead and has no location"";
    }",@return A string that shows that there is an animal object in a location.,Animal.java,396.0,3
10,"protected void giveBirth(List<Animal> newAnimals)
    {
        // New animals are born into adjacent locations.
        Field field = getField();
        // Get a list of adjacent free locations.
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();

        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);            
            Animal young = createNewAnimal(field, loc);
            newAnimals.add(young);
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.

@param newAnimals A list to return newly born animals.",Animal.java,396.0,3
11,"private int breed()
    {
        int births = 0;
        if(canBreed() && randomGenerator.nextDouble() <= getBreedingProbability()) {
            births = randomGenerator.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.

@return births The number of births (may be zero).",Animal.java,396.0,3
12,"private boolean canBreed()
    {
        return getAge() >= getBreedingAge() && foundMate();
    }","An animal can breed if it has reached the breeding age and found a mate.

@return true If this animal satisfies the conditions for breeding.",Animal.java,396.0,3
13,"private boolean foundMate() {
        Field field = getField();
        List<Location> neighbours = field.adjacentLocations(getLocation());

        for(Location location: neighbours) {
            Object currentObject = field.getObjectAt(location);
            Class thisClass = getClass();

            // Checks if the neighbouring object is of the same animal type.
            if (thisClass.isInstance(currentObject)) {
                Animal currentAnimal = (Animal) currentObject;
                if (currentAnimal.getGender() == 'm') {
                    return true;
                }
            }
        }

        return false;
    }","Tries to find a mate in a neighbouring cell.
The mate must be from the same species as the current animal
and be male (since only female animals can give birth).

@return true If the animal has found a suitable mate.",Animal.java,396.0,3
14,"public void nightBehaviour(List<Animal> newAnimals) {
        act(newAnimals);
    }","By default, the animal will act the same at night time.

@param newAnimals List to store new animals created.",Animal.java,396.0,3
15,"protected void becomeInfected()
    {
        if(isAlive()){
            Field field = getField();
            List<Location> neighbours = field.adjacentLocations(getLocation());

            for(Location location: neighbours) {
                Object currentObject = field.getObjectAt(location);
                if(currentObject != null){
                    if (currentObject instanceof Animal) {
                        Animal neighbourAnimal = (Animal) currentObject;
                        if(neighbourAnimal.getIsInfected()) {
                            setInfected();
                        }
                    }
                }   
            }
        } 
    }","Checks if the animal is neighbouring another animal that is infected.
If they are, then the animal also becomes infected.",Animal.java,396.0,3
16,"private void setInfected()
    {
        double infection = randomGenerator.nextDouble();
        isInfected = infection <= infectionSpread ? true : false;
    }","The animal becomes infected based on the probability of the infection spreading.
(This only happens if there is a neighbouring infected animal).",Animal.java,396.0,3
17,"private boolean getIsInfected()
    {
        return isInfected;
    }",@return isInfected Whether or not an animal is infected or not.,Animal.java,396.0,3
18,"protected void checkInfection()
    {
        if(isAlive()){
            if (isInfected){
                incrementAge();
            }   
        }
    }","If the animal is infected, then they age twice as fast.",Animal.java,396.0,3
0,"public void act(List<Animal> newTuna)
    {
        incrementAge();
        incrementHunger(); 
        if(isAlive()) {
            if (getGender() == 'f') {
                giveBirth(newTuna);
            }
            move();
            becomeInfected();
            checkInfection();
        }
    }","This is what the tuna does most of the time - it swims
around. Sometimes it will breed, die of old age or become infected.

@param newTuna A list to return newly born tuna.",Tuna.java,396.0,3
1,"public Animal createNewAnimal(Field field, Location loc) {
        Tuna newTuna = new Tuna(false, field, loc);
        return newTuna;
    }","Creates a new tuna object and returns it.

@param field The field where the new tuna is placed.
@param loc The location where the new tuna is placed.

@return newTuna The new tuna object created.",Tuna.java,396.0,3
2,"public Class getClassToEat() {
        return CLASS_TO_EAT;
    }",@return CLASS_TO_EAT The class that tuna eat.,Tuna.java,396.0,3
3,"public double getBreedingProbability() {
        return BREEDING_PROBABILITY;
    }",@return BREEDING_PROBABILITY The probability that the tuna breeds.,Tuna.java,396.0,3
4,"public int getBreedingAge() {
        return BREEDING_AGE;        
    }",@return BREEDING_AGE The minimum age a tuna has to be to breed.,Tuna.java,396.0,3
5,"public int getMaxLitterSize() {
        return MAX_LITTER_SIZE;
    }",@return MAX_LITTER_SIZE The maximum number of children a tuna can produce when breeding.,Tuna.java,396.0,3
6,"public int getMaxAge()
    {
        return MAX_AGE;
    }",@return MAX_AGE The maximum age of tuna.,Tuna.java,396.0,3
7,"public int getFoodValue()
    {
        return FOOD_VALUE;
    }",@return FOOD_VALUE The value that the tuna food level gets set to when it eats.,Tuna.java,396.0,3
8,"public void nightBehaviour(List<Animal> newAnimals) {
        incrementAge();
        incrementHunger();
    }","During the night, tuna will not move but will still age and get hungry.
@param newAnimals List to store new animals created.",Tuna.java,396.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,362.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,362.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,362.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,362.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,362.0,3
0,"public void act(List<Animal> newSquids)
    {
        incrementAge();
        incrementHunger();

        //Disease
        if(isAlive() && isInfected()){
            spreadDisease(); //Infect other squid if infected
            adjustHealth();
        }

        if(isAlive()) {
            //Reproduce if possible 
            if(meet()){
                giveBirth(newSquids);   
            }

            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the squid does most of the time: it consumes
crabs. In the process, it might breed, die of hunger,
or die of old age.

@param newSquids A list to return newly born squids.",Squid.java,362.0,3
1,"public boolean meet()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Squid) {
                Squid squid = (Squid) animal;
                if(! squid.getSex().equals(sex)) { 
                    return true;   
                }
            }
        }
        return false; 
    }","Checks neighbouring locations.
If another squid of the opposite gender is found, calls giveBirth method
If another squid of the same gender is found, return false
If another animal/plant type is found, return false",Squid.java,362.0,3
2,"public void giveBirth(List<Animal> newSquids)
    {
        // New squids are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Squid young = new Squid(false, field, loc);
            newSquids.add(young);
        }
    }","Check whether or not this squid is to give birth at this step.
New births will be made into free adjacent locations.
@param newSquids A list to return newly born squids.",Squid.java,362.0,3
3,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Crab) {
                Crab crab = (Crab) animal;
                if(crab.isAlive()) { 
                    crab.setDead();
                    foodLevel = crab.getFoodValue();
                    return where;
                }
            }
        }
        return null;
    }","Look for crabs adjacent to the current location.
Only the first live crab is eaten.
@return Where food was found, or null if it wasn't.",Squid.java,362.0,3
4,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Squid) {
                infect(animal); 
            }
        }
    }","Look for squids in adjacent locations.
If squids are found, try to infect them.",Squid.java,362.0,3
5,"public void incrementHunger()
    {
        foodLevel--;
        dieOfHunger(); 
    }",Make this squid more hungry. This could result in the squid's death.,Squid.java,362.0,3
6,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the squid's death.,Squid.java,362.0,3
7,"public int getBreedingAge()
    {
        return BREEDING_AGE; 
    }","Returns the age at which a squid can start to breed.

@return the age at which a squid can start to breed",Squid.java,362.0,3
8,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a squid can live.

@return the age to which a squid can live",Squid.java,362.0,3
9,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY; 
    }","Returns the likelihood of a squid breeding.

@return the likelihood of a squid breeding",Squid.java,362.0,3
10,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE; 
    }","Returns the maximum number of births.

@return the maximum number of births",Squid.java,362.0,3
11,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single squid.
In effect, this is the food value its predator gets when a squid is eaten.

@return the food value of a single squid",Squid.java,362.0,3
12,"public int getPreyFoodValue()
    {
        return PREY_FOOD_VALUE; 
    }","Returns the highest food value of an squid's prey.
In effect, this is the food value of crab

@return the highest food value of an squid's prey (crab)",Squid.java,362.0,3
13,"public int getAge()
    {
        return age; 
    }","Returns the squid's age.

@return the squid's age",Squid.java,362.0,3
14,"public int getFoodLevel()
    {
        return foodLevel; 
    }","Returns the squid's food level, which is increased by eating crab.

@return the squid's food level",Squid.java,362.0,3
15,"public String getSex()
    {
        return sex; 
    }","Returns the squid's sex.

@return the squid's sex",Squid.java,362.0,3
0,"public void act(List<Animal> newSharks)
    {
        incrementAge();
        incrementHunger();

        //Disease
        if(isAlive() && isInfected()){
            spreadDisease(); //Infect other sharks if infected
            adjustHealth();
        }

        if(isAlive()) {
            //Reproduce if possible 
            if(meet()){
                giveBirth(newSharks);   
            }

            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the shark does most of the time: it consumes
whales and dolphins. In the process, it might breed, die of hunger,
or die of old age.

If a shark has a disease, it may infect other whales.

@param newSharks A list to return newly born sharks.",Shark.java,362.0,3
1,"public boolean meet()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Shark) {
                Shark shark = (Shark) animal;
                if(! shark.getSex().equals(sex)) { 
                    return true;   
                }
            }
        }
        return false; 
    }","Checks neighbouring locations.
If another shark of the opposite gender is found, calls giveBirth method.
If another shark of the same gender is found, return false.
If another animal/plant type is found, return false.",Shark.java,362.0,3
2,"public void giveBirth(List<Animal> newSharks)
    {
        // New sharks are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Shark young = new Shark(false, field, loc);
            newSharks.add(young);
        }
    }","Check whether or not this shark is to give birth at this step.
New births will be made into free adjacent locations.
@param newSharks A list to return newly born sharks.",Shark.java,362.0,3
3,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Whale) {
                Whale whale = (Whale) animal;
                if(whale.isAlive()) { 
                    whale.setDead();
                    foodLevel = whale.getFoodValue();
                    return where;
                }
                else if(animal instanceof Dolphin) {
                    Dolphin dolphin = (Dolphin) animal;
                    if(dolphin.isAlive()) { 
                        dolphin.setDead();
                        foodLevel = dolphin.getFoodValue();
                        return where;
                    }
                }
            }
        }
        return null;
    }","Look for whales and dolphins adjacent to the current location.
Only the first live whale or dolphin is eaten.
Sharks always show a preference for whales.
@return Where food was found, or null if it wasn't.",Shark.java,362.0,3
4,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Shark) {
                infect(animal); 
            }
        }
    }","Look for sharks in adjacent locations.
If sharks are found, try to infect them.",Shark.java,362.0,3
5,"public void incrementHunger()
    {
        foodLevel--;
        dieOfHunger(); 
    }",Make this shark more hungry. This could result in the shark's death.,Shark.java,362.0,3
6,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the shark's death.,Shark.java,362.0,3
7,"public int getBreedingAge()
    {
        return BREEDING_AGE; 
    }","Returns the age at which a shark can start to breed.

@return the age at which a shark can start to breed",Shark.java,362.0,3
8,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a shark can live.

@return the age to which a shark can live",Shark.java,362.0,3
9,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY; 
    }","Returns the likelihood of a shark breeding.

@return the likelihood of a shark breeding",Shark.java,362.0,3
10,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE; 
    }","Returns the maximum number of births.

@return the maximum number of births",Shark.java,362.0,3
11,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single shark.
In effect, this is the food value its predator gets when a shark is eaten.

@return the food value of a single shark",Shark.java,362.0,3
12,"public int getPreyFoodValue()
    {
        return PREY_FOOD_VALUE; 
    }","Returns the highest food value of a shark's prey.
In effect, this is the food value of whale.

@return the highest food value of a shark's prey (whale)",Shark.java,362.0,3
13,"public int getAge()
    {
        return age; 
    }","Returns the shark's age.

@return the shark's age",Shark.java,362.0,3
14,"public int getFoodLevel()
    {
        return foodLevel; 
    }","Returns the shark's food level, which is increased by eating whales.

@return the shark's food level",Shark.java,362.0,3
15,"public String getSex()
    {
        return sex; 
    }","Returns the shark's sex.

@return the shark's sex",Shark.java,362.0,3
0,"public void act(List<Animal> newCrabs)
    {
        incrementAge();

        if(time.getTime().equalsIgnoreCase(""day"")){
            incrementHunger();

            //Disease
            if(isAlive() && isInfected()){
                spreadDisease(); //Infect other crabs if infected
                adjustHealth();
            }

            if(isAlive()) {

                //Reproduce if possible 
                if(meet()){
                    giveBirth(newCrabs);   
                }

                // Move towards a source of food if found.
                Location newLocation = findFood();
                if(newLocation == null) { 
                    // No food found - try to move to a free location.
                    newLocation = getField().freeAdjacentLocation(getLocation());
                }
                // See if it was possible to move.
                if(newLocation != null) {
                    setLocation(newLocation);
                }
                else {
                    // Overcrowding.
                    setDead();
                }
            }
        }
    }","This is what the crab does most of the time: it hunts for
seaweed. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newCrabs A list to return newly born crabs.",Crab.java,362.0,3
1,"public boolean meet()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Crab) {
                Crab crab = (Crab) animal;
                if(! crab.getSex().equals(sex)) { 
                    return true;   
                }
            }
        }
        return false; 
    }","Checks neighbouring locations.
If another crab of the opposite gender is found, calls giveBirth method
If another crab of the same gender is found, return false
If another animal/plant type is found, return false",Crab.java,362.0,3
2,"public void giveBirth(List<Animal> newCrabs)
    {
        // New crabs are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Crab young = new Crab(false, field, loc);
            newCrabs.add(young);
        }
    }","Check whether or not this crab is to give birth at this step.
New births will be made into free adjacent locations.
@param newCrabs A list to return newly born crabs.",Crab.java,362.0,3
3,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            //generate a randPreference
            Random randomPreferenceGenerator = new Random(); 
            int randPreference = randomPreferenceGenerator.nextInt(2); 
            if (randPreference == 0) {
                //prefer seaweed
                if(organism instanceof Seaweed) {
                    Seaweed seaweed = (Seaweed) organism;
                    if(seaweed.isAlive()) { 
                        seaweed.setDead();
                        foodLevel = seaweed.getFoodValue();
                        return where;
                    }
                }
                else if(organism instanceof Phytoplankton) {
                    Phytoplankton phytoplankton = (Phytoplankton) organism;
                    if(phytoplankton.isAlive()) { 
                        phytoplankton.setDead();
                        foodLevel = phytoplankton.getFoodValue();
                        return where;
                    }
                }
            }
            else {
                //prefer phytoplankton 
                if(organism instanceof Phytoplankton) {
                    Phytoplankton phytoplankton = (Phytoplankton) organism;
                    if(phytoplankton.isAlive()) { 
                        phytoplankton.setDead();
                        foodLevel = phytoplankton.getFoodValue();
                        return where;
                    }
                }
                else if(organism instanceof Seaweed) {
                    Seaweed seaweed = (Seaweed) organism;
                    if(seaweed.isAlive()) { 
                        seaweed.setDead();
                        foodLevel = seaweed.getFoodValue();
                        return where;
                    }
                }
            }
        }
        return null;
    }","Look for seaweed and phytoplankton adjacent to the current location.
Randomly eats the first seaweed of phytoplankton found.
@return Where food was found, or null if it wasn't.",Crab.java,362.0,3
4,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Crab) {
                infect(animal); 
            }
        }
    }","Look for crabs in adjacent locations.
If crabs are found, try to infect them.",Crab.java,362.0,3
5,"public void incrementHunger()
    {
        foodLevel--;
        dieOfHunger(); 
    }",Make this crab more hungry. This could result in the crab's death.,Crab.java,362.0,3
6,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the crab's death.,Crab.java,362.0,3
7,"public int getBreedingAge()
    {
        return BREEDING_AGE; 
    }","Returns the age at which a crab can start to breed.

@return the age at which a crab can start to breed",Crab.java,362.0,3
8,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a crab can live.

@return the age to which a crab can live",Crab.java,362.0,3
9,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY; 
    }","Returns the likelihood of a crab breeding.

@return the likelihood of a crab breeding",Crab.java,362.0,3
10,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE; 
    }","Returns the maximum number of births.

@return the maximum number of births",Crab.java,362.0,3
11,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single crab.
In effect, this is the food value its predator gets when a crab is eaten.

@return the food value of a single crab",Crab.java,362.0,3
12,"public int getPreyFoodValue()
    {
        return PREY_FOOD_VALUE; 
    }","Returns the highest food value of an crab's food.
In effect, this is the food value of seaweed

@return the highest food value of an crab's food (seaweed)",Crab.java,362.0,3
13,"public int getAge()
    {
        return age; 
    }","Returns the crab's age.

@return the crab's age",Crab.java,362.0,3
14,"public int getFoodLevel()
    {
        return foodLevel; 
    }","Returns the crab's food level, which is increased by eating seaweed.

@return the crab's food level",Crab.java,362.0,3
15,"public String getSex()
    {
        return sex; 
    }","Returns the crab's sex.

@return the crab's sex",Crab.java,362.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,362.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,362.0,3
0,"public void initialiseColors()
    {
        // Create a view of the state of each location in the field.
        view.setColor(Crab.class, Color.ORANGE);
        view.setColor(Squid.class, Color.PINK);
        view.setColor(Shark.class, Color.MAGENTA);
        view.setColor(Whale.class, Color.BLUE);
        view.setColor(Dolphin.class, Color.GRAY);
        view.setColor(Seaweed.class, Color.GREEN);
        view.setColor(Phytoplankton.class, Color.CYAN);
        view.setColor(Hunter.class, Color.RED);
    }",This method assigns unique colors to each type of organism.,FieldSetup.java,362.0,3
1,"public void populateHunters(Simulator simulator)
    {
        hunters = simulator.getHunters();
        Random rand = Randomizer.getRandom();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= HUNTER_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Hunter hunter = new Hunter(field, location);
                    hunters.add(hunter);
                }
                // else leave the location empty.
            }
        }
    }",Add hunters to the field.,FieldSetup.java,362.0,3
2,"public void populate(Simulator simulator)
    {
        animals = simulator.getAnimals();
        plants = simulator.getPlants();
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= SQUID_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Squid squid = new Squid(true, field, location);
                    animals.add(squid);
                }
                else if(rand.nextDouble() <= CRAB_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Crab crab = new Crab(true, field, location);
                    animals.add(crab);
                }
                else if(rand.nextDouble() <= SHARK_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Shark shark = new Shark(true, field, location);
                    animals.add(shark);
                }
                else if(rand.nextDouble() <= WHALE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Whale whale = new Whale(true, field, location);
                    animals.add(whale);
                }
                else if(rand.nextDouble() <= DOLPHIN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Dolphin dolphin = new Dolphin(true, field, location);
                    animals.add(dolphin);
                }
                else if(rand.nextDouble() <= SEAWEED_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Seaweed seaweed = new Seaweed(true, field, location);
                    plants.add(seaweed);
                }
                else if(rand.nextDouble() <= PHYTOPLANKTON_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Phytoplankton phytoplankton = new Phytoplankton(true, field, location);
                    plants.add(phytoplankton);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with organisms.,FieldSetup.java,362.0,3
0,"public void act(List<Animal> newWhales)
    {
        incrementAge();
        incrementHunger();
        
        //Disease
        if(isAlive() && isInfected()){
            spreadDisease(); //Infect other whales if infected
            adjustHealth();
        }
        
        if(isAlive()) {
            //Reproduce if possible 
            if(meet()){
                giveBirth(newWhales);   
            }

            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the whale does most of the time: it consumes
dolphins. In the process, it might breed, die of hunger,
or die of old age.

@param field The field currently occupied.
@param newWhales A list to return newly born whales.",Whale.java,362.0,3
1,"public boolean meet()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Whale) {
                Whale whale = (Whale) animal;
                if(! whale.getSex().equals(sex)) { 
                    return true;   
                }
            }
        }

        return false; 
    }","Checks neighbouring locations.
If another whale of the opposite gender is found, calls giveBirth method
If another whale of the same gender is found, return false
If another animal/plant type is found, return false",Whale.java,362.0,3
2,"public void giveBirth(List<Animal> newWhales)
    {
        // New whales are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Whale young = new Whale(false, field, loc);
            newWhales.add(young);
        }
    }","Check whether or not this whale is to give birth at this step.
New births will be made into free adjacent locations.
@param newWhales A list to return newly born whales.",Whale.java,362.0,3
3,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dolphin) {
                Dolphin dolphin = (Dolphin) animal;
                if(dolphin.isAlive()) { 
                    dolphin.setDead();
                    foodLevel = dolphin.getFoodValue();
                    return where;
                }
            }
        }
        return null;
    }","Look for dolphins adjacent to the current location.
Only the first live dolphin is eaten.
@return Where food was found, or null if it wasn't.",Whale.java,362.0,3
4,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Whale) {
                infect(animal); 
            }
        }
    }","Look for whales in adjacent locations.
If whales are found, try to infect them.",Whale.java,362.0,3
5,"public void incrementHunger()
    {
        foodLevel--;
        dieOfHunger(); 
    }",Make this whale more hungry. This could result in the whale's death.,Whale.java,362.0,3
6,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the whale's death.,Whale.java,362.0,3
7,"public int getBreedingAge()
    {
        return BREEDING_AGE; 
    }","Returns the age at which a whale can start to breed.

@return the age at which a whale can start to breed",Whale.java,362.0,3
8,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a whale can live.

@return the age to which a whale can live",Whale.java,362.0,3
9,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY; 
    }","Returns the likelihood of a whale breeding.

@return the likelihood of a whale breeding",Whale.java,362.0,3
10,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE; 
    }","Returns the maximum number of births.

@return the maximum number of births",Whale.java,362.0,3
11,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single whale.
In effect, this is the food value its predator gets when a whale is eaten.

@return the food value of a single whale",Whale.java,362.0,3
12,"public int getPreyFoodValue()
    {
        return PREY_FOOD_VALUE; 
    }","Returns the highest food value of a whale's prey.
In effect, this is the food value of dolphin

@return the highest food value of a whale's prey (dolphin)",Whale.java,362.0,3
13,"public int getAge()
    {
        return age; 
    }","Returns the whale's age.

@return the whale's age",Whale.java,362.0,3
14,"public int getFoodLevel()
    {
        return foodLevel; 
    }","Returns the whale's food level, which is increased by eating dolphin.

@return the whale's food level",Whale.java,362.0,3
15,"public String getSex()
    {
        return sex; 
    }","Returns the whale's sex.

@return the whale's sex",Whale.java,362.0,3
0,"public void changeWeather()
    {
        if(weather.equalsIgnoreCase(""rainy"")){
            weather = ""sunny"";
        }
        else{
            weather = ""rainy"";
        }
    }","Changes the weather when called.
If rainy, change to sunny.
If dry, change to sunny.",Weather.java,362.0,3
1,"public void setWeather(String weather)
    {
        this.weather = weather; 
    }","Set weather to string in parameter.

@param weather Type of weather (rainy or sunny)",Weather.java,362.0,3
2,"public String getWeather()
    {
        return weather; 
    }","Returns the current weather

@return the current weather",Weather.java,362.0,3
0,"protected void dieOfAge()
    {
        if(getAge() > getMaxAge()) {
            setDead();
        }
    }","If age exceeds max age, the plant dies.",Plant.java,362.0,3
1,"protected int breed()
    {
        int shoots = 0;
        if(canBreed() && rand.nextDouble() <= getShootProductionProbability()) {
            shoots = rand.nextInt(getMaxShootProduction()) + 1;
        }
        return shoots;
    }","Generate a number representing the number of new shoots,
if it can grow.
@return The number of shoots (may be zero).",Plant.java,362.0,3
2,"protected boolean canBreed()
    {
        return getAge() >= getShootProductionAge();
    }","A plant can produce new shoots if it has reached the breeding age.
@return true if the plant can breed, false otherwise.",Plant.java,362.0,3
0,"public String getName()
    {
        return name;
    }",@return The name for this simulation participant.,Counter.java,362.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,362.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,362.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,362.0,3
0,"public void changeTime()
    {
        if(timeOfDay.equalsIgnoreCase(""day"")){
            timeOfDay = ""night"";
        }
        else{
            timeOfDay = ""day"";
            days++;
        }
    }","Change the time of day (day or night).
If day, change to night.
If night, change to day.",TimeOfDay.java,362.0,3
1,"public void setTime(String time)
    {
        timeOfDay = time; 
    }","Change the time of day (day or night) to the time set in
the paramater.",TimeOfDay.java,362.0,3
2,"public String getTime()
    {
        return timeOfDay; 
    }","Returns the current time (day or night)

@return the current time",TimeOfDay.java,362.0,3
3,"public int getDaysPassed()
    {
        return days; 
    }",@return the number of days passed in the field,TimeOfDay.java,362.0,3
4,"public void resetDaysPassed()
    {
        days = 0; 
    }",Set days passed to 0,TimeOfDay.java,362.0,3
0,"public void setTimeOfDayColor()
    {
        if(time.getTime().equalsIgnoreCase(""day"")){
            //set day color
            EMPTY_COLOR = Color.white; 
        }
        else{
            //set night color
            EMPTY_COLOR = Color.black; 
        }
    }",Changes the background color to represent day/night,SimulatorView.java,362.0,3
1,"public void setColor(Class organismClass, Color color)
    {
        colors.put(organismClass, color);
    }","Define a color to be used for a given class of organism.
@param organismClass The organism's Class object.
@param color The color to be used for the given class.",SimulatorView.java,362.0,3
2,"public void setSettingLabelText()
    {
        settingText = ""Time: "" + time.getTime() + ""    Weather: "" + weather.getWeather();  
        settingLabel.setText(settingText);
    }",Display a the current time and weather in the field at the top of the window.,SimulatorView.java,362.0,3
3,"public void setDaysLabelText()
    {
        daysText = ""Days Passed: "" + time.getDaysPassed();   
        daysLabel.setText(daysText);
    }",Display the number of days passed in the field at the top of the window.,SimulatorView.java,362.0,3
4,"private Color getColor(Class organismClass)
    {
        Color col = colors.get(organismClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of organism.,SimulatorView.java,362.0,3
5,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }

        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();

        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object organism = field.getObjectAt(row, col);
                if(organism != null) {
                    stats.incrementCount(organism.getClass());
                    fieldView.drawMark(col, row, getColor(organism.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,362.0,3
6,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,362.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,362.0,3
1,"public void simulateOneDay()
    {
        simulate(LENGTH_OF_DAY*2);
    }","Run the simulation from its current state for a period of one day
(one day and one night)",Simulator.java,362.0,3
2,"public void simulateOneWeek()
    {
        simulate(LENGTH_OF_DAY*7*2);
    }","Run the simulation from its current state for a period of one week
(7 days and 7 nights)",Simulator.java,362.0,3
3,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,362.0,3
4,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();  
        // Provide space for newborn plants.
        List<Plant> newPlants = new ArrayList<>();  

        // Let all animals act.
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }

        // Let all plants act.
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.act(newPlants);
            if(! plant.isAlive()) {
                it.remove();
            }
        }

        // Let all hunters hunt.
        for(Iterator<Hunter> it = hunters.iterator(); it.hasNext(); ) {
            Hunter hunter = it.next();
            hunter.hunt();
            if(! hunter.isAlive()) {
                it.remove();
            }
        }

        // Add the newly born animals to the main lists.
        animals.addAll(newAnimals);
        // Add the newly born plants to the main lists.
        plants.addAll(newPlants);

        //adjust background colour for time of day 
        if(step%LENGTH_OF_DAY == 0){
            //change time of day
            time.changeTime(); 
            view.setTimeOfDayColor(); 
            view.setSettingLabelText();
        }

        //adjust weather label 
        if(step%LENGTH_OF_SEASON == 0){
            weather.changeWeather(); 
            view.setSettingLabelText();
        }

        //add hunters to the field after 3 days
        if((time.getDaysPassed() == 3) && !huntersAdded){
            fieldSetup.populateHunters(this); 
            huntersAdded = true; 
        }

        view.setDaysLabelText(); 

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
organism.",Simulator.java,362.0,3
5,"public void reset()
    {
        step = 0;
        time.setTime(""day""); 
        view.setTimeOfDayColor(); 
        weather.setWeather(""sunny"");
        time.resetDaysPassed();
        view.setDaysLabelText(); 
        animals.clear();
        plants.clear();
        hunters.clear(); 
        huntersAdded = false; 

        // Repopulates field to initial state.
        fieldSetup.populate(this);

        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,362.0,3
6,"public List getAnimals()
    {
        return animals;
    }",@return animals The list of animals on the field.,Simulator.java,362.0,3
7,"public List getPlants()
    {
        return plants;
    }",@return plants The list of plants on the field.,Simulator.java,362.0,3
8,"public List getHunters()
    {
        return hunters;
    }",@return hunters The list of hunters on the field.,Simulator.java,362.0,3
9,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,362.0,3
0,"public void act(List<Plant> newPhytoplanktons)
    {
        incrementAge();
        if(isAlive()) {
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                giveBirth(newPhytoplanktons);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the phytoplankton does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newPhytoplanktons A list to return newly born phytoplanktons.",Phytoplankton.java,362.0,3
1,"public void giveBirth(List<Plant> newPhytoplanktons)
    {
        // New phytoplanktons are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Phytoplankton young = new Phytoplankton(false, field, loc);
            newPhytoplanktons.add(young);
        }
    }","Check whether or not this phytoplankton is to give birth at this step.
New births will be made into free adjacent locations.
@param newPhytoplanktons A list to return newly born phytoplanktons.",Phytoplankton.java,362.0,3
2,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the phytoplankton's death.,Phytoplankton.java,362.0,3
3,"public int getShootProductionAge()
    {
        return SHOOT_PRODUCTION_AGE; 
    }","Returns the age at which a phytoplankton can start to produce shoots.

@return the age at which a phytoplankton can start to produce shoots",Phytoplankton.java,362.0,3
4,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a phytoplankton can live.

@return the age to which a phytoplankton can live",Phytoplankton.java,362.0,3
5,"public double getShootProductionProbability()
    {
        if(weather.getWeather().equalsIgnoreCase(""rainy"")){
            return RAINY_PRODUCTION_PROBABILITY; 
        }
        else{
            return SUNNY_PRODUCTION_PROBABILITY; 
        }
    }","Returns the likelihood of a phytoplankton producing shoots.
The weather affects the production probability of phytoplanktons.

@return the likelihood of a phytoplankton producing shoots",Phytoplankton.java,362.0,3
6,"public int getMaxShootProduction()
    {
        return MAX_SHOOT_PRODUCTION; 
    }","Returns the maximum number of shoots that can be produced.

@return the maximum number of shoots that can be produced",Phytoplankton.java,362.0,3
7,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single phytoplankton.
In effect, this is the food value a plant-eater gets when a phytoplankton is eaten.

@return the food value of a single phytoplanktonrk",Phytoplankton.java,362.0,3
8,"public int getAge()
    {
        return age; 
    }","Returns the phytoplankton's age.

@return the phytoplankton's age",Phytoplankton.java,362.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,362.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,362.0,3
2,"public void incrementCount(Class organismClass)
    {
        Counter count = counters.get(organismClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(organismClass.getName());
            counters.put(organismClass, count);
        }
        count.increment();
    }","Increment the count for one class of organism.
@param organismClass The class of organism to increment.",FieldStats.java,362.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an organism count has been completed.,FieldStats.java,362.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,362.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object organism = field.getObjectAt(row, col);
                if(organism != null) {
                    incrementCount(organism.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of organisms.
These are not kept up to date as organisms
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,362.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,362.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,362.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,362.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,362.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,362.0,3
0,"public boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,362.0,3
1,"public void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,362.0,3
2,"public Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,362.0,3
3,"public void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the organism at the new location in the given field.
@param newLocation The organism's new location.",Organism.java,362.0,3
4,"public Field getField()
    {
        return field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,362.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,362.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,362.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,362.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,362.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,362.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,362.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,362.0,3
0,"public void act(List<Plant> newSeaweeds)
    {
        incrementAge();
        if(isAlive()) {
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                giveBirth(newSeaweeds);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the seaweed does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newSeaweeds A list to return newly born seaweeds.",Seaweed.java,362.0,3
1,"public void giveBirth(List<Plant> newSeaweeds)
    {
        // New seaweeds are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Seaweed young = new Seaweed(false, field, loc);
            newSeaweeds.add(young);
        }
    }","Check whether or not this seaweed is to give birth at this step.
New births will be made into free adjacent locations.
@param newSeaweeds A list to return newly born seaweeds.",Seaweed.java,362.0,3
2,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the seaweed's death.,Seaweed.java,362.0,3
3,"public int getShootProductionAge()
    {
        return SHOOT_PRODUCTION_AGE; 
    }","Returns the age at which a seaweed can start to produce shoots.

@return the age at which a seaweed can start to produce shoots",Seaweed.java,362.0,3
4,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a seaweed can live.

@return the age to which a seaweed can live",Seaweed.java,362.0,3
5,"public double getShootProductionProbability()
    {
        if(weather.getWeather().equalsIgnoreCase(""rainy"")){
            return RAINY_PRODUCTION_PROBABILITY; 
        }
        else{
            return SUNNY_PRODUCTION_PROBABILITY; 
        }
    }","Returns the likelihood of a seaweed producing shoots.
The weather affects the production probability of seaweeds.

@return the likelihood of a seaweed producing shoots",Seaweed.java,362.0,3
6,"public int getMaxShootProduction()
    {
        return MAX_SHOOT_PRODUCTION; 
    }","Returns the maximum number of shoots that can be produced.

@return the maximum number of shoots that can be produced",Seaweed.java,362.0,3
7,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single seaweed.
In effect, this is the food value a plant-eater gets when a seaweed is eaten.

@return the food value of a single seaweed",Seaweed.java,362.0,3
8,"public int getAge()
    {
        return age; 
    }","Returns the seaweed's age.

@return the seaweed's age",Seaweed.java,362.0,3
0,"public void hunt()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Whale) {
                Whale whale = (Whale) animal;
                whale.setDead();
                net++;
                if(net >= CAPACITY){
                    setDead();
                }
            }
        }
    }","This is what a hunter does. It tries to capture nearby whales.
The hunter's net has a capacity. When this capacity is
reached or exceeded, the hunter is removed from the grid
by setting it as dead.",Hunter.java,362.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,362.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,362.0,3
2,"public void place(Object organism, int row, int col)
    {
        place(organism, new Location(row, col));
    }","Place an organism at the given location.
If there is already an organism at the location it will
be lost.
@param organism The organism to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,362.0,3
3,"public void place(Object organism, Location location)
    {
        field[location.getRow()][location.getCol()] = organism;
    }","Place an organism at the given location.
If there is already an organism at the location it will
be lost.
@param organism The organism to be placed.
@param location Where to place the organism.",Field.java,362.0,3
4,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,362.0,3
5,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,362.0,3
6,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,362.0,3
7,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }

            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,362.0,3
8,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the organism at the given location, if any.
@param location Where in the field.
@return The organism at the given location, or null if there is none.",Field.java,362.0,3
9,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the organism at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The organism at the given location, or null if there is none.",Field.java,362.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,362.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,362.0,3
0,"protected void dieOfAge()
    {
        if(getAge() > getMaxAge()) {
            setDead();
        }
    }","If age exceeds max age, this animal dies.",Animal.java,362.0,3
1,"protected void dieOfHunger()
    {
        if(getFoodLevel() <= 0) {
            setDead();
        }
    }","If food level is less than or equal to zero, this animal dies of hunger.",Animal.java,362.0,3
2,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if this animal can breed.
@return The number of births (may be zero).",Animal.java,362.0,3
3,"protected boolean canBreed()
    {
        return getAge() >= getBreedingAge();
    }",An animal can breed if it has reached the breeding age.,Animal.java,362.0,3
4,"public boolean isInfected()
    {
        return infected;
    }","Returns whether this animal is infected or not.

@return Whether this animal is infected or not.",Animal.java,362.0,3
5,"public void setInfected()
    {
        infected = true;
    }",Set this animal's infected field to true,Animal.java,362.0,3
6,"private int getHealth()
    {
        return health;
    }","Returns the health value of this animal.

@return The health value of this animal.",Animal.java,362.0,3
7,"public void adjustHealth()
    {
        Random randomHealthGenerator = new Random(); 
        int randHealth = randomHealthGenerator.nextInt(2); 
        if (randHealth == 0){
            health++;
        }
        else{
            health--;
        }

        if(health<=0){
            setDead();
        }
    }",Increments or decrements this animal's health value.,Animal.java,362.0,3
8,"public void infect(Object neighbour)
    {
        Random randomInfectedGenerator = new Random(); 
        int randInfected = randomInfectedGenerator.nextInt(10); 
        if (randInfected == 5){
            Animal animal = (Animal) neighbour;
            if(!animal.isInfected()) { 
                animal.setInfected();   
            }
        }
    }","If a neighbouring animal is infected,
this animal becomes infected as well.
There is a 1 in 10 chance this is successful.

@param neighbour An animal of the same type in an adjacent location",Animal.java,362.0,3
0,"public void act(List<Animal> newDolphins)
    {
        incrementAge();
        incrementHunger();
        
        //Disease
        if(isAlive() && isInfected()){
            spreadDisease(); //Infect other dolphins if infected
            adjustHealth();
        }
        
        if(isAlive()) {
            //Reproduce if possible 
            if(meet()){
                giveBirth(newDolphins);   
            }

            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the dolphin does most of the time: it consumes
squids. In the process, it might breed, die of hunger,
or die of old age.

@param newDolphins A list to return newly born dolphins.",Dolphin.java,362.0,3
1,"public boolean meet()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dolphin) {
                Dolphin dolphin = (Dolphin) animal;
                if(! dolphin.getSex().equals(sex)) { 
                    return true;   
                }
            }
        }
        return false; 
    }","Checks neighbouring locations.
If another dolphin of the opposite gender is found, calls giveBirth method
If another dolphin of the same gender is found, return false
If another animal/plant type is found, return false",Dolphin.java,362.0,3
2,"public void giveBirth(List<Animal> newDolphins)
    {
        // New dolphins are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Dolphin young = new Dolphin(false, field, loc);
            newDolphins.add(young);
        }
    }","Check whether or not this dolphin is to give birth at this step.
New births will be made into free adjacent locations.
@param newDolphins A list to return newly born dolphins.",Dolphin.java,362.0,3
3,"public Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Squid) {
                Squid squid = (Squid) animal;
                if(squid.isAlive()) { 
                    squid.setDead();
                    foodLevel = squid.getFoodValue();
                    return where;
                }
            }
        }
        return null;
    }","Look for squids adjacent to the current location.
Only the first live squid is eaten.
@return Where food was found, or null if it wasn't.",Dolphin.java,362.0,3
4,"public void spreadDisease()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Dolphin) {
                infect(animal); 
            }
        }
    }","Look for dolphins in adjacent locations.
If dolphins are found, try to infect them.",Dolphin.java,362.0,3
5,"public void incrementHunger()
    {
        foodLevel--;
        dieOfHunger(); 
    }",Make this dolphin more hungry. This could result in the dolphin's death.,Dolphin.java,362.0,3
6,"public void incrementAge()
    {
        age++;
        dieOfAge(); 
    }",Increase the age. This could result in the dolphin's death.,Dolphin.java,362.0,3
7,"public int getBreedingAge()
    {
        return BREEDING_AGE; 
    }","Returns the age at which a dolphin can start to breed.

@return the age at which a dolphin can start to breed",Dolphin.java,362.0,3
8,"public int getMaxAge()
    {
        return MAX_AGE;
    }","Returns the age to which a dolphin can live.

@return the age to which a dolphin can live",Dolphin.java,362.0,3
9,"public double getBreedingProbability()
    {
        return BREEDING_PROBABILITY; 
    }","Returns the likelihood of a dolphin breeding.

@return the likelihood of a dolphin breeding",Dolphin.java,362.0,3
10,"public int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE; 
    }","Returns the maximum number of births.

@return the maximum number of births",Dolphin.java,362.0,3
11,"public int getFoodValue()
    {
        return FOOD_VALUE; 
    }","Returns the food value of a single dolphin.
In effect, this is the food value its predator gets when a dolphin is eaten.

@return the food value of a single dolphin",Dolphin.java,362.0,3
12,"public int getPreyFoodValue()
    {
        return PREY_FOOD_VALUE; 
    }","Returns the highest food value of an dolphin's prey.
In effect, this is the food value of squid

@return the highest food value of an dolphin's prey (squid)",Dolphin.java,362.0,3
13,"public int getAge()
    {
        return age; 
    }","Returns the dolphin's age.

@return the dolphin's age",Dolphin.java,362.0,3
14,"public int getFoodLevel()
    {
        return foodLevel; 
    }","Returns the dolphin's food level, which is increased by eating squid.

@return the dolphin's food level",Dolphin.java,362.0,3
15,"public String getSex()
    {
        return sex; 
    }","Returns the dolphin's sex.

@return the dolphin's sex",Dolphin.java,362.0,3
0,"public void setColor(String species, Color color)
    {
        colors.put(species, color);
        speciesSet = colors.keySet();
    }","Define a colour to be used for a given actor on the graph.

@param species The species of the actor.
@param color The colour to be used for the given actor.",GraphView.java,331.0,3
1,"public void showStatus(int step, int day, String time, Field field)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field, by displaying a line graph for all actors of the field.

@param step Which iteration step it is.
@param day The current day.
@param time The current time.
@param field The field whose status is to be displayed.",GraphView.java,331.0,3
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation is still viable, so if it should continue to run.

@param field The field currently occupied.
@return true if there is more than one species alive.",GraphView.java,331.0,3
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GraphView.java,331.0,3
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        JPanel bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel("" "");
        bottom.add(countLabel);
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 650);  // Place window below the main grid and information windows

        frame.setVisible(true);

        return frame;
    }","Prepare the frame for the graph display.

@param width The width of the plotter window (in pixels).
@param height The height of the plotter window (in pixels).
@param startMax The initial maximum value for the y-axis.
@return The JFrame used to create the window.",GraphView.java,331.0,3
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,331.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,331.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,331.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,331.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,331.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.

@return A random object.",Randomizer.java,331.0,3
0,"public NeuralNetwork crossover(NeuralNetwork b) {
        Layer[] aLayers = getLayers();
        Layer[] bLayers = b.getLayers();
        Layer[] newLayers = new Layer[aLayers.length];

        // For each layer:
        for (int layerIndex = 0; layerIndex < aLayers.length; layerIndex++) {
            Layer currentLayer = new Layer();
            Layer aCurrentLayer = aLayers[layerIndex];
            Layer bCurrentLayer = bLayers[layerIndex];

            Matrix aCurrentLayerWeights = aCurrentLayer.getWeights();
            Matrix bCurrentLayerWeights = bCurrentLayer.getWeights();

            // Set each layer weight to either a's or b's weight.
            Matrix currentLayerWeights = new Matrix(aCurrentLayerWeights.getX(), aCurrentLayerWeights.getY());
            for (int weightsIndex = 0; weightsIndex < currentLayerWeights.getX(); weightsIndex++) {
                if (rand.nextBoolean()) {
                    currentLayerWeights.setValues(weightsIndex, aCurrentLayerWeights.getValues(weightsIndex));
                } else {
                    currentLayerWeights.setValues(weightsIndex, bCurrentLayerWeights.getValues(weightsIndex));
                }
            }
            currentLayer.setWeights(currentLayerWeights);

            // Set layer bias to either a's or b's bias.
            Matrix currentLayerBias = rand.nextBoolean() ? aCurrentLayer.getBias() : bCurrentLayer.getBias();
            currentLayer.setBias(currentLayerBias);

            // Set layer in position.
            newLayers[layerIndex] = currentLayer;
        }

        // Create new NeuralNetwork from newLayers.
        return new NeuralNetwork(newLayers);
    }","For each weight and bias of each layer, randomly select between this and parameter b.

@param b neural network to crossover.
@return merged neural network.",NeuralNetwork.java,331.0,3
1,"public void mutate() {
        for (Layer layer: layers) {
            Callable<Double> mutator = () -> MUTATION_AMOUNT * (1 - (2 * rand.nextDouble()));
            Matrix weights = layer.getWeights();
            weights.mutateValues(mutator);

            Matrix bias = layer.getBias();
            bias.mutateValues(mutator);
        }
    }",Manipulate each weight and bias by a random amount multiplied by MUTATION_AMOUNT.,NeuralNetwork.java,331.0,3
2,"public Layer[] getLayers() {
        return layers;
    }","Get the layers of the neural network in an array.

@return neural network layers.",NeuralNetwork.java,331.0,3
3,"public List<Double> predict(double[] input) {
        Matrix workingMatrix = Matrix.FromArray(input);
        for (Layer layer: layers) {
            if (layer.getWeights() != null) {
                workingMatrix = Matrix.multiply(layer.getWeights(), workingMatrix);
                workingMatrix.add(layer.getBias());
                workingMatrix.sigmoid();
            }
        }
        return workingMatrix.toArray();
    }","Generate neural network prediction from inputs.

@param input to generate prediction from.
@return prediction of neural network.",NeuralNetwork.java,331.0,3
4,"public void train(double[] X, double[] Y)
    {
        // Get model prediction
        Matrix workingMatrix = Matrix.FromArray(X);
        List<Matrix> layersMatrix = new ArrayList<>();
        for (Layer layer: layers) {
            if (layer.getWeights() != null) {
                workingMatrix = Matrix.multiply(layer.getWeights(), workingMatrix);
                workingMatrix.add(layer.getBias());
                workingMatrix.sigmoid();
                layersMatrix.add(Matrix.Copy(workingMatrix));
            }
        }

        Matrix target = Matrix.FromArray(Y);
        Matrix output = layersMatrix.get(layersMatrix.size()-1);

        Matrix error = null;

        // For each layer excluding inputs:
        for (int i = layers.length-1; i > 0; i--) {
            Layer currentLayer = layers[i];

            if (error == null) {
                error = Matrix.subtract(target, output);
            } else {
                Matrix weightsTransposed = Matrix.transpose(currentLayer.getWeights());
                error = Matrix.multiply(weightsTransposed, error);
            }

            Matrix currentLayerOutput = layersMatrix.get(i);

            // Calculate error gradient.
            Matrix gradient = Matrix.dsigmoid(currentLayerOutput);
            gradient.multiply(error);
            // Controls how much the learning gradient manipulates the layer outputs.
            double LRATE = 0.1;
            gradient.multiply(LRATE);

            // Calculate difference in weights and desired weights.
            Matrix previousLayerOutput = layersMatrix.get(i-1);
            Matrix previousLayerOutputTransposed = Matrix.transpose(previousLayerOutput);
            Matrix weightsDelta = Matrix.multiply(gradient, previousLayerOutputTransposed);

            currentLayer.getWeights().add(weightsDelta);
            currentLayer.getBias().add(gradient);
        }
    }","Manipulate layer weights and bias to minimise error between neural network output
and Y (target outputs).

@param X inputs.
@param Y target outputs.",NeuralNetwork.java,331.0,3
0,"public void setValue(int x, int y, double value) {
        matrix[x][y] = value;
    }","Set the value of an element in the matrix.

@param x index in matrix.
@param y index in matrix.
@param value value to set element as.",Matrix.java,331.0,3
1,"public void setValues(int x, double[] values) {
        matrix[x] = values;
    }","Set an array of values in the matrix.

@param x index in matrix.
@param values array of values to set.",Matrix.java,331.0,3
2,"public double getValue(int x, int y) {
        return matrix[x][y];
    }","Get the value of an element in the matrix.

@param x index in matrix.
@param y index in matrix.
@return value indexed by x & y in the matrix.",Matrix.java,331.0,3
3,"public double[] getValues(int x) {
        return matrix[x];
    }","Get an array of values in the matrix.

@param x index in matrix.
@return values indexed by x in the matrix.",Matrix.java,331.0,3
4,"public void mutateValues(Callable<Double> mutator) {
        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                try {
                    setValue(i, j, getValue(i, j) + mutator.call());
                } catch (Exception ignored) {

                }
            }
        }
    }","Add result of mutator function param on each value in the matrix.

@param mutator function which returns a double.",Matrix.java,331.0,3
5,"public int getX() {
        return X;
    }","Get rows of the matrix.

@return rows of matrix.",Matrix.java,331.0,3
6,"public int getY() {
        return Y;
    }","Get columns of the matrix.

@return columns of matrix.",Matrix.java,331.0,3
7,"public static Matrix Random(int X, int Y) {
        Random rand = Randomizer.getRandom();
        return new Matrix(X, Y, () -> rand.nextDouble() * 2.0 - 1.0);
    }","Initialise new Matrix with random values.

@param X width of matrix.
@param Y height of matrix.
@return new random Matrix.",Matrix.java,331.0,3
8,"public static Matrix Empty(int X, int Y) {
        return new Matrix(X, Y, () -> 0.0);
    }","Initialise new Matrix with values of 0.0.

@param X width of matrix.
@param Y height of matrix.
@return new empty Matrix.",Matrix.java,331.0,3
9,"public static Matrix Copy(Matrix matrixToCopy) {
        Matrix newMatrix = Empty(matrixToCopy.getX(), matrixToCopy.getY());
        for (int i = 0; i < matrixToCopy.getX(); i++) {
            for (int j = 0; j < matrixToCopy.getY(); j++) {
                newMatrix.setValue(i, j, matrixToCopy.getValue(i, j));
            }
        }
        return newMatrix;
    }","Initialise new Matrix with values from matrixToCopy.

@param matrixToCopy Matrix to retrieve values from.
@return new copied Matrix.",Matrix.java,331.0,3
10,"public static Matrix FromArray(double[] x) {
        Matrix output = new Matrix(x.length, 1);
        for (int i = 0; i < x.length; i++) {
            output.setValue(i, 0, x[i]);
        }
        return output;
    }","Create Matrix from an array x.

@param x array to create matrix from.
@return new Matrix from array.",Matrix.java,331.0,3
11,"public static Matrix multiply(Matrix a, Matrix b) {
        // Set the new matrix to have the number of rows as a and number of columns as b.
        Matrix output = Empty(a.getX(), b.getY());

        for (int i=0; i < output.getX(); i++)
        {
            for (int j=0; j < output.getY(); j++)
            {
                double sum = 0;
                for (int k=0 ; k < b.getX(); k++)
                {
                    sum += a.getValue(i, k) * b.getValue(k, j);
                }
                output.setValue(i, j, sum);
            }
        }
        return output;
    }","Multiply two matrices together.

@param a matrix to multiply.
@param b matrix to multiply.
@return new Matrix of the matrix product.",Matrix.java,331.0,3
12,"public void multiply(Matrix b) {
        for (int i = 0; i < getX(); i++)
        {
            for (int j = 0; j < b.getY(); j++)
            {
                double sum = 0;
                for (int k = 0 ; k < getY(); k++)
                {
                    sum += getValue(i, k) * b.getValue(k, j);
                }
                setValue(i, j, sum);
            }
        }
    }","Multiply this matrix by b.

@param b matrix to multiply.",Matrix.java,331.0,3
13,"public void multiply(double a) {
        for (int i = 0; i < getX(); i++)
        {
            for (int j = 0; j < getY(); j++)
            {
                setValue(i, j, getValue(i, j)*a);
            }
        }
    }","Multiply this matrix by a single value.

@param a single value to multiply.",Matrix.java,331.0,3
14,"public void add(Matrix a) {
        if(getX() != a.getX() || getY() != a.getY()) {
            throw new IllegalArgumentException(""Shape Mismatch"");
        }

        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                setValue(i, j, getValue(i, j)+a.getValue(i, j));
            }
        }
    }","Add this matrix by a.

@param a matrix to add.
@throws IllegalArgumentException if a is not the same shape as this.",Matrix.java,331.0,3
15,"public void subtract(Matrix a) {
        if(getX() != a.getX() || getY() != a.getY()) {
            throw new IllegalArgumentException(""Shape Mismatch"");
        }

        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                setValue(i, j, getValue(i, j)-a.getValue(i, j));
            }
        }
    }","Subtract this matrix by a.

@param a matrix to subtract.
@throws IllegalArgumentException if a is not the same shape as this.",Matrix.java,331.0,3
16,"public void transpose() {
        Matrix temp = new Matrix(getY(), getX());
        for(int i = 0; i < getX(); i++)
        {
            for(int j = 0; j < getY(); j++)
            {
                temp.setValue(j, i, getValue(i, j));
            }
        }

        X = temp.getX();
        Y = temp.getY();
        matrix = temp.matrix;
    }",Transpose(/flip) this matrix.,Matrix.java,331.0,3
17,"public void sigmoid() {
        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                setValue(i, j, 1/(1+Math.exp(-getValue(i, j))));
            }
        }
    }",Apply the sigmoid function to each value in this matrix.,Matrix.java,331.0,3
18,"public void dsigmoid() {
        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                setValue(i, j, getValue(i, j) * (1-getValue(i, j)));
            }
        }
    }",Apply the derivative of the sigmoid function to each value in this matrix.,Matrix.java,331.0,3
19,"public static Matrix add(Matrix a, Matrix b) {
        Matrix tempA = Matrix.Copy(a);
        tempA.add(b);
        return tempA;
    }","Add two matrices together.

@param a to add.
@param b to add.
@return result matrix of addition.",Matrix.java,331.0,3
20,"public static Matrix subtract(Matrix a, Matrix b) {
        Matrix tempA = Matrix.Copy(a);
        tempA.subtract(b);
        return tempA;
    }","Subtract matrix a by matrix b.

@param a initial matrix.
@param b matrix to subtract.
@return result matrix of subtraction.",Matrix.java,331.0,3
21,"public static Matrix dsigmoid(Matrix a) {
        Matrix tempA = Matrix.Copy(a);
        tempA.dsigmoid();
        return tempA;
    }","Apply the derivative of the sigmoid function to each value in the matrix.

@param a matrix to apply function to.
@return result matrix of function.",Matrix.java,331.0,3
22,"public static Matrix transpose(Matrix a) {
        Matrix tempA = Matrix.Copy(a);
        tempA.transpose();
        return tempA;
    }","Transpose(/flip) the matrix.

@param a matrix to transpose.
@return transposed matrix.",Matrix.java,331.0,3
23,"public List<Double> toArray() {
        List<Double> output = new ArrayList<>();
        for (int i = 0; i < getX(); i++) {
            for (int j = 0; j < getY(); j++) {
                output.add(getValue(i, j));
            }
        }
        return output;
    }","Flatten matrix into 1D list.

@return flattened matrix as list.",Matrix.java,331.0,3
0,"public int getTimeInMinutes() {
        return timeInMinutes;
    }","Get the current time in the simulation.

@return The current time.",Time.java,331.0,3
1,"public int getDay() {
        return day;
    }","Get the current day in the simulation.

@return The current day.",Time.java,331.0,3
2,"public int getDayLength() {
        return dayLength;
    }","Get the length of a day, in minutes.

@return How long a day is, in minutes.",Time.java,331.0,3
3,"public void incrementTime(int increment) {
        if(timeInMinutes < dayLength - increment) {
            timeInMinutes += increment;
        } else {  // Start a new day
            day++;
            timeInMinutes = timeInMinutes + increment - dayLength;
        }
    }","Add a certain time increment to the current simulation time.

@param increment The amount of time to increment by.",Time.java,331.0,3
4,"public String getFormattedTime() {
        int hours = timeInMinutes / 60;
        int minutes = timeInMinutes % 60;
        return(String.format(""%02d:%02d"", hours, minutes));
    }","Get a formatted string of the current time, in hh:mm format.

@return The current time in hh:mm format.",Time.java,331.0,3
5,"public boolean isNight() {
        // Sunrise is at 5:30am, sunset is at 8pm.
        return timeInMinutes < 330 || timeInMinutes > 1200;
    }","Find whether or not it is currently night-time.

@return true if it is currently night-time.",Time.java,331.0,3
0,"public void setFoodLevel(int foodLevel) {
        this.foodLevel = foodLevel;
    }","Set the numerical amount of food that the plant is worth when eaten.

@param foodLevel The amount of food that the plant is worth when eaten.",Plant.java,331.0,3
1,"public void setReproductionProbability(double reproductionProbability) {
        this.reproductionProbability = reproductionProbability;
    }","Set the probability that the plant will reproduce.

@param reproductionProbability The probability that the plant will reproduce.",Plant.java,331.0,3
2,"public void setMaxSeedSize(int maxSeedSize) {
        this.maxSeedSize = maxSeedSize;
    }","Set the maximum number of seeds (children) that the plant can have.

@param maxSeedSize The maximum number of seeds that the plant can have.",Plant.java,331.0,3
3,"public int getFoodLevel() {
        return foodLevel;
    }","Get the numerical amount of food that the plant is worth when eaten.

@return The amount of food that the plant is worth when eaten.",Plant.java,331.0,3
4,"@Override
    public void act(List<Actor> newActors, Time time) {
        if (isAlive()) {
            reproduce(newActors);
        }
    }","Make this plant act - reproduce if it can.

@param newActors A list to receive newly born plants.
@param time The current time.",Plant.java,331.0,3
5,"private void reproduce(List<Actor> newPlants) {
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = generateReproductions();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            // Configure the new plant.
            Plant young = new Plant(species, field, loc);
            young.setFoodLevel(foodLevel);
            young.setReproductionProbability(reproductionProbability);
            young.setMaxSeedSize(maxSeedSize);
            newPlants.add(young);
        }
    }","Try and create new plant children in adjacent locations.

@param newPlants A list to receive newly born plants.",Plant.java,331.0,3
6,"private int generateReproductions() {
        int reproductions = 0;
        if (rand.nextDouble() <= reproductionProbability) {
            reproductions = rand.nextInt(maxSeedSize) + 1;
        }
        return reproductions;
    }","Calculate the number of new children to generate.

@return The number of new plants to birth.",Plant.java,331.0,3
7,"public String getStats() {
        String text = super.getStats();
        text += ""\nFood Level: "" + foodLevel;
        return text;
    }","Return the plant's statistics text.

@return The plant's formatted species and food level.",Plant.java,331.0,3
0,"public int getFoodLevel() {
        return foodLevel;
    }","Get the numerical amount of food that the prey is worth when eaten.

@return The amount of food that the prey is worth when eaten.",Prey.java,331.0,3
1,"protected BreedableActor createYoung(Field field, Location loc) {
        Prey newPrey = new Prey(species, field, loc, false, foodLevel);
        newPrey.setMaxAge(maxAge);
        newPrey.setBreedingAge(breedingAge);
        newPrey.setBreedingProbability(breedingProbability);
        newPrey.setMaxLitterSize(maxLitterSize);
        newPrey.setFoodSources(foodSources);
        return newPrey;
    }","Create a newborn prey with the correct characteristics.

@param field The field currently occupied.
@param loc The location within the field.
@return The newborn prey.",Prey.java,331.0,3
2,"public int getMaxHungerLevel() {
        return foodLevel;
    }","Get the longest the actor can last before dying.

@return The longest the actor can last before dying.",Prey.java,331.0,3
3,"public String getStats() {
        StringBuilder text = new StringBuilder(super.getStats());
        text.append(""\nName: "").append(name);
        text.append(""\nAge: "").append(
                new DecimalFormat(""#.##"").format(age / (double) Simulator.TIME_MULTIPLIER)
        );
        text.append(""\nSex: "").append(sex);
        text.append(""\nHunger Level: "").append(hungerLevel);
        text.append(""\nFood Level: "").append(foodLevel);
        text.append(""\nPregnant: "").append(pregnantTicks > 0);
        if (pregnantTicks > 0) {
            text.append(""\nPregnant Ticks: "").append(pregnantTicks);
        }
        text.append(""\n\nDesires: "");
        for (String desire: desires.keySet()) {
            text.append(""\n - "").append(desire).append("": "").append(desires.get(desire));
        }
        return text.toString();
    }","Return the predator's statistics text.

@return The predator's formatted species, name, age, sex, hunger level, food level, pregnancy status and desires.",Prey.java,331.0,3
0,"public void setFoodSources(ArrayList<String> foodSources) {
        this.foodSources = foodSources;
    }","Set the types of food source that the actor can eat.

@param foodSources An array of food source species names.",ActorBuilder.java,331.0,3
1,"public void setFoodLevel(int foodLevel) {
        this.foodLevel = foodLevel;
    }","Set the numerical amount of food that the actor is worth when eaten.

@param foodLevel The numerical amount of food the actor is worth.",ActorBuilder.java,331.0,3
2,"public void setMaxAge(int maxAge) {
        this.maxAge = maxAge;
    }","Set the highest age the actor can reach before dying.

@param maxAge The highest age the actor can reach.",ActorBuilder.java,331.0,3
3,"public void setBreedingAge(int breedingAge) {
        this.breedingAge = breedingAge;
    }","Set the age the actor must reach to start breeding.

@param breedingAge The age the actor must reach to breed.",ActorBuilder.java,331.0,3
4,"public void setBreedingProbability(double breedingProbability) {
        this.breedingProbability = breedingProbability;
    }","Set the probability that the actor will breed.

@param breedingProbability The probability that the actor will breed.",ActorBuilder.java,331.0,3
5,"public void setMaxLitterSize(int maxLitterSize) {
        this.maxLitterSize = maxLitterSize;
    }","Set the maximum number of children that the actor can have.

@param maxLitterSize The maximum number of children that the actor can have.",ActorBuilder.java,331.0,3
6,"public void setMaxHungerLevel(int maxHungerLevel) {
        this.maxHungerLevel = maxHungerLevel;
    }","Set the longest the actor can last before dying.

@param maxHungerLevel The longest the actor can last before dying.",ActorBuilder.java,331.0,3
7,"public void setCreationProbability(double creationProbability) {
        this.creationProbability = creationProbability;
    }","Set the probability that an actor is built.

@param creationProbability The probability that an actor is built.",ActorBuilder.java,331.0,3
8,"public String getSpecies() {
        return species;
    }","Get the species of the actor to be built.

@return The species of the actor to be built.",ActorBuilder.java,331.0,3
9,"public Actor buildActor(Field field, Location location) {
        Random rand = Randomizer.getRandom(); // might need to move this x
        if (rand.nextDouble() <= creationProbability) {  // Check whether any actor will be built.
            switch (type) {  // Build the correct type of actor with the correct characteristics.
                case ""prey"": {
                    Prey newPrey = new Prey(species, field, location, true, foodLevel);
                    newPrey.setMaxAge(maxAge);
                    newPrey.setBreedingAge(breedingAge);
                    newPrey.setBreedingProbability(breedingProbability);
                    newPrey.setMaxLitterSize(maxLitterSize);
                    newPrey.setFoodSources(foodSources);
                    return newPrey;
                }
                case ""predator"": {
                    Predator newPredator = new Predator(species, field, location, true, maxHungerLevel);
                    newPredator.setMaxAge(maxAge);
                    newPredator.setBreedingAge(breedingAge);
                    newPredator.setBreedingProbability(breedingProbability);
                    newPredator.setMaxLitterSize(maxLitterSize);
                    newPredator.setFoodSources(foodSources);
                    return newPredator;
                }
                case ""plant"": {
                    Plant newPlant = new Plant(species, field, location);
                    newPlant.setFoodLevel(foodLevel);
                    newPlant.setReproductionProbability(breedingProbability);
                    newPlant.setMaxSeedSize(maxLitterSize);
                    return newPlant;
                }
            }
        }
        return null;  // If no actor was buit.
    }","Build a random actor based on the builder's parameters.

@param field The field currently occupied.
@param location The location within the field.
@return The Actor that was built, or null if no actor was built.",ActorBuilder.java,331.0,3
0,"public void setColor(String species, Color color)
    {
        colors.put(species, color);
    }","Define a colour to be used for a given species.

@param species The name of the species.
@param color The colour to be used for the given species.",GridView.java,331.0,3
1,"public void setEmptyColor(Color emptyColor) {
        this.emptyColor = emptyColor;
    }","Set the background colour used for empty locations.

@param emptyColor The new background colour.",GridView.java,331.0,3
2,"private Color getColor(String species)
    {
        Color col = colors.get(species);
        if(col == null) {
            // No colour defined for this species.
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }","Get a species' colour from its name.

@param species The species to be checked.
@return The colour to be used for a given class of animal.",GridView.java,331.0,3
3,"public void showStatus(int step, int day, String time, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        dayTimeLabel.setText(DAY_PREFIX + day + "" "" + TIME_PREFIX + time);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Actor actor = (Actor) field.getObjectAt(row, col);
                if(actor != null) {
                    stats.incrementCount(actor.getSpecies());
                    fieldView.drawMark(col, row, getColor(actor.getSpecies()));
                }
                else {
                    fieldView.drawMark(col, row, emptyColor);
                }
            }
        }

        fieldView.drawSelection(field);

        stats.countFinished();

        population.setText(stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.

@param step Which iteration step it is.
@param day The current day.
@param time The current time.
@param field The field whose status is to be displayed.",GridView.java,331.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.

@param field The field currently occupied.
@return true if there is more than one species alive.",GridView.java,331.0,3
5,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,331.0,3
0,"public String getSpecies() {
        return species;
    }","Get the name of the species of this counter.

@return The species name of this counter.",Counter.java,331.0,3
1,"public int getCount() {
        return count;
    }","Get the number of how many participants of this type currently exist.

@return The current count for this species.",Counter.java,331.0,3
2,"public void increment() {
        count++;
    }",Increment the current count by one.,Counter.java,331.0,3
3,"public void reset() {
        count = 0;
    }",Reset the current count to zero.,Counter.java,331.0,3
0,"public int getMaxHungerLevel() {
        return maxHungerLevel;
    }","Get the longest the actor can last before dying.

@return The longest the actor can last before dying.",Predator.java,331.0,3
1,"protected BreedableActor createYoung(Field field, Location loc) {
        Predator newPredator = new Predator(species, field, loc, false, maxHungerLevel);
        newPredator.setMaxAge(maxAge);
        newPredator.setBreedingAge(breedingAge);
        newPredator.setBreedingProbability(breedingProbability);
        newPredator.setMaxLitterSize(maxLitterSize);
        newPredator.setFoodSources(foodSources);
        return newPredator;
    }","Create a newborn predator with the correct characteristics.

@param field The field currently occupied.
@param loc The location within the field.
@return The newborn predator.",Predator.java,331.0,3
2,"public String getStats() {
        StringBuilder text = new StringBuilder(super.getStats());
        text.append(""\nName: "").append(name);
        text.append(""\nAge: "").append(
                new DecimalFormat(""#.##"").format(age / (double) Simulator.TIME_MULTIPLIER)
        );
        text.append(""\nSex: "").append(sex);
        text.append(""\nHunger Level: "").append(hungerLevel);
        text.append(""\nPregnant: "").append(pregnantTicks > 0);
        if (pregnantTicks > 0) {
            text.append(""\nPregnant Ticks: "").append(pregnantTicks);
        }
        text.append(""\n\nDesires: "");
        for (String desire: desires.keySet()) {
            text.append(""\n - "").append(desire).append("": "").append(desires.get(desire));
        }
        return text.toString();
    }","Return the predator's statistics text.

@return The predator's formatted species, name, age, sex, hunger level, pregnancy status and desires.",Predator.java,331.0,3
0,"public void showStats(Actor actor) {
        if (actor != null) {
            statsTextArea.setText(actor.getStats());
        } else {
            statsTextArea.setText(""Click on an active grid cell to view\nits statistics."");
        }
    }","Change the information window to show a certain actor's statistics.

@param actor The actor whose statistics will be shown.",ActorView.java,331.0,3
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,331.0,3
1,"public void simulate(int numSteps)
    {
        for (int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            updateViews();
            // delay(5);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.

@param numSteps The number of steps to run for.",Simulator.java,331.0,3
2,"public void simulateOneStep()
    {
        step++;
        time.incrementTime(TIME_INCREMENT);

        int alphaMultiplier = 255 / TRANSITION_PHASES;
        if (time.isNight()) {
            // Begin the day-to-night transition.
            if(nightTransition < TRANSITION_PHASES) {
                // Calculate the correct transparency of the current night transition phase.
                views.get(0).setEmptyColor(new Color(NIGHT_TIME_COLOR[0], NIGHT_TIME_COLOR[1], NIGHT_TIME_COLOR[2], nightTransition * alphaMultiplier));
                nightTransition++;
            }
        } else {
            // Check whether night-to-day transition is needed.
            if(nightTransition > 1) {
                // Calculate the correct transparency of the current day transition phase.
                views.get(0).setEmptyColor(new Color(255, 255, 255, (255 - nightTransition * alphaMultiplier)));
                nightTransition--;
            }
        }

        // Provide space for newborn actors.
        List<Actor> newActors = new ArrayList<>();
        // Let all species act.
        for (Iterator<Actor> it = actors.iterator(); it.hasNext(); ) {
            Actor actor = it.next();
            actor.act(newActors, time);
            if(!actor.isAlive()) {
                it.remove();
            }
        }
               
        // Add the newly born actors to the main lists.
        actors.addAll(newActors);

        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each species.",Simulator.java,331.0,3
3,"public void reset()
    {
        step = 0;
        actors.clear();
        for (SimulatorView view : views) {
            view.reset();
        }
        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,331.0,3
4,"private void updateViews() {
        for (SimulatorView view : views) {
            view.showStatus(step, time.getDay(), time.getFormattedTime(), field);
        }
    }",Update all existing views.,Simulator.java,331.0,3
5,"private void populate()
    {
        field.clear();

        // Create instances of ActorBuilder for each Actor, defining Actor attributes.
        ArrayList<ActorBuilder> builders = new ArrayList<>();
        ActorBuilder manBuilder = new ActorBuilder(""Man"", ""predator"", 0.005);
        manBuilder.setFoodSources(new ArrayList<>() {{
            add(""Panda"");
            add(""Gorilla"");
        }});
        manBuilder.setMaxAge(80 * TIME_MULTIPLIER);
        manBuilder.setBreedingAge(16 * TIME_MULTIPLIER);
        manBuilder.setBreedingProbability(0.9);
        manBuilder.setMaxLitterSize(4);
        manBuilder.setMaxHungerLevel((int)(((double)1/52) * TIME_MULTIPLIER)); // 1 week
        builders.add(manBuilder);

        ActorBuilder snowLeopardBuilder = new ActorBuilder(""Snow leopard"", ""predator"", 0.005);
        snowLeopardBuilder.setFoodSources(new ArrayList<>() {{
            add(""Panda"");
            add(""Gorilla"");
        }});
        snowLeopardBuilder.setMaxAge(22 * TIME_MULTIPLIER);
        snowLeopardBuilder.setBreedingAge(4 * TIME_MULTIPLIER);
        snowLeopardBuilder.setBreedingProbability(0.9);
        snowLeopardBuilder.setMaxLitterSize(6);
        snowLeopardBuilder.setMaxHungerLevel((int)(((double)1/52) * TIME_MULTIPLIER)); // 1 week
        builders.add(snowLeopardBuilder);

        ActorBuilder pandaBuilder = new ActorBuilder(""Panda"", ""prey"", 0.04);
        pandaBuilder.setFoodSources(new ArrayList<>() {{
            add(""Bamboo"");
        }});
        pandaBuilder.setMaxAge(30 * TIME_MULTIPLIER);
        pandaBuilder.setBreedingAge(6 * TIME_MULTIPLIER);
        pandaBuilder.setBreedingProbability(0.7);
        pandaBuilder.setMaxLitterSize(6);
        pandaBuilder.setFoodLevel((int)(((double)10/365) * TIME_MULTIPLIER)); // 10 days
        builders.add(pandaBuilder);

        ActorBuilder gorillaBuilder = new ActorBuilder(""Gorilla"", ""prey"", 0.04);
        gorillaBuilder.setFoodSources(new ArrayList<>() {{
            add(""Bamboo"");
            add(""Grass"");
        }});
        gorillaBuilder.setMaxAge(40 * TIME_MULTIPLIER);
        gorillaBuilder.setBreedingAge(10 * TIME_MULTIPLIER);
        gorillaBuilder.setBreedingProbability(0.7);
        gorillaBuilder.setMaxLitterSize(4);
        gorillaBuilder.setFoodLevel((int)(((double)8/365) * TIME_MULTIPLIER)); // 8 days
        builders.add(gorillaBuilder);

        ActorBuilder bambooBuilder = new ActorBuilder(""Bamboo"", ""plant"", 0.3);
        bambooBuilder.setFoodLevel(100 * TIME_INCREMENT);
        bambooBuilder.setBreedingProbability(0.0001);
        bambooBuilder.setMaxLitterSize(2);
        builders.add(bambooBuilder);

        ActorBuilder grassBuilder = new ActorBuilder(""Grass"", ""plant"", 0.2);
        grassBuilder.setFoodLevel(100 * TIME_INCREMENT);
        grassBuilder.setBreedingProbability(0.00005);
        grassBuilder.setMaxLitterSize(1);
        builders.add(grassBuilder);

        // Try to create new actor for each cell in field until one is created.
        for (int row = 0; row < field.getDepth(); row++) {
            for (int col = 0; col < field.getWidth(); col++) {
                for (ActorBuilder builder: builders) {
                    Actor actor = builder.buildActor(field, new Location(row, col));
                    if (actor != null) {
                        actors.add(actor);
                        break;
                    }
                }
            }
        }
    }",Randomly populate the field with the initial actors of all species.,Simulator.java,331.0,3
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.

@param millisec The time to pause for, in milliseconds.",Simulator.java,331.0,3
7,"private void setColors(SimulatorView view) {
        view.setColor(""Man"", Color.decode(""#945A2E""));  // Brown
        view.setColor(""Snow leopard"", Color.decode(""#DEAC40""));  // Yellow ochre
        view.setColor(""Panda"", Color.decode(""#D984D7""));  // Pink
        view.setColor(""Gorilla"", Color.decode(""#262626""));  // Dark gray
        view.setColor(""Bamboo"", Color.decode(""#A9C7BA""));  // Mint green
        view.setColor(""Grass"", Color.decode(""#347D41""));  // Forest green
    }","Sets the correct actor colours in the view.

@param view The SimulatorView of which to set the colours.",Simulator.java,331.0,3
8,"public static void main(String[] args) {
        Simulator simulator = new Simulator();
        //simulator.simulate(5000);
        while (true) {
            simulator.simulateOneStep();
        }
    }","The main method.

@param args Arguments passed to the program.",Simulator.java,331.0,3
0,"public void setFoodSources(ArrayList<String> foodSources) {
        this.foodSources = foodSources;
    }","Set the types of food source that this actor can eat.

@param foodSources An array of food source names.",Actor.java,331.0,3
1,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the actor is alive or not.

@return true if the actor is still alive.",Actor.java,331.0,3
2,"protected void setDead()
    {
        alive = false;
        if (location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }",Indicate that the actor is no longer alive. It is removed from the field.,Actor.java,331.0,3
3,"protected Location getLocation()
    {
        return location;
    }","Return the actor's location.

@return The actor's location.",Actor.java,331.0,3
4,"public String getSpecies()
    {
        return species;
    }","Return the actor's species.

@return The actor's species.",Actor.java,331.0,3
5,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the actor at the new location in the given field.

@param newLocation The actor's new location.",Actor.java,331.0,3
6,"protected Field getField()
    {
        return field;
    }","Return the actor's field.

@return The actor's field.",Actor.java,331.0,3
7,"protected String getStats() {
        return ""Species: "" + species;
    }","e
Return the actor's base statistics text.

@return The actor's formatted species.",Actor.java,331.0,3
0,"public char getSex() {
        return sex;
    }","Get the sex of the breedable actor.

@return The actor's sex.",BreedableActor.java,331.0,3
1,"public void setMaxAge(int maxAge) {
        this.maxAge = maxAge;
        if (randomAge) {
            age = rand.nextInt(maxAge);
        } else {
            age = 0;
        }
    }","Set the breedable actor's maximum age and current age if random age is true.

@param maxAge The highest age the actor can reach.",BreedableActor.java,331.0,3
2,"public void setBreedingAge(int breedingAge) {
        this.breedingAge = breedingAge;
    }","Set the age the actor must reach to start breeding.

@param breedingAge The age the actor must reach to breed.",BreedableActor.java,331.0,3
3,"public void setBreedingProbability(double breedingProbability) {
        this.breedingProbability = breedingProbability;
    }","Set the probability that the actor will breed.

@param breedingProbability The probability that the actor will breed.",BreedableActor.java,331.0,3
4,"public void setMaxLitterSize(int maxLitterSize) {
        this.maxLitterSize = maxLitterSize;
    }","Set the maximum number of children that the actor can have.

@param maxLitterSize The maximum number of children that the actor can have.",BreedableActor.java,331.0,3
6,"public void act(List<Actor> newPrey, Time time)
    {
        incrementAge();

        if (isAlive()) {
            // Give birth if pregnant
            if (pregnantTicks > 1) {
                pregnantTicks--;
            }
            if (pregnantTicks == 1) {
                giveBirth(newPrey);
                incrementHunger(20);
                pregnantTicks--;
            }
        }

        if(!time.isNight()) {
            incrementHunger();
            if (isAlive()) {
                // Compute desires

                // Calculate sensory inputs
                sensoryInputs = new double[] {
                        (double) age / maxAge,
                        sex == 'f' ? 1 : 0,
                        (double) hungerLevel / getMaxHungerLevel(),
                        pregnantTicks > 0 ? 1 : 0,
                        (double) time.getTimeInMinutes() / time.getDayLength()
                };

                // Generate actor's brains prediction
                List<Double> desiresProbabilities = brain.predict(sensoryInputs);

                // Put actor's desires into a HashMap
                HashMap<String, Double> desiresMap = new HashMap<>();
                for (int i = 0; i < desiresProbabilities.size(); i++) {
                    desiresMap.put(DESIRES[i], desiresProbabilities.get(i));
                }

                // Sort actor's desire descending using LinkedHashMap
                desires = desiresMap.entrySet().stream()
                                .sorted((e1, e2) -> Double.compare(e2.getValue(), e1.getValue()))
                                .collect(
                                        LinkedHashMap::new,
                                        (map, item) -> map.put(item.getKey(), item.getValue()),
                                        Map::putAll);

                Location newLocation;
                for (String desire: desires.keySet()) {  // Act based on desire
                    switch (desire) {
                        case ""move"": {
                            newLocation = getField().freeAdjacentLocation(getLocation());
                            if (newLocation != null) {
                                setLocation(newLocation);
                                incrementHunger();
                            } else {
                                //setDead(); // overcrowding
                                return;
                            }
                            break;
                        }
                        case ""findFood"": {
                            newLocation = findFood();
                            if (newLocation != null) {
                                setLocation(newLocation);
                                rewardBrain(desire);
                                return;
                            }
                            break;
                        }
                        case ""breed"": {
                            if (sex == 'f' && canBreed()) {
                                rewardBrain(desire);
                                return;
                            }
                            break;
                        }
                        case ""rest"": {
                            return;
                        }
                    }
                    if (!isAlive()) {
                        return;
                    }
                }
            }
        }
    }","Let the breedable actor decide what to do and act upon this desire.

@param newPrey A list to store possible newborn actors.
@param time The current time.",BreedableActor.java,331.0,3
7,"private void incrementAge()
    {
        age++;
        if (age > maxAge) {
            setDead();
        }
    }","Increase the age, which can result in the breedable actor's death.",BreedableActor.java,331.0,3
8,"private void incrementHunger(int amount)
    {
        hungerLevel = hungerLevel - amount;
        if (hungerLevel <= 0) {
            setDead();
        }
    }","Make this breedable actor more hungry, which can result in the actor's death.",BreedableActor.java,331.0,3
9,"private void incrementHunger() {
        incrementHunger(1);
    }",Increment the breedable actor's hunger by 1.,BreedableActor.java,331.0,3
10,"private Location findFood()
    {
        if (hungerLevel >= getMaxHungerLevel()) {
            return null;
        }
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        for (Location where : adjacent) {
            Actor actor = (Actor) field.getObjectAt(where);
            if (actor != null && foodSources.contains(actor.getSpecies())) {
                if (actor instanceof Plant) {
                    Plant plant = (Plant) actor;
                    if (plant.isAlive()) {
                        plant.setDead();
                        hungerLevel += plant.getFoodLevel();
                        return where;
                    }
                } else if (actor instanceof Prey) {
                    Prey prey = (Prey) actor;
                    if (prey.isAlive()) {
                        prey.setDead();
                        hungerLevel += prey.getFoodLevel();
                        return where;
                    }
                }

            }
        }
        return null;  // No food found.
    }","Make the breedable actor look for food around itself and eat the first one it finds.

@return The location of the actor that was just eaten.",BreedableActor.java,331.0,3
11,"protected void giveBirth(List<Actor> newActors)
    {
        // New breedable actors are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for (int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);

            // Create young
            BreedableActor young = createYoung(field, loc);

            // Crossover parents' brains to generate child brain
            NeuralNetwork youngBrain = brain.crossover(partner.brain);
            youngBrain.mutate();
            young.setBrain(youngBrain);

            newActors.add(young);
        }
    }","Check whether or not this actor is to give birth at this step. New births will be made into free adjacent locations.

@param newActors A list to return newly born actors.",BreedableActor.java,331.0,3
12,"private int breed()
    {
        if (rand.nextDouble() <= breedingProbability) {
            return rand.nextInt(maxLitterSize) + 1;
        } else {
            return 0;
        }
    }","Generate a number representing the number of births, if it can breed.

@return The number of births (may be zero).",BreedableActor.java,331.0,3
13,"private boolean canBreed()
    {
        if (age < breedingAge) {
            return false;
        }

        if (sex == 'f') {
            if (pregnantTicks == 0) {
                Field field = getField();
                List<Location> nearby = field.adjacentLocations(getLocation());
                List<Actor> nearbyActors = new ArrayList<>();

                // Find nearby actors
                nearby.forEach(loc -> {
                    Actor nearbyActor = (Actor) field.getObjectAt(loc);
                    if (nearbyActor != null) {
                        nearbyActors.add(nearbyActor);
                    }
                });

                // Find if theres a male actor of same species which can breed
                BreedableActor availableActor = (BreedableActor) nearbyActors.stream().filter(actor ->
                        actor.species.equals(species) &&
                                ((BreedableActor) actor).getSex() == 'm' &&
                                ((BreedableActor) actor).canBreed()
                ).findFirst().orElse(null);
                if (availableActor != null) {
                    partner = availableActor;
                    pregnantTicks = (int) (maxAge * PREGNANCY_LENGTH);
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }

        return true;
    }","Check whether the breedable actor is able to breed in the current location.

@return true if the actor can breed, false otherwise.",BreedableActor.java,331.0,3
14,"public String getRandomName(char sex) {
        if(sex == 'f') {
            return FEMALE_NAMES.get(new Random().nextInt(FEMALE_NAMES.size()));
        } else {
            return MALE_NAMES.get(new Random().nextInt(MALE_NAMES.size()));
        }
    }","Get a random name for the breedable actor.

@param sex The sex ('f' or 'm') of the breedable actor.
@return A random name corresponding to the sex.",BreedableActor.java,331.0,3
15,"private void rewardBrain(String desireToIncreaseCertainty) {
        // Get index of desire to increase certainty
        int indexToIncreaseCertainty = Arrays.asList(DESIRES).indexOf(desireToIncreaseCertainty);

        // Create a new array of expected outputs
        double[] wantedOutputValues = new double[DESIRES.length];
        wantedOutputValues[indexToIncreaseCertainty] = 1.0;

        // Train actors neural network with current sensory inputs and wanted outputs
        brain.train(sensoryInputs, wantedOutputValues);
    }","Reward the actor's neural network by training the current input values with wanted outputs.
Wanted outputs is an array where the value referenced by the index of desireToIncreaseCertainty
is 1, and all other desires are 0.

@param desireToIncreaseCertainty desire to reward",BreedableActor.java,331.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuilder buffer = new StringBuilder();
        if(!countsValid) {
            generateCounts(field);
        }
        for(String species : counters.keySet()) {
            Counter info = counters.get(species);
            buffer.append(info.getSpecies());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get formatted details of what actors are in the field and how many of them there are.

@return A string describing what is in the field.",FieldStats.java,331.0,3
1,"public int getPopulationCount(Field field, String species)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(species);
        return counter.getCount();
    }","Get the number of individuals in the population of a given species name.

@param field The field currently occupied.
@param species The species to find the population of.
@return An int with the number for this species.",FieldStats.java,331.0,3
2,"public void reset()
    {
        countsValid = false;
        for(String species : counters.keySet()) {
            Counter count = counters.get(species);
            count.reset();
        }
    }","Invalidate the current set of statistics, so reset all counts to zero.",FieldStats.java,331.0,3
3,"public void incrementCount(String species)
    {
        Counter count = counters.get(species);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(species);
            counters.put(species, count);
        }
        count.increment();
    }",Increment the count for one species name.,FieldStats.java,331.0,3
4,"public void countFinished()
    {
        countsValid = true;
    }","Indicate that an animal count has been completed, so counters are up to date.",FieldStats.java,331.0,3
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(String species : counters.keySet()) {
            Counter info = counters.get(species);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable, so if it should continue to run.

@param field The field currently occupied.
@return true if there is more than one species alive.",FieldStats.java,331.0,3
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Actor actor = (Actor) field.getObjectAt(row, col);
                if(actor != null) {
                    incrementCount(actor.getSpecies());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of actors. These are not kept up to date as actors
are placed in the field, but only when a request is made for the information.

@param field The field to generate the stats for.",FieldStats.java,331.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }","Implement content equality.

@param obj The object to check.",Location.java,331.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column

@return A string representation of the location.",Location.java,331.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.

@return A hashcode for the location.",Location.java,331.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,331.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,331.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,331.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,331.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,331.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,331.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,331.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,331.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,331.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,331.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.

@param location The location to clear.",Field.java,331.0,3
2,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an actor at the given location.
If there is already an actor at the location. it will be lost.

@param animal The actor to be placed.
@param location Where to place the actor.",Field.java,331.0,3
3,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the actor at the given location, if any.

@param location Where in the field.
@return The actor at the given location, or null if there is none.",Field.java,331.0,3
4,"public Object getObjectAt(int row, int col)
    {
        try {
            return field[row][col];
        } catch(ArrayIndexOutOfBoundsException e) {
            return null;
    }
    }","Return the actor at the given row and column, if any.

@param row The desired row.
@param col The desired column.
@return The actor at the given location, or null if there is none.",Field.java,331.0,3
5,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of free adjacent locations.

@param location The location to look for locations around.
@return A list of free adjacent locations.",Field.java,331.0,3
6,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the given location.
If there is none, return null. The returned location will be within the valid bounds of the field.

@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,331.0,3
7,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        int row = location.getRow();
        int col = location.getCol();
        for(int roffset = -1; roffset <= 1; roffset++) {
            int nextRow = row + roffset;
            if(nextRow >= 0 && nextRow < depth) {
                for(int coffset = -1; coffset <= 1; coffset++) {
                    int nextCol = col + coffset;
                    // Exclude invalid locations and the original location.
                    if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                        locations.add(new Location(nextRow, nextCol));
                    }
                }
            }
        }

        // Shuffle the list. Several other methods rely on the list
        // being in a random order.
        Collections.shuffle(locations, rand);
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself. All locations will lie within the grid.

@param location The location from which to generate adjacencies.
@return A list of locations adjacent to the location given.",Field.java,331.0,3
8,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.

@return The depth of the field.",Field.java,331.0,3
9,"public int getWidth()
    {
        return width;
    }","Return the width of the field.

@return The width of the field.",Field.java,331.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,331.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,331.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,331.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,331.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,331.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
        classes = colors.keySet();
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GraphView.java,128.0,2
1,"public void showStatus(int step, Field field)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GraphView.java,128.0,2
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GraphView.java,128.0,2
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GraphView.java,128.0,2
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        JPanel bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel("" "");
        bottom.add(countLabel);
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,GraphView.java,128.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,128.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,128.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,128.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,128.0,2
0,"public void act(List<Organism> newRooster)
    {
        incrementAge();
        if(isAlive()) {        
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rooster does most of the time - it runs
around. It will get sick or die of old age.
@param newRooster A list to return newly born roosters.",Rooster.java,128.0,2
1,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of rooster in which it can live,Rooster.java,128.0,2
0,"public void act(List<Organism> newChards){
        incrementAge(); 
        if(isAlive()){
            giveBirth(newChards) ; 
        }
    }","Make this chard act.They age and give birth to new chards.
Chards do not move.
@param newChards A list to receive newly born chards.",Chard.java,128.0,2
1,"public void incrementAge(){
        age++; 
        if(age > getMaxAge()){
            setDead();
        }
    }",Increments age if not reached max age,Chard.java,128.0,2
2,"public static void changeGrowthRate(int newGrowthRate){
        growthRate = newGrowthRate; 
    }","Changes the value of the growth rate according to the weather condition
It is static as it is being accessed from the Simulator class in
simulateOneStep() method.

@param newGrowthRate It is the rate of the growth of the chards",Chard.java,128.0,2
3,"private void giveBirth(List<Organism> newChards){
        // New owles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Chard young = new Chard(false, field, loc);
            newChards.add(young);
        }
    }","Check whether or not this chard is to give birth at this step.
New chards will be made into free adjacent locations.
@param newChards A list to return newly born chards.",Chard.java,128.0,2
4,"public int breed(){
        int seeds = 0 ; 
        if(isMature()){
            seeds = (rand.nextInt(MAX_SEEDS) + 1) * growthRate ; 
        }
        return seeds; 
    }","This checks if the chard has reached the maturity age yet.
If it has, the chard breeds.
@return the number of the seeds given out by the chard",Chard.java,128.0,2
5,"public boolean isMature(){ 
        return age >= getMaxAge(); 
    }","A chard can breed if it has reached the maturity age.
Also gets if the plant is mature enough to give out seeds.
@return true if the chard can breed, false otherwise.",Chard.java,128.0,2
6,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of chard in which it can live,Chard.java,128.0,2
0,"public void act(List<Organism> newOwles)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newOwles);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the owl does most of the time: it hunts for
worms. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newOwles A list to return newly born owles.",Owl.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the owl's death.,Owl.java,128.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this owl more hungry. This could result in the owl's death.,Owl.java,128.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Worm) {
                Worm worm = (Worm) organism;
                if(worm.isAlive()) { 
                    worm.setDead();
                    foodLevel = WORM_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for worms adjacent to the current location.
Only the first live worm is eaten.
@return Where food was found, or null if it wasn't.",Owl.java,128.0,2
4,"private void giveBirth(List<Organism> newOwles)
    {
        // New owles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Owl young = new Owl(false, field, loc);
            newOwles.add(young);
        }
    }","Check whether or not this owl is to give birth at this step.
New births will be made into free adjacent locations.
@param newOwles A list to return newly born owles.",Owl.java,128.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Owl.java,128.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","An owl can breed if it has reached the breeding age.
@return true if the owl can breed, false otherwise.",Owl.java,128.0,2
7,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of owl in which it can live,Owl.java,128.0,2
0,"public void act(List<Organism> newLizardes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newLizardes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the lizard does most of the time: it hunts for
worms. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newLizardes A list to return newly born lizardes.",Lizard.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the lizard's death.,Lizard.java,128.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this lizard more hungry. This could result in the lizard's death.,Lizard.java,128.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Worm) {
                Worm worm = (Worm) organism;
                if(worm.isAlive()) { 
                    worm.setDead();
                    foodLevel = WORM_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for worms adjacent to the current location.
Only the first live worm is eaten.
@return Where food was found, or null if it wasn't.",Lizard.java,128.0,2
4,"private void giveBirth(List<Organism> newLizardes)
    {
        // New lizardes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Lizard young = new Lizard(false, field, loc);
            newLizardes.add(young);
        }
    }","Check whether or not this lizard is to give birth at this step.
New births will be made into free adjacent locations.
@param newLizardes A list to return newly born lizardes.",Lizard.java,128.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Lizard.java,128.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A lizard can breed if it has reached the breeding age.
@return true if the lizard can breed, false otherwise.",Lizard.java,128.0,2
7,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of lizard in which it can live,Lizard.java,128.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,128.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,128.0,2
0,"public void act(List<Organism> newSnakes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newSnakes);  
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
            
            if(isSick){ setDead(); }
        }
        
    }","This is what the snake does most of the time: it hunts for
chickens. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newSnakes A list to return newly born snakees.",Snake.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increase the age. This could result in the snake's death.,Snake.java,128.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this snake more hungry. This could result in the snake's death.,Snake.java,128.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Chicken) {
                Chicken chicken = (Chicken) organism;
                if(chicken.isAlive()) { 
                    if(chicken.getIsSick()){isSick = true;}
                    chicken.setDead();
                    foodLevel = CHICKEN_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for chickens adjacent to the current location.
Only the first live chicken is eaten.
@return Where food was found, or null if it wasn't.",Snake.java,128.0,2
4,"private void giveBirth(List<Organism> newSnakes)
    {
        // New snakees are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Snake young = new Snake(false, field, loc);
            newSnakes.add(young);
        }
    }","Check whether or not this snake is to give birth at this step.
New births will be made into free adjacent locations.
@param newSnakees A list to return newly born snakees.",Snake.java,128.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Snake.java,128.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A snake can breed if it has reached the breeding age.
@return true if the snake can breed, false otherwise.",Snake.java,128.0,2
7,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of snake in which it can live,Snake.java,128.0,2
0,"public void setColor(Class<?> organismClass, Color color)
    {
        //nothing...
    }","Define a color to be used for a given class of organism.
@param organismClass The organism's Class object.
@param color The color to be used for the given class.",TextView.java,128.0,2
1,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",TextView.java,128.0,2
2,"public void showStatus(int step, Field field)
    {
        stats.reset();
        String details = stats.getPopulationDetails(field);
        
        //This can be uncommented to see the stat values
        //System.out.println(""Step: "" + formattedStep + "" "" + details);
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",TextView.java,128.0,2
3,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,TextView.java,128.0,2
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,128.0,2
1,"private Color getColor(Class<?> animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,128.0,2
2,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step + ""        Weather: "" + Simulator.getWeather());
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    Class<?> cls = animal.getClass();
                    stats.incrementCount(cls);
                    fieldView.drawMark(col, row, getColor(cls));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GridView.java,128.0,2
3,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,128.0,2
4,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,128.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,128.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,128.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,128.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,128.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,128.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            //delay(150);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,128.0,2
2,"public void simulateOneStep()
    {
        step++;

        //Padding the step numbers with 0 (step numbers less than 10)
        String formattedStep = String.format(""%02d"", step);  
        //first digit of the step number
        int firstDigit = Integer.parseInt(formattedStep.substring(0, 1));   

        // Provide space for newborn organisms.
        List<Organism> newOrganisms = new ArrayList<>();        
        // List<Chard> newPlants = new ArrayList<>(); 
        if(rand.nextDouble()>=weatherConditions.get(""Sunny"")){    //0.50 probability for sunny
            weather = ""Sunny"" ; 
            Chard.changeGrowthRate(10); 
        }
        else if(rand.nextDouble()>=weatherConditions.get(""Rainy"")){   //0.20 probability for rain 
            weather = ""Rainy"" ; 
            Chard.changeGrowthRate(2);
        }  
        else if(rand.nextDouble()>=weatherConditions.get(""Foggy"")){   //0.15 probability for foggy 
            weather = ""Foggy"" ; 
            Chard.changeGrowthRate(1);
        }
        //0.15 probability for snowy 
        else if(rand.nextDouble()>weatherConditions.get(""Snowy"") || rand.nextDouble()<=weatherConditions.get(""Snowy"")) { 
            weather = ""Snowy"" ; 
            Chard.changeGrowthRate(0); 
        }
        
        //This is a boolean for the time of the day
        boolean morning = false;  
        
        //This checks if the time of the day is morning or not
        //A day is 150 steps, 0-75 is morning and 75-150 is night.
        if(timer <= 75 )
        {
            morning = true; 
        }
        else if(timer>75 && timer<=150)
        {
            morning = false; 
        }
        else
        {
            timer = 0 ; //resets the timer if the day is over
        }

        // Let all organisms act.
        for(Iterator<Organism> it = organisms.iterator(); it.hasNext();) 
        {
            Organism organism = it.next();
            //if it's morning and organism is an owl then put them to sleep
            if(organism.getClass() == Owl.class && morning)
            {
                //Let the owls sleep
                organism.sleep();
            }
            else {
                organism.act(newOrganisms);
            }

            if(!organism.isAlive()) 
            {
                it.remove(); 
            }

        }

        // Add the newly born organisms to the main lists.
        organisms.addAll(newOrganisms);
        timer++; 
        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each organism.",Simulator.java,128.0,2
3,"public void reset()
    {
        step = 0;
        organisms.clear();
        for (SimulatorView view : views) {
            view.reset();
        }

        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,128.0,2
4,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(step, field);
        }
    }",Update all existing views.,Simulator.java,128.0,2
5,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= OWL_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Owl owl = new Owl(true, field, location);
                    organisms.add(owl);
                }
                else if(rand.nextDouble() <= WORM_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Worm worm = new Worm(true, field, location);
                    organisms.add(worm);
                }
                else if(rand.nextDouble() <= LIZARD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lizard lizard = new Lizard(true, field, location);
                    organisms.add(lizard);
                }
                else if(rand.nextDouble() <= SNAKE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Snake snake = new Snake(true, field, location);
                    organisms.add(snake);
                }
                else if(rand.nextDouble() <= HEN_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Hen hen = new Hen(true, field, location);
                    organisms.add(hen);
                }
                else if(rand.nextDouble() <= ROOSTER_CREATION_PROBABILITY){
                    Location location = new Location(row, col) ; 
                    Rooster rooster = new Rooster(true, field, location);
                    organisms.add(rooster); 
                }
                else if(rand.nextDouble() <= CHARD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Chard chard = new Chard(true, field, location);
                    organisms.add(chard);
                }
                // else leave the location empty.
            }
        }
    }","Randomly populate the field with owls, lizards",Simulator.java,128.0,2
6,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,128.0,2
7,"public static String getWeather(){
        return weather ; 
    }","This is static method as it's being accessed by a method in GridView class
@return the value stored in weather",Simulator.java,128.0,2
0,"public void act(List<Organism> newHen)
    {
        incrementAge();
        if(isAlive()) {        
            if(findRooster(newHen)){
                giveBirth(newHen); 
            }
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation()); 
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
          
        }
    }","This is what the hen does most of the time - it runs
around. Sometimes it will breed, die of old age or get sick.
@param newHen A list to return newly born hen.",Hen.java,128.0,2
1,"private void giveBirth(List<Organism> newHen)
    {
        // New hens are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        //Creating new hen and rooster
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Hen youngHen = new Hen(false, field, loc);
            Rooster youngRooster = new Rooster(false, field, loc);
            newHen.add(youngHen);
            newHen.add(youngRooster);
        }
    }","Check whether or not this hen is to give birth at this step.
New births will be made into free adjacent locations.
Hen gives birth to new hens and roosters.
@param newHen A list to return newly born hen.",Hen.java,128.0,2
2,"public void incrementAge(){
        super.incrementAge();
        if(age > getMaxAge()) {
            setDead();
        }
    }",Increments the age of the hen,Hen.java,128.0,2
3,"private boolean canBreed(){
        if(isSick){ 
            return false; 
        }
        return age >= BREEDING_AGE;
    }","A hen can breed if it has reached the breeding age.
@return true if the hen can breed, false otherwise.",Hen.java,128.0,2
4,"public int breed(){
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
           births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Hen.java,128.0,2
5,"public boolean findRooster(List<Organism> newHen){
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object Organism = field.getObjectAt(where);
            if(Organism instanceof Rooster) {
                Rooster rooster = (Rooster) Organism;
                if(rooster.isAlive()) { 
                    giveBirth(newHen);
                    return true;
                }
            }
        }
        return false;
    }","Finds a rooster adjacent to the current location to reproduce with.
@param newHen A list to return newly born chickens.
@return true if a rooster is found and give birth.",Hen.java,128.0,2
6,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of hen in which it can live,Hen.java,128.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,128.0,2
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,128.0,2
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,128.0,2
3,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,128.0,2
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,128.0,2
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,128.0,2
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,128.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,128.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,128.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,128.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,128.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,128.0,2
0,"protected int getRandomAge(){
        return rand.nextInt(getMaxAge());
    }",Generated a random age,Organism.java,128.0,2
1,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,128.0,2
2,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,128.0,2
3,"protected Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,128.0,2
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the organism at the new location in the given field.
@param newLocation The organism's new location.",Organism.java,128.0,2
5,"protected Field getField(){
        return field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,128.0,2
6,"public void sleep(){
         boolean isSleeping = true; 
    }",This checks if the organism is sleep or not,Organism.java,128.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,128.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,128.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,128.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,128.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,128.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,128.0,2
0,"public void act(List<Organism> newChicken)
    {
        incrementAge();
    }","This is what the chicken does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newChickens A list to return newly born chicken.",Chicken.java,128.0,2
1,"protected void incrementAge()
    {
        age++;
    }",Increase the age by one,Chicken.java,128.0,2
2,"protected void shortenLifeSpan(){
        age += 5; 
    }",Decrease the lifespan of the organism by 5,Chicken.java,128.0,2
3,"public boolean getIsSick(){
        return isSick; 
    }",@return true if the chicken is sick or false if not,Chicken.java,128.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,128.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,128.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,128.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,128.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,128.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,128.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,128.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,128.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,128.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,128.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,128.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,128.0,2
0,"public void act(List<Organism> newWorms)
    {
        incrementAge(); //increments age 
        incrementHunger(); //increments hunger
        
        if(isAlive()) {
            giveBirth(newWorms);            
            // Try to move into a free location.
            Location newLocation = findFood();
            // Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the worm does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newWorms A list to return newly born worms.",Worm.java,128.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }","Increase the age.
This could result in the worm's death.",Worm.java,128.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this worms more hungry. This could result in the worms's death.,Worm.java,128.0,2
3,"private void giveBirth(List<Organism> newWorms)
    {
        // New worms are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Worm young = new Worm(false, field, loc);
            newWorms.add(young);
        }
    }","Check whether or not this worm is to give birth at this step.
New births will be made into free adjacent locations.
@param newWorms A list to return newly born worms.",Worm.java,128.0,2
4,"private Location findFood(){
        Field field = getField(); 
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Chard) {
                Chard chard = (Chard) organism;
                if(chard.isAlive()) { 
                    chard.setDead();
                    foodLevel = CHARD_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for chards adjacent to the current location.
Only the first live chard is eaten.
@return where food was found, or null if it wasn't.",Worm.java,128.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Worm.java,128.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A worm can breed if it has reached the breeding age.
@return true if the worm can breed, false otherwise.",Worm.java,128.0,2
7,"public int getMaxAge(){
        return MAX_AGE;
    }",@return the maximum age of worm in which it can live,Worm.java,128.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,128.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,128.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,128.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,128.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,128.0,2
0,"public void act(List<Aquatic> newMollys)
    {
        incrementAge();
        if(isAlive()) 
        {
            giveBirth(newMollys);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) 
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the molly does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newMolly A list to return newly born mollies.",Molly.java,39.0,2
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Moss) 
            {
                Moss moss= (Moss) plant;
                if(moss.isAlive()) 
                { 
                    moss.setDead();
                    foodLevel = MOSS_FOOD_VALUE; 
                    return where;
                }
            }
        }
        return null;
    }","Look for mollys adjacent to the current location.
Only the first live food is eaten.
@return Where food was found, or null if it wasn't.",Molly.java,39.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age .,Molly.java,39.0,2
3,"private void giveBirth(List<Aquatic> newMollys)
    {
        if(getGender()=='F')
        {
        // New mollys are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Molly young = new Molly(false, field, loc);
            newMollys.add(young);
        }
    }
    }","Check whether or not this molly is to give birth at this step.
New births will be made into free adjacent locations.
@param newMollys A list to return newly born mollys.",Molly.java,39.0,2
4,"protected int breed()
    {
       int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) 
        {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births; 
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Molly.java,39.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Molly.java,39.0,2
6,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Molly.java,39.0,2
7,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Molly.java,39.0,2
8,"public  boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
             Location where = it.next();
             Object object = field.getObjectAt(where);
             if(object instanceof Animal)
             {
                Animal animal = (Animal) object;
                if(animal instanceof Molly && this.getGender()!= animal.getGender())
                {
                     return age >= BREEDING_AGE;
                }
             }   
        }
         return false;
    }","A molly can breed if it has reached the breeding age.
@return true if the molly can breed, false otherwise.",Molly.java,39.0,2
9,"protected Animal getYoung(Location loc)
    {
        return new Molly(false, getField(), loc);
    }","Return the young of this animal
@return The young of this animal",Molly.java,39.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,39.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,39.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,39.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,39.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,39.0,2
0,"public void act(List<Aquatic> newFarlowellas)
    {
        incrementAge();
         
        if(isAlive()) 
        {
            giveBirth(newFarlowellas);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) 
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the farlowella does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newFarlowella A list to return newly born farlowellas.",Farlowella.java,39.0,2
1,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
         {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Moss) 
            {
                Moss moss = (Moss) plant;
                if(moss.isAlive()) 
                { 
                    moss.setDead();
                    foodLevel = MOSS_FOOD_VALUE;      return where;
                }
            }
            
        }
        return null;
    }","Look for foods adjacent to the current location.
Only the first live food is eaten.
@return Where food was found, or null if it wasn't.",Farlowella.java,39.0,2
2,"private void giveBirth(List<Aquatic> newFarlowellas)
    {
        if(getGender()=='F')
        {
        // New mollys are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Farlowella young = new Farlowella(false, field, loc);
            
            newFarlowellas.add(young);
        }
        }
    }","Check whether or not this farlowella is to give birth at this step.
New births will be made into free adjacent locations.
@param newFarlowellas A list to return newly born farlowellas.",Farlowella.java,39.0,2
3,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) 
        {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Farlowella.java,39.0,2
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Farlowella.java,39.0,2
5,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Farlowella.java,39.0,2
6,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Farlowella.java,39.0,2
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age,Farlowella.java,39.0,2
8,"protected  boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
             Location where = it.next();
             Object object = field.getObjectAt(where);
             if(object instanceof Animal){
                Animal animal = (Animal) object;
                if(animal instanceof Farlowella && this.getGender()!= animal.getGender()){
                     return age >= BREEDING_AGE;
                }
             }   
        }
         return false;
    }","A farlowella can breed if it has reached the breeding age.
@return true if the farlowella can breed, false otherwise.",Farlowella.java,39.0,2
9,"protected Animal getYoung(Location loc)
    {
        return new Farlowella(false, getField(), loc);
    }","Return the young of this animal
@return The young of this animal",Farlowella.java,39.0,2
0,"public void act(List<Aquatic> newCockatoos)
    {
        incrementAge();
        
        incrementHunger();
        if(isAlive()) 
        {
            diseaseCheck();
            giveBirth(newCockatoos);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) 
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();
            }
            
        }
    }","This is what the cockatoo does most of the time: it hunts for
mollys. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newCockatoo A list to return newly born cockatoos.",Cockatoo.java,39.0,2
1,"protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) 
        {
            setDead();
             
        }
    }",Make this Cockatoo more hungry. This could result in the Cockatoo's death.,Cockatoo.java,39.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
         {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Molly) 
            {
                Molly molly = (Molly) animal;
                if(molly.isAlive()) 
                { 
                  molly.setDead();
                  foodLevel = MOLLY_FOOD_VALUE;
                  return where;
                }
            }
            else if(animal instanceof Piranha)
            {
                Piranha piranha = (Piranha) animal;
                if(piranha.isAlive()) 
                { 
                 piranha.setDead();
                 foodLevel = PIRANHA_FOOD_VALUE;
                 return where;
                }  
             }
        }
        return null;
    }","Look for cockatoos adjacent to the current location.
Only the first live food is eaten.
@return Where food was found, or null if it wasn't.",Cockatoo.java,39.0,2
3,"private void giveBirth(List<Aquatic> newCockatoo)
    {
        if(getGender()=='F')
        {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Cockatoo young = new Cockatoo(false, field, loc);
            
            newCockatoo.add(young);
        }
    }
    }","Check whether or not this cockatoo is to give birth at this step.
New births will be made into free adjacent locations.
@param newCockatoo A list to return newly born cockatoos.",Cockatoo.java,39.0,2
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Cockatoo.java,39.0,2
5,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Cockatoo.java,39.0,2
6,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Cockatoo.java,39.0,2
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age .,Cockatoo.java,39.0,2
8,"protected int breed()
    {
        int births = 0;
        double breeding = BREEDING_PROBABILITY;
        if(isDiseased()){
            breeding=0;
        }
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) 
        {
          births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Cockatoo.java,39.0,2
9,"protected boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
             Location where = it.next();
             Object object = field.getObjectAt(where);
             if(object instanceof Animal)
             {
                Animal animal = (Animal) object;
                if(animal instanceof Cockatoo && this.getGender()!= animal.getGender())
                {
                     return age >= BREEDING_AGE;
                }
             }   
        }
         return false;
    }",A cockatoo can breed if it has reached the breeding age.,Cockatoo.java,39.0,2
10,"protected Animal getYoung(Location loc)
    {
        return new Cockatoo(false, getField(), loc);
    }","Return the young of this animal
@return The young of this animal",Cockatoo.java,39.0,2
11,"public void diseaseCheck()
    {
    	Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            // Check if one of the adjacent locations has a cockatoo
            if(animal instanceof Cockatoo) {
                Cockatoo cockatoo = (Cockatoo) animal;
                // Infect cockatoo if other cockatoo is infected
                if(cockatoo.isDiseased()) {
                	if(diseased == false){
                		setDiseased(rand.nextDouble() <= DISEASED_CHANCE);
                	}
                }
            }
        }
    }",A cockatoo can get ill with a cockatoo virus.,Cockatoo.java,39.0,2
0,"public static Random getRandom()
    {
        if(useShared) 
        {
            return rand;
        }
            else 
        {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,39.0,2
1,"public static void reset()
    {
        if(useShared) 
        {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,39.0,2
1,"private void proliferationOfPlant(List<Aquatic> newMoss)
    {
        // New grass are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int proliferation = breed();
        for(int b = 0; b < proliferation && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Moss young = new Moss(false, field, loc);
            newMoss.add(young);
        }
    }","Check whether or not this  moss is to give birth at this step.
New births will be made into free adjacent locations.
@param newMoss A list to return newly born moss.",Moss.java,39.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age of moss.,Moss.java,39.0,2
3,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Moss.java,39.0,2
4,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Moss.java,39.0,2
5,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Moss.java,39.0,2
6,"protected Plant getYoung(Location loc)
    {
        return new Moss(false, getField(), loc);
    }",Returns ne mosses.,Moss.java,39.0,2
7,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) 
        {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
            
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Moss.java,39.0,2
8,"protected  boolean canBreed()
    {
       return age >= BREEDING_AGE;
    }","A moss can breed if it has reached the breeding age.
@return true if the farlowella can breed, false otherwise.",Moss.java,39.0,2
0,"public boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,39.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) 
        {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,39.0,2
2,"protected  void incrementAge()
    {
        age++;
        if(age > getMaxAge()) 
        {
            setDead();
        }
    }","Increase the age.
This could result in the plant's death.",Plant.java,39.0,2
3,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,39.0,2
4,"protected void setLocation(Location newLocation)
    {
        if(location != null) 
        {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,39.0,2
5,"protected Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,39.0,2
6,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) 
        {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births; 
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Plant.java,39.0,2
7,"protected boolean canBreed()
    {
        return age >= getBreedingAge();
    }","A molly can breed if it has reached the breeding age.
@return true if the molly can breed, false otherwise.",Plant.java,39.0,2
8,"public int getAge()
    {
        return age ;
    }",Returns the age of the plant.,Plant.java,39.0,2
9,"public void setAge(int age)
    {
        this.age = age;
    }",Sets the age.,Plant.java,39.0,2
10,"private void giveBirth(List<Aquatic> newPlants)
    {
        // New mollys are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            newPlants.add(getYoung(loc));
        }
    }","Check whether or not this plant is to give birth at this step.
New births will be made into free adjacent locations.
@param newPlants A list to return newly born plantss.",Plant.java,39.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,39.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,39.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,39.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,39.0,2
0,"public boolean isAlive()
    {
        return alive;
    }","Check whether the human is alive or not.
@return true if the human is still alive.",Human.java,39.0,2
1,"public void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the human is no longer alive.
It is removed from the field.",Human.java,39.0,2
2,"public Location getLocation(){
        return location;
    }","Returns the location of this fieldunit
@return the location of this fieldunit",Human.java,39.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) 
        {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The human's new location.",Human.java,39.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the human's field.
@return The human's field.",Human.java,39.0,2
5,"protected  void incrementAge()
    {
        age++;
        if(age > getMaxAge()) 
        {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Human.java,39.0,2
6,"public int getAge()
    {
        return age ;
    }",Returns the age of the human.,Human.java,39.0,2
7,"public void setAge(int age)
    {
        this.age = age;
    }",Sets the max age.,Human.java,39.0,2
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,39.0,2
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,39.0,2
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) 
        {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else 
        {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,39.0,2
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) 
        {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) 
        {
            for(int col = 0; col < field.getWidth(); col++)
            {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) 
                {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else if(row>20 &&row<60 && col>19 && col<row ){
                    fieldView.drawMark(col, row, BERMUDA);
                    }
                else 
                {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();
        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,39.0,2
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,39.0,2
0,"public void runLongSimulation()
    {
        simulate(4000);
    }","Run the simulation from its current state for a reasonably long period,
(4000 steps).",Simulator.java,39.0,2
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) 
        {
         simulateOneStep();
         //delay(90);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,39.0,2
2,"public void simulateOneStep()
    {
        step++;
        field.bermudaTriangle(view);
        delay(100);
     
        // Provide space for newborn animals.
        List<Aquatic> newAquatic = new ArrayList<>();        
        // Let all rabbits act.
        for(Iterator<Aquatic> it = aquatics.iterator(); it.hasNext(); ) 
        {
         Aquatic aquatic = it.next();
         if (dayTime() && animalCheck(aquatic)) 
         {
          continue;
         }
         aquatic.act (newAquatic);
          if(! aquatic.isAlive()) 
          {
           it.remove();
         }
        }     
        // Add the newly born foxes and rabbits to the main lists.
        aquatics.addAll(newAquatic);
        field.bermudaTriangle(view);
        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
piranha, farlowella, cockatoo, seahorse, molly and fisherman.",Simulator.java,39.0,2
3,"private boolean dayTime()
    {
        if ((step % day) == 0){
            dayTime = !dayTime; //switch between day and night
        }
        return dayTime;
    }",Indicates the day and night time periods.,Simulator.java,39.0,2
4,"private boolean animalCheck (Aquatic aquatic)
    {
     return aquatic instanceof Molly || aquatic instanceof Piranha || aquatic instanceof Cockatoo || aquatic instanceof Farlowella;
    }",Checks whether the aquatic is animal or not.,Simulator.java,39.0,2
5,"public void reset()
    {
        step = 0;
        aquatics.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,39.0,2
6,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) 
        {
            for(int col = 0; col < field.getWidth(); col++) 
            {
                field.bermudaTriangle(view);
                if(rand.nextDouble() <= PIRANHA_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Piranha piranha = new Piranha(true, field, location);
                aquatics.add(piranha);
            }
                else if(rand.nextDouble() <= MOLLY_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Molly molly = new Molly(true, field, location);
                aquatics.add(molly);
            }
                else if(rand.nextDouble() <= FARLOWELLA_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Farlowella farlowella = new Farlowella(true, field, location);
                aquatics.add(farlowella);
            }   
                else if(rand.nextDouble() <= COCKATOO_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Cockatoo cockatoo = new Cockatoo(true, field, location);
                aquatics.add(cockatoo);
            }
                else if(rand.nextDouble() <= MOSS_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Moss moss = new Moss(true, field, location);
                aquatics.add(moss);
            }
                else if(rand.nextDouble() <= SEAHORSE_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Seahorse seahorse = new Seahorse(true, field, location);
                aquatics.add(seahorse);
            }
               else if(rand.nextDouble() <= FISHERMAN_CREATION_PROBABILITY) 
            {
                Location location = new Location(row, col);
                Fisherman fisherman = new Fisherman( field, location);
                aquatics.add(fisherman);
            }
            // else leave the location empty.
            }
        } 
    }","Randomly populate the field with piranhas, farlowellas, cockatoos, seahorses, mollys and fisherman.",Simulator.java,39.0,2
7,"private void delay(int millisec)
    {
        
        try  
        {
        Thread.sleep(millisec);
        }
        catch (InterruptedException ie) 
        {
        // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,39.0,2
0,"public void act(List<Aquatic> newPiranhas)
    {
        incrementAge(); 
        incrementHunger();
        if(isAlive()) 
        {
            giveBirth(newPiranhas);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) 
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();  
            } 
        }
    }","This is what the piranha does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newPiranha A list to return newly born piranhas.",Piranha.java,39.0,2
1,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age .,Piranha.java,39.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) 
        {
            setDead();
        }
    }",Make this  piranha more hungry. This could result in the  piranha's death.,Piranha.java,39.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Molly) 
            {
                Molly molly = (Molly) animal;
                if(molly.isAlive()) 
                { 
                    molly.setDead();
                    foodLevel = MOLLY_FOOD_VALUE; 
                    return where;
                }
            }
            else if(animal instanceof Cockatoo)
            {
                Cockatoo cockatoo = (Cockatoo) animal;
                if(cockatoo.isAlive()) 
                { 
                    cockatoo.setDead();
                    foodLevel = COCKATOO_FOOD_VALUE;  
                    return where;
                } 
            }   
            else if(animal instanceof Farlowella)
                {
                 Farlowella farlowella = (Farlowella) animal;
                if(farlowella.isAlive()) 
                { 
                    farlowella.setDead();
                    foodLevel = FARLOWELLA_FOOD_VALUE;  return where;
                }  
            }
        }
        return null;
    }","Look for foods adjacent to the current location.
Only the first live food is eaten.
@return Where food was found, or null if it wasn't.",Piranha.java,39.0,2
4,"private void giveBirth(List<Aquatic> newPiranha)
    {
        if(getGender()=='F')
        {
        // New  piranhas are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Piranha young = new Piranha(false, field, loc);
            newPiranha.add(young);
        }
    }
    }","Check whether or not this piranha is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Piranha.java,39.0,2
5,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) 
        {
           births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births; 
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Piranha.java,39.0,2
6,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Piranha.java,39.0,2
7,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Piranha.java,39.0,2
8,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Piranha.java,39.0,2
9,"public boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
             Location where = it.next();
             Object object = field.getObjectAt(where);
             if(object instanceof Animal){
                Animal animal = (Animal) object;
                if(animal instanceof Piranha && this.getGender()!= animal.getGender())
                {
                     return age >= BREEDING_AGE;
                }
             }   
        }
         return false;
    }",A  piranha can breed if it has reached the breeding age.,Piranha.java,39.0,2
10,"protected Animal getYoung(Location loc)
    {
        return new Piranha(false, getField(), loc);
    }","Return the young of this animal
@return The young of this animal",Piranha.java,39.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,39.0,2
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,39.0,2
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,39.0,2
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,39.0,2
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,39.0,2
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,39.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) 
        {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else 
        {
            return false;
        }
    }",Implement content equality.,Location.java,39.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,39.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,39.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,39.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,39.0,2
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,39.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,39.0,2
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,39.0,2
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,39.0,2
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,39.0,2
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,39.0,2
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,39.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,39.0,2
1,"public void bermudaTriangle(SimulatorView view)
    {
    for(int row= 20; row < 60 && row<width; row++) {
            for(int col = 19; col < row && col<depth; col++) {
                field[row][col] = null;
                
            }
        }
    }",Empty the specific field.,Field.java,39.0,2
2,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,39.0,2
3,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,39.0,2
4,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,39.0,2
5,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,39.0,2
6,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,39.0,2
7,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,39.0,2
8,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,39.0,2
9,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,39.0,2
10,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,39.0,2
11,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,39.0,2
12,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,39.0,2
0,"public void act(List<Aquatic> newSeahorses)
    {
        incrementAge();
        if(isAlive()) 
        {
            giveBirth(newSeahorses);            
            // Try to move into a free location.
            Location newLocation = findFood();
            if(newLocation == null) 
            { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            if(newLocation != null) 
            {
                setLocation(newLocation);
            }
            else 
            {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the seahorse  does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newSeahorse  A list to return newly born seahorses.",Seahorse.java,39.0,2
1,"private void giveBirth(List<Aquatic> newSeahorses)
    {
        if(getGender()=='M')
        {
        // New seahorses are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            Seahorse  young = new Seahorse (false, field, loc);
            newSeahorses.add(young);
        }
        }
    }","Check whether or not this seahorse  is to give birth at this step.
New births will be made into free adjacent locations.
@param newSeahorse  A list to return newly born seahorses.",Seahorse.java,39.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Moss) 
            {
                Moss moss = (Moss) animal;
                if(moss.isAlive()) 
                { 
                    moss.setDead();
                    foodLevel = MOSS_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for seahorses adjacent to the current location.
Only the first live seahorse is eaten.
@return Where food was found, or null if it wasn't.",Seahorse.java,39.0,2
3,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) 
        {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Seahorse.java,39.0,2
4,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }",Returns the max litter size.,Seahorse.java,39.0,2
5,"protected double  getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }",Returns the probobility for breeding.,Seahorse.java,39.0,2
6,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }",Returns the breeding age.,Seahorse.java,39.0,2
7,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the max age .,Seahorse.java,39.0,2
8,"protected  boolean canBreed()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
             Location where = it.next();
             Object object = field.getObjectAt(where);
             if(object instanceof Animal)
             {
                Animal animal = (Animal) object;
                if(animal instanceof Seahorse && this.getGender()!= animal.getGender())
                {
                     return age >= BREEDING_AGE;
                }
             }   
        }
         return false;
    }","A seahorse can breed if it has reached the breeding age.
@return true if the seahorse can breed, false otherwise.",Seahorse.java,39.0,2
9,"protected Animal getYoung(Location loc)
    {
        return new Seahorse(false, getField(), loc);
    }","Return the young of this animal
@return The young of this animal",Seahorse.java,39.0,2
0,"public int getAge()
    {
        return age ;
    }",Returns the age of the animal.,Animal.java,39.0,2
1,"public void setAge(int age)
    {
        this.age = age;
    }",Sets the age.,Animal.java,39.0,2
2,"protected boolean canBreed()
    {
        return age >= getBreedingAge();
    }","A molly can breed if it has reached the breeding age.
@return true if the molly can breed, false otherwise.",Animal.java,39.0,2
3,"public boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,39.0,2
4,"protected  void incrementAge()
    {
        age++;
        if(age > getMaxAge()) 
        {
            setDead();
       }
       
    }","Increase the age.
This could result in the animals's death.",Animal.java,39.0,2
5,"public boolean isDiseased()
    {
        return diseased;
    }","Check whether the animal is diseased or not.
@return true if the animal is diseased.",Animal.java,39.0,2
6,"public void setDiseased()
    {
        diseased = true;
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,39.0,2
7,"public boolean diseased() 
    {
        return diseased;
    }","Return whether or not the animal is diseased
@return whether or not the animal is diseased",Animal.java,39.0,2
8,"public void setDiseased(boolean newDisease) 
    {
        diseased = newDisease;
    }","Set the whether or not the animal is diseased
@param newDisease Whether or not the animal is diseased",Animal.java,39.0,2
9,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,39.0,2
10,"private void giveBirth(List<Aquatic> newAnimals)
    {
        // New mollys are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) 
        {
            Location loc = free.remove(0);
            newAnimals.add(getYoung(loc));
        }
    }","Check whether or not this animal is to give birth at this step.
New births will be made into free adjacent locations.
@param newMollys A list to return newly born animals.",Animal.java,39.0,2
11,"protected int breed()
    {
        int births = 0;
        
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) 
        {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births; 
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Animal.java,39.0,2
12,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,39.0,2
13,"protected void setLocation(Location newLocation)
    {
        if(location != null) 
        {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,39.0,2
14,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,39.0,2
15,"public char getGender() 
    {
        return gender;
    }","Return the animals gender
@return The animals gender",Animal.java,39.0,2
0,"public void act(List<Aquatic> newHumans)
    {
            incrementAge();
            if(isAlive())
            {
            // Move towards a source of food if found.
            Location newLocation = animalFishing();
            if(newLocation == null) 
            { 
            // No food found - try to move to a free location.
            newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) 
            {
                setLocation(newLocation);
            } else 
            {
                setDead();
            }
        }
    }","This is what the fisherman does most of the time: it hunts farlowellas,
In the process it might die by a bear of old age.",Fisherman.java,39.0,2
1,"private Location animalFishing()
    {
        Field field = getField();
        
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) 
        {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if (animal instanceof Farlowella) 
            {
                Farlowella farlowella = (Farlowella) animal;
                if (farlowella.isAlive()) 
                {
                    farlowella.setDead();
                    return where;
                }
            }
        }
        return null;
    }","Tell the fisherman to look for farlowellas in a 5 square radius to its current location.

@param location Where in the field it is located.",Fisherman.java,39.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }",Returns the fisherman's max age.,Fisherman.java,39.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,127.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,127.0,3
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,127.0,3
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,127.0,3
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,127.0,3
0,"public void act1(List<Animal> newGazelles)
    {
        incrementAge();
        incrementHunger();
        haveDisease();
        if(isAlive()) {
            giveBirth(newGazelles);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the gazelle does most of the time during the day- it runs
around. Sometimes it will breed or die of old age.
@param newGazelles A list to return newly born gazelles.",Gazelle.java,127.0,3
1,"public void act2(List<Animal> newGazelles)
    {
        incrementAge();
        incrementHunger();
        haveDisease();
    }","This is what the gazelle does at night - it sleeps
Hence, its age and hunger increases - which could result in death.
@param newGazelles A list to return newly born Gazelles.",Gazelle.java,127.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the gazelle's death.",Gazelle.java,127.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this gazelle more hungry. This could result in the gazelle's death.,Gazelle.java,127.0,3
4,"private void haveDisease()
    {
      if(isDiseased()){
        incrementDisease();
      }
    }",This method checks if the gazelle has a disease.,Gazelle.java,127.0,3
5,"private void incrementDisease()
    {
        diseaseLevel--;
        if(diseaseLevel <= 0) {
            setDead();
            infectOthers();
        }
    }",This method is to increment the disease of the gazelle.,Gazelle.java,127.0,3
6,"private void infectOthers()
    {
        Field field = getField();
        System.out.println(field);
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Animal) {
                Animal animals = (Animal) animal;
                if(animals.isAlive()) { 
                    animals.getDisease();
                    //return where;
                }
            }
        }
        //return null;
    }","Look for animals adjacent to the current location.
Only the first live animal is infected.",Gazelle.java,127.0,3
7,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Grass) {
                Grass grass = (Grass) plant;
                int grassAge = grass.grassAge;
                if(grass.isAlive()) { 
                    if(grassAge >= 3){
                        foodLevel += 2;
                        grassAge -= 2;
                }
                else {
                    foodLevel += grassAge;
                    grassAge = 0;
                }
              }
            }
        }
        return null;
    }","Look for grass adjacent to the current location.
Only the first grown grass is eaten.
@return Where food was found, or null if it wasn't.",Gazelle.java,127.0,3
8,"private void giveBirth(List<Animal> newGazelles)
    {
        // New gazelles are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Gazelle young = new Gazelle(false, field, loc);
            newGazelles.add(young);
        }
    }","Check whether or not this gazelle is to give birth at this step.
New births will be made into free adjacent locations.
@param newGazelles A list to return newly born gazelles.",Gazelle.java,127.0,3
9,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Gazelle.java,127.0,3
10,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A gazelle can breed if it has reached the breeding age.
@return true if the gazelle can breed, false otherwise.",Gazelle.java,127.0,3
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,127.0,3
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,127.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the plant is alive or not.
@return true if the plant is still alive.",Plant.java,127.0,3
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the plant is no longer alive.
It is removed from the field.",Plant.java,127.0,3
2,"protected Location getLocation()
    {
        return location;
    }","Return the plant's location.
@return The plant's location.",Plant.java,127.0,3
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the plant at the new location in the given field.
@param newLocation The plant's new location.",Plant.java,127.0,3
4,"protected Field getField()
    {
        return field;
    }","Return the plant's field.
@return The plant's field.",Plant.java,127.0,3
5,"protected boolean isRain()
    {
    return rand.nextDouble() <= RAIN_PROBABILITY;
    }","This method is to check whether it is
raining or not.",Plant.java,127.0,3
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,127.0,3
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,127.0,3
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,127.0,3
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,127.0,3
0,"public void act1(List<Animal> newLeopards)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newLeopards);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the leopard does most of the time during the day: it hunts for
pandas. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newLeopards A list to return newly born Leopards.",Leopard.java,127.0,3
1,"public void act2(List<Animal> newLeopards)
    {
        incrementAge();
        incrementHunger();
    }","This is what the leopard does most of the time during the night: it sleeps
In the process, it might die of hunger or old age
@param field The field currently occupied.
@param newLeopards A list to return newly born Leopards.",Leopard.java,127.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the leopard's death.,Leopard.java,127.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this leopard more hungry. This could result in the leopard's death.,Leopard.java,127.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Panda) {
                Panda panda = (Panda) animal;
                int food = panda.foodLevel;
                if(panda.isAlive()) { 
                    panda.setDead();
                    foodLevel += food;
                    return where;
                }
            }
        }
        return null;
    }","Look for pandas adjacent to the current location.
Only the first live panda is eaten.
@return Where food was found, or null if it wasn't.",Leopard.java,127.0,3
5,"private void giveBirth(List<Animal> newLeopards)
    {
        // New leopards are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Leopard young = new Leopard(false, field, loc);
            newLeopards.add(young);
        }
    }","Check whether or not this leopard is to give birth at this step.
New births will be made into free adjacent locations.
@param newLeopards A list to return newly born leopards.",Leopard.java,127.0,3
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Leopard.java,127.0,3
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A leopard can breed if it has reached the breeding age.,Leopard.java,127.0,3
0,"public void setColor(Class animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",SimulatorView.java,127.0,3
1,"public void setInfoText(String text)
    {
        infoLabel.setText(text);
    }",Display a short information label at the top of the window.,SimulatorView.java,127.0,3
2,"private Color getColor(Class animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,SimulatorView.java,127.0,3
3,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    stats.incrementCount(animal.getClass());
                    fieldView.drawMark(col, row, getColor(animal.getClass()));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",SimulatorView.java,127.0,3
4,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",SimulatorView.java,127.0,3
0,"public void act(List<Plant> newBamboos)
    {
        grow();
    }","This is what the bamboo does most of the time during the day- it stays
in one place.
Sometimes it will breed or die of old age.
@param newGazelles A list to return newly born gazelles.",Bamboo.java,127.0,3
1,"private void grow()
    {
        if(isRain()) {
            bambooAge = bambooAge + 50;
        }
    }","Check whether or not this bamboo is to breed at this step.
New plants will be made into free adjacent locations.
@param newGazelles A list to return newly bred bamboos.",Bamboo.java,127.0,3
0,"public void runLongSimulation()
    {
        simulate(3000);
    }","Run the simulation from its current state for a reasonably long period,
(3000 steps).",Simulator.java,127.0,3
1,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && view.isViable(field); step++) {
            simulateOneStep();
            // delay(60);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,127.0,3
2,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn animals.
        List<Animal> newAnimals = new ArrayList<>();   
        List<Plant> newPlants = new ArrayList<>();  
        // Let all preys act.
        
        for(Iterator<Plant> it = plants.iterator(); it.hasNext(); ) {
            Plant plant = it.next();
            plant.act(newPlants);
            if(! plant.isAlive()) {
                it.remove();
            }
        }
        if(step%(2*DAY_LENGTH) <= DAY_LENGTH) {
        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
            Animal animal = it.next();
            animal.act1(newAnimals);
            if(! animal.isAlive()) {
                it.remove();
            }
        }
        } else{
               for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
                Animal animal = it.next();
                animal.act2(newAnimals);
                if(! animal.isAlive()) {
                it.remove();
                }
        }
        }
               
        // Add the newly born predators and preys to the main lists.
        animals.addAll(newAnimals);
        plants.addAll(newPlants);

        view.showStatus(step, field);
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
predator and prey.",Simulator.java,127.0,3
3,"public void reset()
    {
        step = 0;
        animals.clear();
        plants.clear();
        populate();
        
        // Show the starting state in the view.
        view.showStatus(step, field);
    }",Reset the simulation to a starting position.,Simulator.java,127.0,3
4,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                 if(rand.nextDouble() <= BAMBOO_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Bamboo bamboo = new Bamboo(true, field, location);
                    plants.add(bamboo);
                }
                 else if(rand.nextDouble() <= GRASS_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Grass grass = new Grass(true, field, location);
                    plants.add(grass);
                }
                else if(rand.nextDouble() <= CHEETAH_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Cheetah cheetah = new Cheetah(true, field, location);
                    animals.add(cheetah);
                }
                else if(rand.nextDouble() <= GAZELLE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Gazelle gazelle = new Gazelle(true, field, location);
                    animals.add(gazelle);
                }
                else if(rand.nextDouble() <= PANDA_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Panda panda = new Panda(true, field, location);
                    animals.add(panda);
                }
                else if(rand.nextDouble() <= LEOPARD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Leopard leopard = new Leopard(true, field, location);
                    animals.add(leopard);
                }
                 else if(rand.nextDouble() <= LION_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Lion lion = new Lion(true, field, location);
                    animals.add(lion);
                }
                
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with cheetahs and gazelles.,Simulator.java,127.0,3
5,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,127.0,3
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,127.0,3
1,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,127.0,3
2,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,127.0,3
3,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,127.0,3
4,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,127.0,3
5,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,127.0,3
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,127.0,3
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,127.0,3
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,127.0,3
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,127.0,3
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,127.0,3
0,"public void act1(List<Animal> newCheetahs)
    {
        incrementAge();
        incrementHunger();
        haveDisease();
        if(isAlive()) {
            giveBirth(newCheetahs);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the cheetah does most of the time during the day: it hunts for
gazelles. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newCheetahs A list to return newly born Cheetahs.",Cheetah.java,127.0,3
1,"public void act2(List<Animal> newCheetahs)
    {
        incrementAge();
        incrementHunger();
        haveDisease();
    }","This is what the cheetah does at night - it sleeps.
Hence, its age and hunger increases - which could result in death.
@param newCheetahs A list to return newly born Cheetahs.",Cheetah.java,127.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the cheetah's death.,Cheetah.java,127.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this cheetah more hungry. This could result in the cheetah's death.,Cheetah.java,127.0,3
4,"private void haveDisease()
    {
      if(isDiseased()){
        incrementDisease();
      }
    }",This method checks if the cheetah has a disease.,Cheetah.java,127.0,3
5,"private void incrementDisease()
    {
        diseaseLevel--;
        if(diseaseLevel <= 0) {
            setDead();
            infectOthers();
        }
    }",This method is to increment the disease of the cheetah.,Cheetah.java,127.0,3
6,"private void infectOthers()
    {
        Field field = getField();
        System.out.println(field);
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Animal) {
                Animal animals = (Animal) animal;
                if(animals.isAlive()) { 
                    animals.getDisease();
                    //return where;
                }
            }
        }
        //return null;
    }","Look for animals adjacent to the current location.
Only the first live animal is infected.",Cheetah.java,127.0,3
7,"private void overEat()
    {
        
        if(foodLevel >= 50) {
            setDead();
        }
    }",This method kills the animal if they have increased the food level over the limit.,Cheetah.java,127.0,3
8,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Gazelle) {
                Gazelle gazelle = (Gazelle) animal;
                int food = gazelle.foodLevel;
                if(gazelle.isAlive()) { 
                    gazelle.setDead();
                    foodLevel += food;
                    return where;
                }
            }
        }
        return null;
    }","Look for gazelles adjacent to the current location.
Only the first live gazelle is eaten.
@return Where food was found, or null if it wasn't.",Cheetah.java,127.0,3
9,"private void giveBirth(List<Animal> newCheetahs)
    {
        // New cheetahs are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Cheetah young = new Cheetah(false, field, loc);
            newCheetahs.add(young);
        }
    }","Check whether or not this cheetah is to give birth at this step.
New births will be made into free adjacent locations.
@param newCheetahs A list to return newly born cheetahs.",Cheetah.java,127.0,3
10,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Cheetah.java,127.0,3
11,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A cheetah can breed if it has reached the breeding age.,Cheetah.java,127.0,3
0,"public void act(List<Animal> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
rabbits. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,127.0,3
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the fox's death.,Fox.java,127.0,3
2,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,127.0,3
3,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Rabbit) {
                Rabbit rabbit = (Rabbit) animal;
                if(rabbit.isAlive()) { 
                    rabbit.setDead();
                    foodLevel = RABBIT_FOOD_VALUE;
                    return where;
                }
            }
        }
        return null;
    }","Look for rabbits adjacent to the current location.
Only the first live rabbit is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,127.0,3
4,"private void giveBirth(List<Animal> newFoxes)
    {
        // New foxes are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Fox young = new Fox(false, field, loc);
            newFoxes.add(young);
        }
    }","Check whether or not this fox is to give birth at this step.
New births will be made into free adjacent locations.
@param newFoxes A list to return newly born foxes.",Fox.java,127.0,3
5,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Fox.java,127.0,3
6,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }",A fox can breed if it has reached the breeding age.,Fox.java,127.0,3
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,127.0,3
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,127.0,3
2,"public void place(Object thing, int row, int col)
    {
        place(thing, new Location(row, col));
    }","Place an animal or plant at the given location.
If there is already an animal or plant at the location it will
be lost.
@param thing The animal or plant to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,127.0,3
3,"public void place(Object thing, Location location)
    {
        field[location.getRow()][location.getCol()] = thing;
    }","Place an animal or plant at the given location.
If there is already an animal or plant at the location it will
be lost.
@param thing The animal or plant to be placed.
@param location Where to place the animal or plant.",Field.java,127.0,3
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal or plant at the given location, if any.
@param location Where in the field.
@return The animal or plant at the given location, or null if there is none.",Field.java,127.0,3
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal or plant at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal or plant at the given location, or null if there is none.",Field.java,127.0,3
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,127.0,3
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,127.0,3
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,127.0,3
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,127.0,3
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,127.0,3
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,127.0,3
0,"public void act1(List<Animal> newLions)
    {
        incrementAge();
        incrementHunger();
        
    }","This is what the lion does most of the time during the day: it sleeps.
Hence, it could die of old age or hunger.
@param newLions A list to return newly born Lions.",Lion.java,127.0,3
1,"public void act2(List<Animal> newLions)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newLions);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the lion does most of the time during the night: it hunts for
gazelles. In the process, it might breed, die of hunger,
or die of old age.
@param newLions A list to return newly born Lions.",Lion.java,127.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }",Increase the age. This could result in the lion's death.,Lion.java,127.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this lion more hungry. This could result in the lion's death.,Lion.java,127.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Gazelle) {
                Gazelle gazelle = (Gazelle) animal;
                int food = gazelle.foodLevel;
                if(gazelle.isAlive()) { 
                    gazelle.setDead();
                    foodLevel += food;
                    return where;
                }
            }
        }
        return null;
    }","Look for gazelles adjacent to the current location.
Only the first live gazelle is eaten.
@return Where food was found, or null if it wasn't.",Lion.java,127.0,3
5,"private void giveBirth(List<Animal> newLions)
    {
        // New lions are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Lion young = new Lion(false, field, loc);
            newLions.add(young);
        }
    }","Check whether or not this lion is to give birth at this step.
New births will be made into free adjacent locations.
@param newLions A list to return newly born lions.",Lion.java,127.0,3
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Lion.java,127.0,3
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A lion can breed if it has reached the breeding age
and it's mate is of the opposite gender.",Lion.java,127.0,3
0,"public void act(List<Plant> newGrasses)
    {
        grow();
    }","This is what the grass does most of the time during the day- it stays
in one place. Sometimes it will breed or die of old age.
@param newGrasses A list to return newly born grasses.",Grass.java,127.0,3
1,"private void grow()
    {
        if(isRain()) {
            grassAge = grassAge + 50;
        }
    }","Increase the age.
This could result in the grass's death.",Grass.java,127.0,3
0,"public void act1(List<Animal> newPandas)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newPandas);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the panda does most of the time during the day- it runs
around and eats grass. Sometimes it will breed or die of old age or hunger.
@param newPandas A list to return newly born pandas.",Panda.java,127.0,3
1,"public void act2(List<Animal> newPandas)
    {
        incrementAge();
        incrementHunger();
    }","This is what the panda does during the night - it sleeps.
In the process, it might die of hunger, or old age.
@param newPandas A list to return newly born Pandas.",Panda.java,127.0,3
2,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the pandas's death.",Panda.java,127.0,3
3,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this panda more hungry. This could result in the panda's death.,Panda.java,127.0,3
4,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object plant = field.getObjectAt(where);
            if(plant instanceof Bamboo) {
              Bamboo bamboo = (Bamboo) plant;
              int bambooAge = bamboo.bambooAge;
                if(bamboo.isAlive()) { 
                    if(bambooAge >= 3){
                        foodLevel += 2;
                        bambooAge -= 2;
                }
                else {
                    foodLevel += bambooAge;
                    bambooAge = 0;
                }
              }
            }
        }
        return null;
    }","Look for bamboos adjacent to the current location.
Only the first grown bamboo is eaten.
@return Where food was found, or null if it wasn't.",Panda.java,127.0,3
5,"private void giveBirth(List<Animal> newPandas)
    {
        // New pandas are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Panda young = new Panda(false, field, loc);
            newPandas.add(young);
        }
    }","Check whether or not this panda is to give birth at this step.
New births will be made into free adjacent locations.
@param newPandas A list to return newly born pandas.",Panda.java,127.0,3
6,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Panda.java,127.0,3
7,"private boolean canBreed()
    {
        return age >= BREEDING_AGE && findMate() && !isMale();
    }","A panda can breed if it has reached the breeding age and
if the mate is of the opposite gender.
@return true if the panda can breed, false otherwise.",Panda.java,127.0,3
8,"private boolean findMate()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        while(it.hasNext()) {
            Location where = it.next();
            Object animal = field.getObjectAt(where);
            if(animal instanceof Panda) {
                Panda panda = (Panda) animal;
                if(panda.isMale()) { 
                    return true;
                }
            }
        }
        return false;
    }","Look for male pandas adjacent to the current location.
@return Where food was found, or null if it wasn't.",Panda.java,127.0,3
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,127.0,3
1,"protected boolean isMale()
    {
        return !female;
    }",This method is to check if the animal is a male,Animal.java,127.0,3
2,"protected boolean isDiseased()
    {
        return diseased;
    }","Check whether the animal is diseased or not.
@return true if the animal is diseased.",Animal.java,127.0,3
3,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,127.0,3
4,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,127.0,3
5,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,127.0,3
6,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,127.0,3
7,"protected void getDisease()
    {
      if(rand.nextDouble() <= DISEASE_PROBABILITY)
      {
        diseased = true;  
      }
    }",Assigns the animal to be diseased or not.,Animal.java,127.0,3
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
        classes = colors.keySet();
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GraphView.java,120.0,2
1,"public void showStatus(int step, Field field)
    {
        graph.update(step, field, stats);
    }","Show the current status of the field. The status is shown by displaying a line graph for
two classes in the field. This view currently does not work for more (or fewer) than exactly
two classes. If the field contains more than two different types of animal, only two of the classes
will be plotted.

@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GraphView.java,120.0,2
2,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GraphView.java,120.0,2
3,"public void reset()
    {
        stats.reset();
        graph.newRun();
    }",Prepare for a new run.,GraphView.java,120.0,2
4,"private JFrame makeFrame(int width, int height, int startMax)
    {
        JFrame frame = new JFrame(""Graph View"");
        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);

        Container contentPane = frame.getContentPane();

        graph = new GraphPanel(width, height, startMax);
        contentPane.add(graph, BorderLayout.CENTER);

        JPanel bottom = new JPanel();
        bottom.add(new JLabel(""Step:""));
        stepLabel = new JLabel("""");
        bottom.add(stepLabel);
        countLabel = new JLabel("" "");
        bottom.add(countLabel);
        contentPane.add(bottom, BorderLayout.SOUTH);

        frame.pack();
        frame.setLocation(20, 600);

        frame.setVisible(true);

        return frame;
    }",Prepare the frame for the graph display.,GraphView.java,120.0,2
0,"public void act(List<Animal> newRabbits)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newRabbits);            
            // Try to move into a free location.
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the rabbit does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,120.0,2
1,"private void incrementAge()
    {
        age++;
        if(age > MAX_AGE) {
            setDead();
        }
    }","Increase the age.
This could result in the rabbit's death.",Rabbit.java,120.0,2
2,"private void giveBirth(List<Animal> newRabbits)
    {
        // New rabbits are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            Rabbit young = new Rabbit(false, field, loc);
            newRabbits.add(young);
        }
    }","Check whether or not this rabbit is to give birth at this step.
New births will be made into free adjacent locations.
@param newRabbits A list to return newly born rabbits.",Rabbit.java,120.0,2
3,"private int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
            births = rand.nextInt(MAX_LITTER_SIZE) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Rabbit.java,120.0,2
4,"private boolean canBreed()
    {
        return age >= BREEDING_AGE;
    }","A rabbit can breed if it has reached the breeding age.
@return true if the rabbit can breed, false otherwise.",Rabbit.java,120.0,2
0,"public void act(List<Organism> newMice)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newMice);
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the mouse does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newMice A list to return newly born mice.",Mouse.java,120.0,2
1,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Mouse(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the cat will have random gender. 0 for females and 1 for males.",Mouse.java,120.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a mouse can live.
@return The mouse's max age.",Mouse.java,120.0,2
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a mouse can breed.
@return The mouse's breeding age.",Mouse.java,120.0,2
4,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a mouse breeding.
@return The mouse's breeding probability.",Mouse.java,120.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a mouse.
@return The mouse's maximum number of births.",Mouse.java,120.0,2
0,"public void act(List<Organism> newBirds)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newBirds);
            Location newLocation = getField().freeAdjacentLocation(getLocation());
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the bird does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newBirds A list to return newly born birds.",Bird.java,120.0,2
1,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Bird(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the cat will have random gender. 0 for females and 1 for males.",Bird.java,120.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a bird can live.
@return The bird's max age.",Bird.java,120.0,2
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a bird can breed.
@return The bird's breeding age.",Bird.java,120.0,2
4,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a bird breeding.
@return The bird's breeding probability.",Bird.java,120.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a bird.
@return The bird's maximum number of births.",Bird.java,120.0,2
0,"public static Random getRandom()
    {
        if(useShared) {
            return rand;
        }
        else {
            return new Random();
        }
    }","Provide a random generator.
@return A random object.",Randomizer.java,120.0,2
1,"public static void reset()
    {
        if(useShared) {
            rand.setSeed(SEED);
        }
    }","Reset the randomization.
This will have no effect if randomization is not through
a shared Random generator.",Randomizer.java,120.0,2
0,"public void act(List<Organism> newPlants)
    {
        incrementAge();
        if(isAlive()) {
            giveBirth(newPlants);
        }
    }","This is what the plant does most of the time - it runs
around. Sometimes it will breed or die of old age.
@param newPlants A list to return newly born plants.",Plant.java,120.0,2
1,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Plant(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the cat will have random gender. 0 for females and 1 for males.",Plant.java,120.0,2
2,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a plant can live.
@return The plant's max age.",Plant.java,120.0,2
3,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a plant can breed.
@return The plant's breeding age.",Plant.java,120.0,2
4,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a plant breeding.
@return The plant's breeding probability.",Plant.java,120.0,2
5,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a plant.
@return The plant's maximum number of births.",Plant.java,120.0,2
0,"public void setColor(Class<?> animalClass, Color color)
    {
        colors.put(animalClass, color);
    }","Define a color to be used for a given class of animal.
@param animalClass The animal's Class object.
@param color The color to be used for the given class.",GridView.java,120.0,2
1,"private Color getColor(Class<?> animalClass)
    {
        Color col = colors.get(animalClass);
        if(col == null) {
            // no color defined for this class
            return UNKNOWN_COLOR;
        }
        else {
            return col;
        }
    }",@return The color to be used for a given class of animal.,GridView.java,120.0,2
2,"public void showStatus(int step, Field field)
    {
        if(!isVisible()) {
            setVisible(true);
        }
            
        stepLabel.setText(STEP_PREFIX + step);
        stats.reset();
        
        fieldView.preparePaint();

        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    Class<?> cls = animal.getClass();
                    stats.incrementCount(cls);
                    fieldView.drawMark(col, row, getColor(cls));
                }
                else {
                    fieldView.drawMark(col, row, EMPTY_COLOR);
                }
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }","Show the current status of the field.
@param step Which iteration step it is.
@param field The field whose status is to be displayed.",GridView.java,120.0,2
3,"public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }","Determine whether the simulation should continue to run.
@return true If there is more than one species alive.",GridView.java,120.0,2
4,"public void reset()
    {
        stats.reset();
    }",Prepare for a new run.,GridView.java,120.0,2
0,"public String getName()
    {
        return name;
    }",@return The short description of this type.,Counter.java,120.0,2
1,"public int getCount()
    {
        return count;
    }",@return The current count for this type.,Counter.java,120.0,2
2,"public void increment()
    {
        count++;
    }",Increment the current count by one.,Counter.java,120.0,2
3,"public void reset()
    {
        count = 0;
    }",Reset the current count to zero.,Counter.java,120.0,2
0,"public void viewFoodChain() throws Exception
    {
        URI uri = new URI(""https://3.bp.blogspot.com/-EyU79i28mN8/XG8tuEA3nLI/AAAAAAAAUAg/yB93WMe2KYYYIcHC2-T7gZhgFNSu2wlOgCLcBGAs/s1600/Picture1.png"");
        java.awt.Desktop.getDesktop().browse(uri); 
    }","This method opens the system's default internet browser
The Image shows the food chain of all the organisms in this simulation.",Simulator.java,120.0,2
1,"public void runLongSimulation()
    {
        try {
            viewFoodChain(); // launch informative image at the start of the simulation
        }
        catch (Exception e) {
            System.out.println(""INVALID URL"");
        }
        simulate(2000);
        try {
            viewVideo(); // launch funny video at the end of the simulation
        }
        catch (Exception e) {
            System.out.println(""INVALID URL"");
        }
    }","Run the simulation from its current state for a reasonably long period,
e.g. (2000 steps).",Simulator.java,120.0,2
2,"public boolean timeOfDay()
    {
        boolean night; // check if it is night or not
        // if the current step is greater than half of the total
        // then it is night. otherwise it is day.
        if (step >= NIGHT) {
            night = true;
        }
        else {
            night = false;
        }
        return night;
    }","Keeps track of the time of the day. fter half of the given number of steps
the simulation changes from day to night.
@param numSteps The number of steps to run for.",Simulator.java,120.0,2
3,"public String getTimeOfDay()
    {
        // Get strings to represent what time of day it is
        String timeOfDay = """";
        if (timeOfDay() == true) {
            timeOfDay = ""Night"";
        }
        else {
            timeOfDay = ""Day"";
        }
        return timeOfDay;
    }","Return the time of day in the simulation.
@return timeOfDay The current time of day.",Simulator.java,120.0,2
4,"public int getNumSteps()
    {
        return numSteps;
    }","Return the number of steps in the simulation.
@return The number of steps to run for.",Simulator.java,120.0,2
5,"public int getCurrentStep()
    {
        return step;
    }","Return the current step of the simulation.
@return step The current step.",Simulator.java,120.0,2
6,"public void simulate(int numSteps)
    {
        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
            simulateOneStep();
            delay(10);   // uncomment this to run more slowly
        }
    }","Run the simulation from its current state for the given number of steps.
Stop before the given number of steps if it ceases to be viable.
@param numSteps The number of steps to run for.",Simulator.java,120.0,2
7,"public void simulateOneStep()
    {
        step++;

        // Provide space for newborn organisms.
        List<Organism> newOrganisms = new ArrayList<>();        
        // Let all mice act.
        for(Iterator<Organism> it = organisms.iterator(); it.hasNext(); ) {
            Organism organism = it.next();
            // animals only move when it is day time
            if (timeOfDay() == true) {
                organism.act(newOrganisms);
                if(! organism.isAlive()) {
                    it.remove();
                }
            }
        }
               
        // Add the newly born cats and mice to the main lists.
        organisms.addAll(newOrganisms);

        updateViews();
    }","Run the simulation from its current state for a single step.
Iterate over the whole field updating the state of each
cat and mouse.",Simulator.java,120.0,2
8,"public void reset()
    {
        step = 0;
        organisms.clear();
        for (SimulatorView view : views) {
            view.reset();
        }

        populate();
        updateViews();
    }",Reset the simulation to a starting position.,Simulator.java,120.0,2
9,"private void updateViews()
    {
        for (SimulatorView view : views) {
            view.showStatus(step, field);
        }
    }",Update all existing views.,Simulator.java,120.0,2
10,"private void populate()
    {
        Random rand = Randomizer.getRandom();
        field.clear();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                if(rand.nextDouble() <= CAT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Cat cat = new Cat(true, field, location, true);
                    organisms.add(cat);
                }
                else if(rand.nextDouble() <= MOUSE_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Mouse mouse = new Mouse(true, field, location, true);
                    organisms.add(mouse);
                }
                else if(rand.nextDouble() <= BIRD_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Bird bird = new Bird(true, field, location, true);
                    organisms.add(bird);
                }
                else if(rand.nextDouble() <= DOG_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Dog dog = new Dog(true, field, location, true);
                    organisms.add(dog);
                }
                else if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Fox fox = new Fox(true, field, location, true);
                    organisms.add(fox);
                }
                else if(rand.nextDouble() <= WORM_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Worm worm = new Worm(true, field, location, true);
                    organisms.add(worm);
                }
                else if(rand.nextDouble() <= PLANT_CREATION_PROBABILITY) {
                    Location location = new Location(row, col);
                    Plant plant = new Plant(true, field, location, true);
                    organisms.add(plant);
                }
                // else leave the location empty.
            }
        }
    }",Randomly populate the field with cats and mice.,Simulator.java,120.0,2
11,"private void delay(int millisec)
    {
        try {
            Thread.sleep(millisec);
        }
        catch (InterruptedException ie) {
            // wake up
        }
    }","Pause for a given time.
@param millisec  The time to pause for, in milliseconds",Simulator.java,120.0,2
12,"public void viewVideo() throws Exception
    {
        URI uri = new URI(""https://www.youtube.com/watch?v=EtH9Yllzjcc"");
        java.awt.Desktop.getDesktop().browse(uri); 
    }","This method opens the system's default internet browser
The Youtube page shows a funny video about cats and dogs.",Simulator.java,120.0,2
0,"public static void main(String[] args)
    {
        // if the length of the array is one,
        // assume this argument is the user's name
        // and print a welcome statement
        if(args.length == 1) {
            System.out.println(""Hello there: "" + args[0]);
        }
        Simulator simulator = new Simulator(); // create a Simulator object
        simulator.runLongSimulation(); // run the simulation
    }","The starting point for the simulation.
@param args Program arguments.",SimulatorMain.java,120.0,2
0,"public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            buffer.append(info.getName());
            buffer.append("": "");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }","Get details of what is in the field.
@return A string describing what is in the field.",FieldStats.java,120.0,2
1,"public int getPopulationCount(Field field, Class key)
    {
        if(!countsValid) {
            generateCounts(field);
        }

        Counter counter = counters.get(key);
        return counter.getCount();
    }","Get the number of individuals in the population of a given class.
@return  An int with the number for this class.",FieldStats.java,120.0,2
2,"public void reset()
    {
        countsValid = false;
        for(Class key : counters.keySet()) {
            Counter count = counters.get(key);
            count.reset();
        }
    }","Invalidate the current set of statistics; reset all
counts to zero.",FieldStats.java,120.0,2
3,"public void incrementCount(Class animalClass)
    {
        Counter count = counters.get(animalClass);
        if(count == null) {
            // We do not have a counter for this species yet.
            // Create one.
            count = new Counter(animalClass.getName());
            counters.put(animalClass, count);
        }
        count.increment();
    }","Increment the count for one class of animal.
@param animalClass The class of animal to increment.",FieldStats.java,120.0,2
4,"public void countFinished()
    {
        countsValid = true;
    }",Indicate that an animal count has been completed.,FieldStats.java,120.0,2
5,"public boolean isViable(Field field)
    {
        // How many counts are non-zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        for(Class key : counters.keySet()) {
            Counter info = counters.get(key);
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }","Determine whether the simulation is still viable.
I.e., should it continue to run.
@return true If there is more than one species alive.",FieldStats.java,120.0,2
6,"private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                Object animal = field.getObjectAt(row, col);
                if(animal != null) {
                    incrementCount(animal.getClass());
                }
            }
        }
        countsValid = true;
    }","Generate counts of the number of foxes and rabbits.
These are not kept up to date as foxes and rabbits
are placed in the field, but only when a request
is made for the information.
@param field The field to generate the stats for.",FieldStats.java,120.0,2
0,"public void act(List<Organism> newCats)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newCats);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the cat does most of the time: it hunts for
birds. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newCats A list to return newly born cats.",Cat.java,120.0,2
1,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this cat more hungry. This could result in the cat's death.,Cat.java,120.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        Location birdLocation = null;
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Bird) {
                Bird bird = (Bird) organism;
                if(bird.isAlive()) {
                    bird.setDead();
                    foodLevel = foodLevel + BIRD_FOOD_VALUE;
                    if(foodLevel > MAX_FOOD_VALUE) {
                        foodLevel = MAX_FOOD_VALUE;
                    } 
                    birdLocation = where;
                }
            }  
        }
        return birdLocation; 
    }","Look for birds adjacent to the current location.
Only the first live bird is eaten.
@return Where food was found, or null if it wasn't.",Cat.java,120.0,2
3,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Cat(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the cat will have random gender. 0 for females and 1 for males.",Cat.java,120.0,2
4,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a cat can live.
@return The cat's max age.",Cat.java,120.0,2
5,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a cat can breed.
@return The cat's breeding age.",Cat.java,120.0,2
6,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a cat breeding.
@return The cat's breeding probability.",Cat.java,120.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a cat.
@return The cat's maximum number of births.",Cat.java,120.0,2
8,"protected boolean canCatBreed()
    {
        super.canBreed();
        boolean oppositeGender = false;
        Field cell = getField();
        List<Location> neighbouringCells = cell.adjacentLocations(getLocation());
        for (int i = 0; i < neighbouringCells.size(); i++) {
            // iterate through all locations in the list
            // to see if there are any organisms in the neighbouring
            // cells. If there are organisms then check to see if the
            // gender of the organisms are the opposite to the gender of 
            // the organism in the central cell.
            Object organism = cell.getObjectAt(neighbouringCells.get(i));
            if (organism != null) {
                Cat cat = new Cat(false, cell, neighbouringCells.get(i),true);
                if (organism.equals(cat)) {
                    int catGender = cat.getGender();       // to be able to get it's gender
                    if ((catGender == 0) && (catGender == 1)) {
                        oppositeGender = true;
                    }
                    else if ((catGender == 1) && (catGender == 0)) {
                        oppositeGender = true;
                    }
                }
            }
        }
        // check if the organism is of breeding age and there is an organism 
        // in the neighbouring cell that is of the opposite gender.
        if ((super.canBreed() == true) && (oppositeGender == true)) {
            return true;
        }
        return false;
    }","An organism can breed if it has reached the breeding age and
when a male and female individual are in a neighbouring cell.
@return true if the organism can breed, false otherwise.",Cat.java,120.0,2
0,"public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }",Implement content equality.,Location.java,120.0,2
1,"public String toString()
    {
        return row + "","" + col;
    }","Return a string of the form row,column
@return A string representation of the location.",Location.java,120.0,2
2,"public int hashCode()
    {
        return (row << 16) + col;
    }","Use the top 16 bits for the row value and the bottom for
the column. Except for very big grids, this should give a
unique hash code for each (row, col) pair.
@return A hashcode for the location.",Location.java,120.0,2
3,"public int getRow()
    {
        return row;
    }",@return The row.,Location.java,120.0,2
4,"public int getCol()
    {
        return col;
    }",@return The column.,Location.java,120.0,2
0,"protected int getAge()
    {
        return age;
    }","Return the organism's age.
@return The age.",Organism.java,120.0,2
1,"protected void setAge(int age)
    {
        this.age = age;
    }","Set the organism's age.
@param age The new age.",Organism.java,120.0,2
2,"protected int getGender()
    {
        return gender;
    }","Return the organism's gender.
@return The gender.",Organism.java,120.0,2
3,"protected void setGender(int gender)
    {
        this.gender = gender;
    }","Set the organism's gender.
@param gender The new gender.",Organism.java,120.0,2
4,"protected void incrementAge()
    {
        age++;
        if(getAge() > getMaxAge()) {
            setDead();
        }
    }",Increment the organism's age.,Organism.java,120.0,2
5,"protected boolean canBreed()
    {
        return getAge() >= getBreedingAge();
    }","An organism can breed if it has reached the breeding age
@return true if the organism can breed, false otherwise.",Organism.java,120.0,2
6,"protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }","Generate a number representing the number of births,
if it can breed.
@return The number of births (may be zero).",Organism.java,120.0,2
7,"protected void giveBirth(List<Organism> newborn)
    {
        // New organisms are born into adjacent locations.
        // Get a list of adjacent free locations.
        Field field = getField();
        List<Location> free = field.getFreeAdjacentLocations(getLocation());
        int births = breed();
        for(int b = 0; b < births && free.size() > 0; b++) {
            Location loc = free.remove(0);
            newborn.add(createOrganism(false, field, loc, true));
        }
    }","Check whether or not this organism is to give birth at this step.
New births will be made into free adjacent locations.
@param newborn A list to add newly born organisms to.",Organism.java,120.0,2
8,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the organism is alive or not.
@return true if the organism is still alive.",Organism.java,120.0,2
9,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the organism is no longer alive.
It is removed from the field.",Organism.java,120.0,2
10,"protected Location getLocation()
    {
        return location;
    }","Return the organism's location.
@return The organism's location.",Organism.java,120.0,2
11,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the organism at the new location in the given field.
@param newLocation The organism's new location.",Organism.java,120.0,2
12,"protected Field getField()
    {
        return field;
    }","Return the organism's field.
@return The organism's field.",Organism.java,120.0,2
0,"public void act(List<Organism> newFoxes)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newFoxes);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the fox does most of the time: it hunts for
mice. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newFoxes A list to return newly born foxes.",Fox.java,120.0,2
1,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this fox more hungry. This could result in the fox's death.,Fox.java,120.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        Location mouseLocation = null;
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Mouse) {
                Mouse mouse = (Mouse) organism;
                if(mouse.isAlive()) {
                    mouse.setDead();
                    foodLevel = foodLevel + MOUSE_FOOD_VALUE;
                    if(foodLevel > MAX_FOOD_VALUE) {
                        foodLevel = MAX_FOOD_VALUE;
                    } 
                    mouseLocation = where;
                }
            }  
        }
        return mouseLocation; 
    }","Look for mice adjacent to the current location.
Only the first live mouse is eaten.
@return Where food was found, or null if it wasn't.",Fox.java,120.0,2
3,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Fox(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the fox will have random gender. 0 for females and 1 for males.",Fox.java,120.0,2
4,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a fox can live.
@return The fox's max age.",Fox.java,120.0,2
5,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a fox can breed.
@return The fox's breeding age.",Fox.java,120.0,2
6,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a fox breeding.
@return The fox's breeding probability.",Fox.java,120.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a fox.
@return The fox's maximum number of births.",Fox.java,120.0,2
8,"protected boolean canFoxBreed()
    {
        super.canBreed();
        boolean oppositeGender = false;
        Field cell = getField();
        List<Location> neighbouringCells = cell.adjacentLocations(getLocation());
        for (int i = 0; i < neighbouringCells.size(); i++) {
            // iterate through all locations in the list
            // to see if there are any organisms in the neighbouring
            // cells. If there are organisms then check to see if the
            // gender of the organisms are the opposite to the gender of 
            // the organism in the central cell.
            Object organism = cell.getObjectAt(neighbouringCells.get(i));
            if (organism != null) {
                Fox fox = new Fox(false, cell, neighbouringCells.get(i),true);
                if (organism.equals(fox)) {
                    int foxGender = fox.getGender();       // to be able to get it's gender
                    if ((foxGender == 0) && (foxGender == 1)) {
                        oppositeGender = true;
                    }
                    else if ((foxGender == 1) && (foxGender == 0)) {
                        oppositeGender = true;
                    }
                }
            }
        }
        // check if the organism is of breeding age and there is an organism 
        // in the neighbouring cell that is of the opposite gender.
        if ((super.canBreed() == true) && (oppositeGender == true)) {
            return true;
        }
        return false;
    }","An organism can breed if it has reached the breeding age and
when a male and female individual are in a neighbouring cell.
@return true if the organism can breed, false otherwise.",Fox.java,120.0,2
0,"public void act(List<Organism> newDogs)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newDogs);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the dog does most of the time: it hunts for
birds. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newDogs A list to return newly born dogs.",Dog.java,120.0,2
1,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this dog more hungry. This could result in the dog's death.,Dog.java,120.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        Location birdLocation = null;
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Bird) {
                Bird bird = (Bird) organism;
                if(bird.isAlive()) {
                    bird.setDead();
                    foodLevel = foodLevel + BIRD_FOOD_VALUE;
                    if(foodLevel > MAX_FOOD_VALUE) {
                        foodLevel = MAX_FOOD_VALUE;
                    } 
                    birdLocation = where;
                }
            }  
        }
        return birdLocation; 
    }","Look for birds adjacent to the current location.
Only the first live bird is eaten.
@return Where food was found, or null if it wasn't.",Dog.java,120.0,2
3,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Dog(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the dog will have random gender. 0 for females and 1 for males.",Dog.java,120.0,2
4,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a dog can live.
@return The dog's max age.",Dog.java,120.0,2
5,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a dog can breed.
@return The dog's breeding age.",Dog.java,120.0,2
6,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a dog breeding.
@return The dog's breeding probability.",Dog.java,120.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a dog.
@return The dog's maximum number of births.",Dog.java,120.0,2
8,"protected boolean canDogBreed()
    {
        super.canBreed();
        boolean oppositeGender = false;
        Field cell = getField();
        List<Location> neighbouringCells = cell.adjacentLocations(getLocation());
        for (int i = 0; i < neighbouringCells.size(); i++) {
            // iterate through all locations in the list
            // to see if there are any organisms in the neighbouring
            // cells. If there are organisms then check to see if the
            // gender of the organisms are the opposite to the gender of 
            // the organism in the central cell.
            Object organism = cell.getObjectAt(neighbouringCells.get(i));
            if (organism != null) {
                Dog dog = new Dog(false, cell, neighbouringCells.get(i),true);
                if (organism.equals(dog)) {
                    int dogGender = dog.getGender();       // to be able to get it's gender
                    if ((dogGender == 0) && (dogGender == 1)) {
                        oppositeGender = true;
                    }
                    else if ((dogGender == 1) && (dogGender == 0)) {
                        oppositeGender = true;
                    }
                }
            }
        }
        // check if the organism is of breeding age and there is an organism 
        // in the neighbouring cell that is of the opposite gender.
        if ((super.canBreed() == true) && (oppositeGender == true)) {
            return true;
        }
        return false;
    }","An organism can breed if it has reached the breeding age and
when a male and female individual are in a neighbouring cell.
@return true if the organism can breed, false otherwise.",Dog.java,120.0,2
0,"public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }",Empty the field.,Field.java,120.0,2
1,"public void clear(Location location)
    {
        field[location.getRow()][location.getCol()] = null;
    }","Clear the given location.
@param location The location to clear.",Field.java,120.0,2
2,"public void place(Object animal, int row, int col)
    {
        place(animal, new Location(row, col));
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param row Row coordinate of the location.
@param col Column coordinate of the location.",Field.java,120.0,2
3,"public void place(Object animal, Location location)
    {
        field[location.getRow()][location.getCol()] = animal;
    }","Place an animal at the given location.
If there is already an animal at the location it will
be lost.
@param animal The animal to be placed.
@param location Where to place the animal.",Field.java,120.0,2
4,"public Object getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }","Return the animal at the given location, if any.
@param location Where in the field.
@return The animal at the given location, or null if there is none.",Field.java,120.0,2
5,"public Object getObjectAt(int row, int col)
    {
        return field[row][col];
    }","Return the animal at the given location, if any.
@param row The desired row.
@param col The desired column.
@return The animal at the given location, or null if there is none.",Field.java,120.0,2
6,"public Location randomAdjacentLocation(Location location)
    {
        List<Location> adjacent = adjacentLocations(location);
        return adjacent.get(0);
    }","Generate a random location that is adjacent to the
given location, or is the same location.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,120.0,2
7,"public List<Location> getFreeAdjacentLocations(Location location)
    {
        List<Location> free = new LinkedList<>();
        List<Location> adjacent = adjacentLocations(location);
        for(Location next : adjacent) {
            if(getObjectAt(next) == null) {
                free.add(next);
            }
        }
        return free;
    }","Get a shuffled list of the free adjacent locations.
@param location Get locations adjacent to this.
@return A list of free adjacent locations.",Field.java,120.0,2
8,"public Location freeAdjacentLocation(Location location)
    {
        // The available free ones.
        List<Location> free = getFreeAdjacentLocations(location);
        if(free.size() > 0) {
            return free.get(0);
        }
        else {
            return null;
        }
    }","Try to find a free location that is adjacent to the
given location. If there is none, return null.
The returned location will be within the valid bounds
of the field.
@param location The location from which to generate an adjacency.
@return A valid location within the grid area.",Field.java,120.0,2
9,"public List<Location> adjacentLocations(Location location)
    {
        assert location != null : ""Null location passed to adjacentLocations"";
        // The list of locations to be returned.
        List<Location> locations = new LinkedList<>();
        if(location != null) {
            int row = location.getRow();
            int col = location.getCol();
            for(int roffset = -1; roffset <= 1; roffset++) {
                int nextRow = row + roffset;
                if(nextRow >= 0 && nextRow < depth) {
                    for(int coffset = -1; coffset <= 1; coffset++) {
                        int nextCol = col + coffset;
                        // Exclude invalid locations and the original location.
                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                            locations.add(new Location(nextRow, nextCol));
                        }
                    }
                }
            }
            
            // Shuffle the list. Several other methods rely on the list
            // being in a random order.
            Collections.shuffle(locations, rand);
        }
        return locations;
    }","Return a shuffled list of locations adjacent to the given one.
The list will not include the location itself.
All locations will lie within the grid.
@param location The location from which to generate adjacencies.
@return A list of locations adjacent to that given.",Field.java,120.0,2
10,"public int getDepth()
    {
        return depth;
    }","Return the depth of the field.
@return The depth of the field.",Field.java,120.0,2
11,"public int getWidth()
    {
        return width;
    }","Return the width of the field.
@return The width of the field.",Field.java,120.0,2
0,"public void act(List<Organism> newWorms)
    {
        incrementAge();
        incrementHunger();
        if(isAlive()) {
            giveBirth(newWorms);            
            // Move towards a source of food if found.
            Location newLocation = findFood();
            if(newLocation == null) { 
                // No food found - try to move to a free location.
                newLocation = getField().freeAdjacentLocation(getLocation());
            }
            // See if it was possible to move.
            if(newLocation != null) {
                setLocation(newLocation);
            }
            else {
                // Overcrowding.
                setDead();
            }
        }
    }","This is what the worm does most of the time: it hunts for
plants. In the process, it might breed, die of hunger,
or die of old age.
@param field The field currently occupied.
@param newWorms A list to return newly born worms.",Worm.java,120.0,2
1,"private void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }",Make this worm more hungry. This could result in the worm's death.,Worm.java,120.0,2
2,"private Location findFood()
    {
        Field field = getField();
        List<Location> adjacent = field.adjacentLocations(getLocation());
        Iterator<Location> it = adjacent.iterator();
        Location plantLocation = null;
        while(it.hasNext()) {
            Location where = it.next();
            Object organism = field.getObjectAt(where);
            if(organism instanceof Plant) {
                Plant plant = (Plant) organism;
                if(plant.isAlive()) {
                    plant.setDead();
                    foodLevel = foodLevel + PLANT_FOOD_VALUE;
                    if(foodLevel > MAX_FOOD_VALUE) {
                        foodLevel = MAX_FOOD_VALUE;
                    } 
                    plantLocation = where;
                }
            }  
        }
        return plantLocation; 
    }","Look for plants adjacent to the current location.
Only the first live plant is eaten.
@return Where food was found, or null if it wasn't.",Worm.java,120.0,2
3,"protected Organism createOrganism(boolean randomAge, Field field, Location location, boolean randomGender)
    {
        return new Worm(randomAge, field, location, randomGender);
    }","Create a new organism. An organism may be created with age
zero (a new born) or with a random age.

@param randomAge If true, the organism will have a random age.
@param field The field currently occupied.
@param location The location within the field.
@param randomGender If true, the worm will have random gender. 0 for females and 1 for males.",Worm.java,120.0,2
4,"protected int getMaxAge()
    {
        return MAX_AGE;
    }","Return the age to which a worm can live.
@return The worm's max age.",Worm.java,120.0,2
5,"protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }","Return the age at which a worm can breed.
@return The worm's breeding age.",Worm.java,120.0,2
6,"protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }","Return the likelihood of a worm breeding.
@return The worm's breeding probability.",Worm.java,120.0,2
7,"protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }","Return the maximum number of births for a worm.
@return The worm's maximum number of births.",Worm.java,120.0,2
8,"protected boolean canWormBreed()
    {
        super.canBreed();
        boolean oppositeGender = false;
        Field cell = getField();
        List<Location> neighbouringCells = cell.adjacentLocations(getLocation());
        for (int i = 0; i < neighbouringCells.size(); i++) {
            // iterate through all locations in the list
            // to see if there are any organisms in the neighbouring
            // cells. If there are organisms then check to see if the
            // gender of the organisms are the opposite to the gender of 
            // the organism in the central cell.
            Object organism = cell.getObjectAt(neighbouringCells.get(i));
            if (organism != null) {
                Worm worm = new Worm(false, cell, neighbouringCells.get(i),true);
                if (organism.equals(worm)) {
                    int wormGender = worm.getGender();       // to be able to get it's gender
                    if ((wormGender == 0) && (wormGender == 1)) {
                        oppositeGender = true;
                    }
                    else if ((wormGender == 1) && (wormGender == 0)) {
                        oppositeGender = true;
                    }
                }
            }
        }
        // check if the organism is of breeding age and there is an organism 
        // in the neighbouring cell that is of the opposite gender.
        if ((super.canBreed() == true) && (oppositeGender == true)) {
            return true;
        }
        return false;
    }","An organism can breed if it has reached the breeding age and
when a male and female individual are in a neighbouring cell.
@return true if the organism can breed, false otherwise.",Worm.java,120.0,2
0,"protected boolean isAlive()
    {
        return alive;
    }","Check whether the animal is alive or not.
@return true if the animal is still alive.",Animal.java,120.0,2
1,"protected void setDead()
    {
        alive = false;
        if(location != null) {
            field.clear(location);
            location = null;
            field = null;
        }
    }","Indicate that the animal is no longer alive.
It is removed from the field.",Animal.java,120.0,2
2,"protected Location getLocation()
    {
        return location;
    }","Return the animal's location.
@return The animal's location.",Animal.java,120.0,2
3,"protected void setLocation(Location newLocation)
    {
        if(location != null) {
            field.clear(location);
        }
        location = newLocation;
        field.place(this, newLocation);
    }","Place the animal at the new location in the given field.
@param newLocation The animal's new location.",Animal.java,120.0,2
4,"protected Field getField()
    {
        return field;
    }","Return the animal's field.
@return The animal's field.",Animal.java,120.0,2
